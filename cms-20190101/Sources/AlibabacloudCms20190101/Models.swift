import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AlertEvent : Tea.TeaModel {
    public class Metrics : Tea.TeaModel {
        public var curValue: String?

        public var metricName: String?

        public var metricNameEn: String?

        public var metricNameZh: String?

        public var operator_: String?

        public var statistics: String?

        public var threshold: String?

        public var unit: String?

        public var unitFactor: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.curValue != nil {
                map["CurValue"] = self.curValue!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.metricNameEn != nil {
                map["MetricNameEn"] = self.metricNameEn!
            }
            if self.metricNameZh != nil {
                map["MetricNameZh"] = self.metricNameZh!
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.statistics != nil {
                map["Statistics"] = self.statistics!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            if self.unit != nil {
                map["Unit"] = self.unit!
            }
            if self.unitFactor != nil {
                map["UnitFactor"] = self.unitFactor!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurValue") && dict["CurValue"] != nil {
                self.curValue = dict["CurValue"] as! String
            }
            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("MetricNameEn") && dict["MetricNameEn"] != nil {
                self.metricNameEn = dict["MetricNameEn"] as! String
            }
            if dict.keys.contains("MetricNameZh") && dict["MetricNameZh"] != nil {
                self.metricNameZh = dict["MetricNameZh"] as! String
            }
            if dict.keys.contains("Operator") && dict["Operator"] != nil {
                self.operator_ = dict["Operator"] as! String
            }
            if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                self.statistics = dict["Statistics"] as! String
            }
            if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                self.threshold = dict["Threshold"] as! String
            }
            if dict.keys.contains("Unit") && dict["Unit"] != nil {
                self.unit = dict["Unit"] as! String
            }
            if dict.keys.contains("UnitFactor") && dict["UnitFactor"] != nil {
                self.unitFactor = dict["UnitFactor"] as! Double
            }
        }
    }
    public var alertName: String?

    public var alertStatus: String?

    public var customLabels: [String: Any]?

    public var deDupId: String?

    public var details: String?

    public var eventName: String?

    public var expression: String?

    public var metrics: [AlertEvent.Metrics]?

    public var resourceInfo: [String: Any]?

    public var ruleName: String?

    public var severity: String?

    public var source: String?

    public var summary: String?

    public var timestamp: Int64?

    public var traceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertName != nil {
            map["AlertName"] = self.alertName!
        }
        if self.alertStatus != nil {
            map["AlertStatus"] = self.alertStatus!
        }
        if self.customLabels != nil {
            map["CustomLabels"] = self.customLabels!
        }
        if self.deDupId != nil {
            map["DeDupId"] = self.deDupId!
        }
        if self.details != nil {
            map["Details"] = self.details!
        }
        if self.eventName != nil {
            map["EventName"] = self.eventName!
        }
        if self.expression != nil {
            map["Expression"] = self.expression!
        }
        if self.metrics != nil {
            var tmp : [Any] = []
            for k in self.metrics! {
                tmp.append(k.toMap())
            }
            map["Metrics"] = tmp
        }
        if self.resourceInfo != nil {
            map["ResourceInfo"] = self.resourceInfo!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.summary != nil {
            map["Summary"] = self.summary!
        }
        if self.timestamp != nil {
            map["Timestamp"] = self.timestamp!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
            self.alertName = dict["AlertName"] as! String
        }
        if dict.keys.contains("AlertStatus") && dict["AlertStatus"] != nil {
            self.alertStatus = dict["AlertStatus"] as! String
        }
        if dict.keys.contains("CustomLabels") && dict["CustomLabels"] != nil {
            self.customLabels = dict["CustomLabels"] as! [String: Any]
        }
        if dict.keys.contains("DeDupId") && dict["DeDupId"] != nil {
            self.deDupId = dict["DeDupId"] as! String
        }
        if dict.keys.contains("Details") && dict["Details"] != nil {
            self.details = dict["Details"] as! String
        }
        if dict.keys.contains("EventName") && dict["EventName"] != nil {
            self.eventName = dict["EventName"] as! String
        }
        if dict.keys.contains("Expression") && dict["Expression"] != nil {
            self.expression = dict["Expression"] as! String
        }
        if dict.keys.contains("Metrics") && dict["Metrics"] != nil {
            var tmp : [AlertEvent.Metrics] = []
            for v in dict["Metrics"] as! [Any] {
                var model = AlertEvent.Metrics()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.metrics = tmp
        }
        if dict.keys.contains("ResourceInfo") && dict["ResourceInfo"] != nil {
            self.resourceInfo = dict["ResourceInfo"] as! [String: Any]
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("Severity") && dict["Severity"] != nil {
            self.severity = dict["Severity"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Summary") && dict["Summary"] != nil {
            self.summary = dict["Summary"] as! String
        }
        if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
            self.timestamp = dict["Timestamp"] as! Int64
        }
        if dict.keys.contains("TraceId") && dict["TraceId"] != nil {
            self.traceId = dict["TraceId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class AlertStrategyRelation : Tea.TeaModel {
    public var alertName: String?

    public var strategyUuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertName != nil {
            map["AlertName"] = self.alertName!
        }
        if self.strategyUuid != nil {
            map["StrategyUuid"] = self.strategyUuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
            self.alertName = dict["AlertName"] as! String
        }
        if dict.keys.contains("StrategyUuid") && dict["StrategyUuid"] != nil {
            self.strategyUuid = dict["StrategyUuid"] as! String
        }
    }
}

public class Dimension : Tea.TeaModel {
    public var label: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.label != nil {
            map["Label"] = self.label!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Label") && dict["Label"] != nil {
            self.label = dict["Label"] as! String
        }
        if dict.keys.contains("Value") && dict["Value"] != nil {
            self.value = dict["Value"] as! String
        }
    }
}

public class EscalationRule : Tea.TeaModel {
    public class Escalations : Tea.TeaModel {
        public class ContactGroupsByLevel : Tea.TeaModel {
            public var critical: [String]?

            public var error: [String]?

            public var info: [String]?

            public var resolve: [String]?

            public var warning: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.critical != nil {
                    map["Critical"] = self.critical!
                }
                if self.error != nil {
                    map["Error"] = self.error!
                }
                if self.info != nil {
                    map["Info"] = self.info!
                }
                if self.resolve != nil {
                    map["Resolve"] = self.resolve!
                }
                if self.warning != nil {
                    map["Warning"] = self.warning!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Critical") && dict["Critical"] != nil {
                    self.critical = dict["Critical"] as! [String]
                }
                if dict.keys.contains("Error") && dict["Error"] != nil {
                    self.error = dict["Error"] as! [String]
                }
                if dict.keys.contains("Info") && dict["Info"] != nil {
                    self.info = dict["Info"] as! [String]
                }
                if dict.keys.contains("Resolve") && dict["Resolve"] != nil {
                    self.resolve = dict["Resolve"] as! [String]
                }
                if dict.keys.contains("Warning") && dict["Warning"] != nil {
                    self.warning = dict["Warning"] as! [String]
                }
            }
        }
        public var contactGroups: [String]?

        public var contactGroupsByLevel: EscalationRule.Escalations.ContactGroupsByLevel?

        public var escalateMin: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.contactGroupsByLevel?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contactGroups != nil {
                map["ContactGroups"] = self.contactGroups!
            }
            if self.contactGroupsByLevel != nil {
                map["ContactGroupsByLevel"] = self.contactGroupsByLevel?.toMap()
            }
            if self.escalateMin != nil {
                map["EscalateMin"] = self.escalateMin!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
                self.contactGroups = dict["ContactGroups"] as! [String]
            }
            if dict.keys.contains("ContactGroupsByLevel") && dict["ContactGroupsByLevel"] != nil {
                var model = EscalationRule.Escalations.ContactGroupsByLevel()
                model.fromMap(dict["ContactGroupsByLevel"] as! [String: Any])
                self.contactGroupsByLevel = model
            }
            if dict.keys.contains("EscalateMin") && dict["EscalateMin"] != nil {
                self.escalateMin = dict["EscalateMin"] as! Int64
            }
        }
    }
    public var createTime: String?

    public var description_: String?

    public var escalations: [EscalationRule.Escalations]?

    public var name: String?

    public var updateTime: String?

    public var userId: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.escalations != nil {
            var tmp : [Any] = []
            for k in self.escalations! {
                tmp.append(k.toMap())
            }
            map["Escalations"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Escalations") && dict["Escalations"] != nil {
            var tmp : [EscalationRule.Escalations] = []
            for v in dict["Escalations"] as! [Any] {
                var model = EscalationRule.Escalations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.escalations = tmp
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class Incident : Tea.TeaModel {
    public var actionTime: Int64?

    public var alertCount: Int64?

    public var endTime: Int64?

    public var groupingData: [String: Any]?

    public var groupingId: String?

    public var groupingKey: String?

    public var incidentId: String?

    public var incidentStatus: String?

    public var severity: String?

    public var startTime: Int64?

    public var strategyUuid: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionTime != nil {
            map["ActionTime"] = self.actionTime!
        }
        if self.alertCount != nil {
            map["AlertCount"] = self.alertCount!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupingData != nil {
            map["GroupingData"] = self.groupingData!
        }
        if self.groupingId != nil {
            map["GroupingId"] = self.groupingId!
        }
        if self.groupingKey != nil {
            map["GroupingKey"] = self.groupingKey!
        }
        if self.incidentId != nil {
            map["IncidentId"] = self.incidentId!
        }
        if self.incidentStatus != nil {
            map["IncidentStatus"] = self.incidentStatus!
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.strategyUuid != nil {
            map["StrategyUuid"] = self.strategyUuid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionTime") && dict["ActionTime"] != nil {
            self.actionTime = dict["ActionTime"] as! Int64
        }
        if dict.keys.contains("AlertCount") && dict["AlertCount"] != nil {
            self.alertCount = dict["AlertCount"] as! Int64
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("GroupingData") && dict["GroupingData"] != nil {
            self.groupingData = dict["GroupingData"] as! [String: Any]
        }
        if dict.keys.contains("GroupingId") && dict["GroupingId"] != nil {
            self.groupingId = dict["GroupingId"] as! String
        }
        if dict.keys.contains("GroupingKey") && dict["GroupingKey"] != nil {
            self.groupingKey = dict["GroupingKey"] as! String
        }
        if dict.keys.contains("IncidentId") && dict["IncidentId"] != nil {
            self.incidentId = dict["IncidentId"] as! String
        }
        if dict.keys.contains("IncidentStatus") && dict["IncidentStatus"] != nil {
            self.incidentStatus = dict["IncidentStatus"] as! String
        }
        if dict.keys.contains("Severity") && dict["Severity"] != nil {
            self.severity = dict["Severity"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("StrategyUuid") && dict["StrategyUuid"] != nil {
            self.strategyUuid = dict["StrategyUuid"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class Matcher : Tea.TeaModel {
    public var label: String?

    public var operator_: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.label != nil {
            map["Label"] = self.label!
        }
        if self.operator_ != nil {
            map["Operator"] = self.operator_!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Label") && dict["Label"] != nil {
            self.label = dict["Label"] as! String
        }
        if dict.keys.contains("Operator") && dict["Operator"] != nil {
            self.operator_ = dict["Operator"] as! String
        }
        if dict.keys.contains("Value") && dict["Value"] != nil {
            self.value = dict["Value"] as! String
        }
    }
}

public class MetricStat : Tea.TeaModel {
    public var associated: [String: String]?

    public var dimensions: [Dimension]?

    public var logTime: Int64?

    public var measurements: [String: Any]?

    public var metric: String?

    public var namespace: String?

    public var period: Int32?

    public var timestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.associated != nil {
            map["Associated"] = self.associated!
        }
        if self.dimensions != nil {
            var tmp : [Any] = []
            for k in self.dimensions! {
                tmp.append(k.toMap())
            }
            map["Dimensions"] = tmp
        }
        if self.logTime != nil {
            map["LogTime"] = self.logTime!
        }
        if self.measurements != nil {
            map["Measurements"] = self.measurements!
        }
        if self.metric != nil {
            map["Metric"] = self.metric!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.timestamp != nil {
            map["Timestamp"] = self.timestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Associated") && dict["Associated"] != nil {
            self.associated = dict["Associated"] as! [String: String]
        }
        if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
            var tmp : [Dimension] = []
            for v in dict["Dimensions"] as! [Any] {
                var model = Dimension()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dimensions = tmp
        }
        if dict.keys.contains("LogTime") && dict["LogTime"] != nil {
            self.logTime = dict["LogTime"] as! Int64
        }
        if dict.keys.contains("Measurements") && dict["Measurements"] != nil {
            self.measurements = dict["Measurements"] as! [String: Any]
        }
        if dict.keys.contains("Metric") && dict["Metric"] != nil {
            self.metric = dict["Metric"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
            self.timestamp = dict["Timestamp"] as! Int64
        }
    }
}

public class NotificationStrategy : Tea.TeaModel {
    public class EscalationSetting : Tea.TeaModel {
        public class CustomChannels : Tea.TeaModel {
            public var channelType: String?

            public var severities: [String]?

            public var templateUuid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelType != nil {
                    map["ChannelType"] = self.channelType!
                }
                if self.severities != nil {
                    map["Severities"] = self.severities!
                }
                if self.templateUuid != nil {
                    map["TemplateUuid"] = self.templateUuid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChannelType") && dict["ChannelType"] != nil {
                    self.channelType = dict["ChannelType"] as! String
                }
                if dict.keys.contains("Severities") && dict["Severities"] != nil {
                    self.severities = dict["Severities"] as! [String]
                }
                if dict.keys.contains("TemplateUuid") && dict["TemplateUuid"] != nil {
                    self.templateUuid = dict["TemplateUuid"] as! String
                }
            }
        }
        public var autoResolveMin: Int64?

        public var customChannels: [NotificationStrategy.EscalationSetting.CustomChannels]?

        public var escalationLevel: String?

        public var escalationUuid: String?

        public var range: String?

        public var retriggerMin: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoResolveMin != nil {
                map["AutoResolveMin"] = self.autoResolveMin!
            }
            if self.customChannels != nil {
                var tmp : [Any] = []
                for k in self.customChannels! {
                    tmp.append(k.toMap())
                }
                map["CustomChannels"] = tmp
            }
            if self.escalationLevel != nil {
                map["EscalationLevel"] = self.escalationLevel!
            }
            if self.escalationUuid != nil {
                map["EscalationUuid"] = self.escalationUuid!
            }
            if self.range != nil {
                map["Range"] = self.range!
            }
            if self.retriggerMin != nil {
                map["RetriggerMin"] = self.retriggerMin!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoResolveMin") && dict["AutoResolveMin"] != nil {
                self.autoResolveMin = dict["AutoResolveMin"] as! Int64
            }
            if dict.keys.contains("CustomChannels") && dict["CustomChannels"] != nil {
                var tmp : [NotificationStrategy.EscalationSetting.CustomChannels] = []
                for v in dict["CustomChannels"] as! [Any] {
                    var model = NotificationStrategy.EscalationSetting.CustomChannels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customChannels = tmp
            }
            if dict.keys.contains("EscalationLevel") && dict["EscalationLevel"] != nil {
                self.escalationLevel = dict["EscalationLevel"] as! String
            }
            if dict.keys.contains("EscalationUuid") && dict["EscalationUuid"] != nil {
                self.escalationUuid = dict["EscalationUuid"] as! String
            }
            if dict.keys.contains("Range") && dict["Range"] != nil {
                self.range = dict["Range"] as! String
            }
            if dict.keys.contains("RetriggerMin") && dict["RetriggerMin"] != nil {
                self.retriggerMin = dict["RetriggerMin"] as! Int64
            }
        }
    }
    public class FilterSetting : Tea.TeaModel {
        public class BlackList : Tea.TeaModel {
            public var field: String?

            public var op: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.field != nil {
                    map["Field"] = self.field!
                }
                if self.op != nil {
                    map["Op"] = self.op!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Field") && dict["Field"] != nil {
                    self.field = dict["Field"] as! String
                }
                if dict.keys.contains("Op") && dict["Op"] != nil {
                    self.op = dict["Op"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class WhiteList : Tea.TeaModel {
            public var field: String?

            public var op: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.field != nil {
                    map["Field"] = self.field!
                }
                if self.op != nil {
                    map["Op"] = self.op!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Field") && dict["Field"] != nil {
                    self.field = dict["Field"] as! String
                }
                if dict.keys.contains("Op") && dict["Op"] != nil {
                    self.op = dict["Op"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var blackList: [[NotificationStrategy.FilterSetting.BlackList]]?

        public var whiteList: [[NotificationStrategy.FilterSetting.WhiteList]]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.blackList != nil {
                var tmp : [Any] = []
                for k in self.blackList! {
                    var l1 : [Any] = []
                    for k1 in k {
                        l1.append(k1.toMap())
                    }
                    tmp.append(l1)
                }
                map["BlackList"] = tmp
            }
            if self.whiteList != nil {
                var tmp : [Any] = []
                for k in self.whiteList! {
                    var l1 : [Any] = []
                    for k1 in k {
                        l1.append(k1.toMap())
                    }
                    tmp.append(l1)
                }
                map["WhiteList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BlackList") && dict["BlackList"] != nil {
                var tmp : [[NotificationStrategy.FilterSetting.BlackList]] = []
                for v in dict["BlackList"] as! [Any] {
                    var l1 : [NotificationStrategy.FilterSetting.BlackList] = []
                    for v1 in v as! [Any] {
                        var model = NotificationStrategy.FilterSetting.BlackList()
                        if v1 != nil {
                            model.fromMap(v1 as! [String: Any])
                        }
                        l1.append(model)
                    }
                    tmp.append(l1)
                }
                self.blackList = tmp
            }
            if dict.keys.contains("WhiteList") && dict["WhiteList"] != nil {
                var tmp : [[NotificationStrategy.FilterSetting.WhiteList]] = []
                for v in dict["WhiteList"] as! [Any] {
                    var l1 : [NotificationStrategy.FilterSetting.WhiteList] = []
                    for v1 in v as! [Any] {
                        var model = NotificationStrategy.FilterSetting.WhiteList()
                        if v1 != nil {
                            model.fromMap(v1 as! [String: Any])
                        }
                        l1.append(model)
                    }
                    tmp.append(l1)
                }
                self.whiteList = tmp
            }
        }
    }
    public class GroupingSetting : Tea.TeaModel {
        public class GroupingItems : Tea.TeaModel {
            public var keys: [String]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.keys != nil {
                    map["Keys"] = self.keys!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Keys") && dict["Keys"] != nil {
                    self.keys = dict["Keys"] as! [String]
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var enableRawAlertDispatching: Bool?

        public var groupingItems: [NotificationStrategy.GroupingSetting.GroupingItems]?

        public var periodMin: Int32?

        public var silenceSec: Int32?

        public var times: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableRawAlertDispatching != nil {
                map["EnableRawAlertDispatching"] = self.enableRawAlertDispatching!
            }
            if self.groupingItems != nil {
                var tmp : [Any] = []
                for k in self.groupingItems! {
                    tmp.append(k.toMap())
                }
                map["GroupingItems"] = tmp
            }
            if self.periodMin != nil {
                map["PeriodMin"] = self.periodMin!
            }
            if self.silenceSec != nil {
                map["SilenceSec"] = self.silenceSec!
            }
            if self.times != nil {
                map["Times"] = self.times!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableRawAlertDispatching") && dict["EnableRawAlertDispatching"] != nil {
                self.enableRawAlertDispatching = dict["EnableRawAlertDispatching"] as! Bool
            }
            if dict.keys.contains("GroupingItems") && dict["GroupingItems"] != nil {
                var tmp : [NotificationStrategy.GroupingSetting.GroupingItems] = []
                for v in dict["GroupingItems"] as! [Any] {
                    var model = NotificationStrategy.GroupingSetting.GroupingItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.groupingItems = tmp
            }
            if dict.keys.contains("PeriodMin") && dict["PeriodMin"] != nil {
                self.periodMin = dict["PeriodMin"] as! Int32
            }
            if dict.keys.contains("SilenceSec") && dict["SilenceSec"] != nil {
                self.silenceSec = dict["SilenceSec"] as! Int32
            }
            if dict.keys.contains("Times") && dict["Times"] != nil {
                self.times = dict["Times"] as! Int32
            }
        }
    }
    public class PushingSetting : Tea.TeaModel {
        public var pushingDataFormat: String?

        public var range: String?

        public var targetUuids: [String]?

        public var templateUuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pushingDataFormat != nil {
                map["PushingDataFormat"] = self.pushingDataFormat!
            }
            if self.range != nil {
                map["Range"] = self.range!
            }
            if self.targetUuids != nil {
                map["TargetUuids"] = self.targetUuids!
            }
            if self.templateUuid != nil {
                map["TemplateUuid"] = self.templateUuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PushingDataFormat") && dict["PushingDataFormat"] != nil {
                self.pushingDataFormat = dict["PushingDataFormat"] as! String
            }
            if dict.keys.contains("Range") && dict["Range"] != nil {
                self.range = dict["Range"] as! String
            }
            if dict.keys.contains("TargetUuids") && dict["TargetUuids"] != nil {
                self.targetUuids = dict["TargetUuids"] as! [String]
            }
            if dict.keys.contains("TemplateUuid") && dict["TemplateUuid"] != nil {
                self.templateUuid = dict["TemplateUuid"] as! String
            }
        }
    }
    public var createTime: String?

    public var description_: String?

    public var escalationSetting: NotificationStrategy.EscalationSetting?

    public var filterSetting: NotificationStrategy.FilterSetting?

    public var groupingSetting: NotificationStrategy.GroupingSetting?

    public var name: String?

    public var pushingSetting: NotificationStrategy.PushingSetting?

    public var updateTime: String?

    public var userId: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.escalationSetting?.validate()
        try self.filterSetting?.validate()
        try self.groupingSetting?.validate()
        try self.pushingSetting?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.escalationSetting != nil {
            map["EscalationSetting"] = self.escalationSetting?.toMap()
        }
        if self.filterSetting != nil {
            map["FilterSetting"] = self.filterSetting?.toMap()
        }
        if self.groupingSetting != nil {
            map["GroupingSetting"] = self.groupingSetting?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pushingSetting != nil {
            map["PushingSetting"] = self.pushingSetting?.toMap()
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EscalationSetting") && dict["EscalationSetting"] != nil {
            var model = NotificationStrategy.EscalationSetting()
            model.fromMap(dict["EscalationSetting"] as! [String: Any])
            self.escalationSetting = model
        }
        if dict.keys.contains("FilterSetting") && dict["FilterSetting"] != nil {
            var model = NotificationStrategy.FilterSetting()
            model.fromMap(dict["FilterSetting"] as! [String: Any])
            self.filterSetting = model
        }
        if dict.keys.contains("GroupingSetting") && dict["GroupingSetting"] != nil {
            var model = NotificationStrategy.GroupingSetting()
            model.fromMap(dict["GroupingSetting"] as! [String: Any])
            self.groupingSetting = model
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PushingSetting") && dict["PushingSetting"] != nil {
            var model = NotificationStrategy.PushingSetting()
            model.fromMap(dict["PushingSetting"] as! [String: Any])
            self.pushingSetting = model
        }
        if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class NotificationTemplate : Tea.TeaModel {
    public var createTime: String?

    public var description_: String?

    public var enContent: String?

    public var enItemContent: String?

    public var enTitle: String?

    public var name: String?

    public var type: String?

    public var updateTime: String?

    public var userId: String?

    public var uuid: String?

    public var wraperType: String?

    public var zhContent: String?

    public var zhItemContent: String?

    public var zhTitle: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enContent != nil {
            map["EnContent"] = self.enContent!
        }
        if self.enItemContent != nil {
            map["EnItemContent"] = self.enItemContent!
        }
        if self.enTitle != nil {
            map["EnTitle"] = self.enTitle!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        if self.wraperType != nil {
            map["WraperType"] = self.wraperType!
        }
        if self.zhContent != nil {
            map["ZhContent"] = self.zhContent!
        }
        if self.zhItemContent != nil {
            map["ZhItemContent"] = self.zhItemContent!
        }
        if self.zhTitle != nil {
            map["ZhTitle"] = self.zhTitle!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnContent") && dict["EnContent"] != nil {
            self.enContent = dict["EnContent"] as! String
        }
        if dict.keys.contains("EnItemContent") && dict["EnItemContent"] != nil {
            self.enItemContent = dict["EnItemContent"] as! String
        }
        if dict.keys.contains("EnTitle") && dict["EnTitle"] != nil {
            self.enTitle = dict["EnTitle"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
        if dict.keys.contains("WraperType") && dict["WraperType"] != nil {
            self.wraperType = dict["WraperType"] as! String
        }
        if dict.keys.contains("ZhContent") && dict["ZhContent"] != nil {
            self.zhContent = dict["ZhContent"] as! String
        }
        if dict.keys.contains("ZhItemContent") && dict["ZhItemContent"] != nil {
            self.zhItemContent = dict["ZhItemContent"] as! String
        }
        if dict.keys.contains("ZhTitle") && dict["ZhTitle"] != nil {
            self.zhTitle = dict["ZhTitle"] as! String
        }
    }
}

public class PushingTarget : Tea.TeaModel {
    public class HttpRequestTarget : Tea.TeaModel {
        public class Headers : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var contentType: String?

        public var encryptString: String?

        public var headers: [PushingTarget.HttpRequestTarget.Headers]?

        public var method: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contentType != nil {
                map["ContentType"] = self.contentType!
            }
            if self.encryptString != nil {
                map["EncryptString"] = self.encryptString!
            }
            if self.headers != nil {
                var tmp : [Any] = []
                for k in self.headers! {
                    tmp.append(k.toMap())
                }
                map["Headers"] = tmp
            }
            if self.method != nil {
                map["Method"] = self.method!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
                self.contentType = dict["ContentType"] as! String
            }
            if dict.keys.contains("EncryptString") && dict["EncryptString"] != nil {
                self.encryptString = dict["EncryptString"] as! String
            }
            if dict.keys.contains("Headers") && dict["Headers"] != nil {
                var tmp : [PushingTarget.HttpRequestTarget.Headers] = []
                for v in dict["Headers"] as! [Any] {
                    var model = PushingTarget.HttpRequestTarget.Headers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.headers = tmp
            }
            if dict.keys.contains("Method") && dict["Method"] != nil {
                self.method = dict["Method"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var arn: String?

    public var createTime: String?

    public var description_: String?

    public var httpRequestTarget: PushingTarget.HttpRequestTarget?

    public var name: String?

    public var range: String?

    public var templateUuid: String?

    public var type: String?

    public var updateTime: String?

    public var userId: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.httpRequestTarget?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arn != nil {
            map["Arn"] = self.arn!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.httpRequestTarget != nil {
            map["HttpRequestTarget"] = self.httpRequestTarget?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.range != nil {
            map["Range"] = self.range!
        }
        if self.templateUuid != nil {
            map["TemplateUuid"] = self.templateUuid!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Arn") && dict["Arn"] != nil {
            self.arn = dict["Arn"] as! String
        }
        if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("HttpRequestTarget") && dict["HttpRequestTarget"] != nil {
            var model = PushingTarget.HttpRequestTarget()
            model.fromMap(dict["HttpRequestTarget"] as! [String: Any])
            self.httpRequestTarget = model
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Range") && dict["Range"] != nil {
            self.range = dict["Range"] as! String
        }
        if dict.keys.contains("TemplateUuid") && dict["TemplateUuid"] != nil {
            self.templateUuid = dict["TemplateUuid"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class Subscription : Tea.TeaModel {
    public class Conditions : Tea.TeaModel {
        public var field: String?

        public var operator_: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.field != nil {
                map["Field"] = self.field!
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Field") && dict["Field"] != nil {
                self.field = dict["Field"] as! String
            }
            if dict.keys.contains("Operator") && dict["Operator"] != nil {
                self.operator_ = dict["Operator"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var conditions: [Subscription.Conditions]?

    public var createTime: String?

    public var description_: String?

    public var name: String?

    public var relation: String?

    public var strategyUuid: String?

    public var updateTime: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conditions != nil {
            var tmp : [Any] = []
            for k in self.conditions! {
                tmp.append(k.toMap())
            }
            map["Conditions"] = tmp
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.relation != nil {
            map["Relation"] = self.relation!
        }
        if self.strategyUuid != nil {
            map["StrategyUuid"] = self.strategyUuid!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Conditions") && dict["Conditions"] != nil {
            var tmp : [Subscription.Conditions] = []
            for v in dict["Conditions"] as! [Any] {
                var model = Subscription.Conditions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.conditions = tmp
        }
        if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Relation") && dict["Relation"] != nil {
            self.relation = dict["Relation"] as! String
        }
        if dict.keys.contains("StrategyUuid") && dict["StrategyUuid"] != nil {
            self.strategyUuid = dict["StrategyUuid"] as! String
        }
        if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class AddTagsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var groupIds: [String]?

    public var regionId: String?

    public var tag: [AddTagsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupIds != nil {
            map["GroupIds"] = self.groupIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupIds") && dict["GroupIds"] != nil {
            self.groupIds = dict["GroupIds"] as! [String]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [AddTagsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = AddTagsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class AddTagsResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyMetricRuleTemplateRequest : Tea.TeaModel {
    public var applyMode: String?

    public var enableEndTime: Int64?

    public var enableStartTime: Int64?

    public var groupId: Int64?

    public var notifyLevel: Int64?

    public var silenceTime: Int64?

    public var templateIds: String?

    public var webhook: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applyMode != nil {
            map["ApplyMode"] = self.applyMode!
        }
        if self.enableEndTime != nil {
            map["EnableEndTime"] = self.enableEndTime!
        }
        if self.enableStartTime != nil {
            map["EnableStartTime"] = self.enableStartTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.notifyLevel != nil {
            map["NotifyLevel"] = self.notifyLevel!
        }
        if self.silenceTime != nil {
            map["SilenceTime"] = self.silenceTime!
        }
        if self.templateIds != nil {
            map["TemplateIds"] = self.templateIds!
        }
        if self.webhook != nil {
            map["Webhook"] = self.webhook!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplyMode") && dict["ApplyMode"] != nil {
            self.applyMode = dict["ApplyMode"] as! String
        }
        if dict.keys.contains("EnableEndTime") && dict["EnableEndTime"] != nil {
            self.enableEndTime = dict["EnableEndTime"] as! Int64
        }
        if dict.keys.contains("EnableStartTime") && dict["EnableStartTime"] != nil {
            self.enableStartTime = dict["EnableStartTime"] as! Int64
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("NotifyLevel") && dict["NotifyLevel"] != nil {
            self.notifyLevel = dict["NotifyLevel"] as! Int64
        }
        if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
            self.silenceTime = dict["SilenceTime"] as! Int64
        }
        if dict.keys.contains("TemplateIds") && dict["TemplateIds"] != nil {
            self.templateIds = dict["TemplateIds"] as! String
        }
        if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
            self.webhook = dict["Webhook"] as! String
        }
    }
}

public class ApplyMetricRuleTemplateResponseBody : Tea.TeaModel {
    public class Resource : Tea.TeaModel {
        public class AlertResults : Tea.TeaModel {
            public var code: String?

            public var message: String?

            public var ruleId: String?

            public var ruleName: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                    self.ruleId = dict["RuleId"] as! String
                }
                if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("Success") && dict["Success"] != nil {
                    self.success = dict["Success"] as! Bool
                }
            }
        }
        public var alertResults: [ApplyMetricRuleTemplateResponseBody.Resource.AlertResults]?

        public var groupId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertResults != nil {
                var tmp : [Any] = []
                for k in self.alertResults! {
                    tmp.append(k.toMap())
                }
                map["AlertResults"] = tmp
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertResults") && dict["AlertResults"] != nil {
                var tmp : [ApplyMetricRuleTemplateResponseBody.Resource.AlertResults] = []
                for v in dict["AlertResults"] as! [Any] {
                    var model = ApplyMetricRuleTemplateResponseBody.Resource.AlertResults()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertResults = tmp
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var resource: ApplyMetricRuleTemplateResponseBody.Resource?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resource?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Resource") && dict["Resource"] != nil {
            var model = ApplyMetricRuleTemplateResponseBody.Resource()
            model.fromMap(dict["Resource"] as! [String: Any])
            self.resource = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ApplyMetricRuleTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyMetricRuleTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ApplyMetricRuleTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchCreateInstantSiteMonitorRequest : Tea.TeaModel {
    public class TaskList : Tea.TeaModel {
        public var address: String?

        public var ispCities: String?

        public var optionsJson: String?

        public var taskName: String?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.ispCities != nil {
                map["IspCities"] = self.ispCities!
            }
            if self.optionsJson != nil {
                map["OptionsJson"] = self.optionsJson!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") && dict["Address"] != nil {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("IspCities") && dict["IspCities"] != nil {
                self.ispCities = dict["IspCities"] as! String
            }
            if dict.keys.contains("OptionsJson") && dict["OptionsJson"] != nil {
                self.optionsJson = dict["OptionsJson"] as! String
            }
            if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                self.taskName = dict["TaskName"] as! String
            }
            if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                self.taskType = dict["TaskType"] as! String
            }
        }
    }
    public var regionId: String?

    public var taskList: [BatchCreateInstantSiteMonitorRequest.TaskList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskList != nil {
            var tmp : [Any] = []
            for k in self.taskList! {
                tmp.append(k.toMap())
            }
            map["TaskList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskList") && dict["TaskList"] != nil {
            var tmp : [BatchCreateInstantSiteMonitorRequest.TaskList] = []
            for v in dict["TaskList"] as! [Any] {
                var model = BatchCreateInstantSiteMonitorRequest.TaskList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.taskList = tmp
        }
    }
}

public class BatchCreateInstantSiteMonitorResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var taskId: String?

        public var taskName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                self.taskName = dict["TaskName"] as! String
            }
        }
    }
    public var code: String?

    public var data: [BatchCreateInstantSiteMonitorResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [BatchCreateInstantSiteMonitorResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = BatchCreateInstantSiteMonitorResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class BatchCreateInstantSiteMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchCreateInstantSiteMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BatchCreateInstantSiteMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchCreateIntantSiteMonitorRequest : Tea.TeaModel {
    public class TaskList : Tea.TeaModel {
        public var address: String?

        public var ispCities: String?

        public var optionsJson: String?

        public var taskName: String?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.ispCities != nil {
                map["IspCities"] = self.ispCities!
            }
            if self.optionsJson != nil {
                map["OptionsJson"] = self.optionsJson!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") && dict["Address"] != nil {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("IspCities") && dict["IspCities"] != nil {
                self.ispCities = dict["IspCities"] as! String
            }
            if dict.keys.contains("OptionsJson") && dict["OptionsJson"] != nil {
                self.optionsJson = dict["OptionsJson"] as! String
            }
            if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                self.taskName = dict["TaskName"] as! String
            }
            if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                self.taskType = dict["TaskType"] as! String
            }
        }
    }
    public var regionId: String?

    public var taskList: [BatchCreateIntantSiteMonitorRequest.TaskList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskList != nil {
            var tmp : [Any] = []
            for k in self.taskList! {
                tmp.append(k.toMap())
            }
            map["TaskList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskList") && dict["TaskList"] != nil {
            var tmp : [BatchCreateIntantSiteMonitorRequest.TaskList] = []
            for v in dict["TaskList"] as! [Any] {
                var model = BatchCreateIntantSiteMonitorRequest.TaskList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.taskList = tmp
        }
    }
}

public class BatchCreateIntantSiteMonitorResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class BatchCreateIntantSiteMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchCreateIntantSiteMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BatchCreateIntantSiteMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchExportRequest : Tea.TeaModel {
    public var cursor: String?

    public var length: Int32?

    public var measurements: [String]?

    public var metric: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cursor != nil {
            map["Cursor"] = self.cursor!
        }
        if self.length != nil {
            map["Length"] = self.length!
        }
        if self.measurements != nil {
            map["Measurements"] = self.measurements!
        }
        if self.metric != nil {
            map["Metric"] = self.metric!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cursor") && dict["Cursor"] != nil {
            self.cursor = dict["Cursor"] as! String
        }
        if dict.keys.contains("Length") && dict["Length"] != nil {
            self.length = dict["Length"] as! Int32
        }
        if dict.keys.contains("Measurements") && dict["Measurements"] != nil {
            self.measurements = dict["Measurements"] as! [String]
        }
        if dict.keys.contains("Metric") && dict["Metric"] != nil {
            self.metric = dict["Metric"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class BatchExportShrinkRequest : Tea.TeaModel {
    public var cursor: String?

    public var length: Int32?

    public var measurementsShrink: String?

    public var metric: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cursor != nil {
            map["Cursor"] = self.cursor!
        }
        if self.length != nil {
            map["Length"] = self.length!
        }
        if self.measurementsShrink != nil {
            map["Measurements"] = self.measurementsShrink!
        }
        if self.metric != nil {
            map["Metric"] = self.metric!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cursor") && dict["Cursor"] != nil {
            self.cursor = dict["Cursor"] as! String
        }
        if dict.keys.contains("Length") && dict["Length"] != nil {
            self.length = dict["Length"] as! Int32
        }
        if dict.keys.contains("Measurements") && dict["Measurements"] != nil {
            self.measurementsShrink = dict["Measurements"] as! String
        }
        if dict.keys.contains("Metric") && dict["Metric"] != nil {
            self.metric = dict["Metric"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class BatchExportResponseBody : Tea.TeaModel {
    public var anchor: Int64?

    public var code: Int32?

    public var cursor: String?

    public var dataResults: [MetricStat]?

    public var hasNext: Bool?

    public var length: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.anchor != nil {
            map["Anchor"] = self.anchor!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cursor != nil {
            map["Cursor"] = self.cursor!
        }
        if self.dataResults != nil {
            var tmp : [Any] = []
            for k in self.dataResults! {
                tmp.append(k.toMap())
            }
            map["DataResults"] = tmp
        }
        if self.hasNext != nil {
            map["HasNext"] = self.hasNext!
        }
        if self.length != nil {
            map["Length"] = self.length!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Anchor") && dict["Anchor"] != nil {
            self.anchor = dict["Anchor"] as! Int64
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Cursor") && dict["Cursor"] != nil {
            self.cursor = dict["Cursor"] as! String
        }
        if dict.keys.contains("DataResults") && dict["DataResults"] != nil {
            var tmp : [MetricStat] = []
            for v in dict["DataResults"] as! [Any] {
                var model = MetricStat()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataResults = tmp
        }
        if dict.keys.contains("HasNext") && dict["HasNext"] != nil {
            self.hasNext = dict["HasNext"] as! Bool
        }
        if dict.keys.contains("Length") && dict["Length"] != nil {
            self.length = dict["Length"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class BatchExportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchExportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BatchExportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCmsCallNumOrderRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var autoRenewPeriod: Int32?

    public var autoUseCoupon: Bool?

    public var period: Int32?

    public var periodUnit: String?

    public var phoneCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.phoneCount != nil {
            map["PhoneCount"] = self.phoneCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") && dict["AutoPay"] != nil {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoRenewPeriod") && dict["AutoRenewPeriod"] != nil {
            self.autoRenewPeriod = dict["AutoRenewPeriod"] as! Int32
        }
        if dict.keys.contains("AutoUseCoupon") && dict["AutoUseCoupon"] != nil {
            self.autoUseCoupon = dict["AutoUseCoupon"] as! Bool
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") && dict["PeriodUnit"] != nil {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PhoneCount") && dict["PhoneCount"] != nil {
            self.phoneCount = dict["PhoneCount"] as! String
        }
    }
}

public class CreateCmsCallNumOrderResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCmsCallNumOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCmsCallNumOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateCmsCallNumOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCmsOrderRequest : Tea.TeaModel {
    public var apiCount: String?

    public var autoPay: Bool?

    public var autoRenewPeriod: Int32?

    public var autoUseCoupon: Bool?

    public var customTimeSeries: String?

    public var eventStoreNum: String?

    public var eventStoreTime: String?

    public var logMonitorStream: String?

    public var payType: String?

    public var period: Int32?

    public var periodUnit: String?

    public var phoneCount: String?

    public var siteEcsNum: String?

    public var siteOperatorNum: String?

    public var siteTaskNum: String?

    public var smsCount: String?

    public var suggestType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiCount != nil {
            map["ApiCount"] = self.apiCount!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.customTimeSeries != nil {
            map["CustomTimeSeries"] = self.customTimeSeries!
        }
        if self.eventStoreNum != nil {
            map["EventStoreNum"] = self.eventStoreNum!
        }
        if self.eventStoreTime != nil {
            map["EventStoreTime"] = self.eventStoreTime!
        }
        if self.logMonitorStream != nil {
            map["LogMonitorStream"] = self.logMonitorStream!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.phoneCount != nil {
            map["PhoneCount"] = self.phoneCount!
        }
        if self.siteEcsNum != nil {
            map["SiteEcsNum"] = self.siteEcsNum!
        }
        if self.siteOperatorNum != nil {
            map["SiteOperatorNum"] = self.siteOperatorNum!
        }
        if self.siteTaskNum != nil {
            map["SiteTaskNum"] = self.siteTaskNum!
        }
        if self.smsCount != nil {
            map["SmsCount"] = self.smsCount!
        }
        if self.suggestType != nil {
            map["SuggestType"] = self.suggestType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiCount") && dict["ApiCount"] != nil {
            self.apiCount = dict["ApiCount"] as! String
        }
        if dict.keys.contains("AutoPay") && dict["AutoPay"] != nil {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoRenewPeriod") && dict["AutoRenewPeriod"] != nil {
            self.autoRenewPeriod = dict["AutoRenewPeriod"] as! Int32
        }
        if dict.keys.contains("AutoUseCoupon") && dict["AutoUseCoupon"] != nil {
            self.autoUseCoupon = dict["AutoUseCoupon"] as! Bool
        }
        if dict.keys.contains("CustomTimeSeries") && dict["CustomTimeSeries"] != nil {
            self.customTimeSeries = dict["CustomTimeSeries"] as! String
        }
        if dict.keys.contains("EventStoreNum") && dict["EventStoreNum"] != nil {
            self.eventStoreNum = dict["EventStoreNum"] as! String
        }
        if dict.keys.contains("EventStoreTime") && dict["EventStoreTime"] != nil {
            self.eventStoreTime = dict["EventStoreTime"] as! String
        }
        if dict.keys.contains("LogMonitorStream") && dict["LogMonitorStream"] != nil {
            self.logMonitorStream = dict["LogMonitorStream"] as! String
        }
        if dict.keys.contains("PayType") && dict["PayType"] != nil {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") && dict["PeriodUnit"] != nil {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PhoneCount") && dict["PhoneCount"] != nil {
            self.phoneCount = dict["PhoneCount"] as! String
        }
        if dict.keys.contains("SiteEcsNum") && dict["SiteEcsNum"] != nil {
            self.siteEcsNum = dict["SiteEcsNum"] as! String
        }
        if dict.keys.contains("SiteOperatorNum") && dict["SiteOperatorNum"] != nil {
            self.siteOperatorNum = dict["SiteOperatorNum"] as! String
        }
        if dict.keys.contains("SiteTaskNum") && dict["SiteTaskNum"] != nil {
            self.siteTaskNum = dict["SiteTaskNum"] as! String
        }
        if dict.keys.contains("SmsCount") && dict["SmsCount"] != nil {
            self.smsCount = dict["SmsCount"] as! String
        }
        if dict.keys.contains("SuggestType") && dict["SuggestType"] != nil {
            self.suggestType = dict["SuggestType"] as! String
        }
    }
}

public class CreateCmsOrderResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCmsOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCmsOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateCmsOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCmsSmspackageOrderRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var autoRenewPeriod: Int32?

    public var autoUseCoupon: Bool?

    public var period: Int32?

    public var periodUnit: String?

    public var smsCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.smsCount != nil {
            map["SmsCount"] = self.smsCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") && dict["AutoPay"] != nil {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoRenewPeriod") && dict["AutoRenewPeriod"] != nil {
            self.autoRenewPeriod = dict["AutoRenewPeriod"] as! Int32
        }
        if dict.keys.contains("AutoUseCoupon") && dict["AutoUseCoupon"] != nil {
            self.autoUseCoupon = dict["AutoUseCoupon"] as! Bool
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") && dict["PeriodUnit"] != nil {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("SmsCount") && dict["SmsCount"] != nil {
            self.smsCount = dict["SmsCount"] as! String
        }
    }
}

public class CreateCmsSmspackageOrderResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCmsSmspackageOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCmsSmspackageOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateCmsSmspackageOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDynamicTagGroupRequest : Tea.TeaModel {
    public class MatchExpress : Tea.TeaModel {
        public var tagName: String?

        public var tagValue: String?

        public var tagValueMatchFunction: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagName != nil {
                map["TagName"] = self.tagName!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            if self.tagValueMatchFunction != nil {
                map["TagValueMatchFunction"] = self.tagValueMatchFunction!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagName") && dict["TagName"] != nil {
                self.tagName = dict["TagName"] as! String
            }
            if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
                self.tagValue = dict["TagValue"] as! String
            }
            if dict.keys.contains("TagValueMatchFunction") && dict["TagValueMatchFunction"] != nil {
                self.tagValueMatchFunction = dict["TagValueMatchFunction"] as! String
            }
        }
    }
    public var contactGroupList: [String]?

    public var enableInstallAgent: Bool?

    public var enableSubscribeEvent: Bool?

    public var matchExpress: [CreateDynamicTagGroupRequest.MatchExpress]?

    public var matchExpressFilterRelation: String?

    public var regionId: String?

    public var tagKey: String?

    public var tagRegionId: String?

    public var templateIdList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupList != nil {
            map["ContactGroupList"] = self.contactGroupList!
        }
        if self.enableInstallAgent != nil {
            map["EnableInstallAgent"] = self.enableInstallAgent!
        }
        if self.enableSubscribeEvent != nil {
            map["EnableSubscribeEvent"] = self.enableSubscribeEvent!
        }
        if self.matchExpress != nil {
            var tmp : [Any] = []
            for k in self.matchExpress! {
                tmp.append(k.toMap())
            }
            map["MatchExpress"] = tmp
        }
        if self.matchExpressFilterRelation != nil {
            map["MatchExpressFilterRelation"] = self.matchExpressFilterRelation!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        if self.tagRegionId != nil {
            map["TagRegionId"] = self.tagRegionId!
        }
        if self.templateIdList != nil {
            map["TemplateIdList"] = self.templateIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupList") && dict["ContactGroupList"] != nil {
            self.contactGroupList = dict["ContactGroupList"] as! [String]
        }
        if dict.keys.contains("EnableInstallAgent") && dict["EnableInstallAgent"] != nil {
            self.enableInstallAgent = dict["EnableInstallAgent"] as! Bool
        }
        if dict.keys.contains("EnableSubscribeEvent") && dict["EnableSubscribeEvent"] != nil {
            self.enableSubscribeEvent = dict["EnableSubscribeEvent"] as! Bool
        }
        if dict.keys.contains("MatchExpress") && dict["MatchExpress"] != nil {
            var tmp : [CreateDynamicTagGroupRequest.MatchExpress] = []
            for v in dict["MatchExpress"] as! [Any] {
                var model = CreateDynamicTagGroupRequest.MatchExpress()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.matchExpress = tmp
        }
        if dict.keys.contains("MatchExpressFilterRelation") && dict["MatchExpressFilterRelation"] != nil {
            self.matchExpressFilterRelation = dict["MatchExpressFilterRelation"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
            self.tagKey = dict["TagKey"] as! String
        }
        if dict.keys.contains("TagRegionId") && dict["TagRegionId"] != nil {
            self.tagRegionId = dict["TagRegionId"] as! String
        }
        if dict.keys.contains("TemplateIdList") && dict["TemplateIdList"] != nil {
            self.templateIdList = dict["TemplateIdList"] as! [String]
        }
    }
}

public class CreateDynamicTagGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var id: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDynamicTagGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDynamicTagGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateDynamicTagGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateGroupMetricRulesRequest : Tea.TeaModel {
    public class GroupMetricRules : Tea.TeaModel {
        public class Escalations : Tea.TeaModel {
            public class Critical : Tea.TeaModel {
                public var comparisonOperator: String?

                public var n: String?

                public var preCondition: String?

                public var statistics: String?

                public var threshold: String?

                public var times: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.comparisonOperator != nil {
                        map["ComparisonOperator"] = self.comparisonOperator!
                    }
                    if self.n != nil {
                        map["N"] = self.n!
                    }
                    if self.preCondition != nil {
                        map["PreCondition"] = self.preCondition!
                    }
                    if self.statistics != nil {
                        map["Statistics"] = self.statistics!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    if self.times != nil {
                        map["Times"] = self.times!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                        self.comparisonOperator = dict["ComparisonOperator"] as! String
                    }
                    if dict.keys.contains("N") && dict["N"] != nil {
                        self.n = dict["N"] as! String
                    }
                    if dict.keys.contains("PreCondition") && dict["PreCondition"] != nil {
                        self.preCondition = dict["PreCondition"] as! String
                    }
                    if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                        self.statistics = dict["Statistics"] as! String
                    }
                    if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                        self.threshold = dict["Threshold"] as! String
                    }
                    if dict.keys.contains("Times") && dict["Times"] != nil {
                        self.times = dict["Times"] as! Int32
                    }
                }
            }
            public class Info : Tea.TeaModel {
                public var comparisonOperator: String?

                public var n: String?

                public var preCondition: String?

                public var statistics: String?

                public var threshold: String?

                public var times: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.comparisonOperator != nil {
                        map["ComparisonOperator"] = self.comparisonOperator!
                    }
                    if self.n != nil {
                        map["N"] = self.n!
                    }
                    if self.preCondition != nil {
                        map["PreCondition"] = self.preCondition!
                    }
                    if self.statistics != nil {
                        map["Statistics"] = self.statistics!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    if self.times != nil {
                        map["Times"] = self.times!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                        self.comparisonOperator = dict["ComparisonOperator"] as! String
                    }
                    if dict.keys.contains("N") && dict["N"] != nil {
                        self.n = dict["N"] as! String
                    }
                    if dict.keys.contains("PreCondition") && dict["PreCondition"] != nil {
                        self.preCondition = dict["PreCondition"] as! String
                    }
                    if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                        self.statistics = dict["Statistics"] as! String
                    }
                    if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                        self.threshold = dict["Threshold"] as! String
                    }
                    if dict.keys.contains("Times") && dict["Times"] != nil {
                        self.times = dict["Times"] as! Int32
                    }
                }
            }
            public class Warn : Tea.TeaModel {
                public var comparisonOperator: String?

                public var n: String?

                public var preCondition: String?

                public var statistics: String?

                public var threshold: String?

                public var times: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.comparisonOperator != nil {
                        map["ComparisonOperator"] = self.comparisonOperator!
                    }
                    if self.n != nil {
                        map["N"] = self.n!
                    }
                    if self.preCondition != nil {
                        map["PreCondition"] = self.preCondition!
                    }
                    if self.statistics != nil {
                        map["Statistics"] = self.statistics!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    if self.times != nil {
                        map["Times"] = self.times!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                        self.comparisonOperator = dict["ComparisonOperator"] as! String
                    }
                    if dict.keys.contains("N") && dict["N"] != nil {
                        self.n = dict["N"] as! String
                    }
                    if dict.keys.contains("PreCondition") && dict["PreCondition"] != nil {
                        self.preCondition = dict["PreCondition"] as! String
                    }
                    if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                        self.statistics = dict["Statistics"] as! String
                    }
                    if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                        self.threshold = dict["Threshold"] as! String
                    }
                    if dict.keys.contains("Times") && dict["Times"] != nil {
                        self.times = dict["Times"] as! Int32
                    }
                }
            }
            public var critical: CreateGroupMetricRulesRequest.GroupMetricRules.Escalations.Critical?

            public var info: CreateGroupMetricRulesRequest.GroupMetricRules.Escalations.Info?

            public var warn: CreateGroupMetricRulesRequest.GroupMetricRules.Escalations.Warn?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.critical?.validate()
                try self.info?.validate()
                try self.warn?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.critical != nil {
                    map["Critical"] = self.critical?.toMap()
                }
                if self.info != nil {
                    map["Info"] = self.info?.toMap()
                }
                if self.warn != nil {
                    map["Warn"] = self.warn?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Critical") && dict["Critical"] != nil {
                    var model = CreateGroupMetricRulesRequest.GroupMetricRules.Escalations.Critical()
                    model.fromMap(dict["Critical"] as! [String: Any])
                    self.critical = model
                }
                if dict.keys.contains("Info") && dict["Info"] != nil {
                    var model = CreateGroupMetricRulesRequest.GroupMetricRules.Escalations.Info()
                    model.fromMap(dict["Info"] as! [String: Any])
                    self.info = model
                }
                if dict.keys.contains("Warn") && dict["Warn"] != nil {
                    var model = CreateGroupMetricRulesRequest.GroupMetricRules.Escalations.Warn()
                    model.fromMap(dict["Warn"] as! [String: Any])
                    self.warn = model
                }
            }
        }
        public class Labels : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var escalations: CreateGroupMetricRulesRequest.GroupMetricRules.Escalations?

        public var category: String?

        public var contactGroups: String?

        public var dimensions: String?

        public var effectiveInterval: String?

        public var emailSubject: String?

        public var interval: String?

        public var labels: [CreateGroupMetricRulesRequest.GroupMetricRules.Labels]?

        public var metricName: String?

        public var namespace: String?

        public var noDataPolicy: String?

        public var noEffectiveInterval: String?

        public var period: String?

        public var ruleId: String?

        public var ruleName: String?

        public var silenceTime: Int32?

        public var webhook: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.escalations?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.escalations != nil {
                map["Escalations"] = self.escalations?.toMap()
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.contactGroups != nil {
                map["ContactGroups"] = self.contactGroups!
            }
            if self.dimensions != nil {
                map["Dimensions"] = self.dimensions!
            }
            if self.effectiveInterval != nil {
                map["EffectiveInterval"] = self.effectiveInterval!
            }
            if self.emailSubject != nil {
                map["EmailSubject"] = self.emailSubject!
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["Labels"] = tmp
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.noDataPolicy != nil {
                map["NoDataPolicy"] = self.noDataPolicy!
            }
            if self.noEffectiveInterval != nil {
                map["NoEffectiveInterval"] = self.noEffectiveInterval!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.silenceTime != nil {
                map["SilenceTime"] = self.silenceTime!
            }
            if self.webhook != nil {
                map["Webhook"] = self.webhook!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Escalations") && dict["Escalations"] != nil {
                var model = CreateGroupMetricRulesRequest.GroupMetricRules.Escalations()
                model.fromMap(dict["Escalations"] as! [String: Any])
                self.escalations = model
            }
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
                self.contactGroups = dict["ContactGroups"] as! String
            }
            if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
                self.dimensions = dict["Dimensions"] as! String
            }
            if dict.keys.contains("EffectiveInterval") && dict["EffectiveInterval"] != nil {
                self.effectiveInterval = dict["EffectiveInterval"] as! String
            }
            if dict.keys.contains("EmailSubject") && dict["EmailSubject"] != nil {
                self.emailSubject = dict["EmailSubject"] as! String
            }
            if dict.keys.contains("Interval") && dict["Interval"] != nil {
                self.interval = dict["Interval"] as! String
            }
            if dict.keys.contains("Labels") && dict["Labels"] != nil {
                var tmp : [CreateGroupMetricRulesRequest.GroupMetricRules.Labels] = []
                for v in dict["Labels"] as! [Any] {
                    var model = CreateGroupMetricRulesRequest.GroupMetricRules.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NoDataPolicy") && dict["NoDataPolicy"] != nil {
                self.noDataPolicy = dict["NoDataPolicy"] as! String
            }
            if dict.keys.contains("NoEffectiveInterval") && dict["NoEffectiveInterval"] != nil {
                self.noEffectiveInterval = dict["NoEffectiveInterval"] as! String
            }
            if dict.keys.contains("Period") && dict["Period"] != nil {
                self.period = dict["Period"] as! String
            }
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! String
            }
            if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
                self.silenceTime = dict["SilenceTime"] as! Int32
            }
            if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
                self.webhook = dict["Webhook"] as! String
            }
        }
    }
    public var groupId: Int64?

    public var groupMetricRules: [CreateGroupMetricRulesRequest.GroupMetricRules]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupMetricRules != nil {
            var tmp : [Any] = []
            for k in self.groupMetricRules! {
                tmp.append(k.toMap())
            }
            map["GroupMetricRules"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("GroupMetricRules") && dict["GroupMetricRules"] != nil {
            var tmp : [CreateGroupMetricRulesRequest.GroupMetricRules] = []
            for v in dict["GroupMetricRules"] as! [Any] {
                var model = CreateGroupMetricRulesRequest.GroupMetricRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.groupMetricRules = tmp
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateGroupMetricRulesResponseBody : Tea.TeaModel {
    public class Resources : Tea.TeaModel {
        public class AlertResult : Tea.TeaModel {
            public var code: Int32?

            public var message: String?

            public var ruleId: String?

            public var ruleName: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! Int32
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                    self.ruleId = dict["RuleId"] as! String
                }
                if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("Success") && dict["Success"] != nil {
                    self.success = dict["Success"] as! Bool
                }
            }
        }
        public var alertResult: [CreateGroupMetricRulesResponseBody.Resources.AlertResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertResult != nil {
                var tmp : [Any] = []
                for k in self.alertResult! {
                    tmp.append(k.toMap())
                }
                map["AlertResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertResult") && dict["AlertResult"] != nil {
                var tmp : [CreateGroupMetricRulesResponseBody.Resources.AlertResult] = []
                for v in dict["AlertResult"] as! [Any] {
                    var model = CreateGroupMetricRulesResponseBody.Resources.AlertResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertResult = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var resources: CreateGroupMetricRulesResponseBody.Resources?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resources != nil {
            map["Resources"] = self.resources?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Resources") && dict["Resources"] != nil {
            var model = CreateGroupMetricRulesResponseBody.Resources()
            model.fromMap(dict["Resources"] as! [String: Any])
            self.resources = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateGroupMetricRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateGroupMetricRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateGroupMetricRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateGroupMonitoringAgentProcessRequest : Tea.TeaModel {
    public class AlertConfig : Tea.TeaModel {
        public class TargetList : Tea.TeaModel {
            public var arn: String?

            public var id: String?

            public var jsonParams: String?

            public var level: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.arn != nil {
                    map["Arn"] = self.arn!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.jsonParams != nil {
                    map["JsonParams"] = self.jsonParams!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Arn") && dict["Arn"] != nil {
                    self.arn = dict["Arn"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("JsonParams") && dict["JsonParams"] != nil {
                    self.jsonParams = dict["JsonParams"] as! String
                }
                if dict.keys.contains("Level") && dict["Level"] != nil {
                    self.level = dict["Level"] as! String
                }
            }
        }
        public var comparisonOperator: String?

        public var effectiveInterval: String?

        public var escalationsLevel: String?

        public var noEffectiveInterval: String?

        public var silenceTime: String?

        public var statistics: String?

        public var targetList: [CreateGroupMonitoringAgentProcessRequest.AlertConfig.TargetList]?

        public var threshold: String?

        public var times: String?

        public var webhook: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comparisonOperator != nil {
                map["ComparisonOperator"] = self.comparisonOperator!
            }
            if self.effectiveInterval != nil {
                map["EffectiveInterval"] = self.effectiveInterval!
            }
            if self.escalationsLevel != nil {
                map["EscalationsLevel"] = self.escalationsLevel!
            }
            if self.noEffectiveInterval != nil {
                map["NoEffectiveInterval"] = self.noEffectiveInterval!
            }
            if self.silenceTime != nil {
                map["SilenceTime"] = self.silenceTime!
            }
            if self.statistics != nil {
                map["Statistics"] = self.statistics!
            }
            if self.targetList != nil {
                var tmp : [Any] = []
                for k in self.targetList! {
                    tmp.append(k.toMap())
                }
                map["TargetList"] = tmp
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            if self.times != nil {
                map["Times"] = self.times!
            }
            if self.webhook != nil {
                map["Webhook"] = self.webhook!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                self.comparisonOperator = dict["ComparisonOperator"] as! String
            }
            if dict.keys.contains("EffectiveInterval") && dict["EffectiveInterval"] != nil {
                self.effectiveInterval = dict["EffectiveInterval"] as! String
            }
            if dict.keys.contains("EscalationsLevel") && dict["EscalationsLevel"] != nil {
                self.escalationsLevel = dict["EscalationsLevel"] as! String
            }
            if dict.keys.contains("NoEffectiveInterval") && dict["NoEffectiveInterval"] != nil {
                self.noEffectiveInterval = dict["NoEffectiveInterval"] as! String
            }
            if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
                self.silenceTime = dict["SilenceTime"] as! String
            }
            if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                self.statistics = dict["Statistics"] as! String
            }
            if dict.keys.contains("TargetList") && dict["TargetList"] != nil {
                var tmp : [CreateGroupMonitoringAgentProcessRequest.AlertConfig.TargetList] = []
                for v in dict["TargetList"] as! [Any] {
                    var model = CreateGroupMonitoringAgentProcessRequest.AlertConfig.TargetList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.targetList = tmp
            }
            if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                self.threshold = dict["Threshold"] as! String
            }
            if dict.keys.contains("Times") && dict["Times"] != nil {
                self.times = dict["Times"] as! String
            }
            if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
                self.webhook = dict["Webhook"] as! String
            }
        }
    }
    public class MatchExpress : Tea.TeaModel {
        public var function: String?

        public var name: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.function != nil {
                map["Function"] = self.function!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Function") && dict["Function"] != nil {
                self.function = dict["Function"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var alertConfig: [CreateGroupMonitoringAgentProcessRequest.AlertConfig]?

    public var groupId: String?

    public var matchExpress: [CreateGroupMonitoringAgentProcessRequest.MatchExpress]?

    public var matchExpressFilterRelation: String?

    public var processName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertConfig != nil {
            var tmp : [Any] = []
            for k in self.alertConfig! {
                tmp.append(k.toMap())
            }
            map["AlertConfig"] = tmp
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.matchExpress != nil {
            var tmp : [Any] = []
            for k in self.matchExpress! {
                tmp.append(k.toMap())
            }
            map["MatchExpress"] = tmp
        }
        if self.matchExpressFilterRelation != nil {
            map["MatchExpressFilterRelation"] = self.matchExpressFilterRelation!
        }
        if self.processName != nil {
            map["ProcessName"] = self.processName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertConfig") && dict["AlertConfig"] != nil {
            var tmp : [CreateGroupMonitoringAgentProcessRequest.AlertConfig] = []
            for v in dict["AlertConfig"] as! [Any] {
                var model = CreateGroupMonitoringAgentProcessRequest.AlertConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alertConfig = tmp
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("MatchExpress") && dict["MatchExpress"] != nil {
            var tmp : [CreateGroupMonitoringAgentProcessRequest.MatchExpress] = []
            for v in dict["MatchExpress"] as! [Any] {
                var model = CreateGroupMonitoringAgentProcessRequest.MatchExpress()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.matchExpress = tmp
        }
        if dict.keys.contains("MatchExpressFilterRelation") && dict["MatchExpressFilterRelation"] != nil {
            self.matchExpressFilterRelation = dict["MatchExpressFilterRelation"] as! String
        }
        if dict.keys.contains("ProcessName") && dict["ProcessName"] != nil {
            self.processName = dict["ProcessName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateGroupMonitoringAgentProcessResponseBody : Tea.TeaModel {
    public class Resource : Tea.TeaModel {
        public var groupProcessId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupProcessId != nil {
                map["GroupProcessId"] = self.groupProcessId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupProcessId") && dict["GroupProcessId"] != nil {
                self.groupProcessId = dict["GroupProcessId"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var resource: CreateGroupMonitoringAgentProcessResponseBody.Resource?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resource?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Resource") && dict["Resource"] != nil {
            var model = CreateGroupMonitoringAgentProcessResponseBody.Resource()
            model.fromMap(dict["Resource"] as! [String: Any])
            self.resource = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateGroupMonitoringAgentProcessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateGroupMonitoringAgentProcessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateGroupMonitoringAgentProcessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateHostAvailabilityRequest : Tea.TeaModel {
    public class AlertConfig : Tea.TeaModel {
        public var endTime: Int32?

        public var notifyType: Int32?

        public var silenceTime: Int32?

        public var startTime: Int32?

        public var webHook: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.notifyType != nil {
                map["NotifyType"] = self.notifyType!
            }
            if self.silenceTime != nil {
                map["SilenceTime"] = self.silenceTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.webHook != nil {
                map["WebHook"] = self.webHook!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! Int32
            }
            if dict.keys.contains("NotifyType") && dict["NotifyType"] != nil {
                self.notifyType = dict["NotifyType"] as! Int32
            }
            if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
                self.silenceTime = dict["SilenceTime"] as! Int32
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int32
            }
            if dict.keys.contains("WebHook") && dict["WebHook"] != nil {
                self.webHook = dict["WebHook"] as! String
            }
        }
    }
    public class TaskOption : Tea.TeaModel {
        public var httpHeader: String?

        public var httpMethod: String?

        public var httpNegative: Bool?

        public var httpPostContent: String?

        public var httpResponseCharset: String?

        public var httpResponseMatchContent: String?

        public var httpURI: String?

        public var interval: Int32?

        public var telnetOrPingHost: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.httpHeader != nil {
                map["HttpHeader"] = self.httpHeader!
            }
            if self.httpMethod != nil {
                map["HttpMethod"] = self.httpMethod!
            }
            if self.httpNegative != nil {
                map["HttpNegative"] = self.httpNegative!
            }
            if self.httpPostContent != nil {
                map["HttpPostContent"] = self.httpPostContent!
            }
            if self.httpResponseCharset != nil {
                map["HttpResponseCharset"] = self.httpResponseCharset!
            }
            if self.httpResponseMatchContent != nil {
                map["HttpResponseMatchContent"] = self.httpResponseMatchContent!
            }
            if self.httpURI != nil {
                map["HttpURI"] = self.httpURI!
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.telnetOrPingHost != nil {
                map["TelnetOrPingHost"] = self.telnetOrPingHost!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HttpHeader") && dict["HttpHeader"] != nil {
                self.httpHeader = dict["HttpHeader"] as! String
            }
            if dict.keys.contains("HttpMethod") && dict["HttpMethod"] != nil {
                self.httpMethod = dict["HttpMethod"] as! String
            }
            if dict.keys.contains("HttpNegative") && dict["HttpNegative"] != nil {
                self.httpNegative = dict["HttpNegative"] as! Bool
            }
            if dict.keys.contains("HttpPostContent") && dict["HttpPostContent"] != nil {
                self.httpPostContent = dict["HttpPostContent"] as! String
            }
            if dict.keys.contains("HttpResponseCharset") && dict["HttpResponseCharset"] != nil {
                self.httpResponseCharset = dict["HttpResponseCharset"] as! String
            }
            if dict.keys.contains("HttpResponseMatchContent") && dict["HttpResponseMatchContent"] != nil {
                self.httpResponseMatchContent = dict["HttpResponseMatchContent"] as! String
            }
            if dict.keys.contains("HttpURI") && dict["HttpURI"] != nil {
                self.httpURI = dict["HttpURI"] as! String
            }
            if dict.keys.contains("Interval") && dict["Interval"] != nil {
                self.interval = dict["Interval"] as! Int32
            }
            if dict.keys.contains("TelnetOrPingHost") && dict["TelnetOrPingHost"] != nil {
                self.telnetOrPingHost = dict["TelnetOrPingHost"] as! String
            }
        }
    }
    public class AlertConfigEscalationList : Tea.TeaModel {
        public var aggregate: String?

        public var metricName: String?

        public var operator_: String?

        public var times: Int32?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aggregate != nil {
                map["Aggregate"] = self.aggregate!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.times != nil {
                map["Times"] = self.times!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Aggregate") && dict["Aggregate"] != nil {
                self.aggregate = dict["Aggregate"] as! String
            }
            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Operator") && dict["Operator"] != nil {
                self.operator_ = dict["Operator"] as! String
            }
            if dict.keys.contains("Times") && dict["Times"] != nil {
                self.times = dict["Times"] as! Int32
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class AlertConfigTargetList : Tea.TeaModel {
        public var arn: String?

        public var id: String?

        public var jsonParams: String?

        public var level: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.arn != nil {
                map["Arn"] = self.arn!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.jsonParams != nil {
                map["JsonParams"] = self.jsonParams!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Arn") && dict["Arn"] != nil {
                self.arn = dict["Arn"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("JsonParams") && dict["JsonParams"] != nil {
                self.jsonParams = dict["JsonParams"] as! String
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
        }
    }
    public var alertConfig: CreateHostAvailabilityRequest.AlertConfig?

    public var taskOption: CreateHostAvailabilityRequest.TaskOption?

    public var alertConfigEscalationList: [CreateHostAvailabilityRequest.AlertConfigEscalationList]?

    public var alertConfigTargetList: [CreateHostAvailabilityRequest.AlertConfigTargetList]?

    public var groupId: Int64?

    public var instanceList: [String]?

    public var regionId: String?

    public var taskName: String?

    public var taskScope: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertConfig?.validate()
        try self.taskOption?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertConfig != nil {
            map["AlertConfig"] = self.alertConfig?.toMap()
        }
        if self.taskOption != nil {
            map["TaskOption"] = self.taskOption?.toMap()
        }
        if self.alertConfigEscalationList != nil {
            var tmp : [Any] = []
            for k in self.alertConfigEscalationList! {
                tmp.append(k.toMap())
            }
            map["AlertConfigEscalationList"] = tmp
        }
        if self.alertConfigTargetList != nil {
            var tmp : [Any] = []
            for k in self.alertConfigTargetList! {
                tmp.append(k.toMap())
            }
            map["AlertConfigTargetList"] = tmp
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instanceList != nil {
            map["InstanceList"] = self.instanceList!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskScope != nil {
            map["TaskScope"] = self.taskScope!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertConfig") && dict["AlertConfig"] != nil {
            var model = CreateHostAvailabilityRequest.AlertConfig()
            model.fromMap(dict["AlertConfig"] as! [String: Any])
            self.alertConfig = model
        }
        if dict.keys.contains("TaskOption") && dict["TaskOption"] != nil {
            var model = CreateHostAvailabilityRequest.TaskOption()
            model.fromMap(dict["TaskOption"] as! [String: Any])
            self.taskOption = model
        }
        if dict.keys.contains("AlertConfigEscalationList") && dict["AlertConfigEscalationList"] != nil {
            var tmp : [CreateHostAvailabilityRequest.AlertConfigEscalationList] = []
            for v in dict["AlertConfigEscalationList"] as! [Any] {
                var model = CreateHostAvailabilityRequest.AlertConfigEscalationList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alertConfigEscalationList = tmp
        }
        if dict.keys.contains("AlertConfigTargetList") && dict["AlertConfigTargetList"] != nil {
            var tmp : [CreateHostAvailabilityRequest.AlertConfigTargetList] = []
            for v in dict["AlertConfigTargetList"] as! [Any] {
                var model = CreateHostAvailabilityRequest.AlertConfigTargetList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alertConfigTargetList = tmp
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("InstanceList") && dict["InstanceList"] != nil {
            self.instanceList = dict["InstanceList"] as! [String]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskScope") && dict["TaskScope"] != nil {
            self.taskScope = dict["TaskScope"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class CreateHostAvailabilityResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class CreateHostAvailabilityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHostAvailabilityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateHostAvailabilityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateHybridMonitorNamespaceRequest : Tea.TeaModel {
    public var description_: String?

    public var namespace: String?

    public var regionId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Spec") && dict["Spec"] != nil {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class CreateHybridMonitorNamespaceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateHybridMonitorNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHybridMonitorNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateHybridMonitorNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateHybridMonitorSLSGroupRequest : Tea.TeaModel {
    public class SLSGroupConfig : Tea.TeaModel {
        public var SLSLogstore: String?

        public var SLSProject: String?

        public var SLSRegion: String?

        public var SLSUserId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.SLSLogstore != nil {
                map["SLSLogstore"] = self.SLSLogstore!
            }
            if self.SLSProject != nil {
                map["SLSProject"] = self.SLSProject!
            }
            if self.SLSRegion != nil {
                map["SLSRegion"] = self.SLSRegion!
            }
            if self.SLSUserId != nil {
                map["SLSUserId"] = self.SLSUserId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SLSLogstore") && dict["SLSLogstore"] != nil {
                self.SLSLogstore = dict["SLSLogstore"] as! String
            }
            if dict.keys.contains("SLSProject") && dict["SLSProject"] != nil {
                self.SLSProject = dict["SLSProject"] as! String
            }
            if dict.keys.contains("SLSRegion") && dict["SLSRegion"] != nil {
                self.SLSRegion = dict["SLSRegion"] as! String
            }
            if dict.keys.contains("SLSUserId") && dict["SLSUserId"] != nil {
                self.SLSUserId = dict["SLSUserId"] as! String
            }
        }
    }
    public var regionId: String?

    public var SLSGroupConfig: [CreateHybridMonitorSLSGroupRequest.SLSGroupConfig]?

    public var SLSGroupDescription: String?

    public var SLSGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.SLSGroupConfig != nil {
            var tmp : [Any] = []
            for k in self.SLSGroupConfig! {
                tmp.append(k.toMap())
            }
            map["SLSGroupConfig"] = tmp
        }
        if self.SLSGroupDescription != nil {
            map["SLSGroupDescription"] = self.SLSGroupDescription!
        }
        if self.SLSGroupName != nil {
            map["SLSGroupName"] = self.SLSGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SLSGroupConfig") && dict["SLSGroupConfig"] != nil {
            var tmp : [CreateHybridMonitorSLSGroupRequest.SLSGroupConfig] = []
            for v in dict["SLSGroupConfig"] as! [Any] {
                var model = CreateHybridMonitorSLSGroupRequest.SLSGroupConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.SLSGroupConfig = tmp
        }
        if dict.keys.contains("SLSGroupDescription") && dict["SLSGroupDescription"] != nil {
            self.SLSGroupDescription = dict["SLSGroupDescription"] as! String
        }
        if dict.keys.contains("SLSGroupName") && dict["SLSGroupName"] != nil {
            self.SLSGroupName = dict["SLSGroupName"] as! String
        }
    }
}

public class CreateHybridMonitorSLSGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateHybridMonitorSLSGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHybridMonitorSLSGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateHybridMonitorSLSGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateHybridMonitorTaskRequest : Tea.TeaModel {
    public class AttachLabels : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class SLSProcessConfig : Tea.TeaModel {
        public class Express : Tea.TeaModel {
            public var alias: String?

            public var express: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.express != nil {
                    map["Express"] = self.express!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") && dict["Alias"] != nil {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("Express") && dict["Express"] != nil {
                    self.express = dict["Express"] as! String
                }
            }
        }
        public class Filter : Tea.TeaModel {
            public class Filters : Tea.TeaModel {
                public var operator_: String?

                public var SLSKeyName: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.SLSKeyName != nil {
                        map["SLSKeyName"] = self.SLSKeyName!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Operator") && dict["Operator"] != nil {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("SLSKeyName") && dict["SLSKeyName"] != nil {
                        self.SLSKeyName = dict["SLSKeyName"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var filters: [CreateHybridMonitorTaskRequest.SLSProcessConfig.Filter.Filters]?

            public var relation: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.filters != nil {
                    var tmp : [Any] = []
                    for k in self.filters! {
                        tmp.append(k.toMap())
                    }
                    map["Filters"] = tmp
                }
                if self.relation != nil {
                    map["Relation"] = self.relation!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Filters") && dict["Filters"] != nil {
                    var tmp : [CreateHybridMonitorTaskRequest.SLSProcessConfig.Filter.Filters] = []
                    for v in dict["Filters"] as! [Any] {
                        var model = CreateHybridMonitorTaskRequest.SLSProcessConfig.Filter.Filters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.filters = tmp
                }
                if dict.keys.contains("Relation") && dict["Relation"] != nil {
                    self.relation = dict["Relation"] as! String
                }
            }
        }
        public class GroupBy : Tea.TeaModel {
            public var alias: String?

            public var SLSKeyName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.SLSKeyName != nil {
                    map["SLSKeyName"] = self.SLSKeyName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") && dict["Alias"] != nil {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("SLSKeyName") && dict["SLSKeyName"] != nil {
                    self.SLSKeyName = dict["SLSKeyName"] as! String
                }
            }
        }
        public class Statistics : Tea.TeaModel {
            public var alias: String?

            public var function: String?

            public var parameter1: String?

            public var parameter2: String?

            public var SLSKeyName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.function != nil {
                    map["Function"] = self.function!
                }
                if self.parameter1 != nil {
                    map["Parameter1"] = self.parameter1!
                }
                if self.parameter2 != nil {
                    map["Parameter2"] = self.parameter2!
                }
                if self.SLSKeyName != nil {
                    map["SLSKeyName"] = self.SLSKeyName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") && dict["Alias"] != nil {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("Function") && dict["Function"] != nil {
                    self.function = dict["Function"] as! String
                }
                if dict.keys.contains("Parameter1") && dict["Parameter1"] != nil {
                    self.parameter1 = dict["Parameter1"] as! String
                }
                if dict.keys.contains("Parameter2") && dict["Parameter2"] != nil {
                    self.parameter2 = dict["Parameter2"] as! String
                }
                if dict.keys.contains("SLSKeyName") && dict["SLSKeyName"] != nil {
                    self.SLSKeyName = dict["SLSKeyName"] as! String
                }
            }
        }
        public var express: [CreateHybridMonitorTaskRequest.SLSProcessConfig.Express]?

        public var filter: CreateHybridMonitorTaskRequest.SLSProcessConfig.Filter?

        public var groupBy: [CreateHybridMonitorTaskRequest.SLSProcessConfig.GroupBy]?

        public var statistics: [CreateHybridMonitorTaskRequest.SLSProcessConfig.Statistics]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.filter?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.express != nil {
                var tmp : [Any] = []
                for k in self.express! {
                    tmp.append(k.toMap())
                }
                map["Express"] = tmp
            }
            if self.filter != nil {
                map["Filter"] = self.filter?.toMap()
            }
            if self.groupBy != nil {
                var tmp : [Any] = []
                for k in self.groupBy! {
                    tmp.append(k.toMap())
                }
                map["GroupBy"] = tmp
            }
            if self.statistics != nil {
                var tmp : [Any] = []
                for k in self.statistics! {
                    tmp.append(k.toMap())
                }
                map["Statistics"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Express") && dict["Express"] != nil {
                var tmp : [CreateHybridMonitorTaskRequest.SLSProcessConfig.Express] = []
                for v in dict["Express"] as! [Any] {
                    var model = CreateHybridMonitorTaskRequest.SLSProcessConfig.Express()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.express = tmp
            }
            if dict.keys.contains("Filter") && dict["Filter"] != nil {
                var model = CreateHybridMonitorTaskRequest.SLSProcessConfig.Filter()
                model.fromMap(dict["Filter"] as! [String: Any])
                self.filter = model
            }
            if dict.keys.contains("GroupBy") && dict["GroupBy"] != nil {
                var tmp : [CreateHybridMonitorTaskRequest.SLSProcessConfig.GroupBy] = []
                for v in dict["GroupBy"] as! [Any] {
                    var model = CreateHybridMonitorTaskRequest.SLSProcessConfig.GroupBy()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.groupBy = tmp
            }
            if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                var tmp : [CreateHybridMonitorTaskRequest.SLSProcessConfig.Statistics] = []
                for v in dict["Statistics"] as! [Any] {
                    var model = CreateHybridMonitorTaskRequest.SLSProcessConfig.Statistics()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.statistics = tmp
            }
        }
    }
    public var attachLabels: [CreateHybridMonitorTaskRequest.AttachLabels]?

    public var collectInterval: String?

    public var collectTargetType: String?

    public var description_: String?

    public var groupId: String?

    public var namespace: String?

    public var regionId: String?

    public var SLSProcessConfig: CreateHybridMonitorTaskRequest.SLSProcessConfig?

    public var targetUserId: String?

    public var targetUserIdList: String?

    public var taskName: String?

    public var taskType: String?

    public var YARMConfig: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.SLSProcessConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachLabels != nil {
            var tmp : [Any] = []
            for k in self.attachLabels! {
                tmp.append(k.toMap())
            }
            map["AttachLabels"] = tmp
        }
        if self.collectInterval != nil {
            map["CollectInterval"] = self.collectInterval!
        }
        if self.collectTargetType != nil {
            map["CollectTargetType"] = self.collectTargetType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.SLSProcessConfig != nil {
            map["SLSProcessConfig"] = self.SLSProcessConfig?.toMap()
        }
        if self.targetUserId != nil {
            map["TargetUserId"] = self.targetUserId!
        }
        if self.targetUserIdList != nil {
            map["TargetUserIdList"] = self.targetUserIdList!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.YARMConfig != nil {
            map["YARMConfig"] = self.YARMConfig!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachLabels") && dict["AttachLabels"] != nil {
            var tmp : [CreateHybridMonitorTaskRequest.AttachLabels] = []
            for v in dict["AttachLabels"] as! [Any] {
                var model = CreateHybridMonitorTaskRequest.AttachLabels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attachLabels = tmp
        }
        if dict.keys.contains("CollectInterval") && dict["CollectInterval"] != nil {
            self.collectInterval = dict["CollectInterval"] as! String
        }
        if dict.keys.contains("CollectTargetType") && dict["CollectTargetType"] != nil {
            self.collectTargetType = dict["CollectTargetType"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SLSProcessConfig") && dict["SLSProcessConfig"] != nil {
            var model = CreateHybridMonitorTaskRequest.SLSProcessConfig()
            model.fromMap(dict["SLSProcessConfig"] as! [String: Any])
            self.SLSProcessConfig = model
        }
        if dict.keys.contains("TargetUserId") && dict["TargetUserId"] != nil {
            self.targetUserId = dict["TargetUserId"] as! String
        }
        if dict.keys.contains("TargetUserIdList") && dict["TargetUserIdList"] != nil {
            self.targetUserIdList = dict["TargetUserIdList"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
        if dict.keys.contains("YARMConfig") && dict["YARMConfig"] != nil {
            self.YARMConfig = dict["YARMConfig"] as! String
        }
    }
}

public class CreateHybridMonitorTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class CreateHybridMonitorTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHybridMonitorTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateHybridMonitorTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateInstantSiteMonitorRequest : Tea.TeaModel {
    public var address: String?

    public var ispCities: String?

    public var optionsJson: String?

    public var randomIspCity: Int32?

    public var regionId: String?

    public var taskName: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.ispCities != nil {
            map["IspCities"] = self.ispCities!
        }
        if self.optionsJson != nil {
            map["OptionsJson"] = self.optionsJson!
        }
        if self.randomIspCity != nil {
            map["RandomIspCity"] = self.randomIspCity!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("IspCities") && dict["IspCities"] != nil {
            self.ispCities = dict["IspCities"] as! String
        }
        if dict.keys.contains("OptionsJson") && dict["OptionsJson"] != nil {
            self.optionsJson = dict["OptionsJson"] as! String
        }
        if dict.keys.contains("RandomIspCity") && dict["RandomIspCity"] != nil {
            self.randomIspCity = dict["RandomIspCity"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class CreateInstantSiteMonitorResponseBody : Tea.TeaModel {
    public class CreateResultList : Tea.TeaModel {
        public var taskId: String?

        public var taskName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                self.taskName = dict["TaskName"] as! String
            }
        }
    }
    public var code: String?

    public var createResultList: [CreateInstantSiteMonitorResponseBody.CreateResultList]?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.createResultList != nil {
            var tmp : [Any] = []
            for k in self.createResultList! {
                tmp.append(k.toMap())
            }
            map["CreateResultList"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("CreateResultList") && dict["CreateResultList"] != nil {
            var tmp : [CreateInstantSiteMonitorResponseBody.CreateResultList] = []
            for v in dict["CreateResultList"] as! [Any] {
                var model = CreateInstantSiteMonitorResponseBody.CreateResultList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.createResultList = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateInstantSiteMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateInstantSiteMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateInstantSiteMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMetricRuleBlackListRequest : Tea.TeaModel {
    public class Metrics : Tea.TeaModel {
        public var metricName: String?

        public var resource: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.resource != nil {
                map["Resource"] = self.resource!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Resource") && dict["Resource"] != nil {
                self.resource = dict["Resource"] as! String
            }
        }
    }
    public var category: String?

    public var effectiveTime: String?

    public var enableEndTime: String?

    public var enableStartTime: String?

    public var instances: [String]?

    public var metrics: [CreateMetricRuleBlackListRequest.Metrics]?

    public var name: String?

    public var namespace: String?

    public var regionId: String?

    public var scopeType: String?

    public var scopeValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.effectiveTime != nil {
            map["EffectiveTime"] = self.effectiveTime!
        }
        if self.enableEndTime != nil {
            map["EnableEndTime"] = self.enableEndTime!
        }
        if self.enableStartTime != nil {
            map["EnableStartTime"] = self.enableStartTime!
        }
        if self.instances != nil {
            map["Instances"] = self.instances!
        }
        if self.metrics != nil {
            var tmp : [Any] = []
            for k in self.metrics! {
                tmp.append(k.toMap())
            }
            map["Metrics"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scopeType != nil {
            map["ScopeType"] = self.scopeType!
        }
        if self.scopeValue != nil {
            map["ScopeValue"] = self.scopeValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") && dict["Category"] != nil {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("EffectiveTime") && dict["EffectiveTime"] != nil {
            self.effectiveTime = dict["EffectiveTime"] as! String
        }
        if dict.keys.contains("EnableEndTime") && dict["EnableEndTime"] != nil {
            self.enableEndTime = dict["EnableEndTime"] as! String
        }
        if dict.keys.contains("EnableStartTime") && dict["EnableStartTime"] != nil {
            self.enableStartTime = dict["EnableStartTime"] as! String
        }
        if dict.keys.contains("Instances") && dict["Instances"] != nil {
            self.instances = dict["Instances"] as! [String]
        }
        if dict.keys.contains("Metrics") && dict["Metrics"] != nil {
            var tmp : [CreateMetricRuleBlackListRequest.Metrics] = []
            for v in dict["Metrics"] as! [Any] {
                var model = CreateMetricRuleBlackListRequest.Metrics()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.metrics = tmp
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScopeType") && dict["ScopeType"] != nil {
            self.scopeType = dict["ScopeType"] as! String
        }
        if dict.keys.contains("ScopeValue") && dict["ScopeValue"] != nil {
            self.scopeValue = dict["ScopeValue"] as! String
        }
    }
}

public class CreateMetricRuleBlackListResponseBody : Tea.TeaModel {
    public var code: String?

    public var id: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateMetricRuleBlackListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMetricRuleBlackListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMetricRuleBlackListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMetricRuleResourcesRequest : Tea.TeaModel {
    public var overwrite: String?

    public var resources: String?

    public var ruleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.resources != nil {
            map["Resources"] = self.resources!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Overwrite") && dict["Overwrite"] != nil {
            self.overwrite = dict["Overwrite"] as! String
        }
        if dict.keys.contains("Resources") && dict["Resources"] != nil {
            self.resources = dict["Resources"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
    }
}

public class CreateMetricRuleResourcesResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateMetricRuleResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMetricRuleResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMetricRuleResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMetricRuleTemplateRequest : Tea.TeaModel {
    public class AlertTemplates : Tea.TeaModel {
        public class Escalations : Tea.TeaModel {
            public class Critical : Tea.TeaModel {
                public var comparisonOperator: String?

                public var n: Int32?

                public var statistics: String?

                public var threshold: String?

                public var times: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.comparisonOperator != nil {
                        map["ComparisonOperator"] = self.comparisonOperator!
                    }
                    if self.n != nil {
                        map["N"] = self.n!
                    }
                    if self.statistics != nil {
                        map["Statistics"] = self.statistics!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    if self.times != nil {
                        map["Times"] = self.times!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                        self.comparisonOperator = dict["ComparisonOperator"] as! String
                    }
                    if dict.keys.contains("N") && dict["N"] != nil {
                        self.n = dict["N"] as! Int32
                    }
                    if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                        self.statistics = dict["Statistics"] as! String
                    }
                    if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                        self.threshold = dict["Threshold"] as! String
                    }
                    if dict.keys.contains("Times") && dict["Times"] != nil {
                        self.times = dict["Times"] as! Int32
                    }
                }
            }
            public class Info : Tea.TeaModel {
                public var comparisonOperator: String?

                public var n: Int32?

                public var statistics: String?

                public var threshold: String?

                public var times: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.comparisonOperator != nil {
                        map["ComparisonOperator"] = self.comparisonOperator!
                    }
                    if self.n != nil {
                        map["N"] = self.n!
                    }
                    if self.statistics != nil {
                        map["Statistics"] = self.statistics!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    if self.times != nil {
                        map["Times"] = self.times!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                        self.comparisonOperator = dict["ComparisonOperator"] as! String
                    }
                    if dict.keys.contains("N") && dict["N"] != nil {
                        self.n = dict["N"] as! Int32
                    }
                    if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                        self.statistics = dict["Statistics"] as! String
                    }
                    if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                        self.threshold = dict["Threshold"] as! String
                    }
                    if dict.keys.contains("Times") && dict["Times"] != nil {
                        self.times = dict["Times"] as! Int32
                    }
                }
            }
            public class Warn : Tea.TeaModel {
                public var comparisonOperator: String?

                public var n: Int32?

                public var statistics: String?

                public var threshold: String?

                public var times: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.comparisonOperator != nil {
                        map["ComparisonOperator"] = self.comparisonOperator!
                    }
                    if self.n != nil {
                        map["N"] = self.n!
                    }
                    if self.statistics != nil {
                        map["Statistics"] = self.statistics!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    if self.times != nil {
                        map["Times"] = self.times!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                        self.comparisonOperator = dict["ComparisonOperator"] as! String
                    }
                    if dict.keys.contains("N") && dict["N"] != nil {
                        self.n = dict["N"] as! Int32
                    }
                    if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                        self.statistics = dict["Statistics"] as! String
                    }
                    if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                        self.threshold = dict["Threshold"] as! String
                    }
                    if dict.keys.contains("Times") && dict["Times"] != nil {
                        self.times = dict["Times"] as! Int32
                    }
                }
            }
            public var critical: CreateMetricRuleTemplateRequest.AlertTemplates.Escalations.Critical?

            public var info: CreateMetricRuleTemplateRequest.AlertTemplates.Escalations.Info?

            public var warn: CreateMetricRuleTemplateRequest.AlertTemplates.Escalations.Warn?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.critical?.validate()
                try self.info?.validate()
                try self.warn?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.critical != nil {
                    map["Critical"] = self.critical?.toMap()
                }
                if self.info != nil {
                    map["Info"] = self.info?.toMap()
                }
                if self.warn != nil {
                    map["Warn"] = self.warn?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Critical") && dict["Critical"] != nil {
                    var model = CreateMetricRuleTemplateRequest.AlertTemplates.Escalations.Critical()
                    model.fromMap(dict["Critical"] as! [String: Any])
                    self.critical = model
                }
                if dict.keys.contains("Info") && dict["Info"] != nil {
                    var model = CreateMetricRuleTemplateRequest.AlertTemplates.Escalations.Info()
                    model.fromMap(dict["Info"] as! [String: Any])
                    self.info = model
                }
                if dict.keys.contains("Warn") && dict["Warn"] != nil {
                    var model = CreateMetricRuleTemplateRequest.AlertTemplates.Escalations.Warn()
                    model.fromMap(dict["Warn"] as! [String: Any])
                    self.warn = model
                }
            }
        }
        public var escalations: CreateMetricRuleTemplateRequest.AlertTemplates.Escalations?

        public var category: String?

        public var metricName: String?

        public var namespace: String?

        public var period: Int32?

        public var ruleName: String?

        public var selector: String?

        public var webhook: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.escalations?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.escalations != nil {
                map["Escalations"] = self.escalations?.toMap()
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.selector != nil {
                map["Selector"] = self.selector!
            }
            if self.webhook != nil {
                map["Webhook"] = self.webhook!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Escalations") && dict["Escalations"] != nil {
                var model = CreateMetricRuleTemplateRequest.AlertTemplates.Escalations()
                model.fromMap(dict["Escalations"] as! [String: Any])
                self.escalations = model
            }
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Period") && dict["Period"] != nil {
                self.period = dict["Period"] as! Int32
            }
            if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("Selector") && dict["Selector"] != nil {
                self.selector = dict["Selector"] as! String
            }
            if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
                self.webhook = dict["Webhook"] as! String
            }
        }
    }
    public var alertTemplates: [CreateMetricRuleTemplateRequest.AlertTemplates]?

    public var description_: String?

    public var name: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertTemplates != nil {
            var tmp : [Any] = []
            for k in self.alertTemplates! {
                tmp.append(k.toMap())
            }
            map["AlertTemplates"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertTemplates") && dict["AlertTemplates"] != nil {
            var tmp : [CreateMetricRuleTemplateRequest.AlertTemplates] = []
            for v in dict["AlertTemplates"] as! [Any] {
                var model = CreateMetricRuleTemplateRequest.AlertTemplates()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alertTemplates = tmp
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateMetricRuleTemplateResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var id: Int64?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateMetricRuleTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMetricRuleTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMetricRuleTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMonitorAgentProcessRequest : Tea.TeaModel {
    public var instanceId: String?

    public var processName: String?

    public var processUser: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.processName != nil {
            map["ProcessName"] = self.processName!
        }
        if self.processUser != nil {
            map["ProcessUser"] = self.processUser!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ProcessName") && dict["ProcessName"] != nil {
            self.processName = dict["ProcessName"] as! String
        }
        if dict.keys.contains("ProcessUser") && dict["ProcessUser"] != nil {
            self.processUser = dict["ProcessUser"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateMonitorAgentProcessResponseBody : Tea.TeaModel {
    public var code: String?

    public var id: Int64?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateMonitorAgentProcessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMonitorAgentProcessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMonitorAgentProcessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMonitorGroupRequest : Tea.TeaModel {
    public var contactGroups: String?

    public var groupName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroups != nil {
            map["ContactGroups"] = self.contactGroups!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
            self.contactGroups = dict["ContactGroups"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateMonitorGroupResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var groupId: Int64?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateMonitorGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMonitorGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMonitorGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMonitorGroupByResourceGroupIdRequest : Tea.TeaModel {
    public var contactGroupList: [String]?

    public var enableInstallAgent: Bool?

    public var enableSubscribeEvent: Bool?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupList != nil {
            map["ContactGroupList"] = self.contactGroupList!
        }
        if self.enableInstallAgent != nil {
            map["EnableInstallAgent"] = self.enableInstallAgent!
        }
        if self.enableSubscribeEvent != nil {
            map["EnableSubscribeEvent"] = self.enableSubscribeEvent!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceGroupName != nil {
            map["ResourceGroupName"] = self.resourceGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupList") && dict["ContactGroupList"] != nil {
            self.contactGroupList = dict["ContactGroupList"] as! [String]
        }
        if dict.keys.contains("EnableInstallAgent") && dict["EnableInstallAgent"] != nil {
            self.enableInstallAgent = dict["EnableInstallAgent"] as! Bool
        }
        if dict.keys.contains("EnableSubscribeEvent") && dict["EnableSubscribeEvent"] != nil {
            self.enableSubscribeEvent = dict["EnableSubscribeEvent"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceGroupName") && dict["ResourceGroupName"] != nil {
            self.resourceGroupName = dict["ResourceGroupName"] as! String
        }
    }
}

public class CreateMonitorGroupByResourceGroupIdResponseBody : Tea.TeaModel {
    public var code: String?

    public var id: Int64?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateMonitorGroupByResourceGroupIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMonitorGroupByResourceGroupIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMonitorGroupByResourceGroupIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMonitorGroupInstancesRequest : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public var category: String?

        public var instanceId: String?

        public var instanceName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public var groupId: String?

    public var instances: [CreateMonitorGroupInstancesRequest.Instances]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Instances") && dict["Instances"] != nil {
            var tmp : [CreateMonitorGroupInstancesRequest.Instances] = []
            for v in dict["Instances"] as! [Any] {
                var model = CreateMonitorGroupInstancesRequest.Instances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instances = tmp
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateMonitorGroupInstancesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateMonitorGroupInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMonitorGroupInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMonitorGroupInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMonitorGroupNotifyPolicyRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var groupId: String?

    public var policyType: String?

    public var regionId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.policyType != nil {
            map["PolicyType"] = self.policyType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PolicyType") && dict["PolicyType"] != nil {
            self.policyType = dict["PolicyType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class CreateMonitorGroupNotifyPolicyResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var result: Int32?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Int32
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateMonitorGroupNotifyPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMonitorGroupNotifyPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMonitorGroupNotifyPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMonitoringAgentProcessRequest : Tea.TeaModel {
    public var instanceId: String?

    public var processName: String?

    public var processUser: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.processName != nil {
            map["ProcessName"] = self.processName!
        }
        if self.processUser != nil {
            map["ProcessUser"] = self.processUser!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ProcessName") && dict["ProcessName"] != nil {
            self.processName = dict["ProcessName"] as! String
        }
        if dict.keys.contains("ProcessUser") && dict["ProcessUser"] != nil {
            self.processUser = dict["ProcessUser"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateMonitoringAgentProcessResponseBody : Tea.TeaModel {
    public var code: String?

    public var id: Int64?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateMonitoringAgentProcessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMonitoringAgentProcessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMonitoringAgentProcessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSiteMonitorRequest : Tea.TeaModel {
    public var address: String?

    public var alertIds: String?

    public var customSchedule: String?

    public var interval: String?

    public var ispCities: String?

    public var optionsJson: String?

    public var regionId: String?

    public var taskName: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.alertIds != nil {
            map["AlertIds"] = self.alertIds!
        }
        if self.customSchedule != nil {
            map["CustomSchedule"] = self.customSchedule!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCities != nil {
            map["IspCities"] = self.ispCities!
        }
        if self.optionsJson != nil {
            map["OptionsJson"] = self.optionsJson!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("AlertIds") && dict["AlertIds"] != nil {
            self.alertIds = dict["AlertIds"] as! String
        }
        if dict.keys.contains("CustomSchedule") && dict["CustomSchedule"] != nil {
            self.customSchedule = dict["CustomSchedule"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("IspCities") && dict["IspCities"] != nil {
            self.ispCities = dict["IspCities"] as! String
        }
        if dict.keys.contains("OptionsJson") && dict["OptionsJson"] != nil {
            self.optionsJson = dict["OptionsJson"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class CreateSiteMonitorResponseBody : Tea.TeaModel {
    public class CreateResultList : Tea.TeaModel {
        public class CreateResultList : Tea.TeaModel {
            public var taskId: String?

            public var taskName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskName != nil {
                    map["TaskName"] = self.taskName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                    self.taskName = dict["TaskName"] as! String
                }
            }
        }
        public var createResultList: [CreateSiteMonitorResponseBody.CreateResultList.CreateResultList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createResultList != nil {
                var tmp : [Any] = []
                for k in self.createResultList! {
                    tmp.append(k.toMap())
                }
                map["CreateResultList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateResultList") && dict["CreateResultList"] != nil {
                var tmp : [CreateSiteMonitorResponseBody.CreateResultList.CreateResultList] = []
                for v in dict["CreateResultList"] as! [Any] {
                    var model = CreateSiteMonitorResponseBody.CreateResultList.CreateResultList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.createResultList = tmp
            }
        }
    }
    public class Data : Tea.TeaModel {
        public class AttachAlertResult : Tea.TeaModel {
            public class Contact : Tea.TeaModel {
                public var code: String?

                public var message: String?

                public var requestId: String?

                public var ruleId: String?

                public var success: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.requestId != nil {
                        map["RequestId"] = self.requestId!
                    }
                    if self.ruleId != nil {
                        map["RuleId"] = self.ruleId!
                    }
                    if self.success != nil {
                        map["Success"] = self.success!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") && dict["Code"] != nil {
                        self.code = dict["Code"] as! String
                    }
                    if dict.keys.contains("Message") && dict["Message"] != nil {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                        self.requestId = dict["RequestId"] as! String
                    }
                    if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                        self.ruleId = dict["RuleId"] as! String
                    }
                    if dict.keys.contains("Success") && dict["Success"] != nil {
                        self.success = dict["Success"] as! String
                    }
                }
            }
            public var contact: [CreateSiteMonitorResponseBody.Data.AttachAlertResult.Contact]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contact != nil {
                    var tmp : [Any] = []
                    for k in self.contact! {
                        tmp.append(k.toMap())
                    }
                    map["Contact"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Contact") && dict["Contact"] != nil {
                    var tmp : [CreateSiteMonitorResponseBody.Data.AttachAlertResult.Contact] = []
                    for v in dict["Contact"] as! [Any] {
                        var model = CreateSiteMonitorResponseBody.Data.AttachAlertResult.Contact()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.contact = tmp
                }
            }
        }
        public var attachAlertResult: CreateSiteMonitorResponseBody.Data.AttachAlertResult?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.attachAlertResult?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachAlertResult != nil {
                map["AttachAlertResult"] = self.attachAlertResult?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachAlertResult") && dict["AttachAlertResult"] != nil {
                var model = CreateSiteMonitorResponseBody.Data.AttachAlertResult()
                model.fromMap(dict["AttachAlertResult"] as! [String: Any])
                self.attachAlertResult = model
            }
        }
    }
    public var code: String?

    public var createResultList: CreateSiteMonitorResponseBody.CreateResultList?

    public var data: CreateSiteMonitorResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createResultList?.validate()
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.createResultList != nil {
            map["CreateResultList"] = self.createResultList?.toMap()
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("CreateResultList") && dict["CreateResultList"] != nil {
            var model = CreateSiteMonitorResponseBody.CreateResultList()
            model.fromMap(dict["CreateResultList"] as! [String: Any])
            self.createResultList = model
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateSiteMonitorResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateSiteMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSiteMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateSiteMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CursorRequest : Tea.TeaModel {
    public var endTime: String?

    public var matchers: [Matcher]?

    public var metric: String?

    public var namespace: String?

    public var period: Int32?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.matchers != nil {
            var tmp : [Any] = []
            for k in self.matchers! {
                tmp.append(k.toMap())
            }
            map["Matchers"] = tmp
        }
        if self.metric != nil {
            map["Metric"] = self.metric!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Matchers") && dict["Matchers"] != nil {
            var tmp : [Matcher] = []
            for v in dict["Matchers"] as! [Any] {
                var model = Matcher()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.matchers = tmp
        }
        if dict.keys.contains("Metric") && dict["Metric"] != nil {
            self.metric = dict["Metric"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class CursorShrinkRequest : Tea.TeaModel {
    public var endTime: String?

    public var matchersShrink: String?

    public var metric: String?

    public var namespace: String?

    public var period: Int32?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.matchersShrink != nil {
            map["Matchers"] = self.matchersShrink!
        }
        if self.metric != nil {
            map["Metric"] = self.metric!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Matchers") && dict["Matchers"] != nil {
            self.matchersShrink = dict["Matchers"] as! String
        }
        if dict.keys.contains("Metric") && dict["Metric"] != nil {
            self.metric = dict["Metric"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class CursorResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var cursor: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cursor != nil {
            map["Cursor"] = self.cursor!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Cursor") && dict["Cursor"] != nil {
            self.cursor = dict["Cursor"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CursorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CursorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CursorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteContactRequest : Tea.TeaModel {
    public var contactName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
    }
}

public class DeleteContactResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteContactResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteContactResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteContactResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteContactGroupRequest : Tea.TeaModel {
    public var contactGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupName != nil {
            map["ContactGroupName"] = self.contactGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupName") && dict["ContactGroupName"] != nil {
            self.contactGroupName = dict["ContactGroupName"] as! String
        }
    }
}

public class DeleteContactGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteContactGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteContactGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteContactGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomMetricRequest : Tea.TeaModel {
    public var groupId: String?

    public var md5: String?

    public var metricName: String?

    public var regionId: String?

    public var UUID: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.md5 != nil {
            map["Md5"] = self.md5!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.UUID != nil {
            map["UUID"] = self.UUID!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Md5") && dict["Md5"] != nil {
            self.md5 = dict["Md5"] as! String
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("UUID") && dict["UUID"] != nil {
            self.UUID = dict["UUID"] as! String
        }
    }
}

public class DeleteCustomMetricResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCustomMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteCustomMetricResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDynamicTagGroupRequest : Tea.TeaModel {
    public var dynamicTagRuleId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicTagRuleId != nil {
            map["DynamicTagRuleId"] = self.dynamicTagRuleId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicTagRuleId") && dict["DynamicTagRuleId"] != nil {
            self.dynamicTagRuleId = dict["DynamicTagRuleId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteDynamicTagGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDynamicTagGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDynamicTagGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteDynamicTagGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEventRuleTargetsRequest : Tea.TeaModel {
    public var ids: [String]?

    public var regionId: String?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ids") && dict["Ids"] != nil {
            self.ids = dict["Ids"] as! [String]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
    }
}

public class DeleteEventRuleTargetsResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteEventRuleTargetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEventRuleTargetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEventRuleTargetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEventRulesRequest : Tea.TeaModel {
    public var ruleNames: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ruleNames != nil {
            map["RuleNames"] = self.ruleNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RuleNames") && dict["RuleNames"] != nil {
            self.ruleNames = dict["RuleNames"] as! [String]
        }
    }
}

public class DeleteEventRulesResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteEventRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEventRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEventRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteExporterOutputRequest : Tea.TeaModel {
    public var destName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destName != nil {
            map["DestName"] = self.destName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestName") && dict["DestName"] != nil {
            self.destName = dict["DestName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteExporterOutputResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteExporterOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteExporterOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteExporterOutputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteExporterRuleRequest : Tea.TeaModel {
    public var regionId: String?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
    }
}

public class DeleteExporterRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteExporterRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteExporterRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteExporterRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGroupMonitoringAgentProcessRequest : Tea.TeaModel {
    public var groupId: String?

    public var id: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteGroupMonitoringAgentProcessResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGroupMonitoringAgentProcessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGroupMonitoringAgentProcessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteGroupMonitoringAgentProcessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteHostAvailabilityRequest : Tea.TeaModel {
    public var id: [Int64]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! [Int64]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteHostAvailabilityResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteHostAvailabilityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHostAvailabilityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteHostAvailabilityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteHybridMonitorNamespaceRequest : Tea.TeaModel {
    public var namespace: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteHybridMonitorNamespaceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class DeleteHybridMonitorNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHybridMonitorNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteHybridMonitorNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteHybridMonitorSLSGroupRequest : Tea.TeaModel {
    public var regionId: String?

    public var SLSGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.SLSGroupName != nil {
            map["SLSGroupName"] = self.SLSGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SLSGroupName") && dict["SLSGroupName"] != nil {
            self.SLSGroupName = dict["SLSGroupName"] as! String
        }
    }
}

public class DeleteHybridMonitorSLSGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class DeleteHybridMonitorSLSGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHybridMonitorSLSGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteHybridMonitorSLSGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteHybridMonitorTaskRequest : Tea.TeaModel {
    public var namespace: String?

    public var regionId: String?

    public var targetUserId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.targetUserId != nil {
            map["TargetUserId"] = self.targetUserId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TargetUserId") && dict["TargetUserId"] != nil {
            self.targetUserId = dict["TargetUserId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DeleteHybridMonitorTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class DeleteHybridMonitorTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHybridMonitorTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteHybridMonitorTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLogMonitorRequest : Tea.TeaModel {
    public var logId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logId != nil {
            map["LogId"] = self.logId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogId") && dict["LogId"] != nil {
            self.logId = dict["LogId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteLogMonitorResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteLogMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLogMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteLogMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMetricRuleBlackListRequest : Tea.TeaModel {
    public var id: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteMetricRuleBlackListResponseBody : Tea.TeaModel {
    public var code: String?

    public var count: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteMetricRuleBlackListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMetricRuleBlackListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMetricRuleBlackListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMetricRuleResourcesRequest : Tea.TeaModel {
    public var resources: String?

    public var ruleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resources != nil {
            map["Resources"] = self.resources!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Resources") && dict["Resources"] != nil {
            self.resources = dict["Resources"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
    }
}

public class DeleteMetricRuleResourcesResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteMetricRuleResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMetricRuleResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMetricRuleResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMetricRuleTargetsRequest : Tea.TeaModel {
    public var regionId: String?

    public var ruleId: String?

    public var targetIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.targetIds != nil {
            map["TargetIds"] = self.targetIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("TargetIds") && dict["TargetIds"] != nil {
            self.targetIds = dict["TargetIds"] as! [String]
        }
    }
}

public class DeleteMetricRuleTargetsResponseBody : Tea.TeaModel {
    public class FailIds : Tea.TeaModel {
        public class TargetIds : Tea.TeaModel {
            public var targetId: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.targetId != nil {
                    map["TargetId"] = self.targetId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                    self.targetId = dict["TargetId"] as! [String]
                }
            }
        }
        public var targetIds: DeleteMetricRuleTargetsResponseBody.FailIds.TargetIds?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.targetIds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.targetIds != nil {
                map["TargetIds"] = self.targetIds?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TargetIds") && dict["TargetIds"] != nil {
                var model = DeleteMetricRuleTargetsResponseBody.FailIds.TargetIds()
                model.fromMap(dict["TargetIds"] as! [String: Any])
                self.targetIds = model
            }
        }
    }
    public var code: String?

    public var failIds: DeleteMetricRuleTargetsResponseBody.FailIds?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.failIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.failIds != nil {
            map["FailIds"] = self.failIds?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("FailIds") && dict["FailIds"] != nil {
            var model = DeleteMetricRuleTargetsResponseBody.FailIds()
            model.fromMap(dict["FailIds"] as! [String: Any])
            self.failIds = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteMetricRuleTargetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMetricRuleTargetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMetricRuleTargetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMetricRuleTemplateRequest : Tea.TeaModel {
    public var regionId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteMetricRuleTemplateResponseBody : Tea.TeaModel {
    public class Resource : Tea.TeaModel {
        public var templateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var resource: DeleteMetricRuleTemplateResponseBody.Resource?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resource?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Resource") && dict["Resource"] != nil {
            var model = DeleteMetricRuleTemplateResponseBody.Resource()
            model.fromMap(dict["Resource"] as! [String: Any])
            self.resource = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteMetricRuleTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMetricRuleTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMetricRuleTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMetricRulesRequest : Tea.TeaModel {
    public var id: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! [String]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteMetricRulesResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteMetricRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMetricRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMetricRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMonitorGroupRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteMonitorGroupResponseBody : Tea.TeaModel {
    public class Group : Tea.TeaModel {
        public class ContactGroups : Tea.TeaModel {
            public class ContactGroup : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var contactGroup: [DeleteMonitorGroupResponseBody.Group.ContactGroups.ContactGroup]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contactGroup != nil {
                    var tmp : [Any] = []
                    for k in self.contactGroup! {
                        tmp.append(k.toMap())
                    }
                    map["ContactGroup"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContactGroup") && dict["ContactGroup"] != nil {
                    var tmp : [DeleteMonitorGroupResponseBody.Group.ContactGroups.ContactGroup] = []
                    for v in dict["ContactGroup"] as! [Any] {
                        var model = DeleteMonitorGroupResponseBody.Group.ContactGroups.ContactGroup()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.contactGroup = tmp
                }
            }
        }
        public var contactGroups: DeleteMonitorGroupResponseBody.Group.ContactGroups?

        public var groupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.contactGroups?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contactGroups != nil {
                map["ContactGroups"] = self.contactGroups?.toMap()
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
                var model = DeleteMonitorGroupResponseBody.Group.ContactGroups()
                model.fromMap(dict["ContactGroups"] as! [String: Any])
                self.contactGroups = model
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
        }
    }
    public var code: Int32?

    public var group: DeleteMonitorGroupResponseBody.Group?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.group?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.group != nil {
            map["Group"] = self.group?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Group") && dict["Group"] != nil {
            var model = DeleteMonitorGroupResponseBody.Group()
            model.fromMap(dict["Group"] as! [String: Any])
            self.group = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteMonitorGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMonitorGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMonitorGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMonitorGroupDynamicRuleRequest : Tea.TeaModel {
    public var category: String?

    public var groupId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") && dict["Category"] != nil {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteMonitorGroupDynamicRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteMonitorGroupDynamicRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMonitorGroupDynamicRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMonitorGroupDynamicRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMonitorGroupInstancesRequest : Tea.TeaModel {
    public var category: String?

    public var groupId: Int64?

    public var instanceIdList: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instanceIdList != nil {
            map["InstanceIdList"] = self.instanceIdList!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") && dict["Category"] != nil {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("InstanceIdList") && dict["InstanceIdList"] != nil {
            self.instanceIdList = dict["InstanceIdList"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteMonitorGroupInstancesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteMonitorGroupInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMonitorGroupInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMonitorGroupInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMonitorGroupNotifyPolicyRequest : Tea.TeaModel {
    public var groupId: String?

    public var policyType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.policyType != nil {
            map["PolicyType"] = self.policyType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PolicyType") && dict["PolicyType"] != nil {
            self.policyType = dict["PolicyType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteMonitorGroupNotifyPolicyResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var result: Int32?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Int32
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class DeleteMonitorGroupNotifyPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMonitorGroupNotifyPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMonitorGroupNotifyPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMonitoringAgentProcessRequest : Tea.TeaModel {
    public var instanceId: String?

    public var processId: String?

    public var processName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.processId != nil {
            map["ProcessId"] = self.processId!
        }
        if self.processName != nil {
            map["ProcessName"] = self.processName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ProcessId") && dict["ProcessId"] != nil {
            self.processId = dict["ProcessId"] as! String
        }
        if dict.keys.contains("ProcessName") && dict["ProcessName"] != nil {
            self.processName = dict["ProcessName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteMonitoringAgentProcessResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteMonitoringAgentProcessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMonitoringAgentProcessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMonitoringAgentProcessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSiteMonitorsRequest : Tea.TeaModel {
    public var isDeleteAlarms: Bool?

    public var regionId: String?

    public var taskIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isDeleteAlarms != nil {
            map["IsDeleteAlarms"] = self.isDeleteAlarms!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsDeleteAlarms") && dict["IsDeleteAlarms"] != nil {
            self.isDeleteAlarms = dict["IsDeleteAlarms"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskIds") && dict["TaskIds"] != nil {
            self.taskIds = dict["TaskIds"] as! String
        }
    }
}

public class DeleteSiteMonitorsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var count: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["count"] = self.count!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("count") && dict["count"] != nil {
                self.count = dict["count"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: DeleteSiteMonitorsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DeleteSiteMonitorsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class DeleteSiteMonitorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSiteMonitorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSiteMonitorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeActiveMetricRuleListRequest : Tea.TeaModel {
    public var product: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.product != nil {
            map["Product"] = self.product!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Product") && dict["Product"] != nil {
            self.product = dict["Product"] as! String
        }
    }
}

public class DescribeActiveMetricRuleListResponseBody : Tea.TeaModel {
    public class AlertList : Tea.TeaModel {
        public class Alert : Tea.TeaModel {
            public class Escalations : Tea.TeaModel {
                public class Critical : Tea.TeaModel {
                    public var comparisonOperator: String?

                    public var statistics: String?

                    public var threshold: String?

                    public var times: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.comparisonOperator != nil {
                            map["ComparisonOperator"] = self.comparisonOperator!
                        }
                        if self.statistics != nil {
                            map["Statistics"] = self.statistics!
                        }
                        if self.threshold != nil {
                            map["Threshold"] = self.threshold!
                        }
                        if self.times != nil {
                            map["Times"] = self.times!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                            self.comparisonOperator = dict["ComparisonOperator"] as! String
                        }
                        if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                            self.statistics = dict["Statistics"] as! String
                        }
                        if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                            self.threshold = dict["Threshold"] as! String
                        }
                        if dict.keys.contains("Times") && dict["Times"] != nil {
                            self.times = dict["Times"] as! String
                        }
                    }
                }
                public class Info : Tea.TeaModel {
                    public var comparisonOperator: String?

                    public var statistics: String?

                    public var threshold: String?

                    public var times: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.comparisonOperator != nil {
                            map["ComparisonOperator"] = self.comparisonOperator!
                        }
                        if self.statistics != nil {
                            map["Statistics"] = self.statistics!
                        }
                        if self.threshold != nil {
                            map["Threshold"] = self.threshold!
                        }
                        if self.times != nil {
                            map["Times"] = self.times!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                            self.comparisonOperator = dict["ComparisonOperator"] as! String
                        }
                        if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                            self.statistics = dict["Statistics"] as! String
                        }
                        if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                            self.threshold = dict["Threshold"] as! String
                        }
                        if dict.keys.contains("Times") && dict["Times"] != nil {
                            self.times = dict["Times"] as! String
                        }
                    }
                }
                public class Warn : Tea.TeaModel {
                    public var comparisonOperator: String?

                    public var statistics: String?

                    public var threshold: String?

                    public var times: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.comparisonOperator != nil {
                            map["ComparisonOperator"] = self.comparisonOperator!
                        }
                        if self.statistics != nil {
                            map["Statistics"] = self.statistics!
                        }
                        if self.threshold != nil {
                            map["Threshold"] = self.threshold!
                        }
                        if self.times != nil {
                            map["Times"] = self.times!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                            self.comparisonOperator = dict["ComparisonOperator"] as! String
                        }
                        if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                            self.statistics = dict["Statistics"] as! String
                        }
                        if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                            self.threshold = dict["Threshold"] as! String
                        }
                        if dict.keys.contains("Times") && dict["Times"] != nil {
                            self.times = dict["Times"] as! String
                        }
                    }
                }
                public var critical: DescribeActiveMetricRuleListResponseBody.AlertList.Alert.Escalations.Critical?

                public var info: DescribeActiveMetricRuleListResponseBody.AlertList.Alert.Escalations.Info?

                public var warn: DescribeActiveMetricRuleListResponseBody.AlertList.Alert.Escalations.Warn?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.critical?.validate()
                    try self.info?.validate()
                    try self.warn?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.critical != nil {
                        map["Critical"] = self.critical?.toMap()
                    }
                    if self.info != nil {
                        map["Info"] = self.info?.toMap()
                    }
                    if self.warn != nil {
                        map["Warn"] = self.warn?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Critical") && dict["Critical"] != nil {
                        var model = DescribeActiveMetricRuleListResponseBody.AlertList.Alert.Escalations.Critical()
                        model.fromMap(dict["Critical"] as! [String: Any])
                        self.critical = model
                    }
                    if dict.keys.contains("Info") && dict["Info"] != nil {
                        var model = DescribeActiveMetricRuleListResponseBody.AlertList.Alert.Escalations.Info()
                        model.fromMap(dict["Info"] as! [String: Any])
                        self.info = model
                    }
                    if dict.keys.contains("Warn") && dict["Warn"] != nil {
                        var model = DescribeActiveMetricRuleListResponseBody.AlertList.Alert.Escalations.Warn()
                        model.fromMap(dict["Warn"] as! [String: Any])
                        self.warn = model
                    }
                }
            }
            public var alertState: String?

            public var contactGroups: String?

            public var dimensions: String?

            public var effectiveInterval: String?

            public var enableState: Bool?

            public var escalations: DescribeActiveMetricRuleListResponseBody.AlertList.Alert.Escalations?

            public var mailSubject: String?

            public var metricName: String?

            public var namespace: String?

            public var noEffectiveInterval: String?

            public var period: String?

            public var resources: String?

            public var ruleId: String?

            public var ruleName: String?

            public var silenceTime: String?

            public var webhook: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.escalations?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertState != nil {
                    map["AlertState"] = self.alertState!
                }
                if self.contactGroups != nil {
                    map["ContactGroups"] = self.contactGroups!
                }
                if self.dimensions != nil {
                    map["Dimensions"] = self.dimensions!
                }
                if self.effectiveInterval != nil {
                    map["EffectiveInterval"] = self.effectiveInterval!
                }
                if self.enableState != nil {
                    map["EnableState"] = self.enableState!
                }
                if self.escalations != nil {
                    map["Escalations"] = self.escalations?.toMap()
                }
                if self.mailSubject != nil {
                    map["MailSubject"] = self.mailSubject!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.noEffectiveInterval != nil {
                    map["NoEffectiveInterval"] = self.noEffectiveInterval!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.resources != nil {
                    map["Resources"] = self.resources!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.silenceTime != nil {
                    map["SilenceTime"] = self.silenceTime!
                }
                if self.webhook != nil {
                    map["Webhook"] = self.webhook!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertState") && dict["AlertState"] != nil {
                    self.alertState = dict["AlertState"] as! String
                }
                if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
                    self.contactGroups = dict["ContactGroups"] as! String
                }
                if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
                    self.dimensions = dict["Dimensions"] as! String
                }
                if dict.keys.contains("EffectiveInterval") && dict["EffectiveInterval"] != nil {
                    self.effectiveInterval = dict["EffectiveInterval"] as! String
                }
                if dict.keys.contains("EnableState") && dict["EnableState"] != nil {
                    self.enableState = dict["EnableState"] as! Bool
                }
                if dict.keys.contains("Escalations") && dict["Escalations"] != nil {
                    var model = DescribeActiveMetricRuleListResponseBody.AlertList.Alert.Escalations()
                    model.fromMap(dict["Escalations"] as! [String: Any])
                    self.escalations = model
                }
                if dict.keys.contains("MailSubject") && dict["MailSubject"] != nil {
                    self.mailSubject = dict["MailSubject"] as! String
                }
                if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                    self.metricName = dict["MetricName"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("NoEffectiveInterval") && dict["NoEffectiveInterval"] != nil {
                    self.noEffectiveInterval = dict["NoEffectiveInterval"] as! String
                }
                if dict.keys.contains("Period") && dict["Period"] != nil {
                    self.period = dict["Period"] as! String
                }
                if dict.keys.contains("Resources") && dict["Resources"] != nil {
                    self.resources = dict["Resources"] as! String
                }
                if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                    self.ruleId = dict["RuleId"] as! String
                }
                if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
                    self.silenceTime = dict["SilenceTime"] as! String
                }
                if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
                    self.webhook = dict["Webhook"] as! String
                }
            }
        }
        public var alert: [DescribeActiveMetricRuleListResponseBody.AlertList.Alert]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alert != nil {
                var tmp : [Any] = []
                for k in self.alert! {
                    tmp.append(k.toMap())
                }
                map["Alert"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alert") && dict["Alert"] != nil {
                var tmp : [DescribeActiveMetricRuleListResponseBody.AlertList.Alert] = []
                for v in dict["Alert"] as! [Any] {
                    var model = DescribeActiveMetricRuleListResponseBody.AlertList.Alert()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alert = tmp
            }
        }
    }
    public class Datapoints : Tea.TeaModel {
        public class Alarm : Tea.TeaModel {
            public var comparisonOperator: String?

            public var contactGroups: String?

            public var enable: String?

            public var endTime: String?

            public var evaluationCount: String?

            public var metricName: String?

            public var namespace: String?

            public var period: String?

            public var ruleId: String?

            public var ruleName: String?

            public var silenceTime: String?

            public var startTime: String?

            public var state: String?

            public var statistics: String?

            public var threshold: String?

            public var webhook: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comparisonOperator != nil {
                    map["ComparisonOperator"] = self.comparisonOperator!
                }
                if self.contactGroups != nil {
                    map["ContactGroups"] = self.contactGroups!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.evaluationCount != nil {
                    map["EvaluationCount"] = self.evaluationCount!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.silenceTime != nil {
                    map["SilenceTime"] = self.silenceTime!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                if self.webhook != nil {
                    map["Webhook"] = self.webhook!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                    self.comparisonOperator = dict["ComparisonOperator"] as! String
                }
                if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
                    self.contactGroups = dict["ContactGroups"] as! String
                }
                if dict.keys.contains("Enable") && dict["Enable"] != nil {
                    self.enable = dict["Enable"] as! String
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("EvaluationCount") && dict["EvaluationCount"] != nil {
                    self.evaluationCount = dict["EvaluationCount"] as! String
                }
                if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                    self.metricName = dict["MetricName"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Period") && dict["Period"] != nil {
                    self.period = dict["Period"] as! String
                }
                if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                    self.ruleId = dict["RuleId"] as! String
                }
                if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
                    self.silenceTime = dict["SilenceTime"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                    self.statistics = dict["Statistics"] as! String
                }
                if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                    self.threshold = dict["Threshold"] as! String
                }
                if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
                    self.webhook = dict["Webhook"] as! String
                }
            }
        }
        public var alarm: [DescribeActiveMetricRuleListResponseBody.Datapoints.Alarm]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarm != nil {
                var tmp : [Any] = []
                for k in self.alarm! {
                    tmp.append(k.toMap())
                }
                map["Alarm"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alarm") && dict["Alarm"] != nil {
                var tmp : [DescribeActiveMetricRuleListResponseBody.Datapoints.Alarm] = []
                for v in dict["Alarm"] as! [Any] {
                    var model = DescribeActiveMetricRuleListResponseBody.Datapoints.Alarm()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alarm = tmp
            }
        }
    }
    public var alertList: DescribeActiveMetricRuleListResponseBody.AlertList?

    public var code: String?

    public var datapoints: DescribeActiveMetricRuleListResponseBody.Datapoints?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertList?.validate()
        try self.datapoints?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertList != nil {
            map["AlertList"] = self.alertList?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.datapoints != nil {
            map["Datapoints"] = self.datapoints?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertList") && dict["AlertList"] != nil {
            var model = DescribeActiveMetricRuleListResponseBody.AlertList()
            model.fromMap(dict["AlertList"] as! [String: Any])
            self.alertList = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Datapoints") && dict["Datapoints"] != nil {
            var model = DescribeActiveMetricRuleListResponseBody.Datapoints()
            model.fromMap(dict["Datapoints"] as! [String: Any])
            self.datapoints = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeActiveMetricRuleListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeActiveMetricRuleListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeActiveMetricRuleListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAlertHistoryListRequest : Tea.TeaModel {
    public var ascending: Bool?

    public var endTime: String?

    public var groupId: String?

    public var metricName: String?

    public var namespace: String?

    public var page: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var ruleId: String?

    public var ruleName: String?

    public var startTime: String?

    public var state: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ascending != nil {
            map["Ascending"] = self.ascending!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ascending") && dict["Ascending"] != nil {
            self.ascending = dict["Ascending"] as! Bool
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Page") && dict["Page"] != nil {
            self.page = dict["Page"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeAlertHistoryListResponseBody : Tea.TeaModel {
    public class AlarmHistoryList : Tea.TeaModel {
        public class AlarmHistory : Tea.TeaModel {
            public class ContactALIIMs : Tea.TeaModel {
                public var contactALIIM: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.contactALIIM != nil {
                        map["ContactALIIM"] = self.contactALIIM!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ContactALIIM") && dict["ContactALIIM"] != nil {
                        self.contactALIIM = dict["ContactALIIM"] as! [String]
                    }
                }
            }
            public class ContactGroups : Tea.TeaModel {
                public var contactGroup: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.contactGroup != nil {
                        map["ContactGroup"] = self.contactGroup!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ContactGroup") && dict["ContactGroup"] != nil {
                        self.contactGroup = dict["ContactGroup"] as! [String]
                    }
                }
            }
            public class ContactMails : Tea.TeaModel {
                public var contactMail: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.contactMail != nil {
                        map["ContactMail"] = self.contactMail!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ContactMail") && dict["ContactMail"] != nil {
                        self.contactMail = dict["ContactMail"] as! [String]
                    }
                }
            }
            public class ContactSmses : Tea.TeaModel {
                public var contactSms: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.contactSms != nil {
                        map["ContactSms"] = self.contactSms!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ContactSms") && dict["ContactSms"] != nil {
                        self.contactSms = dict["ContactSms"] as! [String]
                    }
                }
            }
            public class Contacts : Tea.TeaModel {
                public var contact: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.contact != nil {
                        map["Contact"] = self.contact!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Contact") && dict["Contact"] != nil {
                        self.contact = dict["Contact"] as! [String]
                    }
                }
            }
            public var alertTime: Int64?

            public var contactALIIMs: DescribeAlertHistoryListResponseBody.AlarmHistoryList.AlarmHistory.ContactALIIMs?

            public var contactGroups: DescribeAlertHistoryListResponseBody.AlarmHistoryList.AlarmHistory.ContactGroups?

            public var contactMails: DescribeAlertHistoryListResponseBody.AlarmHistoryList.AlarmHistory.ContactMails?

            public var contactSmses: DescribeAlertHistoryListResponseBody.AlarmHistoryList.AlarmHistory.ContactSmses?

            public var contacts: DescribeAlertHistoryListResponseBody.AlarmHistoryList.AlarmHistory.Contacts?

            public var dimensions: String?

            public var evaluationCount: Int32?

            public var expression: String?

            public var groupId: String?

            public var instanceName: String?

            public var lastTime: Int64?

            public var level: String?

            public var metricName: String?

            public var namespace: String?

            public var ruleId: String?

            public var ruleName: String?

            public var state: String?

            public var status: Int32?

            public var value: String?

            public var webhooks: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.contactALIIMs?.validate()
                try self.contactGroups?.validate()
                try self.contactMails?.validate()
                try self.contactSmses?.validate()
                try self.contacts?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertTime != nil {
                    map["AlertTime"] = self.alertTime!
                }
                if self.contactALIIMs != nil {
                    map["ContactALIIMs"] = self.contactALIIMs?.toMap()
                }
                if self.contactGroups != nil {
                    map["ContactGroups"] = self.contactGroups?.toMap()
                }
                if self.contactMails != nil {
                    map["ContactMails"] = self.contactMails?.toMap()
                }
                if self.contactSmses != nil {
                    map["ContactSmses"] = self.contactSmses?.toMap()
                }
                if self.contacts != nil {
                    map["Contacts"] = self.contacts?.toMap()
                }
                if self.dimensions != nil {
                    map["Dimensions"] = self.dimensions!
                }
                if self.evaluationCount != nil {
                    map["EvaluationCount"] = self.evaluationCount!
                }
                if self.expression != nil {
                    map["Expression"] = self.expression!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.lastTime != nil {
                    map["LastTime"] = self.lastTime!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                if self.webhooks != nil {
                    map["Webhooks"] = self.webhooks!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertTime") && dict["AlertTime"] != nil {
                    self.alertTime = dict["AlertTime"] as! Int64
                }
                if dict.keys.contains("ContactALIIMs") && dict["ContactALIIMs"] != nil {
                    var model = DescribeAlertHistoryListResponseBody.AlarmHistoryList.AlarmHistory.ContactALIIMs()
                    model.fromMap(dict["ContactALIIMs"] as! [String: Any])
                    self.contactALIIMs = model
                }
                if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
                    var model = DescribeAlertHistoryListResponseBody.AlarmHistoryList.AlarmHistory.ContactGroups()
                    model.fromMap(dict["ContactGroups"] as! [String: Any])
                    self.contactGroups = model
                }
                if dict.keys.contains("ContactMails") && dict["ContactMails"] != nil {
                    var model = DescribeAlertHistoryListResponseBody.AlarmHistoryList.AlarmHistory.ContactMails()
                    model.fromMap(dict["ContactMails"] as! [String: Any])
                    self.contactMails = model
                }
                if dict.keys.contains("ContactSmses") && dict["ContactSmses"] != nil {
                    var model = DescribeAlertHistoryListResponseBody.AlarmHistoryList.AlarmHistory.ContactSmses()
                    model.fromMap(dict["ContactSmses"] as! [String: Any])
                    self.contactSmses = model
                }
                if dict.keys.contains("Contacts") && dict["Contacts"] != nil {
                    var model = DescribeAlertHistoryListResponseBody.AlarmHistoryList.AlarmHistory.Contacts()
                    model.fromMap(dict["Contacts"] as! [String: Any])
                    self.contacts = model
                }
                if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
                    self.dimensions = dict["Dimensions"] as! String
                }
                if dict.keys.contains("EvaluationCount") && dict["EvaluationCount"] != nil {
                    self.evaluationCount = dict["EvaluationCount"] as! Int32
                }
                if dict.keys.contains("Expression") && dict["Expression"] != nil {
                    self.expression = dict["Expression"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("LastTime") && dict["LastTime"] != nil {
                    self.lastTime = dict["LastTime"] as! Int64
                }
                if dict.keys.contains("Level") && dict["Level"] != nil {
                    self.level = dict["Level"] as! String
                }
                if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                    self.metricName = dict["MetricName"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                    self.ruleId = dict["RuleId"] as! String
                }
                if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
                if dict.keys.contains("Webhooks") && dict["Webhooks"] != nil {
                    self.webhooks = dict["Webhooks"] as! String
                }
            }
        }
        public var alarmHistory: [DescribeAlertHistoryListResponseBody.AlarmHistoryList.AlarmHistory]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmHistory != nil {
                var tmp : [Any] = []
                for k in self.alarmHistory! {
                    tmp.append(k.toMap())
                }
                map["AlarmHistory"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmHistory") && dict["AlarmHistory"] != nil {
                var tmp : [DescribeAlertHistoryListResponseBody.AlarmHistoryList.AlarmHistory] = []
                for v in dict["AlarmHistory"] as! [Any] {
                    var model = DescribeAlertHistoryListResponseBody.AlarmHistoryList.AlarmHistory()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alarmHistory = tmp
            }
        }
    }
    public var alarmHistoryList: DescribeAlertHistoryListResponseBody.AlarmHistoryList?

    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var total: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alarmHistoryList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmHistoryList != nil {
            map["AlarmHistoryList"] = self.alarmHistoryList?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmHistoryList") && dict["AlarmHistoryList"] != nil {
            var model = DescribeAlertHistoryListResponseBody.AlarmHistoryList()
            model.fromMap(dict["AlarmHistoryList"] as! [String: Any])
            self.alarmHistoryList = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! String
        }
    }
}

public class DescribeAlertHistoryListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAlertHistoryListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAlertHistoryListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAlertLogCountRequest : Tea.TeaModel {
    public var contactGroup: String?

    public var endTime: Int64?

    public var groupBy: String?

    public var groupId: String?

    public var lastMin: String?

    public var level: String?

    public var metricName: String?

    public var namespace: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var product: String?

    public var regionId: String?

    public var ruleName: String?

    public var searchKey: String?

    public var sendStatus: String?

    public var sourceType: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroup != nil {
            map["ContactGroup"] = self.contactGroup!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupBy != nil {
            map["GroupBy"] = self.groupBy!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lastMin != nil {
            map["LastMin"] = self.lastMin!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.product != nil {
            map["Product"] = self.product!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.sendStatus != nil {
            map["SendStatus"] = self.sendStatus!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroup") && dict["ContactGroup"] != nil {
            self.contactGroup = dict["ContactGroup"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("GroupBy") && dict["GroupBy"] != nil {
            self.groupBy = dict["GroupBy"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("LastMin") && dict["LastMin"] != nil {
            self.lastMin = dict["LastMin"] as! String
        }
        if dict.keys.contains("Level") && dict["Level"] != nil {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Product") && dict["Product"] != nil {
            self.product = dict["Product"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("SearchKey") && dict["SearchKey"] != nil {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("SendStatus") && dict["SendStatus"] != nil {
            self.sendStatus = dict["SendStatus"] as! String
        }
        if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class DescribeAlertLogCountResponseBody : Tea.TeaModel {
    public class AlertLogCount : Tea.TeaModel {
        public class Logs : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var count: Int32?

        public var logs: [DescribeAlertLogCountResponseBody.AlertLogCount.Logs]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.logs != nil {
                var tmp : [Any] = []
                for k in self.logs! {
                    tmp.append(k.toMap())
                }
                map["Logs"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("Logs") && dict["Logs"] != nil {
                var tmp : [DescribeAlertLogCountResponseBody.AlertLogCount.Logs] = []
                for v in dict["Logs"] as! [Any] {
                    var model = DescribeAlertLogCountResponseBody.AlertLogCount.Logs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logs = tmp
            }
        }
    }
    public var alertLogCount: [DescribeAlertLogCountResponseBody.AlertLogCount]?

    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertLogCount != nil {
            var tmp : [Any] = []
            for k in self.alertLogCount! {
                tmp.append(k.toMap())
            }
            map["AlertLogCount"] = tmp
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertLogCount") && dict["AlertLogCount"] != nil {
            var tmp : [DescribeAlertLogCountResponseBody.AlertLogCount] = []
            for v in dict["AlertLogCount"] as! [Any] {
                var model = DescribeAlertLogCountResponseBody.AlertLogCount()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alertLogCount = tmp
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAlertLogCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAlertLogCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAlertLogCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAlertLogHistogramRequest : Tea.TeaModel {
    public var contactGroup: String?

    public var endTime: Int64?

    public var groupBy: String?

    public var groupId: String?

    public var lastMin: String?

    public var level: String?

    public var metricName: String?

    public var namespace: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var product: String?

    public var regionId: String?

    public var ruleName: String?

    public var searchKey: String?

    public var sendStatus: String?

    public var sourceType: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroup != nil {
            map["ContactGroup"] = self.contactGroup!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupBy != nil {
            map["GroupBy"] = self.groupBy!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lastMin != nil {
            map["LastMin"] = self.lastMin!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.product != nil {
            map["Product"] = self.product!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.sendStatus != nil {
            map["SendStatus"] = self.sendStatus!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroup") && dict["ContactGroup"] != nil {
            self.contactGroup = dict["ContactGroup"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("GroupBy") && dict["GroupBy"] != nil {
            self.groupBy = dict["GroupBy"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("LastMin") && dict["LastMin"] != nil {
            self.lastMin = dict["LastMin"] as! String
        }
        if dict.keys.contains("Level") && dict["Level"] != nil {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Product") && dict["Product"] != nil {
            self.product = dict["Product"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("SearchKey") && dict["SearchKey"] != nil {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("SendStatus") && dict["SendStatus"] != nil {
            self.sendStatus = dict["SendStatus"] as! String
        }
        if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class DescribeAlertLogHistogramResponseBody : Tea.TeaModel {
    public class AlertLogHistogramList : Tea.TeaModel {
        public var count: Int32?

        public var from: Int64?

        public var to: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.from != nil {
                map["From"] = self.from!
            }
            if self.to != nil {
                map["To"] = self.to!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("From") && dict["From"] != nil {
                self.from = dict["From"] as! Int64
            }
            if dict.keys.contains("To") && dict["To"] != nil {
                self.to = dict["To"] as! Int64
            }
        }
    }
    public var alertLogHistogramList: [DescribeAlertLogHistogramResponseBody.AlertLogHistogramList]?

    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertLogHistogramList != nil {
            var tmp : [Any] = []
            for k in self.alertLogHistogramList! {
                tmp.append(k.toMap())
            }
            map["AlertLogHistogramList"] = tmp
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertLogHistogramList") && dict["AlertLogHistogramList"] != nil {
            var tmp : [DescribeAlertLogHistogramResponseBody.AlertLogHistogramList] = []
            for v in dict["AlertLogHistogramList"] as! [Any] {
                var model = DescribeAlertLogHistogramResponseBody.AlertLogHistogramList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alertLogHistogramList = tmp
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAlertLogHistogramResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAlertLogHistogramResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAlertLogHistogramResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAlertLogListRequest : Tea.TeaModel {
    public var contactGroup: String?

    public var endTime: Int64?

    public var groupBy: String?

    public var groupId: String?

    public var lastMin: String?

    public var level: String?

    public var metricName: String?

    public var namespace: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var product: String?

    public var regionId: String?

    public var ruleId: String?

    public var ruleName: String?

    public var searchKey: String?

    public var sendStatus: String?

    public var sourceType: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroup != nil {
            map["ContactGroup"] = self.contactGroup!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupBy != nil {
            map["GroupBy"] = self.groupBy!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lastMin != nil {
            map["LastMin"] = self.lastMin!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.product != nil {
            map["Product"] = self.product!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.sendStatus != nil {
            map["SendStatus"] = self.sendStatus!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroup") && dict["ContactGroup"] != nil {
            self.contactGroup = dict["ContactGroup"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("GroupBy") && dict["GroupBy"] != nil {
            self.groupBy = dict["GroupBy"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("LastMin") && dict["LastMin"] != nil {
            self.lastMin = dict["LastMin"] as! String
        }
        if dict.keys.contains("Level") && dict["Level"] != nil {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Product") && dict["Product"] != nil {
            self.product = dict["Product"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("SearchKey") && dict["SearchKey"] != nil {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("SendStatus") && dict["SendStatus"] != nil {
            self.sendStatus = dict["SendStatus"] as! String
        }
        if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class DescribeAlertLogListResponseBody : Tea.TeaModel {
    public class AlertLogList : Tea.TeaModel {
        public class Dimensions : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Escalation : Tea.TeaModel {
            public var expression: String?

            public var level: String?

            public var times: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.expression != nil {
                    map["Expression"] = self.expression!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.times != nil {
                    map["Times"] = self.times!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Expression") && dict["Expression"] != nil {
                    self.expression = dict["Expression"] as! String
                }
                if dict.keys.contains("Level") && dict["Level"] != nil {
                    self.level = dict["Level"] as! String
                }
                if dict.keys.contains("Times") && dict["Times"] != nil {
                    self.times = dict["Times"] as! Int32
                }
            }
        }
        public class ExtendedInfo : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class SendDetail : Tea.TeaModel {
            public class ChannelResultList : Tea.TeaModel {
                public class ResultList : Tea.TeaModel {
                    public var code: String?

                    public var detail: String?

                    public var requestId: String?

                    public var success: Bool?

                    public var notifyTargetList: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.code != nil {
                            map["Code"] = self.code!
                        }
                        if self.detail != nil {
                            map["Detail"] = self.detail!
                        }
                        if self.requestId != nil {
                            map["RequestId"] = self.requestId!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.notifyTargetList != nil {
                            map["notifyTargetList"] = self.notifyTargetList!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Code") && dict["Code"] != nil {
                            self.code = dict["Code"] as! String
                        }
                        if dict.keys.contains("Detail") && dict["Detail"] != nil {
                            self.detail = dict["Detail"] as! String
                        }
                        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                            self.requestId = dict["RequestId"] as! String
                        }
                        if dict.keys.contains("Success") && dict["Success"] != nil {
                            self.success = dict["Success"] as! Bool
                        }
                        if dict.keys.contains("notifyTargetList") && dict["notifyTargetList"] != nil {
                            self.notifyTargetList = dict["notifyTargetList"] as! [String]
                        }
                    }
                }
                public var channel: String?

                public var resultList: [DescribeAlertLogListResponseBody.AlertLogList.SendDetail.ChannelResultList.ResultList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.channel != nil {
                        map["Channel"] = self.channel!
                    }
                    if self.resultList != nil {
                        var tmp : [Any] = []
                        for k in self.resultList! {
                            tmp.append(k.toMap())
                        }
                        map["ResultList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Channel") && dict["Channel"] != nil {
                        self.channel = dict["Channel"] as! String
                    }
                    if dict.keys.contains("ResultList") && dict["ResultList"] != nil {
                        var tmp : [DescribeAlertLogListResponseBody.AlertLogList.SendDetail.ChannelResultList.ResultList] = []
                        for v in dict["ResultList"] as! [Any] {
                            var model = DescribeAlertLogListResponseBody.AlertLogList.SendDetail.ChannelResultList.ResultList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.resultList = tmp
                    }
                }
            }
            public var channelResultList: [DescribeAlertLogListResponseBody.AlertLogList.SendDetail.ChannelResultList]?

            public var resultCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelResultList != nil {
                    var tmp : [Any] = []
                    for k in self.channelResultList! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelResultList"] = tmp
                }
                if self.resultCode != nil {
                    map["ResultCode"] = self.resultCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChannelResultList") && dict["ChannelResultList"] != nil {
                    var tmp : [DescribeAlertLogListResponseBody.AlertLogList.SendDetail.ChannelResultList] = []
                    for v in dict["ChannelResultList"] as! [Any] {
                        var model = DescribeAlertLogListResponseBody.AlertLogList.SendDetail.ChannelResultList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelResultList = tmp
                }
                if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
                    self.resultCode = dict["ResultCode"] as! String
                }
            }
        }
        public class SendResultList : Tea.TeaModel {
            public var key: String?

            public var value: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! [String]
                }
            }
        }
        public class WebhookList : Tea.TeaModel {
            public var code: String?

            public var message: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.url != nil {
                    map["url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") && dict["code"] != nil {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("message") && dict["message"] != nil {
                    self.message = dict["message"] as! String
                }
                if dict.keys.contains("url") && dict["url"] != nil {
                    self.url = dict["url"] as! String
                }
            }
        }
        public var alertTime: String?

        public var blackListDetail: String?

        public var blackListName: String?

        public var blackListUUID: String?

        public var contactALIIWWList: [String]?

        public var contactDingList: [String]?

        public var contactGroups: [String]?

        public var contactMailList: [String]?

        public var contactOnCallList: [String]?

        public var contactSMSList: [String]?

        public var dimensions: [DescribeAlertLogListResponseBody.AlertLogList.Dimensions]?

        public var dingdingWebhookList: [String]?

        public var escalation: DescribeAlertLogListResponseBody.AlertLogList.Escalation?

        public var eventName: String?

        public var extendedInfo: [DescribeAlertLogListResponseBody.AlertLogList.ExtendedInfo]?

        public var groupId: String?

        public var groupName: String?

        public var instanceId: String?

        public var instanceName: String?

        public var level: String?

        public var levelChange: String?

        public var logId: String?

        public var message: String?

        public var metricName: String?

        public var namespace: String?

        public var product: String?

        public var ruleId: String?

        public var ruleName: String?

        public var sendDetail: DescribeAlertLogListResponseBody.AlertLogList.SendDetail?

        public var sendResultList: [DescribeAlertLogListResponseBody.AlertLogList.SendResultList]?

        public var sendStatus: String?

        public var webhookList: [DescribeAlertLogListResponseBody.AlertLogList.WebhookList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.escalation?.validate()
            try self.sendDetail?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertTime != nil {
                map["AlertTime"] = self.alertTime!
            }
            if self.blackListDetail != nil {
                map["BlackListDetail"] = self.blackListDetail!
            }
            if self.blackListName != nil {
                map["BlackListName"] = self.blackListName!
            }
            if self.blackListUUID != nil {
                map["BlackListUUID"] = self.blackListUUID!
            }
            if self.contactALIIWWList != nil {
                map["ContactALIIWWList"] = self.contactALIIWWList!
            }
            if self.contactDingList != nil {
                map["ContactDingList"] = self.contactDingList!
            }
            if self.contactGroups != nil {
                map["ContactGroups"] = self.contactGroups!
            }
            if self.contactMailList != nil {
                map["ContactMailList"] = self.contactMailList!
            }
            if self.contactOnCallList != nil {
                map["ContactOnCallList"] = self.contactOnCallList!
            }
            if self.contactSMSList != nil {
                map["ContactSMSList"] = self.contactSMSList!
            }
            if self.dimensions != nil {
                var tmp : [Any] = []
                for k in self.dimensions! {
                    tmp.append(k.toMap())
                }
                map["Dimensions"] = tmp
            }
            if self.dingdingWebhookList != nil {
                map["DingdingWebhookList"] = self.dingdingWebhookList!
            }
            if self.escalation != nil {
                map["Escalation"] = self.escalation?.toMap()
            }
            if self.eventName != nil {
                map["EventName"] = self.eventName!
            }
            if self.extendedInfo != nil {
                var tmp : [Any] = []
                for k in self.extendedInfo! {
                    tmp.append(k.toMap())
                }
                map["ExtendedInfo"] = tmp
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.levelChange != nil {
                map["LevelChange"] = self.levelChange!
            }
            if self.logId != nil {
                map["LogId"] = self.logId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.product != nil {
                map["Product"] = self.product!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.sendDetail != nil {
                map["SendDetail"] = self.sendDetail?.toMap()
            }
            if self.sendResultList != nil {
                var tmp : [Any] = []
                for k in self.sendResultList! {
                    tmp.append(k.toMap())
                }
                map["SendResultList"] = tmp
            }
            if self.sendStatus != nil {
                map["SendStatus"] = self.sendStatus!
            }
            if self.webhookList != nil {
                var tmp : [Any] = []
                for k in self.webhookList! {
                    tmp.append(k.toMap())
                }
                map["WebhookList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertTime") && dict["AlertTime"] != nil {
                self.alertTime = dict["AlertTime"] as! String
            }
            if dict.keys.contains("BlackListDetail") && dict["BlackListDetail"] != nil {
                self.blackListDetail = dict["BlackListDetail"] as! String
            }
            if dict.keys.contains("BlackListName") && dict["BlackListName"] != nil {
                self.blackListName = dict["BlackListName"] as! String
            }
            if dict.keys.contains("BlackListUUID") && dict["BlackListUUID"] != nil {
                self.blackListUUID = dict["BlackListUUID"] as! String
            }
            if dict.keys.contains("ContactALIIWWList") && dict["ContactALIIWWList"] != nil {
                self.contactALIIWWList = dict["ContactALIIWWList"] as! [String]
            }
            if dict.keys.contains("ContactDingList") && dict["ContactDingList"] != nil {
                self.contactDingList = dict["ContactDingList"] as! [String]
            }
            if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
                self.contactGroups = dict["ContactGroups"] as! [String]
            }
            if dict.keys.contains("ContactMailList") && dict["ContactMailList"] != nil {
                self.contactMailList = dict["ContactMailList"] as! [String]
            }
            if dict.keys.contains("ContactOnCallList") && dict["ContactOnCallList"] != nil {
                self.contactOnCallList = dict["ContactOnCallList"] as! [String]
            }
            if dict.keys.contains("ContactSMSList") && dict["ContactSMSList"] != nil {
                self.contactSMSList = dict["ContactSMSList"] as! [String]
            }
            if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
                var tmp : [DescribeAlertLogListResponseBody.AlertLogList.Dimensions] = []
                for v in dict["Dimensions"] as! [Any] {
                    var model = DescribeAlertLogListResponseBody.AlertLogList.Dimensions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dimensions = tmp
            }
            if dict.keys.contains("DingdingWebhookList") && dict["DingdingWebhookList"] != nil {
                self.dingdingWebhookList = dict["DingdingWebhookList"] as! [String]
            }
            if dict.keys.contains("Escalation") && dict["Escalation"] != nil {
                var model = DescribeAlertLogListResponseBody.AlertLogList.Escalation()
                model.fromMap(dict["Escalation"] as! [String: Any])
                self.escalation = model
            }
            if dict.keys.contains("EventName") && dict["EventName"] != nil {
                self.eventName = dict["EventName"] as! String
            }
            if dict.keys.contains("ExtendedInfo") && dict["ExtendedInfo"] != nil {
                var tmp : [DescribeAlertLogListResponseBody.AlertLogList.ExtendedInfo] = []
                for v in dict["ExtendedInfo"] as! [Any] {
                    var model = DescribeAlertLogListResponseBody.AlertLogList.ExtendedInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.extendedInfo = tmp
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("LevelChange") && dict["LevelChange"] != nil {
                self.levelChange = dict["LevelChange"] as! String
            }
            if dict.keys.contains("LogId") && dict["LogId"] != nil {
                self.logId = dict["LogId"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Product") && dict["Product"] != nil {
                self.product = dict["Product"] as! String
            }
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! String
            }
            if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("SendDetail") && dict["SendDetail"] != nil {
                var model = DescribeAlertLogListResponseBody.AlertLogList.SendDetail()
                model.fromMap(dict["SendDetail"] as! [String: Any])
                self.sendDetail = model
            }
            if dict.keys.contains("SendResultList") && dict["SendResultList"] != nil {
                var tmp : [DescribeAlertLogListResponseBody.AlertLogList.SendResultList] = []
                for v in dict["SendResultList"] as! [Any] {
                    var model = DescribeAlertLogListResponseBody.AlertLogList.SendResultList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sendResultList = tmp
            }
            if dict.keys.contains("SendStatus") && dict["SendStatus"] != nil {
                self.sendStatus = dict["SendStatus"] as! String
            }
            if dict.keys.contains("WebhookList") && dict["WebhookList"] != nil {
                var tmp : [DescribeAlertLogListResponseBody.AlertLogList.WebhookList] = []
                for v in dict["WebhookList"] as! [Any] {
                    var model = DescribeAlertLogListResponseBody.AlertLogList.WebhookList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.webhookList = tmp
            }
        }
    }
    public var alertLogList: [DescribeAlertLogListResponseBody.AlertLogList]?

    public var code: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertLogList != nil {
            var tmp : [Any] = []
            for k in self.alertLogList! {
                tmp.append(k.toMap())
            }
            map["AlertLogList"] = tmp
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertLogList") && dict["AlertLogList"] != nil {
            var tmp : [DescribeAlertLogListResponseBody.AlertLogList] = []
            for v in dict["AlertLogList"] as! [Any] {
                var model = DescribeAlertLogListResponseBody.AlertLogList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alertLogList = tmp
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAlertLogListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAlertLogListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAlertLogListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAlertingMetricRuleResourcesRequest : Tea.TeaModel {
    public var dimensions: String?

    public var groupId: String?

    public var namespace: String?

    public var page: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var ruleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dimensions != nil {
            map["Dimensions"] = self.dimensions!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
            self.dimensions = dict["Dimensions"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Page") && dict["Page"] != nil {
            self.page = dict["Page"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
    }
}

public class DescribeAlertingMetricRuleResourcesResponseBody : Tea.TeaModel {
    public class Resources : Tea.TeaModel {
        public class Resource : Tea.TeaModel {
            public class Escalation : Tea.TeaModel {
                public class Resource : Tea.TeaModel {
                    public class ExpressionList : Tea.TeaModel {
                        public class ExpressionList : Tea.TeaModel {
                            public var comparisonOperator: String?

                            public var metricName: String?

                            public var period: String?

                            public var statistics: String?

                            public var threshold: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.comparisonOperator != nil {
                                    map["ComparisonOperator"] = self.comparisonOperator!
                                }
                                if self.metricName != nil {
                                    map["MetricName"] = self.metricName!
                                }
                                if self.period != nil {
                                    map["Period"] = self.period!
                                }
                                if self.statistics != nil {
                                    map["Statistics"] = self.statistics!
                                }
                                if self.threshold != nil {
                                    map["Threshold"] = self.threshold!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                                    self.comparisonOperator = dict["ComparisonOperator"] as! String
                                }
                                if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                                    self.metricName = dict["MetricName"] as! String
                                }
                                if dict.keys.contains("Period") && dict["Period"] != nil {
                                    self.period = dict["Period"] as! String
                                }
                                if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                                    self.statistics = dict["Statistics"] as! String
                                }
                                if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                                    self.threshold = dict["Threshold"] as! String
                                }
                            }
                        }
                        public var expressionList: [DescribeAlertingMetricRuleResourcesResponseBody.Resources.Resource.Escalation.Resource.ExpressionList.ExpressionList]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.expressionList != nil {
                                var tmp : [Any] = []
                                for k in self.expressionList! {
                                    tmp.append(k.toMap())
                                }
                                map["ExpressionList"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ExpressionList") && dict["ExpressionList"] != nil {
                                var tmp : [DescribeAlertingMetricRuleResourcesResponseBody.Resources.Resource.Escalation.Resource.ExpressionList.ExpressionList] = []
                                for v in dict["ExpressionList"] as! [Any] {
                                    var model = DescribeAlertingMetricRuleResourcesResponseBody.Resources.Resource.Escalation.Resource.ExpressionList.ExpressionList()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.expressionList = tmp
                            }
                        }
                    }
                    public var comparisonOperator: String?

                    public var expression: String?

                    public var expressionList: DescribeAlertingMetricRuleResourcesResponseBody.Resources.Resource.Escalation.Resource.ExpressionList?

                    public var expressionListJoin: String?

                    public var expressionRaw: String?

                    public var level: Int32?

                    public var preCondition: String?

                    public var tag: String?

                    public var threshold: String?

                    public var times: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.expressionList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.comparisonOperator != nil {
                            map["ComparisonOperator"] = self.comparisonOperator!
                        }
                        if self.expression != nil {
                            map["Expression"] = self.expression!
                        }
                        if self.expressionList != nil {
                            map["ExpressionList"] = self.expressionList?.toMap()
                        }
                        if self.expressionListJoin != nil {
                            map["ExpressionListJoin"] = self.expressionListJoin!
                        }
                        if self.expressionRaw != nil {
                            map["ExpressionRaw"] = self.expressionRaw!
                        }
                        if self.level != nil {
                            map["Level"] = self.level!
                        }
                        if self.preCondition != nil {
                            map["PreCondition"] = self.preCondition!
                        }
                        if self.tag != nil {
                            map["Tag"] = self.tag!
                        }
                        if self.threshold != nil {
                            map["Threshold"] = self.threshold!
                        }
                        if self.times != nil {
                            map["Times"] = self.times!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                            self.comparisonOperator = dict["ComparisonOperator"] as! String
                        }
                        if dict.keys.contains("Expression") && dict["Expression"] != nil {
                            self.expression = dict["Expression"] as! String
                        }
                        if dict.keys.contains("ExpressionList") && dict["ExpressionList"] != nil {
                            var model = DescribeAlertingMetricRuleResourcesResponseBody.Resources.Resource.Escalation.Resource.ExpressionList()
                            model.fromMap(dict["ExpressionList"] as! [String: Any])
                            self.expressionList = model
                        }
                        if dict.keys.contains("ExpressionListJoin") && dict["ExpressionListJoin"] != nil {
                            self.expressionListJoin = dict["ExpressionListJoin"] as! String
                        }
                        if dict.keys.contains("ExpressionRaw") && dict["ExpressionRaw"] != nil {
                            self.expressionRaw = dict["ExpressionRaw"] as! String
                        }
                        if dict.keys.contains("Level") && dict["Level"] != nil {
                            self.level = dict["Level"] as! Int32
                        }
                        if dict.keys.contains("PreCondition") && dict["PreCondition"] != nil {
                            self.preCondition = dict["PreCondition"] as! String
                        }
                        if dict.keys.contains("Tag") && dict["Tag"] != nil {
                            self.tag = dict["Tag"] as! String
                        }
                        if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                            self.threshold = dict["Threshold"] as! String
                        }
                        if dict.keys.contains("Times") && dict["Times"] != nil {
                            self.times = dict["Times"] as! Int32
                        }
                    }
                }
                public var resource: [DescribeAlertingMetricRuleResourcesResponseBody.Resources.Resource.Escalation.Resource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resource != nil {
                        var tmp : [Any] = []
                        for k in self.resource! {
                            tmp.append(k.toMap())
                        }
                        map["Resource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Resource") && dict["Resource"] != nil {
                        var tmp : [DescribeAlertingMetricRuleResourcesResponseBody.Resources.Resource.Escalation.Resource] = []
                        for v in dict["Resource"] as! [Any] {
                            var model = DescribeAlertingMetricRuleResourcesResponseBody.Resources.Resource.Escalation.Resource()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.resource = tmp
                    }
                }
            }
            public var dimensions: String?

            public var enable: String?

            public var escalation: DescribeAlertingMetricRuleResourcesResponseBody.Resources.Resource.Escalation?

            public var groupId: String?

            public var lastAlertTime: String?

            public var lastModifyTime: String?

            public var level: Int32?

            public var metricName: String?

            public var metricValues: String?

            public var namespace: String?

            public var productCategory: String?

            public var resource: String?

            public var retryTimes: String?

            public var ruleId: String?

            public var ruleName: String?

            public var startTime: String?

            public var statistics: String?

            public var threshold: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.escalation?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dimensions != nil {
                    map["Dimensions"] = self.dimensions!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.escalation != nil {
                    map["Escalation"] = self.escalation?.toMap()
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.lastAlertTime != nil {
                    map["LastAlertTime"] = self.lastAlertTime!
                }
                if self.lastModifyTime != nil {
                    map["LastModifyTime"] = self.lastModifyTime!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.metricValues != nil {
                    map["MetricValues"] = self.metricValues!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.productCategory != nil {
                    map["ProductCategory"] = self.productCategory!
                }
                if self.resource != nil {
                    map["Resource"] = self.resource!
                }
                if self.retryTimes != nil {
                    map["RetryTimes"] = self.retryTimes!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
                    self.dimensions = dict["Dimensions"] as! String
                }
                if dict.keys.contains("Enable") && dict["Enable"] != nil {
                    self.enable = dict["Enable"] as! String
                }
                if dict.keys.contains("Escalation") && dict["Escalation"] != nil {
                    var model = DescribeAlertingMetricRuleResourcesResponseBody.Resources.Resource.Escalation()
                    model.fromMap(dict["Escalation"] as! [String: Any])
                    self.escalation = model
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("LastAlertTime") && dict["LastAlertTime"] != nil {
                    self.lastAlertTime = dict["LastAlertTime"] as! String
                }
                if dict.keys.contains("LastModifyTime") && dict["LastModifyTime"] != nil {
                    self.lastModifyTime = dict["LastModifyTime"] as! String
                }
                if dict.keys.contains("Level") && dict["Level"] != nil {
                    self.level = dict["Level"] as! Int32
                }
                if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                    self.metricName = dict["MetricName"] as! String
                }
                if dict.keys.contains("MetricValues") && dict["MetricValues"] != nil {
                    self.metricValues = dict["MetricValues"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("ProductCategory") && dict["ProductCategory"] != nil {
                    self.productCategory = dict["ProductCategory"] as! String
                }
                if dict.keys.contains("Resource") && dict["Resource"] != nil {
                    self.resource = dict["Resource"] as! String
                }
                if dict.keys.contains("RetryTimes") && dict["RetryTimes"] != nil {
                    self.retryTimes = dict["RetryTimes"] as! String
                }
                if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                    self.ruleId = dict["RuleId"] as! String
                }
                if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                    self.statistics = dict["Statistics"] as! String
                }
                if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                    self.threshold = dict["Threshold"] as! String
                }
            }
        }
        public var resource: [DescribeAlertingMetricRuleResourcesResponseBody.Resources.Resource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resource != nil {
                var tmp : [Any] = []
                for k in self.resource! {
                    tmp.append(k.toMap())
                }
                map["Resource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Resource") && dict["Resource"] != nil {
                var tmp : [DescribeAlertingMetricRuleResourcesResponseBody.Resources.Resource] = []
                for v in dict["Resource"] as! [Any] {
                    var model = DescribeAlertingMetricRuleResourcesResponseBody.Resources.Resource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resource = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var resources: DescribeAlertingMetricRuleResourcesResponseBody.Resources?

    public var success: Bool?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resources != nil {
            map["Resources"] = self.resources?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Resources") && dict["Resources"] != nil {
            var model = DescribeAlertingMetricRuleResourcesResponseBody.Resources()
            model.fromMap(dict["Resources"] as! [String: Any])
            self.resources = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeAlertingMetricRuleResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAlertingMetricRuleResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAlertingMetricRuleResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeContactGroupListRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeContactGroupListResponseBody : Tea.TeaModel {
    public class ContactGroupList : Tea.TeaModel {
        public class ContactGroup : Tea.TeaModel {
            public class Contacts : Tea.TeaModel {
                public var contact: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.contact != nil {
                        map["Contact"] = self.contact!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Contact") && dict["Contact"] != nil {
                        self.contact = dict["Contact"] as! [String]
                    }
                }
            }
            public var contacts: DescribeContactGroupListResponseBody.ContactGroupList.ContactGroup.Contacts?

            public var createTime: Int64?

            public var describe: String?

            public var enableSubscribed: Bool?

            public var enabledWeeklyReport: Bool?

            public var name: String?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.contacts?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contacts != nil {
                    map["Contacts"] = self.contacts?.toMap()
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.describe != nil {
                    map["Describe"] = self.describe!
                }
                if self.enableSubscribed != nil {
                    map["EnableSubscribed"] = self.enableSubscribed!
                }
                if self.enabledWeeklyReport != nil {
                    map["EnabledWeeklyReport"] = self.enabledWeeklyReport!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Contacts") && dict["Contacts"] != nil {
                    var model = DescribeContactGroupListResponseBody.ContactGroupList.ContactGroup.Contacts()
                    model.fromMap(dict["Contacts"] as! [String: Any])
                    self.contacts = model
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Describe") && dict["Describe"] != nil {
                    self.describe = dict["Describe"] as! String
                }
                if dict.keys.contains("EnableSubscribed") && dict["EnableSubscribed"] != nil {
                    self.enableSubscribed = dict["EnableSubscribed"] as! Bool
                }
                if dict.keys.contains("EnabledWeeklyReport") && dict["EnabledWeeklyReport"] != nil {
                    self.enabledWeeklyReport = dict["EnabledWeeklyReport"] as! Bool
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
            }
        }
        public var contactGroup: [DescribeContactGroupListResponseBody.ContactGroupList.ContactGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contactGroup != nil {
                var tmp : [Any] = []
                for k in self.contactGroup! {
                    tmp.append(k.toMap())
                }
                map["ContactGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContactGroup") && dict["ContactGroup"] != nil {
                var tmp : [DescribeContactGroupListResponseBody.ContactGroupList.ContactGroup] = []
                for v in dict["ContactGroup"] as! [Any] {
                    var model = DescribeContactGroupListResponseBody.ContactGroupList.ContactGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.contactGroup = tmp
            }
        }
    }
    public class ContactGroups : Tea.TeaModel {
        public var contactGroup: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contactGroup != nil {
                map["ContactGroup"] = self.contactGroup!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContactGroup") && dict["ContactGroup"] != nil {
                self.contactGroup = dict["ContactGroup"] as! [String]
            }
        }
    }
    public var code: String?

    public var contactGroupList: DescribeContactGroupListResponseBody.ContactGroupList?

    public var contactGroups: DescribeContactGroupListResponseBody.ContactGroups?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.contactGroupList?.validate()
        try self.contactGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.contactGroupList != nil {
            map["ContactGroupList"] = self.contactGroupList?.toMap()
        }
        if self.contactGroups != nil {
            map["ContactGroups"] = self.contactGroups?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ContactGroupList") && dict["ContactGroupList"] != nil {
            var model = DescribeContactGroupListResponseBody.ContactGroupList()
            model.fromMap(dict["ContactGroupList"] as! [String: Any])
            self.contactGroupList = model
        }
        if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
            var model = DescribeContactGroupListResponseBody.ContactGroups()
            model.fromMap(dict["ContactGroups"] as! [String: Any])
            self.contactGroups = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeContactGroupListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeContactGroupListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeContactGroupListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeContactListRequest : Tea.TeaModel {
    public var chanelType: String?

    public var chanelValue: String?

    public var contactName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chanelType != nil {
            map["ChanelType"] = self.chanelType!
        }
        if self.chanelValue != nil {
            map["ChanelValue"] = self.chanelValue!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChanelType") && dict["ChanelType"] != nil {
            self.chanelType = dict["ChanelType"] as! String
        }
        if dict.keys.contains("ChanelValue") && dict["ChanelValue"] != nil {
            self.chanelValue = dict["ChanelValue"] as! String
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeContactListResponseBody : Tea.TeaModel {
    public class Contacts : Tea.TeaModel {
        public class Contact : Tea.TeaModel {
            public class Channels : Tea.TeaModel {
                public var aliIM: String?

                public var dingWebHook: String?

                public var mail: String?

                public var SMS: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aliIM != nil {
                        map["AliIM"] = self.aliIM!
                    }
                    if self.dingWebHook != nil {
                        map["DingWebHook"] = self.dingWebHook!
                    }
                    if self.mail != nil {
                        map["Mail"] = self.mail!
                    }
                    if self.SMS != nil {
                        map["SMS"] = self.SMS!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AliIM") && dict["AliIM"] != nil {
                        self.aliIM = dict["AliIM"] as! String
                    }
                    if dict.keys.contains("DingWebHook") && dict["DingWebHook"] != nil {
                        self.dingWebHook = dict["DingWebHook"] as! String
                    }
                    if dict.keys.contains("Mail") && dict["Mail"] != nil {
                        self.mail = dict["Mail"] as! String
                    }
                    if dict.keys.contains("SMS") && dict["SMS"] != nil {
                        self.SMS = dict["SMS"] as! String
                    }
                }
            }
            public class ChannelsState : Tea.TeaModel {
                public var aliIM: String?

                public var dingWebHook: String?

                public var mail: String?

                public var SMS: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aliIM != nil {
                        map["AliIM"] = self.aliIM!
                    }
                    if self.dingWebHook != nil {
                        map["DingWebHook"] = self.dingWebHook!
                    }
                    if self.mail != nil {
                        map["Mail"] = self.mail!
                    }
                    if self.SMS != nil {
                        map["SMS"] = self.SMS!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AliIM") && dict["AliIM"] != nil {
                        self.aliIM = dict["AliIM"] as! String
                    }
                    if dict.keys.contains("DingWebHook") && dict["DingWebHook"] != nil {
                        self.dingWebHook = dict["DingWebHook"] as! String
                    }
                    if dict.keys.contains("Mail") && dict["Mail"] != nil {
                        self.mail = dict["Mail"] as! String
                    }
                    if dict.keys.contains("SMS") && dict["SMS"] != nil {
                        self.SMS = dict["SMS"] as! String
                    }
                }
            }
            public class ContactGroups : Tea.TeaModel {
                public var contactGroup: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.contactGroup != nil {
                        map["ContactGroup"] = self.contactGroup!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ContactGroup") && dict["ContactGroup"] != nil {
                        self.contactGroup = dict["ContactGroup"] as! [String]
                    }
                }
            }
            public var channels: DescribeContactListResponseBody.Contacts.Contact.Channels?

            public var channelsState: DescribeContactListResponseBody.Contacts.Contact.ChannelsState?

            public var contactGroups: DescribeContactListResponseBody.Contacts.Contact.ContactGroups?

            public var createTime: Int64?

            public var desc: String?

            public var lang: String?

            public var name: String?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.channels?.validate()
                try self.channelsState?.validate()
                try self.contactGroups?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channels != nil {
                    map["Channels"] = self.channels?.toMap()
                }
                if self.channelsState != nil {
                    map["ChannelsState"] = self.channelsState?.toMap()
                }
                if self.contactGroups != nil {
                    map["ContactGroups"] = self.contactGroups?.toMap()
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.desc != nil {
                    map["Desc"] = self.desc!
                }
                if self.lang != nil {
                    map["Lang"] = self.lang!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Channels") && dict["Channels"] != nil {
                    var model = DescribeContactListResponseBody.Contacts.Contact.Channels()
                    model.fromMap(dict["Channels"] as! [String: Any])
                    self.channels = model
                }
                if dict.keys.contains("ChannelsState") && dict["ChannelsState"] != nil {
                    var model = DescribeContactListResponseBody.Contacts.Contact.ChannelsState()
                    model.fromMap(dict["ChannelsState"] as! [String: Any])
                    self.channelsState = model
                }
                if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
                    var model = DescribeContactListResponseBody.Contacts.Contact.ContactGroups()
                    model.fromMap(dict["ContactGroups"] as! [String: Any])
                    self.contactGroups = model
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Desc") && dict["Desc"] != nil {
                    self.desc = dict["Desc"] as! String
                }
                if dict.keys.contains("Lang") && dict["Lang"] != nil {
                    self.lang = dict["Lang"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
            }
        }
        public var contact: [DescribeContactListResponseBody.Contacts.Contact]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contact != nil {
                var tmp : [Any] = []
                for k in self.contact! {
                    tmp.append(k.toMap())
                }
                map["Contact"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Contact") && dict["Contact"] != nil {
                var tmp : [DescribeContactListResponseBody.Contacts.Contact] = []
                for v in dict["Contact"] as! [Any] {
                    var model = DescribeContactListResponseBody.Contacts.Contact()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.contact = tmp
            }
        }
    }
    public var code: String?

    public var contacts: DescribeContactListResponseBody.Contacts?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.contacts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.contacts != nil {
            map["Contacts"] = self.contacts?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Contacts") && dict["Contacts"] != nil {
            var model = DescribeContactListResponseBody.Contacts()
            model.fromMap(dict["Contacts"] as! [String: Any])
            self.contacts = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeContactListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeContactListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeContactListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeContactListByContactGroupRequest : Tea.TeaModel {
    public var contactGroupName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupName != nil {
            map["ContactGroupName"] = self.contactGroupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupName") && dict["ContactGroupName"] != nil {
            self.contactGroupName = dict["ContactGroupName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeContactListByContactGroupResponseBody : Tea.TeaModel {
    public class Contacts : Tea.TeaModel {
        public class Contact : Tea.TeaModel {
            public class Channels : Tea.TeaModel {
                public var aliIM: String?

                public var dingWebHook: String?

                public var mail: String?

                public var SMS: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aliIM != nil {
                        map["AliIM"] = self.aliIM!
                    }
                    if self.dingWebHook != nil {
                        map["DingWebHook"] = self.dingWebHook!
                    }
                    if self.mail != nil {
                        map["Mail"] = self.mail!
                    }
                    if self.SMS != nil {
                        map["SMS"] = self.SMS!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AliIM") && dict["AliIM"] != nil {
                        self.aliIM = dict["AliIM"] as! String
                    }
                    if dict.keys.contains("DingWebHook") && dict["DingWebHook"] != nil {
                        self.dingWebHook = dict["DingWebHook"] as! String
                    }
                    if dict.keys.contains("Mail") && dict["Mail"] != nil {
                        self.mail = dict["Mail"] as! String
                    }
                    if dict.keys.contains("SMS") && dict["SMS"] != nil {
                        self.SMS = dict["SMS"] as! String
                    }
                }
            }
            public var channels: DescribeContactListByContactGroupResponseBody.Contacts.Contact.Channels?

            public var createTime: Int64?

            public var desc: String?

            public var name: String?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.channels?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channels != nil {
                    map["Channels"] = self.channels?.toMap()
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.desc != nil {
                    map["Desc"] = self.desc!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Channels") && dict["Channels"] != nil {
                    var model = DescribeContactListByContactGroupResponseBody.Contacts.Contact.Channels()
                    model.fromMap(dict["Channels"] as! [String: Any])
                    self.channels = model
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Desc") && dict["Desc"] != nil {
                    self.desc = dict["Desc"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
            }
        }
        public var contact: [DescribeContactListByContactGroupResponseBody.Contacts.Contact]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contact != nil {
                var tmp : [Any] = []
                for k in self.contact! {
                    tmp.append(k.toMap())
                }
                map["Contact"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Contact") && dict["Contact"] != nil {
                var tmp : [DescribeContactListByContactGroupResponseBody.Contacts.Contact] = []
                for v in dict["Contact"] as! [Any] {
                    var model = DescribeContactListByContactGroupResponseBody.Contacts.Contact()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.contact = tmp
            }
        }
    }
    public var code: String?

    public var contacts: DescribeContactListByContactGroupResponseBody.Contacts?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.contacts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.contacts != nil {
            map["Contacts"] = self.contacts?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Contacts") && dict["Contacts"] != nil {
            var model = DescribeContactListByContactGroupResponseBody.Contacts()
            model.fromMap(dict["Contacts"] as! [String: Any])
            self.contacts = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeContactListByContactGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeContactListByContactGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeContactListByContactGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustomEventAttributeRequest : Tea.TeaModel {
    public var endTime: String?

    public var eventId: String?

    public var groupId: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var searchKeywords: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.searchKeywords != nil {
            map["SearchKeywords"] = self.searchKeywords!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SearchKeywords") && dict["SearchKeywords"] != nil {
            self.searchKeywords = dict["SearchKeywords"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeCustomEventAttributeResponseBody : Tea.TeaModel {
    public class CustomEvents : Tea.TeaModel {
        public class CustomEvent : Tea.TeaModel {
            public var content: String?

            public var groupId: String?

            public var id: String?

            public var name: String?

            public var time: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") && dict["Content"] != nil {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Time") && dict["Time"] != nil {
                    self.time = dict["Time"] as! String
                }
            }
        }
        public var customEvent: [DescribeCustomEventAttributeResponseBody.CustomEvents.CustomEvent]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customEvent != nil {
                var tmp : [Any] = []
                for k in self.customEvent! {
                    tmp.append(k.toMap())
                }
                map["CustomEvent"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomEvent") && dict["CustomEvent"] != nil {
                var tmp : [DescribeCustomEventAttributeResponseBody.CustomEvents.CustomEvent] = []
                for v in dict["CustomEvent"] as! [Any] {
                    var model = DescribeCustomEventAttributeResponseBody.CustomEvents.CustomEvent()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customEvent = tmp
            }
        }
    }
    public var code: String?

    public var customEvents: DescribeCustomEventAttributeResponseBody.CustomEvents?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customEvents?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.customEvents != nil {
            map["CustomEvents"] = self.customEvents?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("CustomEvents") && dict["CustomEvents"] != nil {
            var model = DescribeCustomEventAttributeResponseBody.CustomEvents()
            model.fromMap(dict["CustomEvents"] as! [String: Any])
            self.customEvents = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeCustomEventAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomEventAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCustomEventAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustomEventCountRequest : Tea.TeaModel {
    public var endTime: String?

    public var eventId: String?

    public var groupId: String?

    public var name: String?

    public var regionId: String?

    public var searchKeywords: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.searchKeywords != nil {
            map["SearchKeywords"] = self.searchKeywords!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SearchKeywords") && dict["SearchKeywords"] != nil {
            self.searchKeywords = dict["SearchKeywords"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeCustomEventCountResponseBody : Tea.TeaModel {
    public class CustomEventCounts : Tea.TeaModel {
        public class CustomEventCount : Tea.TeaModel {
            public var name: String?

            public var num: Int32?

            public var time: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.num != nil {
                    map["Num"] = self.num!
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Num") && dict["Num"] != nil {
                    self.num = dict["Num"] as! Int32
                }
                if dict.keys.contains("Time") && dict["Time"] != nil {
                    self.time = dict["Time"] as! Int64
                }
            }
        }
        public var customEventCount: [DescribeCustomEventCountResponseBody.CustomEventCounts.CustomEventCount]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customEventCount != nil {
                var tmp : [Any] = []
                for k in self.customEventCount! {
                    tmp.append(k.toMap())
                }
                map["CustomEventCount"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomEventCount") && dict["CustomEventCount"] != nil {
                var tmp : [DescribeCustomEventCountResponseBody.CustomEventCounts.CustomEventCount] = []
                for v in dict["CustomEventCount"] as! [Any] {
                    var model = DescribeCustomEventCountResponseBody.CustomEventCounts.CustomEventCount()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customEventCount = tmp
            }
        }
    }
    public var code: String?

    public var customEventCounts: DescribeCustomEventCountResponseBody.CustomEventCounts?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customEventCounts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.customEventCounts != nil {
            map["CustomEventCounts"] = self.customEventCounts?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("CustomEventCounts") && dict["CustomEventCounts"] != nil {
            var model = DescribeCustomEventCountResponseBody.CustomEventCounts()
            model.fromMap(dict["CustomEventCounts"] as! [String: Any])
            self.customEventCounts = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeCustomEventCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomEventCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCustomEventCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustomEventHistogramRequest : Tea.TeaModel {
    public var endTime: String?

    public var eventId: String?

    public var groupId: String?

    public var level: String?

    public var name: String?

    public var regionId: String?

    public var searchKeywords: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.searchKeywords != nil {
            map["SearchKeywords"] = self.searchKeywords!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Level") && dict["Level"] != nil {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SearchKeywords") && dict["SearchKeywords"] != nil {
            self.searchKeywords = dict["SearchKeywords"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeCustomEventHistogramResponseBody : Tea.TeaModel {
    public class EventHistograms : Tea.TeaModel {
        public class EventHistogram : Tea.TeaModel {
            public var count: Int64?

            public var endTime: Int64?

            public var startTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") && dict["Count"] != nil {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! Int64
                }
            }
        }
        public var eventHistogram: [DescribeCustomEventHistogramResponseBody.EventHistograms.EventHistogram]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventHistogram != nil {
                var tmp : [Any] = []
                for k in self.eventHistogram! {
                    tmp.append(k.toMap())
                }
                map["EventHistogram"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventHistogram") && dict["EventHistogram"] != nil {
                var tmp : [DescribeCustomEventHistogramResponseBody.EventHistograms.EventHistogram] = []
                for v in dict["EventHistogram"] as! [Any] {
                    var model = DescribeCustomEventHistogramResponseBody.EventHistograms.EventHistogram()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eventHistogram = tmp
            }
        }
    }
    public var code: String?

    public var eventHistograms: DescribeCustomEventHistogramResponseBody.EventHistograms?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eventHistograms?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.eventHistograms != nil {
            map["EventHistograms"] = self.eventHistograms?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("EventHistograms") && dict["EventHistograms"] != nil {
            var model = DescribeCustomEventHistogramResponseBody.EventHistograms()
            model.fromMap(dict["EventHistograms"] as! [String: Any])
            self.eventHistograms = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeCustomEventHistogramResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomEventHistogramResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCustomEventHistogramResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustomMetricListRequest : Tea.TeaModel {
    public var dimension: String?

    public var groupId: String?

    public var md5: String?

    public var metricName: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dimension != nil {
            map["Dimension"] = self.dimension!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.md5 != nil {
            map["Md5"] = self.md5!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Dimension") && dict["Dimension"] != nil {
            self.dimension = dict["Dimension"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Md5") && dict["Md5"] != nil {
            self.md5 = dict["Md5"] as! String
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeCustomMetricListResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! String
        }
    }
}

public class DescribeCustomMetricListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomMetricListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCustomMetricListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDynamicTagRuleListRequest : Tea.TeaModel {
    public var dynamicTagRuleId: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var tagKey: String?

    public var tagRegionId: String?

    public var tagValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicTagRuleId != nil {
            map["DynamicTagRuleId"] = self.dynamicTagRuleId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        if self.tagRegionId != nil {
            map["TagRegionId"] = self.tagRegionId!
        }
        if self.tagValue != nil {
            map["TagValue"] = self.tagValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicTagRuleId") && dict["DynamicTagRuleId"] != nil {
            self.dynamicTagRuleId = dict["DynamicTagRuleId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
            self.tagKey = dict["TagKey"] as! String
        }
        if dict.keys.contains("TagRegionId") && dict["TagRegionId"] != nil {
            self.tagRegionId = dict["TagRegionId"] as! String
        }
        if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
            self.tagValue = dict["TagValue"] as! String
        }
    }
}

public class DescribeDynamicTagRuleListResponseBody : Tea.TeaModel {
    public class TagGroupList : Tea.TeaModel {
        public class TagGroup : Tea.TeaModel {
            public class ContactGroupList : Tea.TeaModel {
                public var contactGroupList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.contactGroupList != nil {
                        map["ContactGroupList"] = self.contactGroupList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ContactGroupList") && dict["ContactGroupList"] != nil {
                        self.contactGroupList = dict["ContactGroupList"] as! [String]
                    }
                }
            }
            public class MatchExpress : Tea.TeaModel {
                public class MatchExpress : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public var tagValueMatchFunction: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        if self.tagValueMatchFunction != nil {
                            map["TagValueMatchFunction"] = self.tagValueMatchFunction!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
                            self.tagValue = dict["TagValue"] as! String
                        }
                        if dict.keys.contains("TagValueMatchFunction") && dict["TagValueMatchFunction"] != nil {
                            self.tagValueMatchFunction = dict["TagValueMatchFunction"] as! String
                        }
                    }
                }
                public var matchExpress: [DescribeDynamicTagRuleListResponseBody.TagGroupList.TagGroup.MatchExpress.MatchExpress]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.matchExpress != nil {
                        var tmp : [Any] = []
                        for k in self.matchExpress! {
                            tmp.append(k.toMap())
                        }
                        map["MatchExpress"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MatchExpress") && dict["MatchExpress"] != nil {
                        var tmp : [DescribeDynamicTagRuleListResponseBody.TagGroupList.TagGroup.MatchExpress.MatchExpress] = []
                        for v in dict["MatchExpress"] as! [Any] {
                            var model = DescribeDynamicTagRuleListResponseBody.TagGroupList.TagGroup.MatchExpress.MatchExpress()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.matchExpress = tmp
                    }
                }
            }
            public class TemplateIdList : Tea.TeaModel {
                public var templateIdList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.templateIdList != nil {
                        map["TemplateIdList"] = self.templateIdList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TemplateIdList") && dict["TemplateIdList"] != nil {
                        self.templateIdList = dict["TemplateIdList"] as! [String]
                    }
                }
            }
            public var contactGroupList: DescribeDynamicTagRuleListResponseBody.TagGroupList.TagGroup.ContactGroupList?

            public var dynamicTagRuleId: String?

            public var matchExpress: DescribeDynamicTagRuleListResponseBody.TagGroupList.TagGroup.MatchExpress?

            public var matchExpressFilterRelation: String?

            public var regionId: String?

            public var status: String?

            public var tagKey: String?

            public var templateIdList: DescribeDynamicTagRuleListResponseBody.TagGroupList.TagGroup.TemplateIdList?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.contactGroupList?.validate()
                try self.matchExpress?.validate()
                try self.templateIdList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contactGroupList != nil {
                    map["ContactGroupList"] = self.contactGroupList?.toMap()
                }
                if self.dynamicTagRuleId != nil {
                    map["DynamicTagRuleId"] = self.dynamicTagRuleId!
                }
                if self.matchExpress != nil {
                    map["MatchExpress"] = self.matchExpress?.toMap()
                }
                if self.matchExpressFilterRelation != nil {
                    map["MatchExpressFilterRelation"] = self.matchExpressFilterRelation!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.templateIdList != nil {
                    map["TemplateIdList"] = self.templateIdList?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContactGroupList") && dict["ContactGroupList"] != nil {
                    var model = DescribeDynamicTagRuleListResponseBody.TagGroupList.TagGroup.ContactGroupList()
                    model.fromMap(dict["ContactGroupList"] as! [String: Any])
                    self.contactGroupList = model
                }
                if dict.keys.contains("DynamicTagRuleId") && dict["DynamicTagRuleId"] != nil {
                    self.dynamicTagRuleId = dict["DynamicTagRuleId"] as! String
                }
                if dict.keys.contains("MatchExpress") && dict["MatchExpress"] != nil {
                    var model = DescribeDynamicTagRuleListResponseBody.TagGroupList.TagGroup.MatchExpress()
                    model.fromMap(dict["MatchExpress"] as! [String: Any])
                    self.matchExpress = model
                }
                if dict.keys.contains("MatchExpressFilterRelation") && dict["MatchExpressFilterRelation"] != nil {
                    self.matchExpressFilterRelation = dict["MatchExpressFilterRelation"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TemplateIdList") && dict["TemplateIdList"] != nil {
                    var model = DescribeDynamicTagRuleListResponseBody.TagGroupList.TagGroup.TemplateIdList()
                    model.fromMap(dict["TemplateIdList"] as! [String: Any])
                    self.templateIdList = model
                }
            }
        }
        public var tagGroup: [DescribeDynamicTagRuleListResponseBody.TagGroupList.TagGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagGroup != nil {
                var tmp : [Any] = []
                for k in self.tagGroup! {
                    tmp.append(k.toMap())
                }
                map["TagGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagGroup") && dict["TagGroup"] != nil {
                var tmp : [DescribeDynamicTagRuleListResponseBody.TagGroupList.TagGroup] = []
                for v in dict["TagGroup"] as! [Any] {
                    var model = DescribeDynamicTagRuleListResponseBody.TagGroupList.TagGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagGroup = tmp
            }
        }
    }
    public var code: String?

    public var message: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var success: Bool?

    public var tagGroupList: DescribeDynamicTagRuleListResponseBody.TagGroupList?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagGroupList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tagGroupList != nil {
            map["TagGroupList"] = self.tagGroupList?.toMap()
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TagGroupList") && dict["TagGroupList"] != nil {
            var model = DescribeDynamicTagRuleListResponseBody.TagGroupList()
            model.fromMap(dict["TagGroupList"] as! [String: Any])
            self.tagGroupList = model
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeDynamicTagRuleListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDynamicTagRuleListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDynamicTagRuleListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventRuleAttributeRequest : Tea.TeaModel {
    public var regionId: String?

    public var ruleName: String?

    public var silenceTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.silenceTime != nil {
            map["SilenceTime"] = self.silenceTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
            self.silenceTime = dict["SilenceTime"] as! String
        }
    }
}

public class DescribeEventRuleAttributeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class EventPattern : Tea.TeaModel {
            public class EventTypeList : Tea.TeaModel {
                public var eventTypeList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.eventTypeList != nil {
                        map["EventTypeList"] = self.eventTypeList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EventTypeList") && dict["EventTypeList"] != nil {
                        self.eventTypeList = dict["EventTypeList"] as! [String]
                    }
                }
            }
            public class LevelList : Tea.TeaModel {
                public var levelList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.levelList != nil {
                        map["LevelList"] = self.levelList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LevelList") && dict["LevelList"] != nil {
                        self.levelList = dict["LevelList"] as! [String]
                    }
                }
            }
            public class NameList : Tea.TeaModel {
                public var nameList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameList != nil {
                        map["NameList"] = self.nameList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameList") && dict["NameList"] != nil {
                        self.nameList = dict["NameList"] as! [String]
                    }
                }
            }
            public class StatusList : Tea.TeaModel {
                public var statusList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.statusList != nil {
                        map["StatusList"] = self.statusList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("StatusList") && dict["StatusList"] != nil {
                        self.statusList = dict["StatusList"] as! [String]
                    }
                }
            }
            public var eventTypeList: DescribeEventRuleAttributeResponseBody.Result.EventPattern.EventTypeList?

            public var levelList: DescribeEventRuleAttributeResponseBody.Result.EventPattern.LevelList?

            public var nameList: DescribeEventRuleAttributeResponseBody.Result.EventPattern.NameList?

            public var product: String?

            public var statusList: DescribeEventRuleAttributeResponseBody.Result.EventPattern.StatusList?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.eventTypeList?.validate()
                try self.levelList?.validate()
                try self.nameList?.validate()
                try self.statusList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventTypeList != nil {
                    map["EventTypeList"] = self.eventTypeList?.toMap()
                }
                if self.levelList != nil {
                    map["LevelList"] = self.levelList?.toMap()
                }
                if self.nameList != nil {
                    map["NameList"] = self.nameList?.toMap()
                }
                if self.product != nil {
                    map["Product"] = self.product!
                }
                if self.statusList != nil {
                    map["StatusList"] = self.statusList?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EventTypeList") && dict["EventTypeList"] != nil {
                    var model = DescribeEventRuleAttributeResponseBody.Result.EventPattern.EventTypeList()
                    model.fromMap(dict["EventTypeList"] as! [String: Any])
                    self.eventTypeList = model
                }
                if dict.keys.contains("LevelList") && dict["LevelList"] != nil {
                    var model = DescribeEventRuleAttributeResponseBody.Result.EventPattern.LevelList()
                    model.fromMap(dict["LevelList"] as! [String: Any])
                    self.levelList = model
                }
                if dict.keys.contains("NameList") && dict["NameList"] != nil {
                    var model = DescribeEventRuleAttributeResponseBody.Result.EventPattern.NameList()
                    model.fromMap(dict["NameList"] as! [String: Any])
                    self.nameList = model
                }
                if dict.keys.contains("Product") && dict["Product"] != nil {
                    self.product = dict["Product"] as! String
                }
                if dict.keys.contains("StatusList") && dict["StatusList"] != nil {
                    var model = DescribeEventRuleAttributeResponseBody.Result.EventPattern.StatusList()
                    model.fromMap(dict["StatusList"] as! [String: Any])
                    self.statusList = model
                }
            }
        }
        public var description_: String?

        public var eventPattern: DescribeEventRuleAttributeResponseBody.Result.EventPattern?

        public var eventType: String?

        public var groupId: String?

        public var name: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.eventPattern?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.eventPattern != nil {
                map["EventPattern"] = self.eventPattern?.toMap()
            }
            if self.eventType != nil {
                map["EventType"] = self.eventType!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EventPattern") && dict["EventPattern"] != nil {
                var model = DescribeEventRuleAttributeResponseBody.Result.EventPattern()
                model.fromMap(dict["EventPattern"] as! [String: Any])
                self.eventPattern = model
            }
            if dict.keys.contains("EventType") && dict["EventType"] != nil {
                self.eventType = dict["EventType"] as! String
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var result: DescribeEventRuleAttributeResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            var model = DescribeEventRuleAttributeResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeEventRuleAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventRuleAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEventRuleAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventRuleListRequest : Tea.TeaModel {
    public var groupId: String?

    public var namePrefix: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.namePrefix != nil {
            map["NamePrefix"] = self.namePrefix!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("NamePrefix") && dict["NamePrefix"] != nil {
            self.namePrefix = dict["NamePrefix"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeEventRuleListResponseBody : Tea.TeaModel {
    public class EventRules : Tea.TeaModel {
        public class EventRule : Tea.TeaModel {
            public class EventPattern : Tea.TeaModel {
                public class EventPattern : Tea.TeaModel {
                    public class EventTypeList : Tea.TeaModel {
                        public var eventTypeList: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.eventTypeList != nil {
                                map["EventTypeList"] = self.eventTypeList!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("EventTypeList") && dict["EventTypeList"] != nil {
                                self.eventTypeList = dict["EventTypeList"] as! [String]
                            }
                        }
                    }
                    public class KeywordFilter : Tea.TeaModel {
                        public class Keywords : Tea.TeaModel {
                            public var keywords: [String]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.keywords != nil {
                                    map["Keywords"] = self.keywords!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Keywords") && dict["Keywords"] != nil {
                                    self.keywords = dict["Keywords"] as! [String]
                                }
                            }
                        }
                        public var keywords: DescribeEventRuleListResponseBody.EventRules.EventRule.EventPattern.EventPattern.KeywordFilter.Keywords?

                        public var relation: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.keywords?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.keywords != nil {
                                map["Keywords"] = self.keywords?.toMap()
                            }
                            if self.relation != nil {
                                map["Relation"] = self.relation!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Keywords") && dict["Keywords"] != nil {
                                var model = DescribeEventRuleListResponseBody.EventRules.EventRule.EventPattern.EventPattern.KeywordFilter.Keywords()
                                model.fromMap(dict["Keywords"] as! [String: Any])
                                self.keywords = model
                            }
                            if dict.keys.contains("Relation") && dict["Relation"] != nil {
                                self.relation = dict["Relation"] as! String
                            }
                        }
                    }
                    public class LevelList : Tea.TeaModel {
                        public var levelList: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.levelList != nil {
                                map["LevelList"] = self.levelList!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("LevelList") && dict["LevelList"] != nil {
                                self.levelList = dict["LevelList"] as! [String]
                            }
                        }
                    }
                    public class NameList : Tea.TeaModel {
                        public var nameList: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.nameList != nil {
                                map["NameList"] = self.nameList!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("NameList") && dict["NameList"] != nil {
                                self.nameList = dict["NameList"] as! [String]
                            }
                        }
                    }
                    public var customFilters: String?

                    public var eventTypeList: DescribeEventRuleListResponseBody.EventRules.EventRule.EventPattern.EventPattern.EventTypeList?

                    public var keywordFilter: DescribeEventRuleListResponseBody.EventRules.EventRule.EventPattern.EventPattern.KeywordFilter?

                    public var levelList: DescribeEventRuleListResponseBody.EventRules.EventRule.EventPattern.EventPattern.LevelList?

                    public var nameList: DescribeEventRuleListResponseBody.EventRules.EventRule.EventPattern.EventPattern.NameList?

                    public var product: String?

                    public var SQLFilter: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.eventTypeList?.validate()
                        try self.keywordFilter?.validate()
                        try self.levelList?.validate()
                        try self.nameList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.customFilters != nil {
                            map["CustomFilters"] = self.customFilters!
                        }
                        if self.eventTypeList != nil {
                            map["EventTypeList"] = self.eventTypeList?.toMap()
                        }
                        if self.keywordFilter != nil {
                            map["KeywordFilter"] = self.keywordFilter?.toMap()
                        }
                        if self.levelList != nil {
                            map["LevelList"] = self.levelList?.toMap()
                        }
                        if self.nameList != nil {
                            map["NameList"] = self.nameList?.toMap()
                        }
                        if self.product != nil {
                            map["Product"] = self.product!
                        }
                        if self.SQLFilter != nil {
                            map["SQLFilter"] = self.SQLFilter!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CustomFilters") && dict["CustomFilters"] != nil {
                            self.customFilters = dict["CustomFilters"] as! String
                        }
                        if dict.keys.contains("EventTypeList") && dict["EventTypeList"] != nil {
                            var model = DescribeEventRuleListResponseBody.EventRules.EventRule.EventPattern.EventPattern.EventTypeList()
                            model.fromMap(dict["EventTypeList"] as! [String: Any])
                            self.eventTypeList = model
                        }
                        if dict.keys.contains("KeywordFilter") && dict["KeywordFilter"] != nil {
                            var model = DescribeEventRuleListResponseBody.EventRules.EventRule.EventPattern.EventPattern.KeywordFilter()
                            model.fromMap(dict["KeywordFilter"] as! [String: Any])
                            self.keywordFilter = model
                        }
                        if dict.keys.contains("LevelList") && dict["LevelList"] != nil {
                            var model = DescribeEventRuleListResponseBody.EventRules.EventRule.EventPattern.EventPattern.LevelList()
                            model.fromMap(dict["LevelList"] as! [String: Any])
                            self.levelList = model
                        }
                        if dict.keys.contains("NameList") && dict["NameList"] != nil {
                            var model = DescribeEventRuleListResponseBody.EventRules.EventRule.EventPattern.EventPattern.NameList()
                            model.fromMap(dict["NameList"] as! [String: Any])
                            self.nameList = model
                        }
                        if dict.keys.contains("Product") && dict["Product"] != nil {
                            self.product = dict["Product"] as! String
                        }
                        if dict.keys.contains("SQLFilter") && dict["SQLFilter"] != nil {
                            self.SQLFilter = dict["SQLFilter"] as! String
                        }
                    }
                }
                public var eventPattern: [DescribeEventRuleListResponseBody.EventRules.EventRule.EventPattern.EventPattern]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.eventPattern != nil {
                        var tmp : [Any] = []
                        for k in self.eventPattern! {
                            tmp.append(k.toMap())
                        }
                        map["EventPattern"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EventPattern") && dict["EventPattern"] != nil {
                        var tmp : [DescribeEventRuleListResponseBody.EventRules.EventRule.EventPattern.EventPattern] = []
                        for v in dict["EventPattern"] as! [Any] {
                            var model = DescribeEventRuleListResponseBody.EventRules.EventRule.EventPattern.EventPattern()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.eventPattern = tmp
                    }
                }
            }
            public var description_: String?

            public var eventPattern: DescribeEventRuleListResponseBody.EventRules.EventRule.EventPattern?

            public var eventType: String?

            public var groupId: String?

            public var name: String?

            public var silenceTime: Int64?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.eventPattern?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.eventPattern != nil {
                    map["EventPattern"] = self.eventPattern?.toMap()
                }
                if self.eventType != nil {
                    map["EventType"] = self.eventType!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.silenceTime != nil {
                    map["SilenceTime"] = self.silenceTime!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EventPattern") && dict["EventPattern"] != nil {
                    var model = DescribeEventRuleListResponseBody.EventRules.EventRule.EventPattern()
                    model.fromMap(dict["EventPattern"] as! [String: Any])
                    self.eventPattern = model
                }
                if dict.keys.contains("EventType") && dict["EventType"] != nil {
                    self.eventType = dict["EventType"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
                    self.silenceTime = dict["SilenceTime"] as! Int64
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var eventRule: [DescribeEventRuleListResponseBody.EventRules.EventRule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventRule != nil {
                var tmp : [Any] = []
                for k in self.eventRule! {
                    tmp.append(k.toMap())
                }
                map["EventRule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventRule") && dict["EventRule"] != nil {
                var tmp : [DescribeEventRuleListResponseBody.EventRules.EventRule] = []
                for v in dict["EventRule"] as! [Any] {
                    var model = DescribeEventRuleListResponseBody.EventRules.EventRule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eventRule = tmp
            }
        }
    }
    public var code: String?

    public var eventRules: DescribeEventRuleListResponseBody.EventRules?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eventRules?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.eventRules != nil {
            map["EventRules"] = self.eventRules?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("EventRules") && dict["EventRules"] != nil {
            var model = DescribeEventRuleListResponseBody.EventRules()
            model.fromMap(dict["EventRules"] as! [String: Any])
            self.eventRules = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeEventRuleListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventRuleListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEventRuleListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventRuleTargetListRequest : Tea.TeaModel {
    public var regionId: String?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
    }
}

public class DescribeEventRuleTargetListResponseBody : Tea.TeaModel {
    public class ContactParameters : Tea.TeaModel {
        public class ContactParameter : Tea.TeaModel {
            public var contactGroupName: String?

            public var id: String?

            public var level: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contactGroupName != nil {
                    map["ContactGroupName"] = self.contactGroupName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContactGroupName") && dict["ContactGroupName"] != nil {
                    self.contactGroupName = dict["ContactGroupName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Level") && dict["Level"] != nil {
                    self.level = dict["Level"] as! String
                }
            }
        }
        public var contactParameter: [DescribeEventRuleTargetListResponseBody.ContactParameters.ContactParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contactParameter != nil {
                var tmp : [Any] = []
                for k in self.contactParameter! {
                    tmp.append(k.toMap())
                }
                map["ContactParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContactParameter") && dict["ContactParameter"] != nil {
                var tmp : [DescribeEventRuleTargetListResponseBody.ContactParameters.ContactParameter] = []
                for v in dict["ContactParameter"] as! [Any] {
                    var model = DescribeEventRuleTargetListResponseBody.ContactParameters.ContactParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.contactParameter = tmp
            }
        }
    }
    public class FcParameters : Tea.TeaModel {
        public class FCParameter : Tea.TeaModel {
            public var arn: String?

            public var functionName: String?

            public var id: String?

            public var region: String?

            public var serviceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.arn != nil {
                    map["Arn"] = self.arn!
                }
                if self.functionName != nil {
                    map["FunctionName"] = self.functionName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Arn") && dict["Arn"] != nil {
                    self.arn = dict["Arn"] as! String
                }
                if dict.keys.contains("FunctionName") && dict["FunctionName"] != nil {
                    self.functionName = dict["FunctionName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
            }
        }
        public var FCParameter: [DescribeEventRuleTargetListResponseBody.FcParameters.FCParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.FCParameter != nil {
                var tmp : [Any] = []
                for k in self.FCParameter! {
                    tmp.append(k.toMap())
                }
                map["FCParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FCParameter") && dict["FCParameter"] != nil {
                var tmp : [DescribeEventRuleTargetListResponseBody.FcParameters.FCParameter] = []
                for v in dict["FCParameter"] as! [Any] {
                    var model = DescribeEventRuleTargetListResponseBody.FcParameters.FCParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.FCParameter = tmp
            }
        }
    }
    public class MnsParameters : Tea.TeaModel {
        public class MnsParameter : Tea.TeaModel {
            public var arn: String?

            public var id: String?

            public var queue: String?

            public var region: String?

            public var topic: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.arn != nil {
                    map["Arn"] = self.arn!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.queue != nil {
                    map["Queue"] = self.queue!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.topic != nil {
                    map["Topic"] = self.topic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Arn") && dict["Arn"] != nil {
                    self.arn = dict["Arn"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Queue") && dict["Queue"] != nil {
                    self.queue = dict["Queue"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Topic") && dict["Topic"] != nil {
                    self.topic = dict["Topic"] as! String
                }
            }
        }
        public var mnsParameter: [DescribeEventRuleTargetListResponseBody.MnsParameters.MnsParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mnsParameter != nil {
                var tmp : [Any] = []
                for k in self.mnsParameter! {
                    tmp.append(k.toMap())
                }
                map["MnsParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MnsParameter") && dict["MnsParameter"] != nil {
                var tmp : [DescribeEventRuleTargetListResponseBody.MnsParameters.MnsParameter] = []
                for v in dict["MnsParameter"] as! [Any] {
                    var model = DescribeEventRuleTargetListResponseBody.MnsParameters.MnsParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mnsParameter = tmp
            }
        }
    }
    public class OpenApiParameters : Tea.TeaModel {
        public class OpenApiParameters : Tea.TeaModel {
            public var action: String?

            public var arn: String?

            public var id: String?

            public var product: String?

            public var region: String?

            public var role: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.arn != nil {
                    map["Arn"] = self.arn!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.product != nil {
                    map["Product"] = self.product!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") && dict["Action"] != nil {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("Arn") && dict["Arn"] != nil {
                    self.arn = dict["Arn"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Product") && dict["Product"] != nil {
                    self.product = dict["Product"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Role") && dict["Role"] != nil {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("Version") && dict["Version"] != nil {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var openApiParameters: [DescribeEventRuleTargetListResponseBody.OpenApiParameters.OpenApiParameters]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.openApiParameters != nil {
                var tmp : [Any] = []
                for k in self.openApiParameters! {
                    tmp.append(k.toMap())
                }
                map["OpenApiParameters"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OpenApiParameters") && dict["OpenApiParameters"] != nil {
                var tmp : [DescribeEventRuleTargetListResponseBody.OpenApiParameters.OpenApiParameters] = []
                for v in dict["OpenApiParameters"] as! [Any] {
                    var model = DescribeEventRuleTargetListResponseBody.OpenApiParameters.OpenApiParameters()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.openApiParameters = tmp
            }
        }
    }
    public class SlsParameters : Tea.TeaModel {
        public class SlsParameter : Tea.TeaModel {
            public var arn: String?

            public var id: String?

            public var logStore: String?

            public var project: String?

            public var region: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.arn != nil {
                    map["Arn"] = self.arn!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.logStore != nil {
                    map["LogStore"] = self.logStore!
                }
                if self.project != nil {
                    map["Project"] = self.project!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Arn") && dict["Arn"] != nil {
                    self.arn = dict["Arn"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("LogStore") && dict["LogStore"] != nil {
                    self.logStore = dict["LogStore"] as! String
                }
                if dict.keys.contains("Project") && dict["Project"] != nil {
                    self.project = dict["Project"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! String
                }
            }
        }
        public var slsParameter: [DescribeEventRuleTargetListResponseBody.SlsParameters.SlsParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.slsParameter != nil {
                var tmp : [Any] = []
                for k in self.slsParameter! {
                    tmp.append(k.toMap())
                }
                map["SlsParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SlsParameter") && dict["SlsParameter"] != nil {
                var tmp : [DescribeEventRuleTargetListResponseBody.SlsParameters.SlsParameter] = []
                for v in dict["SlsParameter"] as! [Any] {
                    var model = DescribeEventRuleTargetListResponseBody.SlsParameters.SlsParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.slsParameter = tmp
            }
        }
    }
    public class WebhookParameters : Tea.TeaModel {
        public class WebhookParameter : Tea.TeaModel {
            public var id: String?

            public var method: String?

            public var protocol_: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var webhookParameter: [DescribeEventRuleTargetListResponseBody.WebhookParameters.WebhookParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.webhookParameter != nil {
                var tmp : [Any] = []
                for k in self.webhookParameter! {
                    tmp.append(k.toMap())
                }
                map["WebhookParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WebhookParameter") && dict["WebhookParameter"] != nil {
                var tmp : [DescribeEventRuleTargetListResponseBody.WebhookParameters.WebhookParameter] = []
                for v in dict["WebhookParameter"] as! [Any] {
                    var model = DescribeEventRuleTargetListResponseBody.WebhookParameters.WebhookParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.webhookParameter = tmp
            }
        }
    }
    public var code: String?

    public var contactParameters: DescribeEventRuleTargetListResponseBody.ContactParameters?

    public var fcParameters: DescribeEventRuleTargetListResponseBody.FcParameters?

    public var message: String?

    public var mnsParameters: DescribeEventRuleTargetListResponseBody.MnsParameters?

    public var openApiParameters: DescribeEventRuleTargetListResponseBody.OpenApiParameters?

    public var requestId: String?

    public var slsParameters: DescribeEventRuleTargetListResponseBody.SlsParameters?

    public var webhookParameters: DescribeEventRuleTargetListResponseBody.WebhookParameters?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.contactParameters?.validate()
        try self.fcParameters?.validate()
        try self.mnsParameters?.validate()
        try self.openApiParameters?.validate()
        try self.slsParameters?.validate()
        try self.webhookParameters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.contactParameters != nil {
            map["ContactParameters"] = self.contactParameters?.toMap()
        }
        if self.fcParameters != nil {
            map["FcParameters"] = self.fcParameters?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.mnsParameters != nil {
            map["MnsParameters"] = self.mnsParameters?.toMap()
        }
        if self.openApiParameters != nil {
            map["OpenApiParameters"] = self.openApiParameters?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.slsParameters != nil {
            map["SlsParameters"] = self.slsParameters?.toMap()
        }
        if self.webhookParameters != nil {
            map["WebhookParameters"] = self.webhookParameters?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ContactParameters") && dict["ContactParameters"] != nil {
            var model = DescribeEventRuleTargetListResponseBody.ContactParameters()
            model.fromMap(dict["ContactParameters"] as! [String: Any])
            self.contactParameters = model
        }
        if dict.keys.contains("FcParameters") && dict["FcParameters"] != nil {
            var model = DescribeEventRuleTargetListResponseBody.FcParameters()
            model.fromMap(dict["FcParameters"] as! [String: Any])
            self.fcParameters = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("MnsParameters") && dict["MnsParameters"] != nil {
            var model = DescribeEventRuleTargetListResponseBody.MnsParameters()
            model.fromMap(dict["MnsParameters"] as! [String: Any])
            self.mnsParameters = model
        }
        if dict.keys.contains("OpenApiParameters") && dict["OpenApiParameters"] != nil {
            var model = DescribeEventRuleTargetListResponseBody.OpenApiParameters()
            model.fromMap(dict["OpenApiParameters"] as! [String: Any])
            self.openApiParameters = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SlsParameters") && dict["SlsParameters"] != nil {
            var model = DescribeEventRuleTargetListResponseBody.SlsParameters()
            model.fromMap(dict["SlsParameters"] as! [String: Any])
            self.slsParameters = model
        }
        if dict.keys.contains("WebhookParameters") && dict["WebhookParameters"] != nil {
            var model = DescribeEventRuleTargetListResponseBody.WebhookParameters()
            model.fromMap(dict["WebhookParameters"] as! [String: Any])
            self.webhookParameters = model
        }
    }
}

public class DescribeEventRuleTargetListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventRuleTargetListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEventRuleTargetListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExporterOutputListRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeExporterOutputListResponseBody : Tea.TeaModel {
    public class Datapoints : Tea.TeaModel {
        public class Datapoint : Tea.TeaModel {
            public class ConfigJson : Tea.TeaModel {
                public var ak: String?

                public var endpoint: String?

                public var logstore: String?

                public var project: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ak != nil {
                        map["ak"] = self.ak!
                    }
                    if self.endpoint != nil {
                        map["endpoint"] = self.endpoint!
                    }
                    if self.logstore != nil {
                        map["logstore"] = self.logstore!
                    }
                    if self.project != nil {
                        map["project"] = self.project!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ak") && dict["ak"] != nil {
                        self.ak = dict["ak"] as! String
                    }
                    if dict.keys.contains("endpoint") && dict["endpoint"] != nil {
                        self.endpoint = dict["endpoint"] as! String
                    }
                    if dict.keys.contains("logstore") && dict["logstore"] != nil {
                        self.logstore = dict["logstore"] as! String
                    }
                    if dict.keys.contains("project") && dict["project"] != nil {
                        self.project = dict["project"] as! String
                    }
                }
            }
            public var configJson: DescribeExporterOutputListResponseBody.Datapoints.Datapoint.ConfigJson?

            public var createTime: Int64?

            public var destName: String?

            public var destType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.configJson?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configJson != nil {
                    map["ConfigJson"] = self.configJson?.toMap()
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.destName != nil {
                    map["DestName"] = self.destName!
                }
                if self.destType != nil {
                    map["DestType"] = self.destType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigJson") && dict["ConfigJson"] != nil {
                    var model = DescribeExporterOutputListResponseBody.Datapoints.Datapoint.ConfigJson()
                    model.fromMap(dict["ConfigJson"] as! [String: Any])
                    self.configJson = model
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DestName") && dict["DestName"] != nil {
                    self.destName = dict["DestName"] as! String
                }
                if dict.keys.contains("DestType") && dict["DestType"] != nil {
                    self.destType = dict["DestType"] as! String
                }
            }
        }
        public var datapoint: [DescribeExporterOutputListResponseBody.Datapoints.Datapoint]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.datapoint != nil {
                var tmp : [Any] = []
                for k in self.datapoint! {
                    tmp.append(k.toMap())
                }
                map["Datapoint"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Datapoint") && dict["Datapoint"] != nil {
                var tmp : [DescribeExporterOutputListResponseBody.Datapoints.Datapoint] = []
                for v in dict["Datapoint"] as! [Any] {
                    var model = DescribeExporterOutputListResponseBody.Datapoints.Datapoint()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.datapoint = tmp
            }
        }
    }
    public var code: String?

    public var datapoints: DescribeExporterOutputListResponseBody.Datapoints?

    public var message: String?

    public var pageNumber: Int32?

    public var requestId: String?

    public var success: Bool?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.datapoints?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.datapoints != nil {
            map["Datapoints"] = self.datapoints?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Datapoints") && dict["Datapoints"] != nil {
            var model = DescribeExporterOutputListResponseBody.Datapoints()
            model.fromMap(dict["Datapoints"] as! [String: Any])
            self.datapoints = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeExporterOutputListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExporterOutputListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeExporterOutputListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExporterRuleListRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeExporterRuleListResponseBody : Tea.TeaModel {
    public class Datapoints : Tea.TeaModel {
        public class Datapoint : Tea.TeaModel {
            public class DstName : Tea.TeaModel {
                public var dstName: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dstName != nil {
                        map["DstName"] = self.dstName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DstName") && dict["DstName"] != nil {
                        self.dstName = dict["DstName"] as! [String]
                    }
                }
            }
            public var createTime: Int64?

            public var describe: String?

            public var dimension: String?

            public var dstName: DescribeExporterRuleListResponseBody.Datapoints.Datapoint.DstName?

            public var enabled: Bool?

            public var metricName: String?

            public var namespace: String?

            public var ruleName: String?

            public var targetWindows: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dstName?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.describe != nil {
                    map["Describe"] = self.describe!
                }
                if self.dimension != nil {
                    map["Dimension"] = self.dimension!
                }
                if self.dstName != nil {
                    map["DstName"] = self.dstName?.toMap()
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.targetWindows != nil {
                    map["TargetWindows"] = self.targetWindows!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Describe") && dict["Describe"] != nil {
                    self.describe = dict["Describe"] as! String
                }
                if dict.keys.contains("Dimension") && dict["Dimension"] != nil {
                    self.dimension = dict["Dimension"] as! String
                }
                if dict.keys.contains("DstName") && dict["DstName"] != nil {
                    var model = DescribeExporterRuleListResponseBody.Datapoints.Datapoint.DstName()
                    model.fromMap(dict["DstName"] as! [String: Any])
                    self.dstName = model
                }
                if dict.keys.contains("Enabled") && dict["Enabled"] != nil {
                    self.enabled = dict["Enabled"] as! Bool
                }
                if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                    self.metricName = dict["MetricName"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("TargetWindows") && dict["TargetWindows"] != nil {
                    self.targetWindows = dict["TargetWindows"] as! String
                }
            }
        }
        public var datapoint: [DescribeExporterRuleListResponseBody.Datapoints.Datapoint]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.datapoint != nil {
                var tmp : [Any] = []
                for k in self.datapoint! {
                    tmp.append(k.toMap())
                }
                map["Datapoint"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Datapoint") && dict["Datapoint"] != nil {
                var tmp : [DescribeExporterRuleListResponseBody.Datapoints.Datapoint] = []
                for v in dict["Datapoint"] as! [Any] {
                    var model = DescribeExporterRuleListResponseBody.Datapoints.Datapoint()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.datapoint = tmp
            }
        }
    }
    public var code: String?

    public var datapoints: DescribeExporterRuleListResponseBody.Datapoints?

    public var message: String?

    public var pageNumber: Int32?

    public var requestId: String?

    public var success: Bool?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.datapoints?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.datapoints != nil {
            map["Datapoints"] = self.datapoints?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Datapoints") && dict["Datapoints"] != nil {
            var model = DescribeExporterRuleListResponseBody.Datapoints()
            model.fromMap(dict["Datapoints"] as! [String: Any])
            self.datapoints = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeExporterRuleListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExporterRuleListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeExporterRuleListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGroupMonitoringAgentProcessRequest : Tea.TeaModel {
    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var processName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.processName != nil {
            map["ProcessName"] = self.processName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProcessName") && dict["ProcessName"] != nil {
            self.processName = dict["ProcessName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeGroupMonitoringAgentProcessResponseBody : Tea.TeaModel {
    public class Processes : Tea.TeaModel {
        public class Process : Tea.TeaModel {
            public class AlertConfig : Tea.TeaModel {
                public class AlertConfig : Tea.TeaModel {
                    public class TargetList : Tea.TeaModel {
                        public class Target : Tea.TeaModel {
                            public var arn: String?

                            public var id: String?

                            public var jsonParmas: String?

                            public var level: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.arn != nil {
                                    map["Arn"] = self.arn!
                                }
                                if self.id != nil {
                                    map["Id"] = self.id!
                                }
                                if self.jsonParmas != nil {
                                    map["JsonParmas"] = self.jsonParmas!
                                }
                                if self.level != nil {
                                    map["Level"] = self.level!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Arn") && dict["Arn"] != nil {
                                    self.arn = dict["Arn"] as! String
                                }
                                if dict.keys.contains("Id") && dict["Id"] != nil {
                                    self.id = dict["Id"] as! String
                                }
                                if dict.keys.contains("JsonParmas") && dict["JsonParmas"] != nil {
                                    self.jsonParmas = dict["JsonParmas"] as! String
                                }
                                if dict.keys.contains("Level") && dict["Level"] != nil {
                                    self.level = dict["Level"] as! String
                                }
                            }
                        }
                        public var target: [DescribeGroupMonitoringAgentProcessResponseBody.Processes.Process.AlertConfig.AlertConfig.TargetList.Target]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.target != nil {
                                var tmp : [Any] = []
                                for k in self.target! {
                                    tmp.append(k.toMap())
                                }
                                map["Target"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Target") && dict["Target"] != nil {
                                var tmp : [DescribeGroupMonitoringAgentProcessResponseBody.Processes.Process.AlertConfig.AlertConfig.TargetList.Target] = []
                                for v in dict["Target"] as! [Any] {
                                    var model = DescribeGroupMonitoringAgentProcessResponseBody.Processes.Process.AlertConfig.AlertConfig.TargetList.Target()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.target = tmp
                            }
                        }
                    }
                    public var comparisonOperator: String?

                    public var effectiveInterval: String?

                    public var escalationsLevel: String?

                    public var noEffectiveInterval: String?

                    public var silenceTime: String?

                    public var statistics: String?

                    public var targetList: DescribeGroupMonitoringAgentProcessResponseBody.Processes.Process.AlertConfig.AlertConfig.TargetList?

                    public var threshold: String?

                    public var times: String?

                    public var webhook: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.targetList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.comparisonOperator != nil {
                            map["ComparisonOperator"] = self.comparisonOperator!
                        }
                        if self.effectiveInterval != nil {
                            map["EffectiveInterval"] = self.effectiveInterval!
                        }
                        if self.escalationsLevel != nil {
                            map["EscalationsLevel"] = self.escalationsLevel!
                        }
                        if self.noEffectiveInterval != nil {
                            map["NoEffectiveInterval"] = self.noEffectiveInterval!
                        }
                        if self.silenceTime != nil {
                            map["SilenceTime"] = self.silenceTime!
                        }
                        if self.statistics != nil {
                            map["Statistics"] = self.statistics!
                        }
                        if self.targetList != nil {
                            map["TargetList"] = self.targetList?.toMap()
                        }
                        if self.threshold != nil {
                            map["Threshold"] = self.threshold!
                        }
                        if self.times != nil {
                            map["Times"] = self.times!
                        }
                        if self.webhook != nil {
                            map["Webhook"] = self.webhook!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                            self.comparisonOperator = dict["ComparisonOperator"] as! String
                        }
                        if dict.keys.contains("EffectiveInterval") && dict["EffectiveInterval"] != nil {
                            self.effectiveInterval = dict["EffectiveInterval"] as! String
                        }
                        if dict.keys.contains("EscalationsLevel") && dict["EscalationsLevel"] != nil {
                            self.escalationsLevel = dict["EscalationsLevel"] as! String
                        }
                        if dict.keys.contains("NoEffectiveInterval") && dict["NoEffectiveInterval"] != nil {
                            self.noEffectiveInterval = dict["NoEffectiveInterval"] as! String
                        }
                        if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
                            self.silenceTime = dict["SilenceTime"] as! String
                        }
                        if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                            self.statistics = dict["Statistics"] as! String
                        }
                        if dict.keys.contains("TargetList") && dict["TargetList"] != nil {
                            var model = DescribeGroupMonitoringAgentProcessResponseBody.Processes.Process.AlertConfig.AlertConfig.TargetList()
                            model.fromMap(dict["TargetList"] as! [String: Any])
                            self.targetList = model
                        }
                        if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                            self.threshold = dict["Threshold"] as! String
                        }
                        if dict.keys.contains("Times") && dict["Times"] != nil {
                            self.times = dict["Times"] as! String
                        }
                        if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
                            self.webhook = dict["Webhook"] as! String
                        }
                    }
                }
                public var alertConfig: [DescribeGroupMonitoringAgentProcessResponseBody.Processes.Process.AlertConfig.AlertConfig]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alertConfig != nil {
                        var tmp : [Any] = []
                        for k in self.alertConfig! {
                            tmp.append(k.toMap())
                        }
                        map["AlertConfig"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AlertConfig") && dict["AlertConfig"] != nil {
                        var tmp : [DescribeGroupMonitoringAgentProcessResponseBody.Processes.Process.AlertConfig.AlertConfig] = []
                        for v in dict["AlertConfig"] as! [Any] {
                            var model = DescribeGroupMonitoringAgentProcessResponseBody.Processes.Process.AlertConfig.AlertConfig()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.alertConfig = tmp
                    }
                }
            }
            public class MatchExpress : Tea.TeaModel {
                public class MatchExpress : Tea.TeaModel {
                    public var function: String?

                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.function != nil {
                            map["Function"] = self.function!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Function") && dict["Function"] != nil {
                            self.function = dict["Function"] as! String
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var matchExpress: [DescribeGroupMonitoringAgentProcessResponseBody.Processes.Process.MatchExpress.MatchExpress]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.matchExpress != nil {
                        var tmp : [Any] = []
                        for k in self.matchExpress! {
                            tmp.append(k.toMap())
                        }
                        map["MatchExpress"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MatchExpress") && dict["MatchExpress"] != nil {
                        var tmp : [DescribeGroupMonitoringAgentProcessResponseBody.Processes.Process.MatchExpress.MatchExpress] = []
                        for v in dict["MatchExpress"] as! [Any] {
                            var model = DescribeGroupMonitoringAgentProcessResponseBody.Processes.Process.MatchExpress.MatchExpress()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.matchExpress = tmp
                    }
                }
            }
            public var alertConfig: DescribeGroupMonitoringAgentProcessResponseBody.Processes.Process.AlertConfig?

            public var groupId: String?

            public var id: String?

            public var matchExpress: DescribeGroupMonitoringAgentProcessResponseBody.Processes.Process.MatchExpress?

            public var matchExpressFilterRelation: String?

            public var processName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.alertConfig?.validate()
                try self.matchExpress?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertConfig != nil {
                    map["AlertConfig"] = self.alertConfig?.toMap()
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.matchExpress != nil {
                    map["MatchExpress"] = self.matchExpress?.toMap()
                }
                if self.matchExpressFilterRelation != nil {
                    map["MatchExpressFilterRelation"] = self.matchExpressFilterRelation!
                }
                if self.processName != nil {
                    map["ProcessName"] = self.processName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertConfig") && dict["AlertConfig"] != nil {
                    var model = DescribeGroupMonitoringAgentProcessResponseBody.Processes.Process.AlertConfig()
                    model.fromMap(dict["AlertConfig"] as! [String: Any])
                    self.alertConfig = model
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("MatchExpress") && dict["MatchExpress"] != nil {
                    var model = DescribeGroupMonitoringAgentProcessResponseBody.Processes.Process.MatchExpress()
                    model.fromMap(dict["MatchExpress"] as! [String: Any])
                    self.matchExpress = model
                }
                if dict.keys.contains("MatchExpressFilterRelation") && dict["MatchExpressFilterRelation"] != nil {
                    self.matchExpressFilterRelation = dict["MatchExpressFilterRelation"] as! String
                }
                if dict.keys.contains("ProcessName") && dict["ProcessName"] != nil {
                    self.processName = dict["ProcessName"] as! String
                }
            }
        }
        public var process: [DescribeGroupMonitoringAgentProcessResponseBody.Processes.Process]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.process != nil {
                var tmp : [Any] = []
                for k in self.process! {
                    tmp.append(k.toMap())
                }
                map["Process"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Process") && dict["Process"] != nil {
                var tmp : [DescribeGroupMonitoringAgentProcessResponseBody.Processes.Process] = []
                for v in dict["Process"] as! [Any] {
                    var model = DescribeGroupMonitoringAgentProcessResponseBody.Processes.Process()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.process = tmp
            }
        }
    }
    public var code: String?

    public var message: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var processes: DescribeGroupMonitoringAgentProcessResponseBody.Processes?

    public var requestId: String?

    public var success: Bool?

    public var total: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.processes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.processes != nil {
            map["Processes"] = self.processes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("Processes") && dict["Processes"] != nil {
            var model = DescribeGroupMonitoringAgentProcessResponseBody.Processes()
            model.fromMap(dict["Processes"] as! [String: Any])
            self.processes = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! String
        }
    }
}

public class DescribeGroupMonitoringAgentProcessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGroupMonitoringAgentProcessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeGroupMonitoringAgentProcessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHostAvailabilityListRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var id: Int64?

    public var ids: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Ids") && dict["Ids"] != nil {
            self.ids = dict["Ids"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
    }
}

public class DescribeHostAvailabilityListResponseBody : Tea.TeaModel {
    public class TaskList : Tea.TeaModel {
        public class NodeTaskConfig : Tea.TeaModel {
            public class AlertConfig : Tea.TeaModel {
                public class EscalationList : Tea.TeaModel {
                    public class EscalationList : Tea.TeaModel {
                        public var aggregate: String?

                        public var metricName: String?

                        public var operator_: String?

                        public var times: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.aggregate != nil {
                                map["Aggregate"] = self.aggregate!
                            }
                            if self.metricName != nil {
                                map["MetricName"] = self.metricName!
                            }
                            if self.operator_ != nil {
                                map["Operator"] = self.operator_!
                            }
                            if self.times != nil {
                                map["Times"] = self.times!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Aggregate") && dict["Aggregate"] != nil {
                                self.aggregate = dict["Aggregate"] as! String
                            }
                            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                                self.metricName = dict["MetricName"] as! String
                            }
                            if dict.keys.contains("Operator") && dict["Operator"] != nil {
                                self.operator_ = dict["Operator"] as! String
                            }
                            if dict.keys.contains("Times") && dict["Times"] != nil {
                                self.times = dict["Times"] as! String
                            }
                            if dict.keys.contains("Value") && dict["Value"] != nil {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public var escalationList: [DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig.AlertConfig.EscalationList.EscalationList]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.escalationList != nil {
                            var tmp : [Any] = []
                            for k in self.escalationList! {
                                tmp.append(k.toMap())
                            }
                            map["escalationList"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("escalationList") && dict["escalationList"] != nil {
                            var tmp : [DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig.AlertConfig.EscalationList.EscalationList] = []
                            for v in dict["escalationList"] as! [Any] {
                                var model = DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig.AlertConfig.EscalationList.EscalationList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.escalationList = tmp
                        }
                    }
                }
                public class TargetList : Tea.TeaModel {
                    public class Target : Tea.TeaModel {
                        public var arn: String?

                        public var id: String?

                        public var jsonParams: String?

                        public var level: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.arn != nil {
                                map["Arn"] = self.arn!
                            }
                            if self.id != nil {
                                map["Id"] = self.id!
                            }
                            if self.jsonParams != nil {
                                map["JsonParams"] = self.jsonParams!
                            }
                            if self.level != nil {
                                map["Level"] = self.level!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Arn") && dict["Arn"] != nil {
                                self.arn = dict["Arn"] as! String
                            }
                            if dict.keys.contains("Id") && dict["Id"] != nil {
                                self.id = dict["Id"] as! String
                            }
                            if dict.keys.contains("JsonParams") && dict["JsonParams"] != nil {
                                self.jsonParams = dict["JsonParams"] as! String
                            }
                            if dict.keys.contains("Level") && dict["Level"] != nil {
                                self.level = dict["Level"] as! String
                            }
                        }
                    }
                    public var target: [DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig.AlertConfig.TargetList.Target]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.target != nil {
                            var tmp : [Any] = []
                            for k in self.target! {
                                tmp.append(k.toMap())
                            }
                            map["Target"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Target") && dict["Target"] != nil {
                            var tmp : [DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig.AlertConfig.TargetList.Target] = []
                            for v in dict["Target"] as! [Any] {
                                var model = DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig.AlertConfig.TargetList.Target()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.target = tmp
                        }
                    }
                }
                public var endTime: Int32?

                public var escalationList: DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig.AlertConfig.EscalationList?

                public var notifyType: Int32?

                public var silenceTime: Int32?

                public var startTime: Int32?

                public var targetList: DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig.AlertConfig.TargetList?

                public var webHook: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.escalationList?.validate()
                    try self.targetList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.escalationList != nil {
                        map["EscalationList"] = self.escalationList?.toMap()
                    }
                    if self.notifyType != nil {
                        map["NotifyType"] = self.notifyType!
                    }
                    if self.silenceTime != nil {
                        map["SilenceTime"] = self.silenceTime!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.targetList != nil {
                        map["TargetList"] = self.targetList?.toMap()
                    }
                    if self.webHook != nil {
                        map["WebHook"] = self.webHook!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                        self.endTime = dict["EndTime"] as! Int32
                    }
                    if dict.keys.contains("EscalationList") && dict["EscalationList"] != nil {
                        var model = DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig.AlertConfig.EscalationList()
                        model.fromMap(dict["EscalationList"] as! [String: Any])
                        self.escalationList = model
                    }
                    if dict.keys.contains("NotifyType") && dict["NotifyType"] != nil {
                        self.notifyType = dict["NotifyType"] as! Int32
                    }
                    if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
                        self.silenceTime = dict["SilenceTime"] as! Int32
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! Int32
                    }
                    if dict.keys.contains("TargetList") && dict["TargetList"] != nil {
                        var model = DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig.AlertConfig.TargetList()
                        model.fromMap(dict["TargetList"] as! [String: Any])
                        self.targetList = model
                    }
                    if dict.keys.contains("WebHook") && dict["WebHook"] != nil {
                        self.webHook = dict["WebHook"] as! String
                    }
                }
            }
            public class Instances : Tea.TeaModel {
                public var instance: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instance != nil {
                        map["Instance"] = self.instance!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Instance") && dict["Instance"] != nil {
                        self.instance = dict["Instance"] as! [String]
                    }
                }
            }
            public class TaskOption : Tea.TeaModel {
                public var httpKeyword: String?

                public var httpMethod: String?

                public var httpNegative: Bool?

                public var httpPostContent: String?

                public var httpResponseCharset: String?

                public var httpURI: String?

                public var interval: Int32?

                public var telnetOrPingHost: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.httpKeyword != nil {
                        map["HttpKeyword"] = self.httpKeyword!
                    }
                    if self.httpMethod != nil {
                        map["HttpMethod"] = self.httpMethod!
                    }
                    if self.httpNegative != nil {
                        map["HttpNegative"] = self.httpNegative!
                    }
                    if self.httpPostContent != nil {
                        map["HttpPostContent"] = self.httpPostContent!
                    }
                    if self.httpResponseCharset != nil {
                        map["HttpResponseCharset"] = self.httpResponseCharset!
                    }
                    if self.httpURI != nil {
                        map["HttpURI"] = self.httpURI!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.telnetOrPingHost != nil {
                        map["TelnetOrPingHost"] = self.telnetOrPingHost!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HttpKeyword") && dict["HttpKeyword"] != nil {
                        self.httpKeyword = dict["HttpKeyword"] as! String
                    }
                    if dict.keys.contains("HttpMethod") && dict["HttpMethod"] != nil {
                        self.httpMethod = dict["HttpMethod"] as! String
                    }
                    if dict.keys.contains("HttpNegative") && dict["HttpNegative"] != nil {
                        self.httpNegative = dict["HttpNegative"] as! Bool
                    }
                    if dict.keys.contains("HttpPostContent") && dict["HttpPostContent"] != nil {
                        self.httpPostContent = dict["HttpPostContent"] as! String
                    }
                    if dict.keys.contains("HttpResponseCharset") && dict["HttpResponseCharset"] != nil {
                        self.httpResponseCharset = dict["HttpResponseCharset"] as! String
                    }
                    if dict.keys.contains("HttpURI") && dict["HttpURI"] != nil {
                        self.httpURI = dict["HttpURI"] as! String
                    }
                    if dict.keys.contains("Interval") && dict["Interval"] != nil {
                        self.interval = dict["Interval"] as! Int32
                    }
                    if dict.keys.contains("TelnetOrPingHost") && dict["TelnetOrPingHost"] != nil {
                        self.telnetOrPingHost = dict["TelnetOrPingHost"] as! String
                    }
                }
            }
            public var alertConfig: DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig.AlertConfig?

            public var disabled: Bool?

            public var groupId: Int64?

            public var groupName: String?

            public var id: Int64?

            public var instances: DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig.Instances?

            public var taskName: String?

            public var taskOption: DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig.TaskOption?

            public var taskScope: String?

            public var taskType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.alertConfig?.validate()
                try self.instances?.validate()
                try self.taskOption?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertConfig != nil {
                    map["AlertConfig"] = self.alertConfig?.toMap()
                }
                if self.disabled != nil {
                    map["Disabled"] = self.disabled!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.instances != nil {
                    map["Instances"] = self.instances?.toMap()
                }
                if self.taskName != nil {
                    map["TaskName"] = self.taskName!
                }
                if self.taskOption != nil {
                    map["TaskOption"] = self.taskOption?.toMap()
                }
                if self.taskScope != nil {
                    map["TaskScope"] = self.taskScope!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertConfig") && dict["AlertConfig"] != nil {
                    var model = DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig.AlertConfig()
                    model.fromMap(dict["AlertConfig"] as! [String: Any])
                    self.alertConfig = model
                }
                if dict.keys.contains("Disabled") && dict["Disabled"] != nil {
                    self.disabled = dict["Disabled"] as! Bool
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! Int64
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Instances") && dict["Instances"] != nil {
                    var model = DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig.Instances()
                    model.fromMap(dict["Instances"] as! [String: Any])
                    self.instances = model
                }
                if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                    self.taskName = dict["TaskName"] as! String
                }
                if dict.keys.contains("TaskOption") && dict["TaskOption"] != nil {
                    var model = DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig.TaskOption()
                    model.fromMap(dict["TaskOption"] as! [String: Any])
                    self.taskOption = model
                }
                if dict.keys.contains("TaskScope") && dict["TaskScope"] != nil {
                    self.taskScope = dict["TaskScope"] as! String
                }
                if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                    self.taskType = dict["TaskType"] as! String
                }
            }
        }
        public var nodeTaskConfig: [DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeTaskConfig != nil {
                var tmp : [Any] = []
                for k in self.nodeTaskConfig! {
                    tmp.append(k.toMap())
                }
                map["NodeTaskConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NodeTaskConfig") && dict["NodeTaskConfig"] != nil {
                var tmp : [DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig] = []
                for v in dict["NodeTaskConfig"] as! [Any] {
                    var model = DescribeHostAvailabilityListResponseBody.TaskList.NodeTaskConfig()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeTaskConfig = tmp
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var taskList: DescribeHostAvailabilityListResponseBody.TaskList?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskList != nil {
            map["TaskList"] = self.taskList?.toMap()
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TaskList") && dict["TaskList"] != nil {
            var model = DescribeHostAvailabilityListResponseBody.TaskList()
            model.fromMap(dict["TaskList"] as! [String: Any])
            self.taskList = model
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeHostAvailabilityListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHostAvailabilityListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeHostAvailabilityListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHybridMonitorDataListRequest : Tea.TeaModel {
    public var end: Int64?

    public var namespace: String?

    public var period: String?

    public var promSQL: String?

    public var regionId: String?

    public var start: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.promSQL != nil {
            map["PromSQL"] = self.promSQL!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("End") && dict["End"] != nil {
            self.end = dict["End"] as! Int64
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("PromSQL") && dict["PromSQL"] != nil {
            self.promSQL = dict["PromSQL"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Start") && dict["Start"] != nil {
            self.start = dict["Start"] as! Int64
        }
    }
}

public class DescribeHybridMonitorDataListResponseBody : Tea.TeaModel {
    public class TimeSeries : Tea.TeaModel {
        public class Labels : Tea.TeaModel {
            public var k: String?

            public var v: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.k != nil {
                    map["K"] = self.k!
                }
                if self.v != nil {
                    map["V"] = self.v!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("K") && dict["K"] != nil {
                    self.k = dict["K"] as! String
                }
                if dict.keys.contains("V") && dict["V"] != nil {
                    self.v = dict["V"] as! String
                }
            }
        }
        public class Values : Tea.TeaModel {
            public var ts: String?

            public var v: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ts != nil {
                    map["Ts"] = self.ts!
                }
                if self.v != nil {
                    map["V"] = self.v!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ts") && dict["Ts"] != nil {
                    self.ts = dict["Ts"] as! String
                }
                if dict.keys.contains("V") && dict["V"] != nil {
                    self.v = dict["V"] as! String
                }
            }
        }
        public var labels: [DescribeHybridMonitorDataListResponseBody.TimeSeries.Labels]?

        public var metricName: String?

        public var values: [DescribeHybridMonitorDataListResponseBody.TimeSeries.Values]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["Labels"] = tmp
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.values != nil {
                var tmp : [Any] = []
                for k in self.values! {
                    tmp.append(k.toMap())
                }
                map["Values"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Labels") && dict["Labels"] != nil {
                var tmp : [DescribeHybridMonitorDataListResponseBody.TimeSeries.Labels] = []
                for v in dict["Labels"] as! [Any] {
                    var model = DescribeHybridMonitorDataListResponseBody.TimeSeries.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Values") && dict["Values"] != nil {
                var tmp : [DescribeHybridMonitorDataListResponseBody.TimeSeries.Values] = []
                for v in dict["Values"] as! [Any] {
                    var model = DescribeHybridMonitorDataListResponseBody.TimeSeries.Values()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.values = tmp
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var timeSeries: [DescribeHybridMonitorDataListResponseBody.TimeSeries]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.timeSeries != nil {
            var tmp : [Any] = []
            for k in self.timeSeries! {
                tmp.append(k.toMap())
            }
            map["TimeSeries"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TimeSeries") && dict["TimeSeries"] != nil {
            var tmp : [DescribeHybridMonitorDataListResponseBody.TimeSeries] = []
            for v in dict["TimeSeries"] as! [Any] {
                var model = DescribeHybridMonitorDataListResponseBody.TimeSeries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.timeSeries = tmp
        }
    }
}

public class DescribeHybridMonitorDataListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHybridMonitorDataListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeHybridMonitorDataListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHybridMonitorNamespaceListRequest : Tea.TeaModel {
    public var keyword: String?

    public var namespace: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var showTaskStatistic: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.showTaskStatistic != nil {
            map["ShowTaskStatistic"] = self.showTaskStatistic!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ShowTaskStatistic") && dict["ShowTaskStatistic"] != nil {
            self.showTaskStatistic = dict["ShowTaskStatistic"] as! Bool
        }
    }
}

public class DescribeHybridMonitorNamespaceListResponseBody : Tea.TeaModel {
    public class DescribeHybridMonitorNamespace : Tea.TeaModel {
        public class AliyunProductMetricList : Tea.TeaModel {
            public class NamespaceList : Tea.TeaModel {
                public class MetricList : Tea.TeaModel {
                    public var list: [String]?

                    public var period: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.list != nil {
                            map["List"] = self.list!
                        }
                        if self.period != nil {
                            map["Period"] = self.period!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("List") && dict["List"] != nil {
                            self.list = dict["List"] as! [String]
                        }
                        if dict.keys.contains("Period") && dict["Period"] != nil {
                            self.period = dict["Period"] as! Int64
                        }
                    }
                }
                public var metricList: [DescribeHybridMonitorNamespaceListResponseBody.DescribeHybridMonitorNamespace.AliyunProductMetricList.NamespaceList.MetricList]?

                public var namespace: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricList != nil {
                        var tmp : [Any] = []
                        for k in self.metricList! {
                            tmp.append(k.toMap())
                        }
                        map["MetricList"] = tmp
                    }
                    if self.namespace != nil {
                        map["Namespace"] = self.namespace!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MetricList") && dict["MetricList"] != nil {
                        var tmp : [DescribeHybridMonitorNamespaceListResponseBody.DescribeHybridMonitorNamespace.AliyunProductMetricList.NamespaceList.MetricList] = []
                        for v in dict["MetricList"] as! [Any] {
                            var model = DescribeHybridMonitorNamespaceListResponseBody.DescribeHybridMonitorNamespace.AliyunProductMetricList.NamespaceList.MetricList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.metricList = tmp
                    }
                    if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                        self.namespace = dict["Namespace"] as! String
                    }
                }
            }
            public var namespaceList: [DescribeHybridMonitorNamespaceListResponseBody.DescribeHybridMonitorNamespace.AliyunProductMetricList.NamespaceList]?

            public var userId: Int64?

            public var YAMLConfig: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.namespaceList != nil {
                    var tmp : [Any] = []
                    for k in self.namespaceList! {
                        tmp.append(k.toMap())
                    }
                    map["NamespaceList"] = tmp
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.YAMLConfig != nil {
                    map["YAMLConfig"] = self.YAMLConfig!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NamespaceList") && dict["NamespaceList"] != nil {
                    var tmp : [DescribeHybridMonitorNamespaceListResponseBody.DescribeHybridMonitorNamespace.AliyunProductMetricList.NamespaceList] = []
                    for v in dict["NamespaceList"] as! [Any] {
                        var model = DescribeHybridMonitorNamespaceListResponseBody.DescribeHybridMonitorNamespace.AliyunProductMetricList.NamespaceList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.namespaceList = tmp
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! Int64
                }
                if dict.keys.contains("YAMLConfig") && dict["YAMLConfig"] != nil {
                    self.YAMLConfig = dict["YAMLConfig"] as! String
                }
            }
        }
        public class Detail : Tea.TeaModel {
            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Spec") && dict["Spec"] != nil {
                    self.spec = dict["Spec"] as! String
                }
            }
        }
        public var aliyunProductMetricList: [DescribeHybridMonitorNamespaceListResponseBody.DescribeHybridMonitorNamespace.AliyunProductMetricList]?

        public var createTime: String?

        public var description_: String?

        public var detail: DescribeHybridMonitorNamespaceListResponseBody.DescribeHybridMonitorNamespace.Detail?

        public var id: String?

        public var isDelete: Int32?

        public var modifyTime: String?

        public var namespace: String?

        public var notAliyunTaskNumber: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.detail?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliyunProductMetricList != nil {
                var tmp : [Any] = []
                for k in self.aliyunProductMetricList! {
                    tmp.append(k.toMap())
                }
                map["AliyunProductMetricList"] = tmp
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.detail != nil {
                map["Detail"] = self.detail?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isDelete != nil {
                map["IsDelete"] = self.isDelete!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.notAliyunTaskNumber != nil {
                map["NotAliyunTaskNumber"] = self.notAliyunTaskNumber!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliyunProductMetricList") && dict["AliyunProductMetricList"] != nil {
                var tmp : [DescribeHybridMonitorNamespaceListResponseBody.DescribeHybridMonitorNamespace.AliyunProductMetricList] = []
                for v in dict["AliyunProductMetricList"] as! [Any] {
                    var model = DescribeHybridMonitorNamespaceListResponseBody.DescribeHybridMonitorNamespace.AliyunProductMetricList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.aliyunProductMetricList = tmp
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Detail") && dict["Detail"] != nil {
                var model = DescribeHybridMonitorNamespaceListResponseBody.DescribeHybridMonitorNamespace.Detail()
                model.fromMap(dict["Detail"] as! [String: Any])
                self.detail = model
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IsDelete") && dict["IsDelete"] != nil {
                self.isDelete = dict["IsDelete"] as! Int32
            }
            if dict.keys.contains("ModifyTime") && dict["ModifyTime"] != nil {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NotAliyunTaskNumber") && dict["NotAliyunTaskNumber"] != nil {
                self.notAliyunTaskNumber = dict["NotAliyunTaskNumber"] as! Int64
            }
        }
    }
    public var code: String?

    public var describeHybridMonitorNamespace: [DescribeHybridMonitorNamespaceListResponseBody.DescribeHybridMonitorNamespace]?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.describeHybridMonitorNamespace != nil {
            var tmp : [Any] = []
            for k in self.describeHybridMonitorNamespace! {
                tmp.append(k.toMap())
            }
            map["DescribeHybridMonitorNamespace"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DescribeHybridMonitorNamespace") && dict["DescribeHybridMonitorNamespace"] != nil {
            var tmp : [DescribeHybridMonitorNamespaceListResponseBody.DescribeHybridMonitorNamespace] = []
            for v in dict["DescribeHybridMonitorNamespace"] as! [Any] {
                var model = DescribeHybridMonitorNamespaceListResponseBody.DescribeHybridMonitorNamespace()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.describeHybridMonitorNamespace = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeHybridMonitorNamespaceListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHybridMonitorNamespaceListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeHybridMonitorNamespaceListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHybridMonitorSLSGroupRequest : Tea.TeaModel {
    public var keyword: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var regionId: String?

    public var SLSGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.SLSGroupName != nil {
            map["SLSGroupName"] = self.SLSGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SLSGroupName") && dict["SLSGroupName"] != nil {
            self.SLSGroupName = dict["SLSGroupName"] as! String
        }
    }
}

public class DescribeHybridMonitorSLSGroupResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public class SLSGroupConfig : Tea.TeaModel {
            public var SLSLogstore: String?

            public var SLSProject: String?

            public var SLSRegion: String?

            public var SLSUserId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.SLSLogstore != nil {
                    map["SLSLogstore"] = self.SLSLogstore!
                }
                if self.SLSProject != nil {
                    map["SLSProject"] = self.SLSProject!
                }
                if self.SLSRegion != nil {
                    map["SLSRegion"] = self.SLSRegion!
                }
                if self.SLSUserId != nil {
                    map["SLSUserId"] = self.SLSUserId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SLSLogstore") && dict["SLSLogstore"] != nil {
                    self.SLSLogstore = dict["SLSLogstore"] as! String
                }
                if dict.keys.contains("SLSProject") && dict["SLSProject"] != nil {
                    self.SLSProject = dict["SLSProject"] as! String
                }
                if dict.keys.contains("SLSRegion") && dict["SLSRegion"] != nil {
                    self.SLSRegion = dict["SLSRegion"] as! String
                }
                if dict.keys.contains("SLSUserId") && dict["SLSUserId"] != nil {
                    self.SLSUserId = dict["SLSUserId"] as! String
                }
            }
        }
        public var createTime: String?

        public var SLSGroupConfig: [DescribeHybridMonitorSLSGroupResponseBody.List.SLSGroupConfig]?

        public var SLSGroupDescription: String?

        public var SLSGroupName: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.SLSGroupConfig != nil {
                var tmp : [Any] = []
                for k in self.SLSGroupConfig! {
                    tmp.append(k.toMap())
                }
                map["SLSGroupConfig"] = tmp
            }
            if self.SLSGroupDescription != nil {
                map["SLSGroupDescription"] = self.SLSGroupDescription!
            }
            if self.SLSGroupName != nil {
                map["SLSGroupName"] = self.SLSGroupName!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("SLSGroupConfig") && dict["SLSGroupConfig"] != nil {
                var tmp : [DescribeHybridMonitorSLSGroupResponseBody.List.SLSGroupConfig] = []
                for v in dict["SLSGroupConfig"] as! [Any] {
                    var model = DescribeHybridMonitorSLSGroupResponseBody.List.SLSGroupConfig()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.SLSGroupConfig = tmp
            }
            if dict.keys.contains("SLSGroupDescription") && dict["SLSGroupDescription"] != nil {
                self.SLSGroupDescription = dict["SLSGroupDescription"] as! String
            }
            if dict.keys.contains("SLSGroupName") && dict["SLSGroupName"] != nil {
                self.SLSGroupName = dict["SLSGroupName"] as! String
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var code: String?

    public var list: [DescribeHybridMonitorSLSGroupResponseBody.List]?

    public var message: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var success: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [DescribeHybridMonitorSLSGroupResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = DescribeHybridMonitorSLSGroupResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class DescribeHybridMonitorSLSGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHybridMonitorSLSGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeHybridMonitorSLSGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHybridMonitorTaskListRequest : Tea.TeaModel {
    public var groupId: String?

    public var includeAliyunTask: Bool?

    public var keyword: String?

    public var namespace: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var targetUserId: Int64?

    public var taskId: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.includeAliyunTask != nil {
            map["IncludeAliyunTask"] = self.includeAliyunTask!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.targetUserId != nil {
            map["TargetUserId"] = self.targetUserId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("IncludeAliyunTask") && dict["IncludeAliyunTask"] != nil {
            self.includeAliyunTask = dict["IncludeAliyunTask"] as! Bool
        }
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TargetUserId") && dict["TargetUserId"] != nil {
            self.targetUserId = dict["TargetUserId"] as! Int64
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class DescribeHybridMonitorTaskListResponseBody : Tea.TeaModel {
    public class TaskList : Tea.TeaModel {
        public class AttachLabels : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class MatchExpress : Tea.TeaModel {
            public var function: String?

            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.function != nil {
                    map["Function"] = self.function!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Function") && dict["Function"] != nil {
                    self.function = dict["Function"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class SLSProcessConfig : Tea.TeaModel {
            public class Express : Tea.TeaModel {
                public var alias: String?

                public var express: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alias != nil {
                        map["Alias"] = self.alias!
                    }
                    if self.express != nil {
                        map["Express"] = self.express!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Alias") && dict["Alias"] != nil {
                        self.alias = dict["Alias"] as! String
                    }
                    if dict.keys.contains("Express") && dict["Express"] != nil {
                        self.express = dict["Express"] as! String
                    }
                }
            }
            public class Filter : Tea.TeaModel {
                public class Filters : Tea.TeaModel {
                    public var operator_: String?

                    public var SLSKeyName: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.SLSKeyName != nil {
                            map["SLSKeyName"] = self.SLSKeyName!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Operator") && dict["Operator"] != nil {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("SLSKeyName") && dict["SLSKeyName"] != nil {
                            self.SLSKeyName = dict["SLSKeyName"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var filters: [DescribeHybridMonitorTaskListResponseBody.TaskList.SLSProcessConfig.Filter.Filters]?

                public var relation: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.filters != nil {
                        var tmp : [Any] = []
                        for k in self.filters! {
                            tmp.append(k.toMap())
                        }
                        map["Filters"] = tmp
                    }
                    if self.relation != nil {
                        map["Relation"] = self.relation!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Filters") && dict["Filters"] != nil {
                        var tmp : [DescribeHybridMonitorTaskListResponseBody.TaskList.SLSProcessConfig.Filter.Filters] = []
                        for v in dict["Filters"] as! [Any] {
                            var model = DescribeHybridMonitorTaskListResponseBody.TaskList.SLSProcessConfig.Filter.Filters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.filters = tmp
                    }
                    if dict.keys.contains("Relation") && dict["Relation"] != nil {
                        self.relation = dict["Relation"] as! String
                    }
                }
            }
            public class GroupBy : Tea.TeaModel {
                public var alias: String?

                public var SLSKeyName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alias != nil {
                        map["Alias"] = self.alias!
                    }
                    if self.SLSKeyName != nil {
                        map["SLSKeyName"] = self.SLSKeyName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Alias") && dict["Alias"] != nil {
                        self.alias = dict["Alias"] as! String
                    }
                    if dict.keys.contains("SLSKeyName") && dict["SLSKeyName"] != nil {
                        self.SLSKeyName = dict["SLSKeyName"] as! String
                    }
                }
            }
            public class Statistics : Tea.TeaModel {
                public var alias: String?

                public var function: String?

                public var parameter1: String?

                public var parameter2: String?

                public var SLSKeyName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alias != nil {
                        map["Alias"] = self.alias!
                    }
                    if self.function != nil {
                        map["Function"] = self.function!
                    }
                    if self.parameter1 != nil {
                        map["Parameter1"] = self.parameter1!
                    }
                    if self.parameter2 != nil {
                        map["Parameter2"] = self.parameter2!
                    }
                    if self.SLSKeyName != nil {
                        map["SLSKeyName"] = self.SLSKeyName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Alias") && dict["Alias"] != nil {
                        self.alias = dict["Alias"] as! String
                    }
                    if dict.keys.contains("Function") && dict["Function"] != nil {
                        self.function = dict["Function"] as! String
                    }
                    if dict.keys.contains("Parameter1") && dict["Parameter1"] != nil {
                        self.parameter1 = dict["Parameter1"] as! String
                    }
                    if dict.keys.contains("Parameter2") && dict["Parameter2"] != nil {
                        self.parameter2 = dict["Parameter2"] as! String
                    }
                    if dict.keys.contains("SLSKeyName") && dict["SLSKeyName"] != nil {
                        self.SLSKeyName = dict["SLSKeyName"] as! String
                    }
                }
            }
            public var express: [DescribeHybridMonitorTaskListResponseBody.TaskList.SLSProcessConfig.Express]?

            public var filter: DescribeHybridMonitorTaskListResponseBody.TaskList.SLSProcessConfig.Filter?

            public var groupBy: [DescribeHybridMonitorTaskListResponseBody.TaskList.SLSProcessConfig.GroupBy]?

            public var statistics: [DescribeHybridMonitorTaskListResponseBody.TaskList.SLSProcessConfig.Statistics]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.filter?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.express != nil {
                    var tmp : [Any] = []
                    for k in self.express! {
                        tmp.append(k.toMap())
                    }
                    map["Express"] = tmp
                }
                if self.filter != nil {
                    map["Filter"] = self.filter?.toMap()
                }
                if self.groupBy != nil {
                    var tmp : [Any] = []
                    for k in self.groupBy! {
                        tmp.append(k.toMap())
                    }
                    map["GroupBy"] = tmp
                }
                if self.statistics != nil {
                    var tmp : [Any] = []
                    for k in self.statistics! {
                        tmp.append(k.toMap())
                    }
                    map["Statistics"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Express") && dict["Express"] != nil {
                    var tmp : [DescribeHybridMonitorTaskListResponseBody.TaskList.SLSProcessConfig.Express] = []
                    for v in dict["Express"] as! [Any] {
                        var model = DescribeHybridMonitorTaskListResponseBody.TaskList.SLSProcessConfig.Express()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.express = tmp
                }
                if dict.keys.contains("Filter") && dict["Filter"] != nil {
                    var model = DescribeHybridMonitorTaskListResponseBody.TaskList.SLSProcessConfig.Filter()
                    model.fromMap(dict["Filter"] as! [String: Any])
                    self.filter = model
                }
                if dict.keys.contains("GroupBy") && dict["GroupBy"] != nil {
                    var tmp : [DescribeHybridMonitorTaskListResponseBody.TaskList.SLSProcessConfig.GroupBy] = []
                    for v in dict["GroupBy"] as! [Any] {
                        var model = DescribeHybridMonitorTaskListResponseBody.TaskList.SLSProcessConfig.GroupBy()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.groupBy = tmp
                }
                if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                    var tmp : [DescribeHybridMonitorTaskListResponseBody.TaskList.SLSProcessConfig.Statistics] = []
                    for v in dict["Statistics"] as! [Any] {
                        var model = DescribeHybridMonitorTaskListResponseBody.TaskList.SLSProcessConfig.Statistics()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.statistics = tmp
                }
            }
        }
        public var attachLabels: [DescribeHybridMonitorTaskListResponseBody.TaskList.AttachLabels]?

        public var collectInterval: Int32?

        public var collectTargetEndpoint: String?

        public var collectTargetPath: String?

        public var collectTargetType: String?

        public var collectTimout: Int32?

        public var createTime: String?

        public var description_: String?

        public var extraInfo: String?

        public var groupId: String?

        public var instances: [String]?

        public var logFilePath: String?

        public var logProcess: String?

        public var logSample: String?

        public var logSplit: String?

        public var matchExpress: [DescribeHybridMonitorTaskListResponseBody.TaskList.MatchExpress]?

        public var matchExpressRelation: String?

        public var namespace: String?

        public var networkType: String?

        public var SLSProcess: String?

        public var SLSProcessConfig: DescribeHybridMonitorTaskListResponseBody.TaskList.SLSProcessConfig?

        public var targetUserId: String?

        public var taskId: String?

        public var taskName: String?

        public var taskType: String?

        public var uploadRegion: String?

        public var YARMConfig: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.SLSProcessConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachLabels != nil {
                var tmp : [Any] = []
                for k in self.attachLabels! {
                    tmp.append(k.toMap())
                }
                map["AttachLabels"] = tmp
            }
            if self.collectInterval != nil {
                map["CollectInterval"] = self.collectInterval!
            }
            if self.collectTargetEndpoint != nil {
                map["CollectTargetEndpoint"] = self.collectTargetEndpoint!
            }
            if self.collectTargetPath != nil {
                map["CollectTargetPath"] = self.collectTargetPath!
            }
            if self.collectTargetType != nil {
                map["CollectTargetType"] = self.collectTargetType!
            }
            if self.collectTimout != nil {
                map["CollectTimout"] = self.collectTimout!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.instances != nil {
                map["Instances"] = self.instances!
            }
            if self.logFilePath != nil {
                map["LogFilePath"] = self.logFilePath!
            }
            if self.logProcess != nil {
                map["LogProcess"] = self.logProcess!
            }
            if self.logSample != nil {
                map["LogSample"] = self.logSample!
            }
            if self.logSplit != nil {
                map["LogSplit"] = self.logSplit!
            }
            if self.matchExpress != nil {
                var tmp : [Any] = []
                for k in self.matchExpress! {
                    tmp.append(k.toMap())
                }
                map["MatchExpress"] = tmp
            }
            if self.matchExpressRelation != nil {
                map["MatchExpressRelation"] = self.matchExpressRelation!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.networkType != nil {
                map["NetworkType"] = self.networkType!
            }
            if self.SLSProcess != nil {
                map["SLSProcess"] = self.SLSProcess!
            }
            if self.SLSProcessConfig != nil {
                map["SLSProcessConfig"] = self.SLSProcessConfig?.toMap()
            }
            if self.targetUserId != nil {
                map["TargetUserId"] = self.targetUserId!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.uploadRegion != nil {
                map["UploadRegion"] = self.uploadRegion!
            }
            if self.YARMConfig != nil {
                map["YARMConfig"] = self.YARMConfig!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachLabels") && dict["AttachLabels"] != nil {
                var tmp : [DescribeHybridMonitorTaskListResponseBody.TaskList.AttachLabels] = []
                for v in dict["AttachLabels"] as! [Any] {
                    var model = DescribeHybridMonitorTaskListResponseBody.TaskList.AttachLabels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.attachLabels = tmp
            }
            if dict.keys.contains("CollectInterval") && dict["CollectInterval"] != nil {
                self.collectInterval = dict["CollectInterval"] as! Int32
            }
            if dict.keys.contains("CollectTargetEndpoint") && dict["CollectTargetEndpoint"] != nil {
                self.collectTargetEndpoint = dict["CollectTargetEndpoint"] as! String
            }
            if dict.keys.contains("CollectTargetPath") && dict["CollectTargetPath"] != nil {
                self.collectTargetPath = dict["CollectTargetPath"] as! String
            }
            if dict.keys.contains("CollectTargetType") && dict["CollectTargetType"] != nil {
                self.collectTargetType = dict["CollectTargetType"] as! String
            }
            if dict.keys.contains("CollectTimout") && dict["CollectTimout"] != nil {
                self.collectTimout = dict["CollectTimout"] as! Int32
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ExtraInfo") && dict["ExtraInfo"] != nil {
                self.extraInfo = dict["ExtraInfo"] as! String
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("Instances") && dict["Instances"] != nil {
                self.instances = dict["Instances"] as! [String]
            }
            if dict.keys.contains("LogFilePath") && dict["LogFilePath"] != nil {
                self.logFilePath = dict["LogFilePath"] as! String
            }
            if dict.keys.contains("LogProcess") && dict["LogProcess"] != nil {
                self.logProcess = dict["LogProcess"] as! String
            }
            if dict.keys.contains("LogSample") && dict["LogSample"] != nil {
                self.logSample = dict["LogSample"] as! String
            }
            if dict.keys.contains("LogSplit") && dict["LogSplit"] != nil {
                self.logSplit = dict["LogSplit"] as! String
            }
            if dict.keys.contains("MatchExpress") && dict["MatchExpress"] != nil {
                var tmp : [DescribeHybridMonitorTaskListResponseBody.TaskList.MatchExpress] = []
                for v in dict["MatchExpress"] as! [Any] {
                    var model = DescribeHybridMonitorTaskListResponseBody.TaskList.MatchExpress()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.matchExpress = tmp
            }
            if dict.keys.contains("MatchExpressRelation") && dict["MatchExpressRelation"] != nil {
                self.matchExpressRelation = dict["MatchExpressRelation"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NetworkType") && dict["NetworkType"] != nil {
                self.networkType = dict["NetworkType"] as! String
            }
            if dict.keys.contains("SLSProcess") && dict["SLSProcess"] != nil {
                self.SLSProcess = dict["SLSProcess"] as! String
            }
            if dict.keys.contains("SLSProcessConfig") && dict["SLSProcessConfig"] != nil {
                var model = DescribeHybridMonitorTaskListResponseBody.TaskList.SLSProcessConfig()
                model.fromMap(dict["SLSProcessConfig"] as! [String: Any])
                self.SLSProcessConfig = model
            }
            if dict.keys.contains("TargetUserId") && dict["TargetUserId"] != nil {
                self.targetUserId = dict["TargetUserId"] as! String
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                self.taskName = dict["TaskName"] as! String
            }
            if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                self.taskType = dict["TaskType"] as! String
            }
            if dict.keys.contains("UploadRegion") && dict["UploadRegion"] != nil {
                self.uploadRegion = dict["UploadRegion"] as! String
            }
            if dict.keys.contains("YARMConfig") && dict["YARMConfig"] != nil {
                self.YARMConfig = dict["YARMConfig"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: String?

    public var taskList: [DescribeHybridMonitorTaskListResponseBody.TaskList]?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskList != nil {
            var tmp : [Any] = []
            for k in self.taskList! {
                tmp.append(k.toMap())
            }
            map["TaskList"] = tmp
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TaskList") && dict["TaskList"] != nil {
            var tmp : [DescribeHybridMonitorTaskListResponseBody.TaskList] = []
            for v in dict["TaskList"] as! [Any] {
                var model = DescribeHybridMonitorTaskListResponseBody.TaskList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.taskList = tmp
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeHybridMonitorTaskListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHybridMonitorTaskListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeHybridMonitorTaskListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLogMonitorAttributeRequest : Tea.TeaModel {
    public var metricName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeLogMonitorAttributeResponseBody : Tea.TeaModel {
    public class LogMonitor : Tea.TeaModel {
        public class Aggregates : Tea.TeaModel {
            public var alias: String?

            public var fieldName: String?

            public var function: String?

            public var max: String?

            public var min: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.fieldName != nil {
                    map["FieldName"] = self.fieldName!
                }
                if self.function != nil {
                    map["Function"] = self.function!
                }
                if self.max != nil {
                    map["Max"] = self.max!
                }
                if self.min != nil {
                    map["Min"] = self.min!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") && dict["Alias"] != nil {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("FieldName") && dict["FieldName"] != nil {
                    self.fieldName = dict["FieldName"] as! String
                }
                if dict.keys.contains("Function") && dict["Function"] != nil {
                    self.function = dict["Function"] as! String
                }
                if dict.keys.contains("Max") && dict["Max"] != nil {
                    self.max = dict["Max"] as! String
                }
                if dict.keys.contains("Min") && dict["Min"] != nil {
                    self.min = dict["Min"] as! String
                }
            }
        }
        public class ValueFilter : Tea.TeaModel {
            public var key: String?

            public var operator_: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Operator") && dict["Operator"] != nil {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var aggregates: [DescribeLogMonitorAttributeResponseBody.LogMonitor.Aggregates]?

        public var gmtCreate: Int64?

        public var groupId: Int64?

        public var groupbys: [String]?

        public var logId: Int64?

        public var metricExpress: String?

        public var metricName: String?

        public var slsLogstore: String?

        public var slsProject: String?

        public var slsRegionId: String?

        public var tumblingwindows: [String]?

        public var valueFilter: [DescribeLogMonitorAttributeResponseBody.LogMonitor.ValueFilter]?

        public var valueFilterRelation: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aggregates != nil {
                var tmp : [Any] = []
                for k in self.aggregates! {
                    tmp.append(k.toMap())
                }
                map["Aggregates"] = tmp
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupbys != nil {
                map["Groupbys"] = self.groupbys!
            }
            if self.logId != nil {
                map["LogId"] = self.logId!
            }
            if self.metricExpress != nil {
                map["MetricExpress"] = self.metricExpress!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.slsLogstore != nil {
                map["SlsLogstore"] = self.slsLogstore!
            }
            if self.slsProject != nil {
                map["SlsProject"] = self.slsProject!
            }
            if self.slsRegionId != nil {
                map["SlsRegionId"] = self.slsRegionId!
            }
            if self.tumblingwindows != nil {
                map["Tumblingwindows"] = self.tumblingwindows!
            }
            if self.valueFilter != nil {
                var tmp : [Any] = []
                for k in self.valueFilter! {
                    tmp.append(k.toMap())
                }
                map["ValueFilter"] = tmp
            }
            if self.valueFilterRelation != nil {
                map["ValueFilterRelation"] = self.valueFilterRelation!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Aggregates") && dict["Aggregates"] != nil {
                var tmp : [DescribeLogMonitorAttributeResponseBody.LogMonitor.Aggregates] = []
                for v in dict["Aggregates"] as! [Any] {
                    var model = DescribeLogMonitorAttributeResponseBody.LogMonitor.Aggregates()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.aggregates = tmp
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! Int64
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! Int64
            }
            if dict.keys.contains("Groupbys") && dict["Groupbys"] != nil {
                self.groupbys = dict["Groupbys"] as! [String]
            }
            if dict.keys.contains("LogId") && dict["LogId"] != nil {
                self.logId = dict["LogId"] as! Int64
            }
            if dict.keys.contains("MetricExpress") && dict["MetricExpress"] != nil {
                self.metricExpress = dict["MetricExpress"] as! String
            }
            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("SlsLogstore") && dict["SlsLogstore"] != nil {
                self.slsLogstore = dict["SlsLogstore"] as! String
            }
            if dict.keys.contains("SlsProject") && dict["SlsProject"] != nil {
                self.slsProject = dict["SlsProject"] as! String
            }
            if dict.keys.contains("SlsRegionId") && dict["SlsRegionId"] != nil {
                self.slsRegionId = dict["SlsRegionId"] as! String
            }
            if dict.keys.contains("Tumblingwindows") && dict["Tumblingwindows"] != nil {
                self.tumblingwindows = dict["Tumblingwindows"] as! [String]
            }
            if dict.keys.contains("ValueFilter") && dict["ValueFilter"] != nil {
                var tmp : [DescribeLogMonitorAttributeResponseBody.LogMonitor.ValueFilter] = []
                for v in dict["ValueFilter"] as! [Any] {
                    var model = DescribeLogMonitorAttributeResponseBody.LogMonitor.ValueFilter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.valueFilter = tmp
            }
            if dict.keys.contains("ValueFilterRelation") && dict["ValueFilterRelation"] != nil {
                self.valueFilterRelation = dict["ValueFilterRelation"] as! String
            }
        }
    }
    public var code: String?

    public var logMonitor: DescribeLogMonitorAttributeResponseBody.LogMonitor?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logMonitor?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logMonitor != nil {
            map["LogMonitor"] = self.logMonitor?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogMonitor") && dict["LogMonitor"] != nil {
            var model = DescribeLogMonitorAttributeResponseBody.LogMonitor()
            model.fromMap(dict["LogMonitor"] as! [String: Any])
            self.logMonitor = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeLogMonitorAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLogMonitorAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLogMonitorAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLogMonitorListRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var searchValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.searchValue != nil {
            map["SearchValue"] = self.searchValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SearchValue") && dict["SearchValue"] != nil {
            self.searchValue = dict["SearchValue"] as! String
        }
    }
}

public class DescribeLogMonitorListResponseBody : Tea.TeaModel {
    public class LogMonitorList : Tea.TeaModel {
        public class ValueFilter : Tea.TeaModel {
            public var key: String?

            public var operator_: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Operator") && dict["Operator"] != nil {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var gmtCreate: Int64?

        public var groupId: Int64?

        public var logId: Int64?

        public var metricName: String?

        public var slsLogstore: String?

        public var slsProject: String?

        public var slsRegionId: String?

        public var valueFilter: [DescribeLogMonitorListResponseBody.LogMonitorList.ValueFilter]?

        public var valueFilterRelation: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.logId != nil {
                map["LogId"] = self.logId!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.slsLogstore != nil {
                map["SlsLogstore"] = self.slsLogstore!
            }
            if self.slsProject != nil {
                map["SlsProject"] = self.slsProject!
            }
            if self.slsRegionId != nil {
                map["SlsRegionId"] = self.slsRegionId!
            }
            if self.valueFilter != nil {
                var tmp : [Any] = []
                for k in self.valueFilter! {
                    tmp.append(k.toMap())
                }
                map["ValueFilter"] = tmp
            }
            if self.valueFilterRelation != nil {
                map["ValueFilterRelation"] = self.valueFilterRelation!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! Int64
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! Int64
            }
            if dict.keys.contains("LogId") && dict["LogId"] != nil {
                self.logId = dict["LogId"] as! Int64
            }
            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("SlsLogstore") && dict["SlsLogstore"] != nil {
                self.slsLogstore = dict["SlsLogstore"] as! String
            }
            if dict.keys.contains("SlsProject") && dict["SlsProject"] != nil {
                self.slsProject = dict["SlsProject"] as! String
            }
            if dict.keys.contains("SlsRegionId") && dict["SlsRegionId"] != nil {
                self.slsRegionId = dict["SlsRegionId"] as! String
            }
            if dict.keys.contains("ValueFilter") && dict["ValueFilter"] != nil {
                var tmp : [DescribeLogMonitorListResponseBody.LogMonitorList.ValueFilter] = []
                for v in dict["ValueFilter"] as! [Any] {
                    var model = DescribeLogMonitorListResponseBody.LogMonitorList.ValueFilter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.valueFilter = tmp
            }
            if dict.keys.contains("ValueFilterRelation") && dict["ValueFilterRelation"] != nil {
                self.valueFilterRelation = dict["ValueFilterRelation"] as! String
            }
        }
    }
    public var code: String?

    public var logMonitorList: [DescribeLogMonitorListResponseBody.LogMonitorList]?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logMonitorList != nil {
            var tmp : [Any] = []
            for k in self.logMonitorList! {
                tmp.append(k.toMap())
            }
            map["LogMonitorList"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogMonitorList") && dict["LogMonitorList"] != nil {
            var tmp : [DescribeLogMonitorListResponseBody.LogMonitorList] = []
            for v in dict["LogMonitorList"] as! [Any] {
                var model = DescribeLogMonitorListResponseBody.LogMonitorList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.logMonitorList = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class DescribeLogMonitorListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLogMonitorListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLogMonitorListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMetricDataRequest : Tea.TeaModel {
    public var dimensions: String?

    public var endTime: String?

    public var express: String?

    public var length: String?

    public var metricName: String?

    public var namespace: String?

    public var period: String?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dimensions != nil {
            map["Dimensions"] = self.dimensions!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.express != nil {
            map["Express"] = self.express!
        }
        if self.length != nil {
            map["Length"] = self.length!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
            self.dimensions = dict["Dimensions"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Express") && dict["Express"] != nil {
            self.express = dict["Express"] as! String
        }
        if dict.keys.contains("Length") && dict["Length"] != nil {
            self.length = dict["Length"] as! String
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeMetricDataResponseBody : Tea.TeaModel {
    public var code: String?

    public var datapoints: String?

    public var message: String?

    public var period: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.datapoints != nil {
            map["Datapoints"] = self.datapoints!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Datapoints") && dict["Datapoints"] != nil {
            self.datapoints = dict["Datapoints"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMetricDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMetricDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMetricDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMetricLastRequest : Tea.TeaModel {
    public var dimensions: String?

    public var endTime: String?

    public var express: String?

    public var length: String?

    public var metricName: String?

    public var namespace: String?

    public var nextToken: String?

    public var period: String?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dimensions != nil {
            map["Dimensions"] = self.dimensions!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.express != nil {
            map["Express"] = self.express!
        }
        if self.length != nil {
            map["Length"] = self.length!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
            self.dimensions = dict["Dimensions"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Express") && dict["Express"] != nil {
            self.express = dict["Express"] as! String
        }
        if dict.keys.contains("Length") && dict["Length"] != nil {
            self.length = dict["Length"] as! String
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeMetricLastResponseBody : Tea.TeaModel {
    public var code: String?

    public var datapoints: String?

    public var message: String?

    public var nextToken: String?

    public var period: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.datapoints != nil {
            map["Datapoints"] = self.datapoints!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Datapoints") && dict["Datapoints"] != nil {
            self.datapoints = dict["Datapoints"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeMetricLastResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMetricLastResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMetricLastResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMetricListRequest : Tea.TeaModel {
    public var dimensions: String?

    public var endTime: String?

    public var express: String?

    public var length: String?

    public var metricName: String?

    public var namespace: String?

    public var nextToken: String?

    public var period: String?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dimensions != nil {
            map["Dimensions"] = self.dimensions!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.express != nil {
            map["Express"] = self.express!
        }
        if self.length != nil {
            map["Length"] = self.length!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
            self.dimensions = dict["Dimensions"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Express") && dict["Express"] != nil {
            self.express = dict["Express"] as! String
        }
        if dict.keys.contains("Length") && dict["Length"] != nil {
            self.length = dict["Length"] as! String
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeMetricListResponseBody : Tea.TeaModel {
    public var code: String?

    public var datapoints: String?

    public var message: String?

    public var nextToken: String?

    public var period: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.datapoints != nil {
            map["Datapoints"] = self.datapoints!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Datapoints") && dict["Datapoints"] != nil {
            self.datapoints = dict["Datapoints"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeMetricListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMetricListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMetricListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMetricMetaListRequest : Tea.TeaModel {
    public var labels: String?

    public var metricName: String?

    public var namespace: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Labels") && dict["Labels"] != nil {
            self.labels = dict["Labels"] as! String
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeMetricMetaListResponseBody : Tea.TeaModel {
    public class Resources : Tea.TeaModel {
        public class Resource : Tea.TeaModel {
            public var description_: String?

            public var dimensions: String?

            public var labels: String?

            public var metricName: String?

            public var namespace: String?

            public var periods: String?

            public var statistics: String?

            public var unit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.dimensions != nil {
                    map["Dimensions"] = self.dimensions!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.periods != nil {
                    map["Periods"] = self.periods!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.unit != nil {
                    map["Unit"] = self.unit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
                    self.dimensions = dict["Dimensions"] as! String
                }
                if dict.keys.contains("Labels") && dict["Labels"] != nil {
                    self.labels = dict["Labels"] as! String
                }
                if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                    self.metricName = dict["MetricName"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Periods") && dict["Periods"] != nil {
                    self.periods = dict["Periods"] as! String
                }
                if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                    self.statistics = dict["Statistics"] as! String
                }
                if dict.keys.contains("Unit") && dict["Unit"] != nil {
                    self.unit = dict["Unit"] as! String
                }
            }
        }
        public var resource: [DescribeMetricMetaListResponseBody.Resources.Resource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resource != nil {
                var tmp : [Any] = []
                for k in self.resource! {
                    tmp.append(k.toMap())
                }
                map["Resource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Resource") && dict["Resource"] != nil {
                var tmp : [DescribeMetricMetaListResponseBody.Resources.Resource] = []
                for v in dict["Resource"] as! [Any] {
                    var model = DescribeMetricMetaListResponseBody.Resources.Resource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resource = tmp
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var resources: DescribeMetricMetaListResponseBody.Resources?

    public var success: Bool?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resources != nil {
            map["Resources"] = self.resources?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Resources") && dict["Resources"] != nil {
            var model = DescribeMetricMetaListResponseBody.Resources()
            model.fromMap(dict["Resources"] as! [String: Any])
            self.resources = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class DescribeMetricMetaListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMetricMetaListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMetricMetaListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMetricRuleBlackListRequest : Tea.TeaModel {
    public var category: String?

    public var ids: [String]?

    public var instanceIds: [String]?

    public var isEnable: Bool?

    public var name: String?

    public var namespace: String?

    public var order: Int32?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var scopeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.isEnable != nil {
            map["IsEnable"] = self.isEnable!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scopeType != nil {
            map["ScopeType"] = self.scopeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") && dict["Category"] != nil {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("Ids") && dict["Ids"] != nil {
            self.ids = dict["Ids"] as! [String]
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("IsEnable") && dict["IsEnable"] != nil {
            self.isEnable = dict["IsEnable"] as! Bool
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Order") && dict["Order"] != nil {
            self.order = dict["Order"] as! Int32
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScopeType") && dict["ScopeType"] != nil {
            self.scopeType = dict["ScopeType"] as! String
        }
    }
}

public class DescribeMetricRuleBlackListResponseBody : Tea.TeaModel {
    public class DescribeMetricRuleBlackList : Tea.TeaModel {
        public class Metrics : Tea.TeaModel {
            public var metricName: String?

            public var resource: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.resource != nil {
                    map["Resource"] = self.resource!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                    self.metricName = dict["MetricName"] as! String
                }
                if dict.keys.contains("Resource") && dict["Resource"] != nil {
                    self.resource = dict["Resource"] as! String
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var effectiveTime: String?

        public var enableEndTime: Int64?

        public var enableStartTime: Int64?

        public var id: String?

        public var instances: [String]?

        public var isEnable: Bool?

        public var metrics: [DescribeMetricRuleBlackListResponseBody.DescribeMetricRuleBlackList.Metrics]?

        public var name: String?

        public var namespace: String?

        public var scopeType: String?

        public var scopeValue: [String]?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.effectiveTime != nil {
                map["EffectiveTime"] = self.effectiveTime!
            }
            if self.enableEndTime != nil {
                map["EnableEndTime"] = self.enableEndTime!
            }
            if self.enableStartTime != nil {
                map["EnableStartTime"] = self.enableStartTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instances != nil {
                map["Instances"] = self.instances!
            }
            if self.isEnable != nil {
                map["IsEnable"] = self.isEnable!
            }
            if self.metrics != nil {
                var tmp : [Any] = []
                for k in self.metrics! {
                    tmp.append(k.toMap())
                }
                map["Metrics"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.scopeType != nil {
                map["ScopeType"] = self.scopeType!
            }
            if self.scopeValue != nil {
                map["ScopeValue"] = self.scopeValue!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("EffectiveTime") && dict["EffectiveTime"] != nil {
                self.effectiveTime = dict["EffectiveTime"] as! String
            }
            if dict.keys.contains("EnableEndTime") && dict["EnableEndTime"] != nil {
                self.enableEndTime = dict["EnableEndTime"] as! Int64
            }
            if dict.keys.contains("EnableStartTime") && dict["EnableStartTime"] != nil {
                self.enableStartTime = dict["EnableStartTime"] as! Int64
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Instances") && dict["Instances"] != nil {
                self.instances = dict["Instances"] as! [String]
            }
            if dict.keys.contains("IsEnable") && dict["IsEnable"] != nil {
                self.isEnable = dict["IsEnable"] as! Bool
            }
            if dict.keys.contains("Metrics") && dict["Metrics"] != nil {
                var tmp : [DescribeMetricRuleBlackListResponseBody.DescribeMetricRuleBlackList.Metrics] = []
                for v in dict["Metrics"] as! [Any] {
                    var model = DescribeMetricRuleBlackListResponseBody.DescribeMetricRuleBlackList.Metrics()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.metrics = tmp
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("ScopeType") && dict["ScopeType"] != nil {
                self.scopeType = dict["ScopeType"] as! String
            }
            if dict.keys.contains("ScopeValue") && dict["ScopeValue"] != nil {
                self.scopeValue = dict["ScopeValue"] as! [String]
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var code: String?

    public var describeMetricRuleBlackList: [DescribeMetricRuleBlackListResponseBody.DescribeMetricRuleBlackList]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.describeMetricRuleBlackList != nil {
            var tmp : [Any] = []
            for k in self.describeMetricRuleBlackList! {
                tmp.append(k.toMap())
            }
            map["DescribeMetricRuleBlackList"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DescribeMetricRuleBlackList") && dict["DescribeMetricRuleBlackList"] != nil {
            var tmp : [DescribeMetricRuleBlackListResponseBody.DescribeMetricRuleBlackList] = []
            for v in dict["DescribeMetricRuleBlackList"] as! [Any] {
                var model = DescribeMetricRuleBlackListResponseBody.DescribeMetricRuleBlackList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.describeMetricRuleBlackList = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeMetricRuleBlackListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMetricRuleBlackListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMetricRuleBlackListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMetricRuleCountRequest : Tea.TeaModel {
    public var metricName: String?

    public var namespace: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeMetricRuleCountResponseBody : Tea.TeaModel {
    public class MetricRuleCount : Tea.TeaModel {
        public var alarm: Int32?

        public var disable: Int32?

        public var nodata: Int32?

        public var ok: Int32?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarm != nil {
                map["Alarm"] = self.alarm!
            }
            if self.disable != nil {
                map["Disable"] = self.disable!
            }
            if self.nodata != nil {
                map["Nodata"] = self.nodata!
            }
            if self.ok != nil {
                map["Ok"] = self.ok!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alarm") && dict["Alarm"] != nil {
                self.alarm = dict["Alarm"] as! Int32
            }
            if dict.keys.contains("Disable") && dict["Disable"] != nil {
                self.disable = dict["Disable"] as! Int32
            }
            if dict.keys.contains("Nodata") && dict["Nodata"] != nil {
                self.nodata = dict["Nodata"] as! Int32
            }
            if dict.keys.contains("Ok") && dict["Ok"] != nil {
                self.ok = dict["Ok"] as! Int32
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var code: String?

    public var message: String?

    public var metricRuleCount: DescribeMetricRuleCountResponseBody.MetricRuleCount?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.metricRuleCount?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.metricRuleCount != nil {
            map["MetricRuleCount"] = self.metricRuleCount?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("MetricRuleCount") && dict["MetricRuleCount"] != nil {
            var model = DescribeMetricRuleCountResponseBody.MetricRuleCount()
            model.fromMap(dict["MetricRuleCount"] as! [String: Any])
            self.metricRuleCount = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeMetricRuleCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMetricRuleCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMetricRuleCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMetricRuleListRequest : Tea.TeaModel {
    public var alertState: String?

    public var dimensions: String?

    public var enableState: Bool?

    public var groupId: String?

    public var metricName: String?

    public var namespace: String?

    public var page: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var ruleIds: String?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertState != nil {
            map["AlertState"] = self.alertState!
        }
        if self.dimensions != nil {
            map["Dimensions"] = self.dimensions!
        }
        if self.enableState != nil {
            map["EnableState"] = self.enableState!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleIds != nil {
            map["RuleIds"] = self.ruleIds!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertState") && dict["AlertState"] != nil {
            self.alertState = dict["AlertState"] as! String
        }
        if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
            self.dimensions = dict["Dimensions"] as! String
        }
        if dict.keys.contains("EnableState") && dict["EnableState"] != nil {
            self.enableState = dict["EnableState"] as! Bool
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Page") && dict["Page"] != nil {
            self.page = dict["Page"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleIds") && dict["RuleIds"] != nil {
            self.ruleIds = dict["RuleIds"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
    }
}

public class DescribeMetricRuleListResponseBody : Tea.TeaModel {
    public class Alarms : Tea.TeaModel {
        public class Alarm : Tea.TeaModel {
            public class CompositeExpression : Tea.TeaModel {
                public class ExpressionList : Tea.TeaModel {
                    public class ExpressionList : Tea.TeaModel {
                        public var comparisonOperator: String?

                        public var metricName: String?

                        public var period: Int32?

                        public var statistics: String?

                        public var threshold: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.comparisonOperator != nil {
                                map["ComparisonOperator"] = self.comparisonOperator!
                            }
                            if self.metricName != nil {
                                map["MetricName"] = self.metricName!
                            }
                            if self.period != nil {
                                map["Period"] = self.period!
                            }
                            if self.statistics != nil {
                                map["Statistics"] = self.statistics!
                            }
                            if self.threshold != nil {
                                map["Threshold"] = self.threshold!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                                self.comparisonOperator = dict["ComparisonOperator"] as! String
                            }
                            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                                self.metricName = dict["MetricName"] as! String
                            }
                            if dict.keys.contains("Period") && dict["Period"] != nil {
                                self.period = dict["Period"] as! Int32
                            }
                            if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                                self.statistics = dict["Statistics"] as! String
                            }
                            if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                                self.threshold = dict["Threshold"] as! String
                            }
                        }
                    }
                    public var expressionList: [DescribeMetricRuleListResponseBody.Alarms.Alarm.CompositeExpression.ExpressionList.ExpressionList]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.expressionList != nil {
                            var tmp : [Any] = []
                            for k in self.expressionList! {
                                tmp.append(k.toMap())
                            }
                            map["ExpressionList"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ExpressionList") && dict["ExpressionList"] != nil {
                            var tmp : [DescribeMetricRuleListResponseBody.Alarms.Alarm.CompositeExpression.ExpressionList.ExpressionList] = []
                            for v in dict["ExpressionList"] as! [Any] {
                                var model = DescribeMetricRuleListResponseBody.Alarms.Alarm.CompositeExpression.ExpressionList.ExpressionList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.expressionList = tmp
                        }
                    }
                }
                public var expressionList: DescribeMetricRuleListResponseBody.Alarms.Alarm.CompositeExpression.ExpressionList?

                public var expressionListJoin: String?

                public var expressionRaw: String?

                public var level: String?

                public var times: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.expressionList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expressionList != nil {
                        map["ExpressionList"] = self.expressionList?.toMap()
                    }
                    if self.expressionListJoin != nil {
                        map["ExpressionListJoin"] = self.expressionListJoin!
                    }
                    if self.expressionRaw != nil {
                        map["ExpressionRaw"] = self.expressionRaw!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.times != nil {
                        map["Times"] = self.times!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ExpressionList") && dict["ExpressionList"] != nil {
                        var model = DescribeMetricRuleListResponseBody.Alarms.Alarm.CompositeExpression.ExpressionList()
                        model.fromMap(dict["ExpressionList"] as! [String: Any])
                        self.expressionList = model
                    }
                    if dict.keys.contains("ExpressionListJoin") && dict["ExpressionListJoin"] != nil {
                        self.expressionListJoin = dict["ExpressionListJoin"] as! String
                    }
                    if dict.keys.contains("ExpressionRaw") && dict["ExpressionRaw"] != nil {
                        self.expressionRaw = dict["ExpressionRaw"] as! String
                    }
                    if dict.keys.contains("Level") && dict["Level"] != nil {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Times") && dict["Times"] != nil {
                        self.times = dict["Times"] as! Int32
                    }
                }
            }
            public class Escalations : Tea.TeaModel {
                public class Critical : Tea.TeaModel {
                    public var comparisonOperator: String?

                    public var preCondition: String?

                    public var statistics: String?

                    public var threshold: String?

                    public var times: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.comparisonOperator != nil {
                            map["ComparisonOperator"] = self.comparisonOperator!
                        }
                        if self.preCondition != nil {
                            map["PreCondition"] = self.preCondition!
                        }
                        if self.statistics != nil {
                            map["Statistics"] = self.statistics!
                        }
                        if self.threshold != nil {
                            map["Threshold"] = self.threshold!
                        }
                        if self.times != nil {
                            map["Times"] = self.times!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                            self.comparisonOperator = dict["ComparisonOperator"] as! String
                        }
                        if dict.keys.contains("PreCondition") && dict["PreCondition"] != nil {
                            self.preCondition = dict["PreCondition"] as! String
                        }
                        if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                            self.statistics = dict["Statistics"] as! String
                        }
                        if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                            self.threshold = dict["Threshold"] as! String
                        }
                        if dict.keys.contains("Times") && dict["Times"] != nil {
                            self.times = dict["Times"] as! Int32
                        }
                    }
                }
                public class Info : Tea.TeaModel {
                    public var comparisonOperator: String?

                    public var preCondition: String?

                    public var statistics: String?

                    public var threshold: String?

                    public var times: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.comparisonOperator != nil {
                            map["ComparisonOperator"] = self.comparisonOperator!
                        }
                        if self.preCondition != nil {
                            map["PreCondition"] = self.preCondition!
                        }
                        if self.statistics != nil {
                            map["Statistics"] = self.statistics!
                        }
                        if self.threshold != nil {
                            map["Threshold"] = self.threshold!
                        }
                        if self.times != nil {
                            map["Times"] = self.times!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                            self.comparisonOperator = dict["ComparisonOperator"] as! String
                        }
                        if dict.keys.contains("PreCondition") && dict["PreCondition"] != nil {
                            self.preCondition = dict["PreCondition"] as! String
                        }
                        if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                            self.statistics = dict["Statistics"] as! String
                        }
                        if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                            self.threshold = dict["Threshold"] as! String
                        }
                        if dict.keys.contains("Times") && dict["Times"] != nil {
                            self.times = dict["Times"] as! Int32
                        }
                    }
                }
                public class Warn : Tea.TeaModel {
                    public var comparisonOperator: String?

                    public var preCondition: String?

                    public var statistics: String?

                    public var threshold: String?

                    public var times: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.comparisonOperator != nil {
                            map["ComparisonOperator"] = self.comparisonOperator!
                        }
                        if self.preCondition != nil {
                            map["PreCondition"] = self.preCondition!
                        }
                        if self.statistics != nil {
                            map["Statistics"] = self.statistics!
                        }
                        if self.threshold != nil {
                            map["Threshold"] = self.threshold!
                        }
                        if self.times != nil {
                            map["Times"] = self.times!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                            self.comparisonOperator = dict["ComparisonOperator"] as! String
                        }
                        if dict.keys.contains("PreCondition") && dict["PreCondition"] != nil {
                            self.preCondition = dict["PreCondition"] as! String
                        }
                        if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                            self.statistics = dict["Statistics"] as! String
                        }
                        if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                            self.threshold = dict["Threshold"] as! String
                        }
                        if dict.keys.contains("Times") && dict["Times"] != nil {
                            self.times = dict["Times"] as! Int32
                        }
                    }
                }
                public var critical: DescribeMetricRuleListResponseBody.Alarms.Alarm.Escalations.Critical?

                public var info: DescribeMetricRuleListResponseBody.Alarms.Alarm.Escalations.Info?

                public var warn: DescribeMetricRuleListResponseBody.Alarms.Alarm.Escalations.Warn?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.critical?.validate()
                    try self.info?.validate()
                    try self.warn?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.critical != nil {
                        map["Critical"] = self.critical?.toMap()
                    }
                    if self.info != nil {
                        map["Info"] = self.info?.toMap()
                    }
                    if self.warn != nil {
                        map["Warn"] = self.warn?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Critical") && dict["Critical"] != nil {
                        var model = DescribeMetricRuleListResponseBody.Alarms.Alarm.Escalations.Critical()
                        model.fromMap(dict["Critical"] as! [String: Any])
                        self.critical = model
                    }
                    if dict.keys.contains("Info") && dict["Info"] != nil {
                        var model = DescribeMetricRuleListResponseBody.Alarms.Alarm.Escalations.Info()
                        model.fromMap(dict["Info"] as! [String: Any])
                        self.info = model
                    }
                    if dict.keys.contains("Warn") && dict["Warn"] != nil {
                        var model = DescribeMetricRuleListResponseBody.Alarms.Alarm.Escalations.Warn()
                        model.fromMap(dict["Warn"] as! [String: Any])
                        self.warn = model
                    }
                }
            }
            public class Labels : Tea.TeaModel {
                public class Labels : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var labels: [DescribeMetricRuleListResponseBody.Alarms.Alarm.Labels.Labels]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.labels != nil {
                        var tmp : [Any] = []
                        for k in self.labels! {
                            tmp.append(k.toMap())
                        }
                        map["Labels"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Labels") && dict["Labels"] != nil {
                        var tmp : [DescribeMetricRuleListResponseBody.Alarms.Alarm.Labels.Labels] = []
                        for v in dict["Labels"] as! [Any] {
                            var model = DescribeMetricRuleListResponseBody.Alarms.Alarm.Labels.Labels()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.labels = tmp
                    }
                }
            }
            public class Prometheus : Tea.TeaModel {
                public class Annotations : Tea.TeaModel {
                    public class Annotations : Tea.TeaModel {
                        public var key: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.key != nil {
                                map["Key"] = self.key!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Key") && dict["Key"] != nil {
                                self.key = dict["Key"] as! String
                            }
                            if dict.keys.contains("Value") && dict["Value"] != nil {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public var annotations: [DescribeMetricRuleListResponseBody.Alarms.Alarm.Prometheus.Annotations.Annotations]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.annotations != nil {
                            var tmp : [Any] = []
                            for k in self.annotations! {
                                tmp.append(k.toMap())
                            }
                            map["Annotations"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
                            var tmp : [DescribeMetricRuleListResponseBody.Alarms.Alarm.Prometheus.Annotations.Annotations] = []
                            for v in dict["Annotations"] as! [Any] {
                                var model = DescribeMetricRuleListResponseBody.Alarms.Alarm.Prometheus.Annotations.Annotations()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.annotations = tmp
                        }
                    }
                }
                public var annotations: DescribeMetricRuleListResponseBody.Alarms.Alarm.Prometheus.Annotations?

                public var level: String?

                public var promQL: String?

                public var times: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.annotations?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.annotations != nil {
                        map["Annotations"] = self.annotations?.toMap()
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.promQL != nil {
                        map["PromQL"] = self.promQL!
                    }
                    if self.times != nil {
                        map["Times"] = self.times!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
                        var model = DescribeMetricRuleListResponseBody.Alarms.Alarm.Prometheus.Annotations()
                        model.fromMap(dict["Annotations"] as! [String: Any])
                        self.annotations = model
                    }
                    if dict.keys.contains("Level") && dict["Level"] != nil {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("PromQL") && dict["PromQL"] != nil {
                        self.promQL = dict["PromQL"] as! String
                    }
                    if dict.keys.contains("Times") && dict["Times"] != nil {
                        self.times = dict["Times"] as! Int64
                    }
                }
            }
            public var alertState: String?

            public var compositeExpression: DescribeMetricRuleListResponseBody.Alarms.Alarm.CompositeExpression?

            public var contactGroups: String?

            public var dimensions: String?

            public var effectiveInterval: String?

            public var enableState: Bool?

            public var escalations: DescribeMetricRuleListResponseBody.Alarms.Alarm.Escalations?

            public var groupId: String?

            public var groupName: String?

            public var labels: DescribeMetricRuleListResponseBody.Alarms.Alarm.Labels?

            public var mailSubject: String?

            public var metricName: String?

            public var namespace: String?

            public var noDataPolicy: String?

            public var noEffectiveInterval: String?

            public var period: String?

            public var prometheus: DescribeMetricRuleListResponseBody.Alarms.Alarm.Prometheus?

            public var resources: String?

            public var ruleId: String?

            public var ruleName: String?

            public var silenceTime: Int32?

            public var sourceType: String?

            public var webhook: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.compositeExpression?.validate()
                try self.escalations?.validate()
                try self.labels?.validate()
                try self.prometheus?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertState != nil {
                    map["AlertState"] = self.alertState!
                }
                if self.compositeExpression != nil {
                    map["CompositeExpression"] = self.compositeExpression?.toMap()
                }
                if self.contactGroups != nil {
                    map["ContactGroups"] = self.contactGroups!
                }
                if self.dimensions != nil {
                    map["Dimensions"] = self.dimensions!
                }
                if self.effectiveInterval != nil {
                    map["EffectiveInterval"] = self.effectiveInterval!
                }
                if self.enableState != nil {
                    map["EnableState"] = self.enableState!
                }
                if self.escalations != nil {
                    map["Escalations"] = self.escalations?.toMap()
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels?.toMap()
                }
                if self.mailSubject != nil {
                    map["MailSubject"] = self.mailSubject!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.noDataPolicy != nil {
                    map["NoDataPolicy"] = self.noDataPolicy!
                }
                if self.noEffectiveInterval != nil {
                    map["NoEffectiveInterval"] = self.noEffectiveInterval!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.prometheus != nil {
                    map["Prometheus"] = self.prometheus?.toMap()
                }
                if self.resources != nil {
                    map["Resources"] = self.resources!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.silenceTime != nil {
                    map["SilenceTime"] = self.silenceTime!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.webhook != nil {
                    map["Webhook"] = self.webhook!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertState") && dict["AlertState"] != nil {
                    self.alertState = dict["AlertState"] as! String
                }
                if dict.keys.contains("CompositeExpression") && dict["CompositeExpression"] != nil {
                    var model = DescribeMetricRuleListResponseBody.Alarms.Alarm.CompositeExpression()
                    model.fromMap(dict["CompositeExpression"] as! [String: Any])
                    self.compositeExpression = model
                }
                if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
                    self.contactGroups = dict["ContactGroups"] as! String
                }
                if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
                    self.dimensions = dict["Dimensions"] as! String
                }
                if dict.keys.contains("EffectiveInterval") && dict["EffectiveInterval"] != nil {
                    self.effectiveInterval = dict["EffectiveInterval"] as! String
                }
                if dict.keys.contains("EnableState") && dict["EnableState"] != nil {
                    self.enableState = dict["EnableState"] as! Bool
                }
                if dict.keys.contains("Escalations") && dict["Escalations"] != nil {
                    var model = DescribeMetricRuleListResponseBody.Alarms.Alarm.Escalations()
                    model.fromMap(dict["Escalations"] as! [String: Any])
                    self.escalations = model
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Labels") && dict["Labels"] != nil {
                    var model = DescribeMetricRuleListResponseBody.Alarms.Alarm.Labels()
                    model.fromMap(dict["Labels"] as! [String: Any])
                    self.labels = model
                }
                if dict.keys.contains("MailSubject") && dict["MailSubject"] != nil {
                    self.mailSubject = dict["MailSubject"] as! String
                }
                if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                    self.metricName = dict["MetricName"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("NoDataPolicy") && dict["NoDataPolicy"] != nil {
                    self.noDataPolicy = dict["NoDataPolicy"] as! String
                }
                if dict.keys.contains("NoEffectiveInterval") && dict["NoEffectiveInterval"] != nil {
                    self.noEffectiveInterval = dict["NoEffectiveInterval"] as! String
                }
                if dict.keys.contains("Period") && dict["Period"] != nil {
                    self.period = dict["Period"] as! String
                }
                if dict.keys.contains("Prometheus") && dict["Prometheus"] != nil {
                    var model = DescribeMetricRuleListResponseBody.Alarms.Alarm.Prometheus()
                    model.fromMap(dict["Prometheus"] as! [String: Any])
                    self.prometheus = model
                }
                if dict.keys.contains("Resources") && dict["Resources"] != nil {
                    self.resources = dict["Resources"] as! String
                }
                if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                    self.ruleId = dict["RuleId"] as! String
                }
                if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
                    self.silenceTime = dict["SilenceTime"] as! Int32
                }
                if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
                    self.webhook = dict["Webhook"] as! String
                }
            }
        }
        public var alarm: [DescribeMetricRuleListResponseBody.Alarms.Alarm]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarm != nil {
                var tmp : [Any] = []
                for k in self.alarm! {
                    tmp.append(k.toMap())
                }
                map["Alarm"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alarm") && dict["Alarm"] != nil {
                var tmp : [DescribeMetricRuleListResponseBody.Alarms.Alarm] = []
                for v in dict["Alarm"] as! [Any] {
                    var model = DescribeMetricRuleListResponseBody.Alarms.Alarm()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alarm = tmp
            }
        }
    }
    public var alarms: DescribeMetricRuleListResponseBody.Alarms?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var total: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alarms?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarms != nil {
            map["Alarms"] = self.alarms?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Alarms") && dict["Alarms"] != nil {
            var model = DescribeMetricRuleListResponseBody.Alarms()
            model.fromMap(dict["Alarms"] as! [String: Any])
            self.alarms = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! String
        }
    }
}

public class DescribeMetricRuleListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMetricRuleListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMetricRuleListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMetricRuleTargetsRequest : Tea.TeaModel {
    public var regionId: String?

    public var ruleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
    }
}

public class DescribeMetricRuleTargetsResponseBody : Tea.TeaModel {
    public class Targets : Tea.TeaModel {
        public class Target : Tea.TeaModel {
            public var arn: String?

            public var id: String?

            public var jsonParams: String?

            public var level: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.arn != nil {
                    map["Arn"] = self.arn!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.jsonParams != nil {
                    map["JsonParams"] = self.jsonParams!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Arn") && dict["Arn"] != nil {
                    self.arn = dict["Arn"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("JsonParams") && dict["JsonParams"] != nil {
                    self.jsonParams = dict["JsonParams"] as! String
                }
                if dict.keys.contains("Level") && dict["Level"] != nil {
                    self.level = dict["Level"] as! String
                }
            }
        }
        public var target: [DescribeMetricRuleTargetsResponseBody.Targets.Target]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.target != nil {
                var tmp : [Any] = []
                for k in self.target! {
                    tmp.append(k.toMap())
                }
                map["Target"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Target") && dict["Target"] != nil {
                var tmp : [DescribeMetricRuleTargetsResponseBody.Targets.Target] = []
                for v in dict["Target"] as! [Any] {
                    var model = DescribeMetricRuleTargetsResponseBody.Targets.Target()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.target = tmp
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var targets: DescribeMetricRuleTargetsResponseBody.Targets?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.targets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.targets != nil {
            map["Targets"] = self.targets?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Targets") && dict["Targets"] != nil {
            var model = DescribeMetricRuleTargetsResponseBody.Targets()
            model.fromMap(dict["Targets"] as! [String: Any])
            self.targets = model
        }
    }
}

public class DescribeMetricRuleTargetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMetricRuleTargetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMetricRuleTargetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMetricRuleTemplateAttributeRequest : Tea.TeaModel {
    public var name: String?

    public var regionId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DescribeMetricRuleTemplateAttributeResponseBody : Tea.TeaModel {
    public class Resource : Tea.TeaModel {
        public class AlertTemplates : Tea.TeaModel {
            public class AlertTemplate : Tea.TeaModel {
                public class Escalations : Tea.TeaModel {
                    public class Critical : Tea.TeaModel {
                        public var comparisonOperator: String?

                        public var statistics: String?

                        public var threshold: String?

                        public var times: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.comparisonOperator != nil {
                                map["ComparisonOperator"] = self.comparisonOperator!
                            }
                            if self.statistics != nil {
                                map["Statistics"] = self.statistics!
                            }
                            if self.threshold != nil {
                                map["Threshold"] = self.threshold!
                            }
                            if self.times != nil {
                                map["Times"] = self.times!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                                self.comparisonOperator = dict["ComparisonOperator"] as! String
                            }
                            if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                                self.statistics = dict["Statistics"] as! String
                            }
                            if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                                self.threshold = dict["Threshold"] as! String
                            }
                            if dict.keys.contains("Times") && dict["Times"] != nil {
                                self.times = dict["Times"] as! Int32
                            }
                        }
                    }
                    public class Info : Tea.TeaModel {
                        public var comparisonOperator: String?

                        public var statistics: String?

                        public var threshold: String?

                        public var times: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.comparisonOperator != nil {
                                map["ComparisonOperator"] = self.comparisonOperator!
                            }
                            if self.statistics != nil {
                                map["Statistics"] = self.statistics!
                            }
                            if self.threshold != nil {
                                map["Threshold"] = self.threshold!
                            }
                            if self.times != nil {
                                map["Times"] = self.times!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                                self.comparisonOperator = dict["ComparisonOperator"] as! String
                            }
                            if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                                self.statistics = dict["Statistics"] as! String
                            }
                            if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                                self.threshold = dict["Threshold"] as! String
                            }
                            if dict.keys.contains("Times") && dict["Times"] != nil {
                                self.times = dict["Times"] as! Int32
                            }
                        }
                    }
                    public class Warn : Tea.TeaModel {
                        public var comparisonOperator: String?

                        public var statistics: String?

                        public var threshold: String?

                        public var times: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.comparisonOperator != nil {
                                map["ComparisonOperator"] = self.comparisonOperator!
                            }
                            if self.statistics != nil {
                                map["Statistics"] = self.statistics!
                            }
                            if self.threshold != nil {
                                map["Threshold"] = self.threshold!
                            }
                            if self.times != nil {
                                map["Times"] = self.times!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                                self.comparisonOperator = dict["ComparisonOperator"] as! String
                            }
                            if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                                self.statistics = dict["Statistics"] as! String
                            }
                            if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                                self.threshold = dict["Threshold"] as! String
                            }
                            if dict.keys.contains("Times") && dict["Times"] != nil {
                                self.times = dict["Times"] as! Int32
                            }
                        }
                    }
                    public var critical: DescribeMetricRuleTemplateAttributeResponseBody.Resource.AlertTemplates.AlertTemplate.Escalations.Critical?

                    public var info: DescribeMetricRuleTemplateAttributeResponseBody.Resource.AlertTemplates.AlertTemplate.Escalations.Info?

                    public var warn: DescribeMetricRuleTemplateAttributeResponseBody.Resource.AlertTemplates.AlertTemplate.Escalations.Warn?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.critical?.validate()
                        try self.info?.validate()
                        try self.warn?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.critical != nil {
                            map["Critical"] = self.critical?.toMap()
                        }
                        if self.info != nil {
                            map["Info"] = self.info?.toMap()
                        }
                        if self.warn != nil {
                            map["Warn"] = self.warn?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Critical") && dict["Critical"] != nil {
                            var model = DescribeMetricRuleTemplateAttributeResponseBody.Resource.AlertTemplates.AlertTemplate.Escalations.Critical()
                            model.fromMap(dict["Critical"] as! [String: Any])
                            self.critical = model
                        }
                        if dict.keys.contains("Info") && dict["Info"] != nil {
                            var model = DescribeMetricRuleTemplateAttributeResponseBody.Resource.AlertTemplates.AlertTemplate.Escalations.Info()
                            model.fromMap(dict["Info"] as! [String: Any])
                            self.info = model
                        }
                        if dict.keys.contains("Warn") && dict["Warn"] != nil {
                            var model = DescribeMetricRuleTemplateAttributeResponseBody.Resource.AlertTemplates.AlertTemplate.Escalations.Warn()
                            model.fromMap(dict["Warn"] as! [String: Any])
                            self.warn = model
                        }
                    }
                }
                public class Labels : Tea.TeaModel {
                    public class Labels : Tea.TeaModel {
                        public var key: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.key != nil {
                                map["Key"] = self.key!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Key") && dict["Key"] != nil {
                                self.key = dict["Key"] as! String
                            }
                            if dict.keys.contains("Value") && dict["Value"] != nil {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public var labels: [DescribeMetricRuleTemplateAttributeResponseBody.Resource.AlertTemplates.AlertTemplate.Labels.Labels]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.labels != nil {
                            var tmp : [Any] = []
                            for k in self.labels! {
                                tmp.append(k.toMap())
                            }
                            map["Labels"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Labels") && dict["Labels"] != nil {
                            var tmp : [DescribeMetricRuleTemplateAttributeResponseBody.Resource.AlertTemplates.AlertTemplate.Labels.Labels] = []
                            for v in dict["Labels"] as! [Any] {
                                var model = DescribeMetricRuleTemplateAttributeResponseBody.Resource.AlertTemplates.AlertTemplate.Labels.Labels()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.labels = tmp
                        }
                    }
                }
                public var category: String?

                public var escalations: DescribeMetricRuleTemplateAttributeResponseBody.Resource.AlertTemplates.AlertTemplate.Escalations?

                public var labels: DescribeMetricRuleTemplateAttributeResponseBody.Resource.AlertTemplates.AlertTemplate.Labels?

                public var metricName: String?

                public var namespace: String?

                public var noDataPolicy: String?

                public var ruleName: String?

                public var selector: String?

                public var webhook: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.escalations?.validate()
                    try self.labels?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.escalations != nil {
                        map["Escalations"] = self.escalations?.toMap()
                    }
                    if self.labels != nil {
                        map["Labels"] = self.labels?.toMap()
                    }
                    if self.metricName != nil {
                        map["MetricName"] = self.metricName!
                    }
                    if self.namespace != nil {
                        map["Namespace"] = self.namespace!
                    }
                    if self.noDataPolicy != nil {
                        map["NoDataPolicy"] = self.noDataPolicy!
                    }
                    if self.ruleName != nil {
                        map["RuleName"] = self.ruleName!
                    }
                    if self.selector != nil {
                        map["Selector"] = self.selector!
                    }
                    if self.webhook != nil {
                        map["Webhook"] = self.webhook!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Category") && dict["Category"] != nil {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("Escalations") && dict["Escalations"] != nil {
                        var model = DescribeMetricRuleTemplateAttributeResponseBody.Resource.AlertTemplates.AlertTemplate.Escalations()
                        model.fromMap(dict["Escalations"] as! [String: Any])
                        self.escalations = model
                    }
                    if dict.keys.contains("Labels") && dict["Labels"] != nil {
                        var model = DescribeMetricRuleTemplateAttributeResponseBody.Resource.AlertTemplates.AlertTemplate.Labels()
                        model.fromMap(dict["Labels"] as! [String: Any])
                        self.labels = model
                    }
                    if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                        self.metricName = dict["MetricName"] as! String
                    }
                    if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                        self.namespace = dict["Namespace"] as! String
                    }
                    if dict.keys.contains("NoDataPolicy") && dict["NoDataPolicy"] != nil {
                        self.noDataPolicy = dict["NoDataPolicy"] as! String
                    }
                    if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                        self.ruleName = dict["RuleName"] as! String
                    }
                    if dict.keys.contains("Selector") && dict["Selector"] != nil {
                        self.selector = dict["Selector"] as! String
                    }
                    if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
                        self.webhook = dict["Webhook"] as! String
                    }
                }
            }
            public var alertTemplate: [DescribeMetricRuleTemplateAttributeResponseBody.Resource.AlertTemplates.AlertTemplate]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertTemplate != nil {
                    var tmp : [Any] = []
                    for k in self.alertTemplate! {
                        tmp.append(k.toMap())
                    }
                    map["AlertTemplate"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertTemplate") && dict["AlertTemplate"] != nil {
                    var tmp : [DescribeMetricRuleTemplateAttributeResponseBody.Resource.AlertTemplates.AlertTemplate] = []
                    for v in dict["AlertTemplate"] as! [Any] {
                        var model = DescribeMetricRuleTemplateAttributeResponseBody.Resource.AlertTemplates.AlertTemplate()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.alertTemplate = tmp
                }
            }
        }
        public var alertTemplates: DescribeMetricRuleTemplateAttributeResponseBody.Resource.AlertTemplates?

        public var description_: String?

        public var name: String?

        public var restVersion: String?

        public var templateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.alertTemplates?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertTemplates != nil {
                map["AlertTemplates"] = self.alertTemplates?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.restVersion != nil {
                map["RestVersion"] = self.restVersion!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertTemplates") && dict["AlertTemplates"] != nil {
                var model = DescribeMetricRuleTemplateAttributeResponseBody.Resource.AlertTemplates()
                model.fromMap(dict["AlertTemplates"] as! [String: Any])
                self.alertTemplates = model
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RestVersion") && dict["RestVersion"] != nil {
                self.restVersion = dict["RestVersion"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var resource: DescribeMetricRuleTemplateAttributeResponseBody.Resource?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resource?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Resource") && dict["Resource"] != nil {
            var model = DescribeMetricRuleTemplateAttributeResponseBody.Resource()
            model.fromMap(dict["Resource"] as! [String: Any])
            self.resource = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeMetricRuleTemplateAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMetricRuleTemplateAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMetricRuleTemplateAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMetricRuleTemplateListRequest : Tea.TeaModel {
    public var history: Bool?

    public var keyword: String?

    public var name: String?

    public var order: Bool?

    public var orderBy: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var templateId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.history != nil {
            map["History"] = self.history!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("History") && dict["History"] != nil {
            self.history = dict["History"] as! Bool
        }
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Order") && dict["Order"] != nil {
            self.order = dict["Order"] as! Bool
        }
        if dict.keys.contains("OrderBy") && dict["OrderBy"] != nil {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! Int64
        }
    }
}

public class DescribeMetricRuleTemplateListResponseBody : Tea.TeaModel {
    public class Templates : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public class ApplyHistories : Tea.TeaModel {
                public class ApplyHistory : Tea.TeaModel {
                    public var applyTime: Int64?

                    public var groupId: Int64?

                    public var groupName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.applyTime != nil {
                            map["ApplyTime"] = self.applyTime!
                        }
                        if self.groupId != nil {
                            map["GroupId"] = self.groupId!
                        }
                        if self.groupName != nil {
                            map["GroupName"] = self.groupName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ApplyTime") && dict["ApplyTime"] != nil {
                            self.applyTime = dict["ApplyTime"] as! Int64
                        }
                        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                            self.groupId = dict["GroupId"] as! Int64
                        }
                        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                            self.groupName = dict["GroupName"] as! String
                        }
                    }
                }
                public var applyHistory: [DescribeMetricRuleTemplateListResponseBody.Templates.Template.ApplyHistories.ApplyHistory]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.applyHistory != nil {
                        var tmp : [Any] = []
                        for k in self.applyHistory! {
                            tmp.append(k.toMap())
                        }
                        map["ApplyHistory"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ApplyHistory") && dict["ApplyHistory"] != nil {
                        var tmp : [DescribeMetricRuleTemplateListResponseBody.Templates.Template.ApplyHistories.ApplyHistory] = []
                        for v in dict["ApplyHistory"] as! [Any] {
                            var model = DescribeMetricRuleTemplateListResponseBody.Templates.Template.ApplyHistories.ApplyHistory()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.applyHistory = tmp
                    }
                }
            }
            public var applyHistories: DescribeMetricRuleTemplateListResponseBody.Templates.Template.ApplyHistories?

            public var description_: String?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var name: String?

            public var restVersion: Int64?

            public var templateId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.applyHistories?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applyHistories != nil {
                    map["ApplyHistories"] = self.applyHistories?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.restVersion != nil {
                    map["RestVersion"] = self.restVersion!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApplyHistories") && dict["ApplyHistories"] != nil {
                    var model = DescribeMetricRuleTemplateListResponseBody.Templates.Template.ApplyHistories()
                    model.fromMap(dict["ApplyHistories"] as! [String: Any])
                    self.applyHistories = model
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! Int64
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RestVersion") && dict["RestVersion"] != nil {
                    self.restVersion = dict["RestVersion"] as! Int64
                }
                if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                    self.templateId = dict["TemplateId"] as! Int64
                }
            }
        }
        public var template: [DescribeMetricRuleTemplateListResponseBody.Templates.Template]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.template != nil {
                var tmp : [Any] = []
                for k in self.template! {
                    tmp.append(k.toMap())
                }
                map["Template"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Template") && dict["Template"] != nil {
                var tmp : [DescribeMetricRuleTemplateListResponseBody.Templates.Template] = []
                for v in dict["Template"] as! [Any] {
                    var model = DescribeMetricRuleTemplateListResponseBody.Templates.Template()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.template = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var templates: DescribeMetricRuleTemplateListResponseBody.Templates?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templates?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.templates != nil {
            map["Templates"] = self.templates?.toMap()
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Templates") && dict["Templates"] != nil {
            var model = DescribeMetricRuleTemplateListResponseBody.Templates()
            model.fromMap(dict["Templates"] as! [String: Any])
            self.templates = model
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class DescribeMetricRuleTemplateListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMetricRuleTemplateListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMetricRuleTemplateListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMetricTopRequest : Tea.TeaModel {
    public var dimensions: String?

    public var endTime: String?

    public var express: String?

    public var length: String?

    public var metricName: String?

    public var namespace: String?

    public var orderDesc: String?

    public var orderby: String?

    public var period: String?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dimensions != nil {
            map["Dimensions"] = self.dimensions!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.express != nil {
            map["Express"] = self.express!
        }
        if self.length != nil {
            map["Length"] = self.length!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.orderDesc != nil {
            map["OrderDesc"] = self.orderDesc!
        }
        if self.orderby != nil {
            map["Orderby"] = self.orderby!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
            self.dimensions = dict["Dimensions"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Express") && dict["Express"] != nil {
            self.express = dict["Express"] as! String
        }
        if dict.keys.contains("Length") && dict["Length"] != nil {
            self.length = dict["Length"] as! String
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("OrderDesc") && dict["OrderDesc"] != nil {
            self.orderDesc = dict["OrderDesc"] as! String
        }
        if dict.keys.contains("Orderby") && dict["Orderby"] != nil {
            self.orderby = dict["Orderby"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeMetricTopResponseBody : Tea.TeaModel {
    public var code: String?

    public var datapoints: String?

    public var message: String?

    public var period: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.datapoints != nil {
            map["Datapoints"] = self.datapoints!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Datapoints") && dict["Datapoints"] != nil {
            self.datapoints = dict["Datapoints"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMetricTopResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMetricTopResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMetricTopResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMonitorGroupCategoriesRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeMonitorGroupCategoriesResponseBody : Tea.TeaModel {
    public class MonitorGroupCategories : Tea.TeaModel {
        public class MonitorGroupCategory : Tea.TeaModel {
            public class CategoryItem : Tea.TeaModel {
                public var category: String?

                public var count: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Category") && dict["Category"] != nil {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("Count") && dict["Count"] != nil {
                        self.count = dict["Count"] as! Int32
                    }
                }
            }
            public var categoryItem: [DescribeMonitorGroupCategoriesResponseBody.MonitorGroupCategories.MonitorGroupCategory.CategoryItem]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.categoryItem != nil {
                    var tmp : [Any] = []
                    for k in self.categoryItem! {
                        tmp.append(k.toMap())
                    }
                    map["CategoryItem"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CategoryItem") && dict["CategoryItem"] != nil {
                    var tmp : [DescribeMonitorGroupCategoriesResponseBody.MonitorGroupCategories.MonitorGroupCategory.CategoryItem] = []
                    for v in dict["CategoryItem"] as! [Any] {
                        var model = DescribeMonitorGroupCategoriesResponseBody.MonitorGroupCategories.MonitorGroupCategory.CategoryItem()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.categoryItem = tmp
                }
            }
        }
        public var groupId: Int64?

        public var monitorGroupCategory: DescribeMonitorGroupCategoriesResponseBody.MonitorGroupCategories.MonitorGroupCategory?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.monitorGroupCategory?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.monitorGroupCategory != nil {
                map["MonitorGroupCategory"] = self.monitorGroupCategory?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! Int64
            }
            if dict.keys.contains("MonitorGroupCategory") && dict["MonitorGroupCategory"] != nil {
                var model = DescribeMonitorGroupCategoriesResponseBody.MonitorGroupCategories.MonitorGroupCategory()
                model.fromMap(dict["MonitorGroupCategory"] as! [String: Any])
                self.monitorGroupCategory = model
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var monitorGroupCategories: DescribeMonitorGroupCategoriesResponseBody.MonitorGroupCategories?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.monitorGroupCategories?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.monitorGroupCategories != nil {
            map["MonitorGroupCategories"] = self.monitorGroupCategories?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("MonitorGroupCategories") && dict["MonitorGroupCategories"] != nil {
            var model = DescribeMonitorGroupCategoriesResponseBody.MonitorGroupCategories()
            model.fromMap(dict["MonitorGroupCategories"] as! [String: Any])
            self.monitorGroupCategories = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeMonitorGroupCategoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMonitorGroupCategoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMonitorGroupCategoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMonitorGroupDynamicRulesRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeMonitorGroupDynamicRulesResponseBody : Tea.TeaModel {
    public class Resource : Tea.TeaModel {
        public class Resource : Tea.TeaModel {
            public class Filters : Tea.TeaModel {
                public class Filter : Tea.TeaModel {
                    public var function: String?

                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.function != nil {
                            map["Function"] = self.function!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Function") && dict["Function"] != nil {
                            self.function = dict["Function"] as! String
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var filter: [DescribeMonitorGroupDynamicRulesResponseBody.Resource.Resource.Filters.Filter]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.filter != nil {
                        var tmp : [Any] = []
                        for k in self.filter! {
                            tmp.append(k.toMap())
                        }
                        map["Filter"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Filter") && dict["Filter"] != nil {
                        var tmp : [DescribeMonitorGroupDynamicRulesResponseBody.Resource.Resource.Filters.Filter] = []
                        for v in dict["Filter"] as! [Any] {
                            var model = DescribeMonitorGroupDynamicRulesResponseBody.Resource.Resource.Filters.Filter()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.filter = tmp
                    }
                }
            }
            public var category: String?

            public var filterRelation: String?

            public var filters: DescribeMonitorGroupDynamicRulesResponseBody.Resource.Resource.Filters?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.filters?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.filterRelation != nil {
                    map["FilterRelation"] = self.filterRelation!
                }
                if self.filters != nil {
                    map["Filters"] = self.filters?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") && dict["Category"] != nil {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("FilterRelation") && dict["FilterRelation"] != nil {
                    self.filterRelation = dict["FilterRelation"] as! String
                }
                if dict.keys.contains("Filters") && dict["Filters"] != nil {
                    var model = DescribeMonitorGroupDynamicRulesResponseBody.Resource.Resource.Filters()
                    model.fromMap(dict["Filters"] as! [String: Any])
                    self.filters = model
                }
            }
        }
        public var resource: [DescribeMonitorGroupDynamicRulesResponseBody.Resource.Resource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resource != nil {
                var tmp : [Any] = []
                for k in self.resource! {
                    tmp.append(k.toMap())
                }
                map["Resource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Resource") && dict["Resource"] != nil {
                var tmp : [DescribeMonitorGroupDynamicRulesResponseBody.Resource.Resource] = []
                for v in dict["Resource"] as! [Any] {
                    var model = DescribeMonitorGroupDynamicRulesResponseBody.Resource.Resource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resource = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var resource: DescribeMonitorGroupDynamicRulesResponseBody.Resource?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resource?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Resource") && dict["Resource"] != nil {
            var model = DescribeMonitorGroupDynamicRulesResponseBody.Resource()
            model.fromMap(dict["Resource"] as! [String: Any])
            self.resource = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeMonitorGroupDynamicRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMonitorGroupDynamicRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMonitorGroupDynamicRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMonitorGroupInstanceAttributeRequest : Tea.TeaModel {
    public var category: String?

    public var groupId: Int64?

    public var instanceIds: String?

    public var keyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var total: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") && dict["Category"] != nil {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Bool
        }
    }
}

public class DescribeMonitorGroupInstanceAttributeResponseBody : Tea.TeaModel {
    public class Resources : Tea.TeaModel {
        public class Resource : Tea.TeaModel {
            public class Region : Tea.TeaModel {
                public var availabilityZone: String?

                public var regionId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.availabilityZone != nil {
                        map["AvailabilityZone"] = self.availabilityZone!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvailabilityZone") && dict["AvailabilityZone"] != nil {
                        self.availabilityZone = dict["AvailabilityZone"] as! String
                    }
                    if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                        self.regionId = dict["RegionId"] as! String
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeMonitorGroupInstanceAttributeResponseBody.Resources.Resource.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") && dict["Tag"] != nil {
                        var tmp : [DescribeMonitorGroupInstanceAttributeResponseBody.Resources.Resource.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeMonitorGroupInstanceAttributeResponseBody.Resources.Resource.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public class Vpc : Tea.TeaModel {
                public var vpcInstanceId: String?

                public var vswitchInstanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.vpcInstanceId != nil {
                        map["VpcInstanceId"] = self.vpcInstanceId!
                    }
                    if self.vswitchInstanceId != nil {
                        map["VswitchInstanceId"] = self.vswitchInstanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("VpcInstanceId") && dict["VpcInstanceId"] != nil {
                        self.vpcInstanceId = dict["VpcInstanceId"] as! String
                    }
                    if dict.keys.contains("VswitchInstanceId") && dict["VswitchInstanceId"] != nil {
                        self.vswitchInstanceId = dict["VswitchInstanceId"] as! String
                    }
                }
            }
            public var category: String?

            public var desc: String?

            public var dimension: String?

            public var instanceId: String?

            public var instanceName: String?

            public var networkType: String?

            public var region: DescribeMonitorGroupInstanceAttributeResponseBody.Resources.Resource.Region?

            public var tags: DescribeMonitorGroupInstanceAttributeResponseBody.Resources.Resource.Tags?

            public var vpc: DescribeMonitorGroupInstanceAttributeResponseBody.Resources.Resource.Vpc?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.region?.validate()
                try self.tags?.validate()
                try self.vpc?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.desc != nil {
                    map["Desc"] = self.desc!
                }
                if self.dimension != nil {
                    map["Dimension"] = self.dimension!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.region != nil {
                    map["Region"] = self.region?.toMap()
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vpc != nil {
                    map["Vpc"] = self.vpc?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") && dict["Category"] != nil {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("Desc") && dict["Desc"] != nil {
                    self.desc = dict["Desc"] as! String
                }
                if dict.keys.contains("Dimension") && dict["Dimension"] != nil {
                    self.dimension = dict["Dimension"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("NetworkType") && dict["NetworkType"] != nil {
                    self.networkType = dict["NetworkType"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    var model = DescribeMonitorGroupInstanceAttributeResponseBody.Resources.Resource.Region()
                    model.fromMap(dict["Region"] as! [String: Any])
                    self.region = model
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    var model = DescribeMonitorGroupInstanceAttributeResponseBody.Resources.Resource.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("Vpc") && dict["Vpc"] != nil {
                    var model = DescribeMonitorGroupInstanceAttributeResponseBody.Resources.Resource.Vpc()
                    model.fromMap(dict["Vpc"] as! [String: Any])
                    self.vpc = model
                }
            }
        }
        public var resource: [DescribeMonitorGroupInstanceAttributeResponseBody.Resources.Resource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resource != nil {
                var tmp : [Any] = []
                for k in self.resource! {
                    tmp.append(k.toMap())
                }
                map["Resource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Resource") && dict["Resource"] != nil {
                var tmp : [DescribeMonitorGroupInstanceAttributeResponseBody.Resources.Resource] = []
                for v in dict["Resource"] as! [Any] {
                    var model = DescribeMonitorGroupInstanceAttributeResponseBody.Resources.Resource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resource = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var resources: DescribeMonitorGroupInstanceAttributeResponseBody.Resources?

    public var success: Bool?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resources != nil {
            map["Resources"] = self.resources?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Resources") && dict["Resources"] != nil {
            var model = DescribeMonitorGroupInstanceAttributeResponseBody.Resources()
            model.fromMap(dict["Resources"] as! [String: Any])
            self.resources = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeMonitorGroupInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMonitorGroupInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMonitorGroupInstanceAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMonitorGroupInstancesRequest : Tea.TeaModel {
    public var category: String?

    public var groupId: Int64?

    public var instanceIds: String?

    public var keyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") && dict["Category"] != nil {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeMonitorGroupInstancesResponseBody : Tea.TeaModel {
    public class Resources : Tea.TeaModel {
        public class Resource : Tea.TeaModel {
            public var category: String?

            public var id: Int64?

            public var instanceId: String?

            public var instanceName: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") && dict["Category"] != nil {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var resource: [DescribeMonitorGroupInstancesResponseBody.Resources.Resource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resource != nil {
                var tmp : [Any] = []
                for k in self.resource! {
                    tmp.append(k.toMap())
                }
                map["Resource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Resource") && dict["Resource"] != nil {
                var tmp : [DescribeMonitorGroupInstancesResponseBody.Resources.Resource] = []
                for v in dict["Resource"] as! [Any] {
                    var model = DescribeMonitorGroupInstancesResponseBody.Resources.Resource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resource = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var resources: DescribeMonitorGroupInstancesResponseBody.Resources?

    public var success: Bool?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resources != nil {
            map["Resources"] = self.resources?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Resources") && dict["Resources"] != nil {
            var model = DescribeMonitorGroupInstancesResponseBody.Resources()
            model.fromMap(dict["Resources"] as! [String: Any])
            self.resources = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeMonitorGroupInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMonitorGroupInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMonitorGroupInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMonitorGroupNotifyPolicyListRequest : Tea.TeaModel {
    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var policyType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.policyType != nil {
            map["PolicyType"] = self.policyType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PolicyType") && dict["PolicyType"] != nil {
            self.policyType = dict["PolicyType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeMonitorGroupNotifyPolicyListResponseBody : Tea.TeaModel {
    public class NotifyPolicyList : Tea.TeaModel {
        public class NotifyPolicy : Tea.TeaModel {
            public var endTime: Int64?

            public var groupId: String?

            public var id: String?

            public var startTime: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var notifyPolicy: [DescribeMonitorGroupNotifyPolicyListResponseBody.NotifyPolicyList.NotifyPolicy]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.notifyPolicy != nil {
                var tmp : [Any] = []
                for k in self.notifyPolicy! {
                    tmp.append(k.toMap())
                }
                map["NotifyPolicy"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NotifyPolicy") && dict["NotifyPolicy"] != nil {
                var tmp : [DescribeMonitorGroupNotifyPolicyListResponseBody.NotifyPolicyList.NotifyPolicy] = []
                for v in dict["NotifyPolicy"] as! [Any] {
                    var model = DescribeMonitorGroupNotifyPolicyListResponseBody.NotifyPolicyList.NotifyPolicy()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notifyPolicy = tmp
            }
        }
    }
    public var code: String?

    public var message: String?

    public var notifyPolicyList: DescribeMonitorGroupNotifyPolicyListResponseBody.NotifyPolicyList?

    public var requestId: String?

    public var success: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notifyPolicyList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.notifyPolicyList != nil {
            map["NotifyPolicyList"] = self.notifyPolicyList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NotifyPolicyList") && dict["NotifyPolicyList"] != nil {
            var model = DescribeMonitorGroupNotifyPolicyListResponseBody.NotifyPolicyList()
            model.fromMap(dict["NotifyPolicyList"] as! [String: Any])
            self.notifyPolicyList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeMonitorGroupNotifyPolicyListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMonitorGroupNotifyPolicyListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMonitorGroupNotifyPolicyListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMonitorGroupsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var dynamicTagRuleId: String?

    public var groupFounderTagKey: String?

    public var groupFounderTagValue: String?

    public var groupId: String?

    public var groupName: String?

    public var includeTemplateHistory: Bool?

    public var instanceId: String?

    public var keyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var selectContactGroups: Bool?

    public var tag: [DescribeMonitorGroupsRequest.Tag]?

    public var type: String?

    public var types: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicTagRuleId != nil {
            map["DynamicTagRuleId"] = self.dynamicTagRuleId!
        }
        if self.groupFounderTagKey != nil {
            map["GroupFounderTagKey"] = self.groupFounderTagKey!
        }
        if self.groupFounderTagValue != nil {
            map["GroupFounderTagValue"] = self.groupFounderTagValue!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.includeTemplateHistory != nil {
            map["IncludeTemplateHistory"] = self.includeTemplateHistory!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.selectContactGroups != nil {
            map["SelectContactGroups"] = self.selectContactGroups!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.types != nil {
            map["Types"] = self.types!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicTagRuleId") && dict["DynamicTagRuleId"] != nil {
            self.dynamicTagRuleId = dict["DynamicTagRuleId"] as! String
        }
        if dict.keys.contains("GroupFounderTagKey") && dict["GroupFounderTagKey"] != nil {
            self.groupFounderTagKey = dict["GroupFounderTagKey"] as! String
        }
        if dict.keys.contains("GroupFounderTagValue") && dict["GroupFounderTagValue"] != nil {
            self.groupFounderTagValue = dict["GroupFounderTagValue"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("IncludeTemplateHistory") && dict["IncludeTemplateHistory"] != nil {
            self.includeTemplateHistory = dict["IncludeTemplateHistory"] as! Bool
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SelectContactGroups") && dict["SelectContactGroups"] != nil {
            self.selectContactGroups = dict["SelectContactGroups"] as! Bool
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [DescribeMonitorGroupsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeMonitorGroupsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Types") && dict["Types"] != nil {
            self.types = dict["Types"] as! String
        }
    }
}

public class DescribeMonitorGroupsResponseBody : Tea.TeaModel {
    public class Resources : Tea.TeaModel {
        public class Resource : Tea.TeaModel {
            public class ContactGroups : Tea.TeaModel {
                public class ContactGroup : Tea.TeaModel {
                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                    }
                }
                public var contactGroup: [DescribeMonitorGroupsResponseBody.Resources.Resource.ContactGroups.ContactGroup]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.contactGroup != nil {
                        var tmp : [Any] = []
                        for k in self.contactGroup! {
                            tmp.append(k.toMap())
                        }
                        map["ContactGroup"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ContactGroup") && dict["ContactGroup"] != nil {
                        var tmp : [DescribeMonitorGroupsResponseBody.Resources.Resource.ContactGroups.ContactGroup] = []
                        for v in dict["ContactGroup"] as! [Any] {
                            var model = DescribeMonitorGroupsResponseBody.Resources.Resource.ContactGroups.ContactGroup()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.contactGroup = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeMonitorGroupsResponseBody.Resources.Resource.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") && dict["Tag"] != nil {
                        var tmp : [DescribeMonitorGroupsResponseBody.Resources.Resource.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeMonitorGroupsResponseBody.Resources.Resource.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public class TemplateIds : Tea.TeaModel {
                public var templateId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                        self.templateId = dict["TemplateId"] as! [String]
                    }
                }
            }
            public var bindUrl: String?

            public var contactGroups: DescribeMonitorGroupsResponseBody.Resources.Resource.ContactGroups?

            public var dynamicTagRuleId: String?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var groupFounderTagKey: String?

            public var groupFounderTagValue: String?

            public var groupId: Int64?

            public var groupName: String?

            public var resourceGroupId: String?

            public var serviceId: String?

            public var tags: DescribeMonitorGroupsResponseBody.Resources.Resource.Tags?

            public var templateIds: DescribeMonitorGroupsResponseBody.Resources.Resource.TemplateIds?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.contactGroups?.validate()
                try self.tags?.validate()
                try self.templateIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bindUrl != nil {
                    map["BindUrl"] = self.bindUrl!
                }
                if self.contactGroups != nil {
                    map["ContactGroups"] = self.contactGroups?.toMap()
                }
                if self.dynamicTagRuleId != nil {
                    map["DynamicTagRuleId"] = self.dynamicTagRuleId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.groupFounderTagKey != nil {
                    map["GroupFounderTagKey"] = self.groupFounderTagKey!
                }
                if self.groupFounderTagValue != nil {
                    map["GroupFounderTagValue"] = self.groupFounderTagValue!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.serviceId != nil {
                    map["ServiceId"] = self.serviceId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.templateIds != nil {
                    map["TemplateIds"] = self.templateIds?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BindUrl") && dict["BindUrl"] != nil {
                    self.bindUrl = dict["BindUrl"] as! String
                }
                if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
                    var model = DescribeMonitorGroupsResponseBody.Resources.Resource.ContactGroups()
                    model.fromMap(dict["ContactGroups"] as! [String: Any])
                    self.contactGroups = model
                }
                if dict.keys.contains("DynamicTagRuleId") && dict["DynamicTagRuleId"] != nil {
                    self.dynamicTagRuleId = dict["DynamicTagRuleId"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! Int64
                }
                if dict.keys.contains("GroupFounderTagKey") && dict["GroupFounderTagKey"] != nil {
                    self.groupFounderTagKey = dict["GroupFounderTagKey"] as! String
                }
                if dict.keys.contains("GroupFounderTagValue") && dict["GroupFounderTagValue"] != nil {
                    self.groupFounderTagValue = dict["GroupFounderTagValue"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! Int64
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                    self.serviceId = dict["ServiceId"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    var model = DescribeMonitorGroupsResponseBody.Resources.Resource.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("TemplateIds") && dict["TemplateIds"] != nil {
                    var model = DescribeMonitorGroupsResponseBody.Resources.Resource.TemplateIds()
                    model.fromMap(dict["TemplateIds"] as! [String: Any])
                    self.templateIds = model
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var resource: [DescribeMonitorGroupsResponseBody.Resources.Resource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resource != nil {
                var tmp : [Any] = []
                for k in self.resource! {
                    tmp.append(k.toMap())
                }
                map["Resource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Resource") && dict["Resource"] != nil {
                var tmp : [DescribeMonitorGroupsResponseBody.Resources.Resource] = []
                for v in dict["Resource"] as! [Any] {
                    var model = DescribeMonitorGroupsResponseBody.Resources.Resource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resource = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var resources: DescribeMonitorGroupsResponseBody.Resources?

    public var success: Bool?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resources != nil {
            map["Resources"] = self.resources?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Resources") && dict["Resources"] != nil {
            var model = DescribeMonitorGroupsResponseBody.Resources()
            model.fromMap(dict["Resources"] as! [String: Any])
            self.resources = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeMonitorGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMonitorGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMonitorGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMonitorResourceQuotaAttributeRequest : Tea.TeaModel {
    public var regionId: String?

    public var showUsed: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.showUsed != nil {
            map["ShowUsed"] = self.showUsed!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ShowUsed") && dict["ShowUsed"] != nil {
            self.showUsed = dict["ShowUsed"] as! Bool
        }
    }
}

public class DescribeMonitorResourceQuotaAttributeResponseBody : Tea.TeaModel {
    public class ResourceQuota : Tea.TeaModel {
        public class Api : Tea.TeaModel {
            public var quotaLimit: Int32?

            public var quotaPackage: Int32?

            public var quotaUsed: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.quotaLimit != nil {
                    map["QuotaLimit"] = self.quotaLimit!
                }
                if self.quotaPackage != nil {
                    map["QuotaPackage"] = self.quotaPackage!
                }
                if self.quotaUsed != nil {
                    map["QuotaUsed"] = self.quotaUsed!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("QuotaLimit") && dict["QuotaLimit"] != nil {
                    self.quotaLimit = dict["QuotaLimit"] as! Int32
                }
                if dict.keys.contains("QuotaPackage") && dict["QuotaPackage"] != nil {
                    self.quotaPackage = dict["QuotaPackage"] as! Int32
                }
                if dict.keys.contains("QuotaUsed") && dict["QuotaUsed"] != nil {
                    self.quotaUsed = dict["QuotaUsed"] as! Int32
                }
            }
        }
        public class CustomMonitor : Tea.TeaModel {
            public var quotaLimit: Int32?

            public var quotaPackage: Int32?

            public var quotaUsed: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.quotaLimit != nil {
                    map["QuotaLimit"] = self.quotaLimit!
                }
                if self.quotaPackage != nil {
                    map["QuotaPackage"] = self.quotaPackage!
                }
                if self.quotaUsed != nil {
                    map["QuotaUsed"] = self.quotaUsed!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("QuotaLimit") && dict["QuotaLimit"] != nil {
                    self.quotaLimit = dict["QuotaLimit"] as! Int32
                }
                if dict.keys.contains("QuotaPackage") && dict["QuotaPackage"] != nil {
                    self.quotaPackage = dict["QuotaPackage"] as! Int32
                }
                if dict.keys.contains("QuotaUsed") && dict["QuotaUsed"] != nil {
                    self.quotaUsed = dict["QuotaUsed"] as! Int32
                }
            }
        }
        public class EnterpriseQuota : Tea.TeaModel {
            public var instanceId: String?

            public var suitInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.suitInfo != nil {
                    map["SuitInfo"] = self.suitInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("SuitInfo") && dict["SuitInfo"] != nil {
                    self.suitInfo = dict["SuitInfo"] as! String
                }
            }
        }
        public class EventMonitor : Tea.TeaModel {
            public var quotaLimit: Int32?

            public var quotaPackage: Int32?

            public var quotaUsed: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.quotaLimit != nil {
                    map["QuotaLimit"] = self.quotaLimit!
                }
                if self.quotaPackage != nil {
                    map["QuotaPackage"] = self.quotaPackage!
                }
                if self.quotaUsed != nil {
                    map["QuotaUsed"] = self.quotaUsed!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("QuotaLimit") && dict["QuotaLimit"] != nil {
                    self.quotaLimit = dict["QuotaLimit"] as! Int32
                }
                if dict.keys.contains("QuotaPackage") && dict["QuotaPackage"] != nil {
                    self.quotaPackage = dict["QuotaPackage"] as! Int32
                }
                if dict.keys.contains("QuotaUsed") && dict["QuotaUsed"] != nil {
                    self.quotaUsed = dict["QuotaUsed"] as! Int32
                }
            }
        }
        public class LogMonitor : Tea.TeaModel {
            public var quotaLimit: Int32?

            public var quotaPackage: Int32?

            public var quotaUsed: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.quotaLimit != nil {
                    map["QuotaLimit"] = self.quotaLimit!
                }
                if self.quotaPackage != nil {
                    map["QuotaPackage"] = self.quotaPackage!
                }
                if self.quotaUsed != nil {
                    map["QuotaUsed"] = self.quotaUsed!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("QuotaLimit") && dict["QuotaLimit"] != nil {
                    self.quotaLimit = dict["QuotaLimit"] as! Int32
                }
                if dict.keys.contains("QuotaPackage") && dict["QuotaPackage"] != nil {
                    self.quotaPackage = dict["QuotaPackage"] as! Int32
                }
                if dict.keys.contains("QuotaUsed") && dict["QuotaUsed"] != nil {
                    self.quotaUsed = dict["QuotaUsed"] as! Int32
                }
            }
        }
        public class Phone : Tea.TeaModel {
            public var quotaLimit: Int32?

            public var quotaPackage: Int32?

            public var quotaUsed: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.quotaLimit != nil {
                    map["QuotaLimit"] = self.quotaLimit!
                }
                if self.quotaPackage != nil {
                    map["QuotaPackage"] = self.quotaPackage!
                }
                if self.quotaUsed != nil {
                    map["QuotaUsed"] = self.quotaUsed!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("QuotaLimit") && dict["QuotaLimit"] != nil {
                    self.quotaLimit = dict["QuotaLimit"] as! Int32
                }
                if dict.keys.contains("QuotaPackage") && dict["QuotaPackage"] != nil {
                    self.quotaPackage = dict["QuotaPackage"] as! Int32
                }
                if dict.keys.contains("QuotaUsed") && dict["QuotaUsed"] != nil {
                    self.quotaUsed = dict["QuotaUsed"] as! Int32
                }
            }
        }
        public class SMS : Tea.TeaModel {
            public var quotaLimit: Int32?

            public var quotaPackage: Int32?

            public var quotaUsed: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.quotaLimit != nil {
                    map["QuotaLimit"] = self.quotaLimit!
                }
                if self.quotaPackage != nil {
                    map["QuotaPackage"] = self.quotaPackage!
                }
                if self.quotaUsed != nil {
                    map["QuotaUsed"] = self.quotaUsed!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("QuotaLimit") && dict["QuotaLimit"] != nil {
                    self.quotaLimit = dict["QuotaLimit"] as! Int32
                }
                if dict.keys.contains("QuotaPackage") && dict["QuotaPackage"] != nil {
                    self.quotaPackage = dict["QuotaPackage"] as! Int32
                }
                if dict.keys.contains("QuotaUsed") && dict["QuotaUsed"] != nil {
                    self.quotaUsed = dict["QuotaUsed"] as! Int32
                }
            }
        }
        public class SiteMonitorEcsProbe : Tea.TeaModel {
            public var quotaLimit: Int32?

            public var quotaPackage: Int32?

            public var quotaUsed: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.quotaLimit != nil {
                    map["QuotaLimit"] = self.quotaLimit!
                }
                if self.quotaPackage != nil {
                    map["QuotaPackage"] = self.quotaPackage!
                }
                if self.quotaUsed != nil {
                    map["QuotaUsed"] = self.quotaUsed!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("QuotaLimit") && dict["QuotaLimit"] != nil {
                    self.quotaLimit = dict["QuotaLimit"] as! Int32
                }
                if dict.keys.contains("QuotaPackage") && dict["QuotaPackage"] != nil {
                    self.quotaPackage = dict["QuotaPackage"] as! Int32
                }
                if dict.keys.contains("QuotaUsed") && dict["QuotaUsed"] != nil {
                    self.quotaUsed = dict["QuotaUsed"] as! Int32
                }
            }
        }
        public class SiteMonitorOperatorProbe : Tea.TeaModel {
            public var quotaLimit: Int32?

            public var quotaPackage: Int32?

            public var quotaUsed: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.quotaLimit != nil {
                    map["QuotaLimit"] = self.quotaLimit!
                }
                if self.quotaPackage != nil {
                    map["QuotaPackage"] = self.quotaPackage!
                }
                if self.quotaUsed != nil {
                    map["QuotaUsed"] = self.quotaUsed!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("QuotaLimit") && dict["QuotaLimit"] != nil {
                    self.quotaLimit = dict["QuotaLimit"] as! Int32
                }
                if dict.keys.contains("QuotaPackage") && dict["QuotaPackage"] != nil {
                    self.quotaPackage = dict["QuotaPackage"] as! Int32
                }
                if dict.keys.contains("QuotaUsed") && dict["QuotaUsed"] != nil {
                    self.quotaUsed = dict["QuotaUsed"] as! Int32
                }
            }
        }
        public class SiteMonitorTask : Tea.TeaModel {
            public var quotaLimit: Int32?

            public var quotaPackage: Int32?

            public var quotaUsed: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.quotaLimit != nil {
                    map["QuotaLimit"] = self.quotaLimit!
                }
                if self.quotaPackage != nil {
                    map["QuotaPackage"] = self.quotaPackage!
                }
                if self.quotaUsed != nil {
                    map["QuotaUsed"] = self.quotaUsed!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("QuotaLimit") && dict["QuotaLimit"] != nil {
                    self.quotaLimit = dict["QuotaLimit"] as! Int32
                }
                if dict.keys.contains("QuotaPackage") && dict["QuotaPackage"] != nil {
                    self.quotaPackage = dict["QuotaPackage"] as! Int32
                }
                if dict.keys.contains("QuotaUsed") && dict["QuotaUsed"] != nil {
                    self.quotaUsed = dict["QuotaUsed"] as! Int32
                }
            }
        }
        public var api: DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.Api?

        public var customMonitor: DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.CustomMonitor?

        public var enterpriseQuota: DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.EnterpriseQuota?

        public var eventMonitor: DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.EventMonitor?

        public var expireTime: String?

        public var instanceId: String?

        public var logMonitor: DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.LogMonitor?

        public var phone: DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.Phone?

        public var SMS: DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.SMS?

        public var siteMonitorEcsProbe: DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.SiteMonitorEcsProbe?

        public var siteMonitorOperatorProbe: DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.SiteMonitorOperatorProbe?

        public var siteMonitorTask: DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.SiteMonitorTask?

        public var suitInfo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.api?.validate()
            try self.customMonitor?.validate()
            try self.enterpriseQuota?.validate()
            try self.eventMonitor?.validate()
            try self.logMonitor?.validate()
            try self.phone?.validate()
            try self.SMS?.validate()
            try self.siteMonitorEcsProbe?.validate()
            try self.siteMonitorOperatorProbe?.validate()
            try self.siteMonitorTask?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.api != nil {
                map["Api"] = self.api?.toMap()
            }
            if self.customMonitor != nil {
                map["CustomMonitor"] = self.customMonitor?.toMap()
            }
            if self.enterpriseQuota != nil {
                map["EnterpriseQuota"] = self.enterpriseQuota?.toMap()
            }
            if self.eventMonitor != nil {
                map["EventMonitor"] = self.eventMonitor?.toMap()
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.logMonitor != nil {
                map["LogMonitor"] = self.logMonitor?.toMap()
            }
            if self.phone != nil {
                map["Phone"] = self.phone?.toMap()
            }
            if self.SMS != nil {
                map["SMS"] = self.SMS?.toMap()
            }
            if self.siteMonitorEcsProbe != nil {
                map["SiteMonitorEcsProbe"] = self.siteMonitorEcsProbe?.toMap()
            }
            if self.siteMonitorOperatorProbe != nil {
                map["SiteMonitorOperatorProbe"] = self.siteMonitorOperatorProbe?.toMap()
            }
            if self.siteMonitorTask != nil {
                map["SiteMonitorTask"] = self.siteMonitorTask?.toMap()
            }
            if self.suitInfo != nil {
                map["SuitInfo"] = self.suitInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Api") && dict["Api"] != nil {
                var model = DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.Api()
                model.fromMap(dict["Api"] as! [String: Any])
                self.api = model
            }
            if dict.keys.contains("CustomMonitor") && dict["CustomMonitor"] != nil {
                var model = DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.CustomMonitor()
                model.fromMap(dict["CustomMonitor"] as! [String: Any])
                self.customMonitor = model
            }
            if dict.keys.contains("EnterpriseQuota") && dict["EnterpriseQuota"] != nil {
                var model = DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.EnterpriseQuota()
                model.fromMap(dict["EnterpriseQuota"] as! [String: Any])
                self.enterpriseQuota = model
            }
            if dict.keys.contains("EventMonitor") && dict["EventMonitor"] != nil {
                var model = DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.EventMonitor()
                model.fromMap(dict["EventMonitor"] as! [String: Any])
                self.eventMonitor = model
            }
            if dict.keys.contains("ExpireTime") && dict["ExpireTime"] != nil {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("LogMonitor") && dict["LogMonitor"] != nil {
                var model = DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.LogMonitor()
                model.fromMap(dict["LogMonitor"] as! [String: Any])
                self.logMonitor = model
            }
            if dict.keys.contains("Phone") && dict["Phone"] != nil {
                var model = DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.Phone()
                model.fromMap(dict["Phone"] as! [String: Any])
                self.phone = model
            }
            if dict.keys.contains("SMS") && dict["SMS"] != nil {
                var model = DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.SMS()
                model.fromMap(dict["SMS"] as! [String: Any])
                self.SMS = model
            }
            if dict.keys.contains("SiteMonitorEcsProbe") && dict["SiteMonitorEcsProbe"] != nil {
                var model = DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.SiteMonitorEcsProbe()
                model.fromMap(dict["SiteMonitorEcsProbe"] as! [String: Any])
                self.siteMonitorEcsProbe = model
            }
            if dict.keys.contains("SiteMonitorOperatorProbe") && dict["SiteMonitorOperatorProbe"] != nil {
                var model = DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.SiteMonitorOperatorProbe()
                model.fromMap(dict["SiteMonitorOperatorProbe"] as! [String: Any])
                self.siteMonitorOperatorProbe = model
            }
            if dict.keys.contains("SiteMonitorTask") && dict["SiteMonitorTask"] != nil {
                var model = DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota.SiteMonitorTask()
                model.fromMap(dict["SiteMonitorTask"] as! [String: Any])
                self.siteMonitorTask = model
            }
            if dict.keys.contains("SuitInfo") && dict["SuitInfo"] != nil {
                self.suitInfo = dict["SuitInfo"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var resourceQuota: DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceQuota?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceQuota != nil {
            map["ResourceQuota"] = self.resourceQuota?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceQuota") && dict["ResourceQuota"] != nil {
            var model = DescribeMonitorResourceQuotaAttributeResponseBody.ResourceQuota()
            model.fromMap(dict["ResourceQuota"] as! [String: Any])
            self.resourceQuota = model
        }
    }
}

public class DescribeMonitorResourceQuotaAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMonitorResourceQuotaAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMonitorResourceQuotaAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMonitoringAgentAccessKeyRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeMonitoringAgentAccessKeyResponseBody : Tea.TeaModel {
    public var accessKey: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var secretKey: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessKey != nil {
            map["AccessKey"] = self.accessKey!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.secretKey != nil {
            map["SecretKey"] = self.secretKey!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessKey") && dict["AccessKey"] != nil {
            self.accessKey = dict["AccessKey"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecretKey") && dict["SecretKey"] != nil {
            self.secretKey = dict["SecretKey"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeMonitoringAgentAccessKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMonitoringAgentAccessKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMonitoringAgentAccessKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMonitoringAgentConfigRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeMonitoringAgentConfigResponseBody : Tea.TeaModel {
    public var autoInstall: Bool?

    public var code: String?

    public var enableActiveAlert: String?

    public var enableInstallAgentNewECS: Bool?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoInstall != nil {
            map["AutoInstall"] = self.autoInstall!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.enableActiveAlert != nil {
            map["EnableActiveAlert"] = self.enableActiveAlert!
        }
        if self.enableInstallAgentNewECS != nil {
            map["EnableInstallAgentNewECS"] = self.enableInstallAgentNewECS!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoInstall") && dict["AutoInstall"] != nil {
            self.autoInstall = dict["AutoInstall"] as! Bool
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("EnableActiveAlert") && dict["EnableActiveAlert"] != nil {
            self.enableActiveAlert = dict["EnableActiveAlert"] as! String
        }
        if dict.keys.contains("EnableInstallAgentNewECS") && dict["EnableInstallAgentNewECS"] != nil {
            self.enableInstallAgentNewECS = dict["EnableInstallAgentNewECS"] as! Bool
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeMonitoringAgentConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMonitoringAgentConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMonitoringAgentConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMonitoringAgentHostsRequest : Tea.TeaModel {
    public var aliyunHost: Bool?

    public var hostName: String?

    public var instanceIds: String?

    public var instanceRegionId: String?

    public var keyWord: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var serialNumbers: String?

    public var status: String?

    public var sysomStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunHost != nil {
            map["AliyunHost"] = self.aliyunHost!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.instanceRegionId != nil {
            map["InstanceRegionId"] = self.instanceRegionId!
        }
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.serialNumbers != nil {
            map["SerialNumbers"] = self.serialNumbers!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.sysomStatus != nil {
            map["SysomStatus"] = self.sysomStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunHost") && dict["AliyunHost"] != nil {
            self.aliyunHost = dict["AliyunHost"] as! Bool
        }
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("InstanceRegionId") && dict["InstanceRegionId"] != nil {
            self.instanceRegionId = dict["InstanceRegionId"] as! String
        }
        if dict.keys.contains("KeyWord") && dict["KeyWord"] != nil {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SerialNumbers") && dict["SerialNumbers"] != nil {
            self.serialNumbers = dict["SerialNumbers"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("SysomStatus") && dict["SysomStatus"] != nil {
            self.sysomStatus = dict["SysomStatus"] as! String
        }
    }
}

public class DescribeMonitoringAgentHostsResponseBody : Tea.TeaModel {
    public class Hosts : Tea.TeaModel {
        public class Host : Tea.TeaModel {
            public var agentVersion: String?

            public var aliUid: Int64?

            public var eipAddress: String?

            public var eipId: String?

            public var hostName: String?

            public var instanceId: String?

            public var instanceTypeFamily: String?

            public var ipGroup: String?

            public var natIp: String?

            public var networkType: String?

            public var operatingSystem: String?

            public var region: String?

            public var serialNumber: String?

            public var isAliyunHost: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentVersion != nil {
                    map["AgentVersion"] = self.agentVersion!
                }
                if self.aliUid != nil {
                    map["AliUid"] = self.aliUid!
                }
                if self.eipAddress != nil {
                    map["EipAddress"] = self.eipAddress!
                }
                if self.eipId != nil {
                    map["EipId"] = self.eipId!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceTypeFamily != nil {
                    map["InstanceTypeFamily"] = self.instanceTypeFamily!
                }
                if self.ipGroup != nil {
                    map["IpGroup"] = self.ipGroup!
                }
                if self.natIp != nil {
                    map["NatIp"] = self.natIp!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.operatingSystem != nil {
                    map["OperatingSystem"] = self.operatingSystem!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.serialNumber != nil {
                    map["SerialNumber"] = self.serialNumber!
                }
                if self.isAliyunHost != nil {
                    map["isAliyunHost"] = self.isAliyunHost!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentVersion") && dict["AgentVersion"] != nil {
                    self.agentVersion = dict["AgentVersion"] as! String
                }
                if dict.keys.contains("AliUid") && dict["AliUid"] != nil {
                    self.aliUid = dict["AliUid"] as! Int64
                }
                if dict.keys.contains("EipAddress") && dict["EipAddress"] != nil {
                    self.eipAddress = dict["EipAddress"] as! String
                }
                if dict.keys.contains("EipId") && dict["EipId"] != nil {
                    self.eipId = dict["EipId"] as! String
                }
                if dict.keys.contains("HostName") && dict["HostName"] != nil {
                    self.hostName = dict["HostName"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceTypeFamily") && dict["InstanceTypeFamily"] != nil {
                    self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
                }
                if dict.keys.contains("IpGroup") && dict["IpGroup"] != nil {
                    self.ipGroup = dict["IpGroup"] as! String
                }
                if dict.keys.contains("NatIp") && dict["NatIp"] != nil {
                    self.natIp = dict["NatIp"] as! String
                }
                if dict.keys.contains("NetworkType") && dict["NetworkType"] != nil {
                    self.networkType = dict["NetworkType"] as! String
                }
                if dict.keys.contains("OperatingSystem") && dict["OperatingSystem"] != nil {
                    self.operatingSystem = dict["OperatingSystem"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("SerialNumber") && dict["SerialNumber"] != nil {
                    self.serialNumber = dict["SerialNumber"] as! String
                }
                if dict.keys.contains("isAliyunHost") && dict["isAliyunHost"] != nil {
                    self.isAliyunHost = dict["isAliyunHost"] as! Bool
                }
            }
        }
        public var host: [DescribeMonitoringAgentHostsResponseBody.Hosts.Host]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                var tmp : [Any] = []
                for k in self.host! {
                    tmp.append(k.toMap())
                }
                map["Host"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Host") && dict["Host"] != nil {
                var tmp : [DescribeMonitoringAgentHostsResponseBody.Hosts.Host] = []
                for v in dict["Host"] as! [Any] {
                    var model = DescribeMonitoringAgentHostsResponseBody.Hosts.Host()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.host = tmp
            }
        }
    }
    public var code: String?

    public var hosts: DescribeMonitoringAgentHostsResponseBody.Hosts?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var pageTotal: Int32?

    public var requestId: String?

    public var success: Bool?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.hosts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.hosts != nil {
            map["Hosts"] = self.hosts?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pageTotal != nil {
            map["PageTotal"] = self.pageTotal!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Hosts") && dict["Hosts"] != nil {
            var model = DescribeMonitoringAgentHostsResponseBody.Hosts()
            model.fromMap(dict["Hosts"] as! [String: Any])
            self.hosts = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PageTotal") && dict["PageTotal"] != nil {
            self.pageTotal = dict["PageTotal"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeMonitoringAgentHostsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMonitoringAgentHostsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMonitoringAgentHostsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMonitoringAgentProcessesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeMonitoringAgentProcessesResponseBody : Tea.TeaModel {
    public class NodeProcesses : Tea.TeaModel {
        public class NodeProcess : Tea.TeaModel {
            public var command: String?

            public var groupId: String?

            public var instanceId: String?

            public var processId: Int64?

            public var processName: String?

            public var processUser: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.command != nil {
                    map["Command"] = self.command!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.processId != nil {
                    map["ProcessId"] = self.processId!
                }
                if self.processName != nil {
                    map["ProcessName"] = self.processName!
                }
                if self.processUser != nil {
                    map["ProcessUser"] = self.processUser!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Command") && dict["Command"] != nil {
                    self.command = dict["Command"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("ProcessId") && dict["ProcessId"] != nil {
                    self.processId = dict["ProcessId"] as! Int64
                }
                if dict.keys.contains("ProcessName") && dict["ProcessName"] != nil {
                    self.processName = dict["ProcessName"] as! String
                }
                if dict.keys.contains("ProcessUser") && dict["ProcessUser"] != nil {
                    self.processUser = dict["ProcessUser"] as! String
                }
            }
        }
        public var nodeProcess: [DescribeMonitoringAgentProcessesResponseBody.NodeProcesses.NodeProcess]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeProcess != nil {
                var tmp : [Any] = []
                for k in self.nodeProcess! {
                    tmp.append(k.toMap())
                }
                map["NodeProcess"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NodeProcess") && dict["NodeProcess"] != nil {
                var tmp : [DescribeMonitoringAgentProcessesResponseBody.NodeProcesses.NodeProcess] = []
                for v in dict["NodeProcess"] as! [Any] {
                    var model = DescribeMonitoringAgentProcessesResponseBody.NodeProcesses.NodeProcess()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeProcess = tmp
            }
        }
    }
    public var code: String?

    public var message: String?

    public var nodeProcesses: DescribeMonitoringAgentProcessesResponseBody.NodeProcesses?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeProcesses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.nodeProcesses != nil {
            map["NodeProcesses"] = self.nodeProcesses?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NodeProcesses") && dict["NodeProcesses"] != nil {
            var model = DescribeMonitoringAgentProcessesResponseBody.NodeProcesses()
            model.fromMap(dict["NodeProcesses"] as! [String: Any])
            self.nodeProcesses = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeMonitoringAgentProcessesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMonitoringAgentProcessesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMonitoringAgentProcessesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMonitoringAgentStatusesRequest : Tea.TeaModel {
    public var hostAvailabilityTaskId: String?

    public var instanceIds: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hostAvailabilityTaskId != nil {
            map["HostAvailabilityTaskId"] = self.hostAvailabilityTaskId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HostAvailabilityTaskId") && dict["HostAvailabilityTaskId"] != nil {
            self.hostAvailabilityTaskId = dict["HostAvailabilityTaskId"] as! String
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeMonitoringAgentStatusesResponseBody : Tea.TeaModel {
    public class NodeStatusList : Tea.TeaModel {
        public class NodeStatus : Tea.TeaModel {
            public var autoInstall: Bool?

            public var instanceId: String?

            public var osMonitorConfig: String?

            public var osMonitorErrorCode: String?

            public var osMonitorErrorDetail: String?

            public var osMonitorStatus: String?

            public var osMonitorVersion: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoInstall != nil {
                    map["AutoInstall"] = self.autoInstall!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.osMonitorConfig != nil {
                    map["OsMonitorConfig"] = self.osMonitorConfig!
                }
                if self.osMonitorErrorCode != nil {
                    map["OsMonitorErrorCode"] = self.osMonitorErrorCode!
                }
                if self.osMonitorErrorDetail != nil {
                    map["OsMonitorErrorDetail"] = self.osMonitorErrorDetail!
                }
                if self.osMonitorStatus != nil {
                    map["OsMonitorStatus"] = self.osMonitorStatus!
                }
                if self.osMonitorVersion != nil {
                    map["OsMonitorVersion"] = self.osMonitorVersion!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoInstall") && dict["AutoInstall"] != nil {
                    self.autoInstall = dict["AutoInstall"] as! Bool
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("OsMonitorConfig") && dict["OsMonitorConfig"] != nil {
                    self.osMonitorConfig = dict["OsMonitorConfig"] as! String
                }
                if dict.keys.contains("OsMonitorErrorCode") && dict["OsMonitorErrorCode"] != nil {
                    self.osMonitorErrorCode = dict["OsMonitorErrorCode"] as! String
                }
                if dict.keys.contains("OsMonitorErrorDetail") && dict["OsMonitorErrorDetail"] != nil {
                    self.osMonitorErrorDetail = dict["OsMonitorErrorDetail"] as! String
                }
                if dict.keys.contains("OsMonitorStatus") && dict["OsMonitorStatus"] != nil {
                    self.osMonitorStatus = dict["OsMonitorStatus"] as! String
                }
                if dict.keys.contains("OsMonitorVersion") && dict["OsMonitorVersion"] != nil {
                    self.osMonitorVersion = dict["OsMonitorVersion"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var nodeStatus: [DescribeMonitoringAgentStatusesResponseBody.NodeStatusList.NodeStatus]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeStatus != nil {
                var tmp : [Any] = []
                for k in self.nodeStatus! {
                    tmp.append(k.toMap())
                }
                map["NodeStatus"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NodeStatus") && dict["NodeStatus"] != nil {
                var tmp : [DescribeMonitoringAgentStatusesResponseBody.NodeStatusList.NodeStatus] = []
                for v in dict["NodeStatus"] as! [Any] {
                    var model = DescribeMonitoringAgentStatusesResponseBody.NodeStatusList.NodeStatus()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeStatus = tmp
            }
        }
    }
    public var code: String?

    public var message: String?

    public var nodeStatusList: DescribeMonitoringAgentStatusesResponseBody.NodeStatusList?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeStatusList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.nodeStatusList != nil {
            map["NodeStatusList"] = self.nodeStatusList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NodeStatusList") && dict["NodeStatusList"] != nil {
            var model = DescribeMonitoringAgentStatusesResponseBody.NodeStatusList()
            model.fromMap(dict["NodeStatusList"] as! [String: Any])
            self.nodeStatusList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeMonitoringAgentStatusesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMonitoringAgentStatusesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMonitoringAgentStatusesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMonitoringConfigRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeMonitoringConfigResponseBody : Tea.TeaModel {
    public var autoInstall: Bool?

    public var code: String?

    public var enableInstallAgentNewECS: Bool?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoInstall != nil {
            map["AutoInstall"] = self.autoInstall!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.enableInstallAgentNewECS != nil {
            map["EnableInstallAgentNewECS"] = self.enableInstallAgentNewECS!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoInstall") && dict["AutoInstall"] != nil {
            self.autoInstall = dict["AutoInstall"] as! Bool
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("EnableInstallAgentNewECS") && dict["EnableInstallAgentNewECS"] != nil {
            self.enableInstallAgentNewECS = dict["EnableInstallAgentNewECS"] as! Bool
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeMonitoringConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMonitoringConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMonitoringConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeProductResourceTagKeyListRequest : Tea.TeaModel {
    public var nextToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeProductResourceTagKeyListResponseBody : Tea.TeaModel {
    public class TagKeys : Tea.TeaModel {
        public var tagKey: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
                self.tagKey = dict["TagKey"] as! [String]
            }
        }
    }
    public var code: String?

    public var message: String?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var tagKeys: DescribeProductResourceTagKeyListResponseBody.TagKeys?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagKeys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TagKeys") && dict["TagKeys"] != nil {
            var model = DescribeProductResourceTagKeyListResponseBody.TagKeys()
            model.fromMap(dict["TagKeys"] as! [String: Any])
            self.tagKeys = model
        }
    }
}

public class DescribeProductResourceTagKeyListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeProductResourceTagKeyListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeProductResourceTagKeyListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeProductsOfActiveMetricRuleRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeProductsOfActiveMetricRuleResponseBody : Tea.TeaModel {
    public class AllProductInitMetricRuleList : Tea.TeaModel {
        public class AllProductInitMetricRule : Tea.TeaModel {
            public class AlertInitConfigList : Tea.TeaModel {
                public class AlertInitConfig : Tea.TeaModel {
                    public var evaluationCount: String?

                    public var metricName: String?

                    public var namespace: String?

                    public var period: String?

                    public var statistics: String?

                    public var threshold: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.evaluationCount != nil {
                            map["EvaluationCount"] = self.evaluationCount!
                        }
                        if self.metricName != nil {
                            map["MetricName"] = self.metricName!
                        }
                        if self.namespace != nil {
                            map["Namespace"] = self.namespace!
                        }
                        if self.period != nil {
                            map["Period"] = self.period!
                        }
                        if self.statistics != nil {
                            map["Statistics"] = self.statistics!
                        }
                        if self.threshold != nil {
                            map["Threshold"] = self.threshold!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EvaluationCount") && dict["EvaluationCount"] != nil {
                            self.evaluationCount = dict["EvaluationCount"] as! String
                        }
                        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                            self.metricName = dict["MetricName"] as! String
                        }
                        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                            self.namespace = dict["Namespace"] as! String
                        }
                        if dict.keys.contains("Period") && dict["Period"] != nil {
                            self.period = dict["Period"] as! String
                        }
                        if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                            self.statistics = dict["Statistics"] as! String
                        }
                        if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                            self.threshold = dict["Threshold"] as! String
                        }
                    }
                }
                public var alertInitConfig: [DescribeProductsOfActiveMetricRuleResponseBody.AllProductInitMetricRuleList.AllProductInitMetricRule.AlertInitConfigList.AlertInitConfig]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alertInitConfig != nil {
                        var tmp : [Any] = []
                        for k in self.alertInitConfig! {
                            tmp.append(k.toMap())
                        }
                        map["AlertInitConfig"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AlertInitConfig") && dict["AlertInitConfig"] != nil {
                        var tmp : [DescribeProductsOfActiveMetricRuleResponseBody.AllProductInitMetricRuleList.AllProductInitMetricRule.AlertInitConfigList.AlertInitConfig] = []
                        for v in dict["AlertInitConfig"] as! [Any] {
                            var model = DescribeProductsOfActiveMetricRuleResponseBody.AllProductInitMetricRuleList.AllProductInitMetricRule.AlertInitConfigList.AlertInitConfig()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.alertInitConfig = tmp
                    }
                }
            }
            public var alertInitConfigList: DescribeProductsOfActiveMetricRuleResponseBody.AllProductInitMetricRuleList.AllProductInitMetricRule.AlertInitConfigList?

            public var product: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.alertInitConfigList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertInitConfigList != nil {
                    map["AlertInitConfigList"] = self.alertInitConfigList?.toMap()
                }
                if self.product != nil {
                    map["Product"] = self.product!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertInitConfigList") && dict["AlertInitConfigList"] != nil {
                    var model = DescribeProductsOfActiveMetricRuleResponseBody.AllProductInitMetricRuleList.AllProductInitMetricRule.AlertInitConfigList()
                    model.fromMap(dict["AlertInitConfigList"] as! [String: Any])
                    self.alertInitConfigList = model
                }
                if dict.keys.contains("Product") && dict["Product"] != nil {
                    self.product = dict["Product"] as! String
                }
            }
        }
        public var allProductInitMetricRule: [DescribeProductsOfActiveMetricRuleResponseBody.AllProductInitMetricRuleList.AllProductInitMetricRule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allProductInitMetricRule != nil {
                var tmp : [Any] = []
                for k in self.allProductInitMetricRule! {
                    tmp.append(k.toMap())
                }
                map["AllProductInitMetricRule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllProductInitMetricRule") && dict["AllProductInitMetricRule"] != nil {
                var tmp : [DescribeProductsOfActiveMetricRuleResponseBody.AllProductInitMetricRuleList.AllProductInitMetricRule] = []
                for v in dict["AllProductInitMetricRule"] as! [Any] {
                    var model = DescribeProductsOfActiveMetricRuleResponseBody.AllProductInitMetricRuleList.AllProductInitMetricRule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.allProductInitMetricRule = tmp
            }
        }
    }
    public var allProductInitMetricRuleList: DescribeProductsOfActiveMetricRuleResponseBody.AllProductInitMetricRuleList?

    public var code: Int32?

    public var datapoints: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.allProductInitMetricRuleList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allProductInitMetricRuleList != nil {
            map["AllProductInitMetricRuleList"] = self.allProductInitMetricRuleList?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.datapoints != nil {
            map["Datapoints"] = self.datapoints!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllProductInitMetricRuleList") && dict["AllProductInitMetricRuleList"] != nil {
            var model = DescribeProductsOfActiveMetricRuleResponseBody.AllProductInitMetricRuleList()
            model.fromMap(dict["AllProductInitMetricRuleList"] as! [String: Any])
            self.allProductInitMetricRuleList = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Datapoints") && dict["Datapoints"] != nil {
            self.datapoints = dict["Datapoints"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeProductsOfActiveMetricRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeProductsOfActiveMetricRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeProductsOfActiveMetricRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeProjectMetaRequest : Tea.TeaModel {
    public var labels: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Labels") && dict["Labels"] != nil {
            self.labels = dict["Labels"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeProjectMetaResponseBody : Tea.TeaModel {
    public class Resources : Tea.TeaModel {
        public class Resource : Tea.TeaModel {
            public var description_: String?

            public var labels: String?

            public var namespace: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Labels") && dict["Labels"] != nil {
                    self.labels = dict["Labels"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
            }
        }
        public var resource: [DescribeProjectMetaResponseBody.Resources.Resource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resource != nil {
                var tmp : [Any] = []
                for k in self.resource! {
                    tmp.append(k.toMap())
                }
                map["Resource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Resource") && dict["Resource"] != nil {
                var tmp : [DescribeProjectMetaResponseBody.Resources.Resource] = []
                for v in dict["Resource"] as! [Any] {
                    var model = DescribeProjectMetaResponseBody.Resources.Resource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resource = tmp
            }
        }
    }
    public var code: String?

    public var message: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var resources: DescribeProjectMetaResponseBody.Resources?

    public var success: Bool?

    public var total: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resources != nil {
            map["Resources"] = self.resources?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Resources") && dict["Resources"] != nil {
            var model = DescribeProjectMetaResponseBody.Resources()
            model.fromMap(dict["Resources"] as! [String: Any])
            self.resources = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! String
        }
    }
}

public class DescribeProjectMetaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeProjectMetaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeProjectMetaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSiteMonitorAttributeRequest : Tea.TeaModel {
    public var includeAlert: Bool?

    public var regionId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.includeAlert != nil {
            map["IncludeAlert"] = self.includeAlert!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IncludeAlert") && dict["IncludeAlert"] != nil {
            self.includeAlert = dict["IncludeAlert"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribeSiteMonitorAttributeResponseBody : Tea.TeaModel {
    public class MetricRules : Tea.TeaModel {
        public class MetricRule : Tea.TeaModel {
            public var actionEnable: String?

            public var alarmActions: String?

            public var comparisonOperator: String?

            public var dimensions: String?

            public var evaluationCount: String?

            public var expression: String?

            public var level: String?

            public var metricName: String?

            public var namespace: String?

            public var okActions: String?

            public var period: String?

            public var ruleId: String?

            public var ruleName: String?

            public var stateValue: String?

            public var statistics: String?

            public var threshold: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actionEnable != nil {
                    map["ActionEnable"] = self.actionEnable!
                }
                if self.alarmActions != nil {
                    map["AlarmActions"] = self.alarmActions!
                }
                if self.comparisonOperator != nil {
                    map["ComparisonOperator"] = self.comparisonOperator!
                }
                if self.dimensions != nil {
                    map["Dimensions"] = self.dimensions!
                }
                if self.evaluationCount != nil {
                    map["EvaluationCount"] = self.evaluationCount!
                }
                if self.expression != nil {
                    map["Expression"] = self.expression!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.okActions != nil {
                    map["OkActions"] = self.okActions!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.stateValue != nil {
                    map["StateValue"] = self.stateValue!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActionEnable") && dict["ActionEnable"] != nil {
                    self.actionEnable = dict["ActionEnable"] as! String
                }
                if dict.keys.contains("AlarmActions") && dict["AlarmActions"] != nil {
                    self.alarmActions = dict["AlarmActions"] as! String
                }
                if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                    self.comparisonOperator = dict["ComparisonOperator"] as! String
                }
                if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
                    self.dimensions = dict["Dimensions"] as! String
                }
                if dict.keys.contains("EvaluationCount") && dict["EvaluationCount"] != nil {
                    self.evaluationCount = dict["EvaluationCount"] as! String
                }
                if dict.keys.contains("Expression") && dict["Expression"] != nil {
                    self.expression = dict["Expression"] as! String
                }
                if dict.keys.contains("Level") && dict["Level"] != nil {
                    self.level = dict["Level"] as! String
                }
                if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                    self.metricName = dict["MetricName"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("OkActions") && dict["OkActions"] != nil {
                    self.okActions = dict["OkActions"] as! String
                }
                if dict.keys.contains("Period") && dict["Period"] != nil {
                    self.period = dict["Period"] as! String
                }
                if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                    self.ruleId = dict["RuleId"] as! String
                }
                if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("StateValue") && dict["StateValue"] != nil {
                    self.stateValue = dict["StateValue"] as! String
                }
                if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                    self.statistics = dict["Statistics"] as! String
                }
                if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                    self.threshold = dict["Threshold"] as! String
                }
            }
        }
        public var metricRule: [DescribeSiteMonitorAttributeResponseBody.MetricRules.MetricRule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metricRule != nil {
                var tmp : [Any] = []
                for k in self.metricRule! {
                    tmp.append(k.toMap())
                }
                map["MetricRule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MetricRule") && dict["MetricRule"] != nil {
                var tmp : [DescribeSiteMonitorAttributeResponseBody.MetricRules.MetricRule] = []
                for v in dict["MetricRule"] as! [Any] {
                    var model = DescribeSiteMonitorAttributeResponseBody.MetricRules.MetricRule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.metricRule = tmp
            }
        }
    }
    public class SiteMonitors : Tea.TeaModel {
        public class CustomSchedule : Tea.TeaModel {
            public class Days : Tea.TeaModel {
                public var days: [Int32]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.days != nil {
                        map["days"] = self.days!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("days") && dict["days"] != nil {
                        self.days = dict["days"] as! [Int32]
                    }
                }
            }
            public var days: DescribeSiteMonitorAttributeResponseBody.SiteMonitors.CustomSchedule.Days?

            public var endHour: Int32?

            public var startHour: Int32?

            public var timeZone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.days?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.days != nil {
                    map["days"] = self.days?.toMap()
                }
                if self.endHour != nil {
                    map["end_hour"] = self.endHour!
                }
                if self.startHour != nil {
                    map["start_hour"] = self.startHour!
                }
                if self.timeZone != nil {
                    map["time_zone"] = self.timeZone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("days") && dict["days"] != nil {
                    var model = DescribeSiteMonitorAttributeResponseBody.SiteMonitors.CustomSchedule.Days()
                    model.fromMap(dict["days"] as! [String: Any])
                    self.days = model
                }
                if dict.keys.contains("end_hour") && dict["end_hour"] != nil {
                    self.endHour = dict["end_hour"] as! Int32
                }
                if dict.keys.contains("start_hour") && dict["start_hour"] != nil {
                    self.startHour = dict["start_hour"] as! Int32
                }
                if dict.keys.contains("time_zone") && dict["time_zone"] != nil {
                    self.timeZone = dict["time_zone"] as! String
                }
            }
        }
        public class IspCities : Tea.TeaModel {
            public class IspCity : Tea.TeaModel {
                public var city: String?

                public var cityName: String?

                public var isp: String?

                public var ispName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.city != nil {
                        map["City"] = self.city!
                    }
                    if self.cityName != nil {
                        map["CityName"] = self.cityName!
                    }
                    if self.isp != nil {
                        map["Isp"] = self.isp!
                    }
                    if self.ispName != nil {
                        map["IspName"] = self.ispName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("City") && dict["City"] != nil {
                        self.city = dict["City"] as! String
                    }
                    if dict.keys.contains("CityName") && dict["CityName"] != nil {
                        self.cityName = dict["CityName"] as! String
                    }
                    if dict.keys.contains("Isp") && dict["Isp"] != nil {
                        self.isp = dict["Isp"] as! String
                    }
                    if dict.keys.contains("IspName") && dict["IspName"] != nil {
                        self.ispName = dict["IspName"] as! String
                    }
                }
            }
            public var ispCity: [DescribeSiteMonitorAttributeResponseBody.SiteMonitors.IspCities.IspCity]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ispCity != nil {
                    var tmp : [Any] = []
                    for k in self.ispCity! {
                        tmp.append(k.toMap())
                    }
                    map["IspCity"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IspCity") && dict["IspCity"] != nil {
                    var tmp : [DescribeSiteMonitorAttributeResponseBody.SiteMonitors.IspCities.IspCity] = []
                    for v in dict["IspCity"] as! [Any] {
                        var model = DescribeSiteMonitorAttributeResponseBody.SiteMonitors.IspCities.IspCity()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ispCity = tmp
                }
            }
        }
        public class OptionJson : Tea.TeaModel {
            public class Assertions : Tea.TeaModel {
                public class Assertions : Tea.TeaModel {
                    public var operator_: String?

                    public var property: String?

                    public var target: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.operator_ != nil {
                            map["operator"] = self.operator_!
                        }
                        if self.property != nil {
                            map["property"] = self.property!
                        }
                        if self.target != nil {
                            map["target"] = self.target!
                        }
                        if self.type != nil {
                            map["type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("operator") && dict["operator"] != nil {
                            self.operator_ = dict["operator"] as! String
                        }
                        if dict.keys.contains("property") && dict["property"] != nil {
                            self.property = dict["property"] as! String
                        }
                        if dict.keys.contains("target") && dict["target"] != nil {
                            self.target = dict["target"] as! String
                        }
                        if dict.keys.contains("type") && dict["type"] != nil {
                            self.type = dict["type"] as! String
                        }
                    }
                }
                public var assertions: [DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.Assertions.Assertions]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.assertions != nil {
                        var tmp : [Any] = []
                        for k in self.assertions! {
                            tmp.append(k.toMap())
                        }
                        map["assertions"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("assertions") && dict["assertions"] != nil {
                        var tmp : [DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.Assertions.Assertions] = []
                        for v in dict["assertions"] as! [Any] {
                            var model = DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.Assertions.Assertions()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.assertions = tmp
                    }
                }
            }
            public class BlockedUrlList : Tea.TeaModel {
                public var blockedUrlList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.blockedUrlList != nil {
                        map["blocked_url_list"] = self.blockedUrlList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("blocked_url_list") && dict["blocked_url_list"] != nil {
                        self.blockedUrlList = dict["blocked_url_list"] as! [String]
                    }
                }
            }
            public class BrowserHeaders : Tea.TeaModel {
                public var browserHeaders: [[String: Any]]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.browserHeaders != nil {
                        map["browser_headers"] = self.browserHeaders!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("browser_headers") && dict["browser_headers"] != nil {
                        self.browserHeaders = dict["browser_headers"] as! [[String: Any]]
                    }
                }
            }
            public class BrowserHosts : Tea.TeaModel {
                public var browserHosts: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.browserHosts != nil {
                        map["browser_hosts"] = self.browserHosts!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("browser_hosts") && dict["browser_hosts"] != nil {
                        self.browserHosts = dict["browser_hosts"] as! [String]
                    }
                }
            }
            public class BrowserInfo : Tea.TeaModel {
                public class BrowserInfo : Tea.TeaModel {
                    public var browser: String?

                    public var device: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.browser != nil {
                            map["browser"] = self.browser!
                        }
                        if self.device != nil {
                            map["device"] = self.device!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("browser") && dict["browser"] != nil {
                            self.browser = dict["browser"] as! String
                        }
                        if dict.keys.contains("device") && dict["device"] != nil {
                            self.device = dict["device"] as! String
                        }
                    }
                }
                public var browserInfo: [DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.BrowserInfo.BrowserInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.browserInfo != nil {
                        var tmp : [Any] = []
                        for k in self.browserInfo! {
                            tmp.append(k.toMap())
                        }
                        map["browser_info"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("browser_info") && dict["browser_info"] != nil {
                        var tmp : [DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.BrowserInfo.BrowserInfo] = []
                        for v in dict["browser_info"] as! [Any] {
                            var model = DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.BrowserInfo.BrowserInfo()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.browserInfo = tmp
                    }
                }
            }
            public class ExpectExistString : Tea.TeaModel {
                public var expectExistString: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expectExistString != nil {
                        map["expect_exist_string"] = self.expectExistString!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("expect_exist_string") && dict["expect_exist_string"] != nil {
                        self.expectExistString = dict["expect_exist_string"] as! [String]
                    }
                }
            }
            public class ExpectNonExistString : Tea.TeaModel {
                public var expectNonExistString: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expectNonExistString != nil {
                        map["expect_non_exist_string"] = self.expectNonExistString!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("expect_non_exist_string") && dict["expect_non_exist_string"] != nil {
                        self.expectNonExistString = dict["expect_non_exist_string"] as! [String]
                    }
                }
            }
            public class TrafficHijackElementBlacklist : Tea.TeaModel {
                public var trafficHijackElementBlacklist: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.trafficHijackElementBlacklist != nil {
                        map["traffic_hijack_element_blacklist"] = self.trafficHijackElementBlacklist!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("traffic_hijack_element_blacklist") && dict["traffic_hijack_element_blacklist"] != nil {
                        self.trafficHijackElementBlacklist = dict["traffic_hijack_element_blacklist"] as! [String]
                    }
                }
            }
            public class TrafficHijackElementWhitelist : Tea.TeaModel {
                public var trafficHijackElementWhitelist: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.trafficHijackElementWhitelist != nil {
                        map["traffic_hijack_element_whitelist"] = self.trafficHijackElementWhitelist!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("traffic_hijack_element_whitelist") && dict["traffic_hijack_element_whitelist"] != nil {
                        self.trafficHijackElementWhitelist = dict["traffic_hijack_element_whitelist"] as! [String]
                    }
                }
            }
            public var assertions: DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.Assertions?

            public var attempts: Int64?

            public var authentication: Int32?

            public var blockedUrlList: DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.BlockedUrlList?

            public var browserHeaders: DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.BrowserHeaders?

            public var browserHosts: DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.BrowserHosts?

            public var browserInfo: DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.BrowserInfo?

            public var browserInsecure: Bool?

            public var browserTaskVersion: String?

            public var cookie: String?

            public var diagnosisMtr: Bool?

            public var diagnosisPing: Bool?

            public var dnsHijackWhitelist: String?

            public var dnsMatchRule: String?

            public var dnsServer: String?

            public var dnsType: String?

            public var expectExistString: DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.ExpectExistString?

            public var expectNonExistString: DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.ExpectNonExistString?

            public var expectValue: String?

            public var failureRate: Double?

            public var header: String?

            public var httpMethod: String?

            public var isBase64Encode: String?

            public var matchRule: Int32?

            public var minTlsVersion: String?

            public var password: String?

            public var pingNum: Int32?

            public var pingPort: Int32?

            public var pingType: String?

            public var port: Int32?

            public var protocol_: String?

            public var requestContent: String?

            public var requestFormat: String?

            public var responseContent: String?

            public var responseFormat: String?

            public var retryDelay: Int32?

            public var strictMode: Bool?

            public var timeOut: Int64?

            public var trafficHijackElementBlacklist: DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.TrafficHijackElementBlacklist?

            public var trafficHijackElementCount: Int32?

            public var trafficHijackElementWhitelist: DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.TrafficHijackElementWhitelist?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.assertions?.validate()
                try self.blockedUrlList?.validate()
                try self.browserHeaders?.validate()
                try self.browserHosts?.validate()
                try self.browserInfo?.validate()
                try self.expectExistString?.validate()
                try self.expectNonExistString?.validate()
                try self.trafficHijackElementBlacklist?.validate()
                try self.trafficHijackElementWhitelist?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assertions != nil {
                    map["assertions"] = self.assertions?.toMap()
                }
                if self.attempts != nil {
                    map["attempts"] = self.attempts!
                }
                if self.authentication != nil {
                    map["authentication"] = self.authentication!
                }
                if self.blockedUrlList != nil {
                    map["blocked_url_list"] = self.blockedUrlList?.toMap()
                }
                if self.browserHeaders != nil {
                    map["browser_headers"] = self.browserHeaders?.toMap()
                }
                if self.browserHosts != nil {
                    map["browser_hosts"] = self.browserHosts?.toMap()
                }
                if self.browserInfo != nil {
                    map["browser_info"] = self.browserInfo?.toMap()
                }
                if self.browserInsecure != nil {
                    map["browser_insecure"] = self.browserInsecure!
                }
                if self.browserTaskVersion != nil {
                    map["browser_task_version"] = self.browserTaskVersion!
                }
                if self.cookie != nil {
                    map["cookie"] = self.cookie!
                }
                if self.diagnosisMtr != nil {
                    map["diagnosis_mtr"] = self.diagnosisMtr!
                }
                if self.diagnosisPing != nil {
                    map["diagnosis_ping"] = self.diagnosisPing!
                }
                if self.dnsHijackWhitelist != nil {
                    map["dns_hijack_whitelist"] = self.dnsHijackWhitelist!
                }
                if self.dnsMatchRule != nil {
                    map["dns_match_rule"] = self.dnsMatchRule!
                }
                if self.dnsServer != nil {
                    map["dns_server"] = self.dnsServer!
                }
                if self.dnsType != nil {
                    map["dns_type"] = self.dnsType!
                }
                if self.expectExistString != nil {
                    map["expect_exist_string"] = self.expectExistString?.toMap()
                }
                if self.expectNonExistString != nil {
                    map["expect_non_exist_string"] = self.expectNonExistString?.toMap()
                }
                if self.expectValue != nil {
                    map["expect_value"] = self.expectValue!
                }
                if self.failureRate != nil {
                    map["failure_rate"] = self.failureRate!
                }
                if self.header != nil {
                    map["header"] = self.header!
                }
                if self.httpMethod != nil {
                    map["http_method"] = self.httpMethod!
                }
                if self.isBase64Encode != nil {
                    map["isBase64Encode"] = self.isBase64Encode!
                }
                if self.matchRule != nil {
                    map["match_rule"] = self.matchRule!
                }
                if self.minTlsVersion != nil {
                    map["min_tls_version"] = self.minTlsVersion!
                }
                if self.password != nil {
                    map["password"] = self.password!
                }
                if self.pingNum != nil {
                    map["ping_num"] = self.pingNum!
                }
                if self.pingPort != nil {
                    map["ping_port"] = self.pingPort!
                }
                if self.pingType != nil {
                    map["ping_type"] = self.pingType!
                }
                if self.port != nil {
                    map["port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["protocol"] = self.protocol_!
                }
                if self.requestContent != nil {
                    map["request_content"] = self.requestContent!
                }
                if self.requestFormat != nil {
                    map["request_format"] = self.requestFormat!
                }
                if self.responseContent != nil {
                    map["response_content"] = self.responseContent!
                }
                if self.responseFormat != nil {
                    map["response_format"] = self.responseFormat!
                }
                if self.retryDelay != nil {
                    map["retry_delay"] = self.retryDelay!
                }
                if self.strictMode != nil {
                    map["strict_mode"] = self.strictMode!
                }
                if self.timeOut != nil {
                    map["time_out"] = self.timeOut!
                }
                if self.trafficHijackElementBlacklist != nil {
                    map["traffic_hijack_element_blacklist"] = self.trafficHijackElementBlacklist?.toMap()
                }
                if self.trafficHijackElementCount != nil {
                    map["traffic_hijack_element_count"] = self.trafficHijackElementCount!
                }
                if self.trafficHijackElementWhitelist != nil {
                    map["traffic_hijack_element_whitelist"] = self.trafficHijackElementWhitelist?.toMap()
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("assertions") && dict["assertions"] != nil {
                    var model = DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.Assertions()
                    model.fromMap(dict["assertions"] as! [String: Any])
                    self.assertions = model
                }
                if dict.keys.contains("attempts") && dict["attempts"] != nil {
                    self.attempts = dict["attempts"] as! Int64
                }
                if dict.keys.contains("authentication") && dict["authentication"] != nil {
                    self.authentication = dict["authentication"] as! Int32
                }
                if dict.keys.contains("blocked_url_list") && dict["blocked_url_list"] != nil {
                    var model = DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.BlockedUrlList()
                    model.fromMap(dict["blocked_url_list"] as! [String: Any])
                    self.blockedUrlList = model
                }
                if dict.keys.contains("browser_headers") && dict["browser_headers"] != nil {
                    var model = DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.BrowserHeaders()
                    model.fromMap(dict["browser_headers"] as! [String: Any])
                    self.browserHeaders = model
                }
                if dict.keys.contains("browser_hosts") && dict["browser_hosts"] != nil {
                    var model = DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.BrowserHosts()
                    model.fromMap(dict["browser_hosts"] as! [String: Any])
                    self.browserHosts = model
                }
                if dict.keys.contains("browser_info") && dict["browser_info"] != nil {
                    var model = DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.BrowserInfo()
                    model.fromMap(dict["browser_info"] as! [String: Any])
                    self.browserInfo = model
                }
                if dict.keys.contains("browser_insecure") && dict["browser_insecure"] != nil {
                    self.browserInsecure = dict["browser_insecure"] as! Bool
                }
                if dict.keys.contains("browser_task_version") && dict["browser_task_version"] != nil {
                    self.browserTaskVersion = dict["browser_task_version"] as! String
                }
                if dict.keys.contains("cookie") && dict["cookie"] != nil {
                    self.cookie = dict["cookie"] as! String
                }
                if dict.keys.contains("diagnosis_mtr") && dict["diagnosis_mtr"] != nil {
                    self.diagnosisMtr = dict["diagnosis_mtr"] as! Bool
                }
                if dict.keys.contains("diagnosis_ping") && dict["diagnosis_ping"] != nil {
                    self.diagnosisPing = dict["diagnosis_ping"] as! Bool
                }
                if dict.keys.contains("dns_hijack_whitelist") && dict["dns_hijack_whitelist"] != nil {
                    self.dnsHijackWhitelist = dict["dns_hijack_whitelist"] as! String
                }
                if dict.keys.contains("dns_match_rule") && dict["dns_match_rule"] != nil {
                    self.dnsMatchRule = dict["dns_match_rule"] as! String
                }
                if dict.keys.contains("dns_server") && dict["dns_server"] != nil {
                    self.dnsServer = dict["dns_server"] as! String
                }
                if dict.keys.contains("dns_type") && dict["dns_type"] != nil {
                    self.dnsType = dict["dns_type"] as! String
                }
                if dict.keys.contains("expect_exist_string") && dict["expect_exist_string"] != nil {
                    var model = DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.ExpectExistString()
                    model.fromMap(dict["expect_exist_string"] as! [String: Any])
                    self.expectExistString = model
                }
                if dict.keys.contains("expect_non_exist_string") && dict["expect_non_exist_string"] != nil {
                    var model = DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.ExpectNonExistString()
                    model.fromMap(dict["expect_non_exist_string"] as! [String: Any])
                    self.expectNonExistString = model
                }
                if dict.keys.contains("expect_value") && dict["expect_value"] != nil {
                    self.expectValue = dict["expect_value"] as! String
                }
                if dict.keys.contains("failure_rate") && dict["failure_rate"] != nil {
                    self.failureRate = dict["failure_rate"] as! Double
                }
                if dict.keys.contains("header") && dict["header"] != nil {
                    self.header = dict["header"] as! String
                }
                if dict.keys.contains("http_method") && dict["http_method"] != nil {
                    self.httpMethod = dict["http_method"] as! String
                }
                if dict.keys.contains("isBase64Encode") && dict["isBase64Encode"] != nil {
                    self.isBase64Encode = dict["isBase64Encode"] as! String
                }
                if dict.keys.contains("match_rule") && dict["match_rule"] != nil {
                    self.matchRule = dict["match_rule"] as! Int32
                }
                if dict.keys.contains("min_tls_version") && dict["min_tls_version"] != nil {
                    self.minTlsVersion = dict["min_tls_version"] as! String
                }
                if dict.keys.contains("password") && dict["password"] != nil {
                    self.password = dict["password"] as! String
                }
                if dict.keys.contains("ping_num") && dict["ping_num"] != nil {
                    self.pingNum = dict["ping_num"] as! Int32
                }
                if dict.keys.contains("ping_port") && dict["ping_port"] != nil {
                    self.pingPort = dict["ping_port"] as! Int32
                }
                if dict.keys.contains("ping_type") && dict["ping_type"] != nil {
                    self.pingType = dict["ping_type"] as! String
                }
                if dict.keys.contains("port") && dict["port"] != nil {
                    self.port = dict["port"] as! Int32
                }
                if dict.keys.contains("protocol") && dict["protocol"] != nil {
                    self.protocol_ = dict["protocol"] as! String
                }
                if dict.keys.contains("request_content") && dict["request_content"] != nil {
                    self.requestContent = dict["request_content"] as! String
                }
                if dict.keys.contains("request_format") && dict["request_format"] != nil {
                    self.requestFormat = dict["request_format"] as! String
                }
                if dict.keys.contains("response_content") && dict["response_content"] != nil {
                    self.responseContent = dict["response_content"] as! String
                }
                if dict.keys.contains("response_format") && dict["response_format"] != nil {
                    self.responseFormat = dict["response_format"] as! String
                }
                if dict.keys.contains("retry_delay") && dict["retry_delay"] != nil {
                    self.retryDelay = dict["retry_delay"] as! Int32
                }
                if dict.keys.contains("strict_mode") && dict["strict_mode"] != nil {
                    self.strictMode = dict["strict_mode"] as! Bool
                }
                if dict.keys.contains("time_out") && dict["time_out"] != nil {
                    self.timeOut = dict["time_out"] as! Int64
                }
                if dict.keys.contains("traffic_hijack_element_blacklist") && dict["traffic_hijack_element_blacklist"] != nil {
                    var model = DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.TrafficHijackElementBlacklist()
                    model.fromMap(dict["traffic_hijack_element_blacklist"] as! [String: Any])
                    self.trafficHijackElementBlacklist = model
                }
                if dict.keys.contains("traffic_hijack_element_count") && dict["traffic_hijack_element_count"] != nil {
                    self.trafficHijackElementCount = dict["traffic_hijack_element_count"] as! Int32
                }
                if dict.keys.contains("traffic_hijack_element_whitelist") && dict["traffic_hijack_element_whitelist"] != nil {
                    var model = DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson.TrafficHijackElementWhitelist()
                    model.fromMap(dict["traffic_hijack_element_whitelist"] as! [String: Any])
                    self.trafficHijackElementWhitelist = model
                }
                if dict.keys.contains("username") && dict["username"] != nil {
                    self.username = dict["username"] as! String
                }
            }
        }
        public var address: String?

        public var agentGroup: String?

        public var customSchedule: DescribeSiteMonitorAttributeResponseBody.SiteMonitors.CustomSchedule?

        public var interval: String?

        public var ispCities: DescribeSiteMonitorAttributeResponseBody.SiteMonitors.IspCities?

        public var optionJson: DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson?

        public var taskId: String?

        public var taskName: String?

        public var taskState: String?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.customSchedule?.validate()
            try self.ispCities?.validate()
            try self.optionJson?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.agentGroup != nil {
                map["AgentGroup"] = self.agentGroup!
            }
            if self.customSchedule != nil {
                map["CustomSchedule"] = self.customSchedule?.toMap()
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.ispCities != nil {
                map["IspCities"] = self.ispCities?.toMap()
            }
            if self.optionJson != nil {
                map["OptionJson"] = self.optionJson?.toMap()
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            if self.taskState != nil {
                map["TaskState"] = self.taskState!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") && dict["Address"] != nil {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("AgentGroup") && dict["AgentGroup"] != nil {
                self.agentGroup = dict["AgentGroup"] as! String
            }
            if dict.keys.contains("CustomSchedule") && dict["CustomSchedule"] != nil {
                var model = DescribeSiteMonitorAttributeResponseBody.SiteMonitors.CustomSchedule()
                model.fromMap(dict["CustomSchedule"] as! [String: Any])
                self.customSchedule = model
            }
            if dict.keys.contains("Interval") && dict["Interval"] != nil {
                self.interval = dict["Interval"] as! String
            }
            if dict.keys.contains("IspCities") && dict["IspCities"] != nil {
                var model = DescribeSiteMonitorAttributeResponseBody.SiteMonitors.IspCities()
                model.fromMap(dict["IspCities"] as! [String: Any])
                self.ispCities = model
            }
            if dict.keys.contains("OptionJson") && dict["OptionJson"] != nil {
                var model = DescribeSiteMonitorAttributeResponseBody.SiteMonitors.OptionJson()
                model.fromMap(dict["OptionJson"] as! [String: Any])
                self.optionJson = model
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                self.taskName = dict["TaskName"] as! String
            }
            if dict.keys.contains("TaskState") && dict["TaskState"] != nil {
                self.taskState = dict["TaskState"] as! String
            }
            if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                self.taskType = dict["TaskType"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var metricRules: DescribeSiteMonitorAttributeResponseBody.MetricRules?

    public var requestId: String?

    public var siteMonitors: DescribeSiteMonitorAttributeResponseBody.SiteMonitors?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.metricRules?.validate()
        try self.siteMonitors?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.metricRules != nil {
            map["MetricRules"] = self.metricRules?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.siteMonitors != nil {
            map["SiteMonitors"] = self.siteMonitors?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("MetricRules") && dict["MetricRules"] != nil {
            var model = DescribeSiteMonitorAttributeResponseBody.MetricRules()
            model.fromMap(dict["MetricRules"] as! [String: Any])
            self.metricRules = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SiteMonitors") && dict["SiteMonitors"] != nil {
            var model = DescribeSiteMonitorAttributeResponseBody.SiteMonitors()
            model.fromMap(dict["SiteMonitors"] as! [String: Any])
            self.siteMonitors = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeSiteMonitorAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSiteMonitorAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSiteMonitorAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSiteMonitorDataRequest : Tea.TeaModel {
    public var endTime: String?

    public var length: Int32?

    public var metricName: String?

    public var nextToken: String?

    public var period: String?

    public var regionId: String?

    public var startTime: String?

    public var taskId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.length != nil {
            map["Length"] = self.length!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Length") && dict["Length"] != nil {
            self.length = dict["Length"] as! Int32
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeSiteMonitorDataResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var nextToken: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeSiteMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSiteMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSiteMonitorDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSiteMonitorISPCityListRequest : Tea.TeaModel {
    public var city: String?

    public var IPV4: Bool?

    public var IPV6: Bool?

    public var isp: String?

    public var regionId: String?

    public var viewAll: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.city != nil {
            map["City"] = self.city!
        }
        if self.IPV4 != nil {
            map["IPV4"] = self.IPV4!
        }
        if self.IPV6 != nil {
            map["IPV6"] = self.IPV6!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.viewAll != nil {
            map["ViewAll"] = self.viewAll!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("City") && dict["City"] != nil {
            self.city = dict["City"] as! String
        }
        if dict.keys.contains("IPV4") && dict["IPV4"] != nil {
            self.IPV4 = dict["IPV4"] as! Bool
        }
        if dict.keys.contains("IPV6") && dict["IPV6"] != nil {
            self.IPV6 = dict["IPV6"] as! Bool
        }
        if dict.keys.contains("Isp") && dict["Isp"] != nil {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ViewAll") && dict["ViewAll"] != nil {
            self.viewAll = dict["ViewAll"] as! Bool
        }
    }
}

public class DescribeSiteMonitorISPCityListResponseBody : Tea.TeaModel {
    public class IspCityList : Tea.TeaModel {
        public class IspCity : Tea.TeaModel {
            public class IPPool : Tea.TeaModel {
                public var IPPool: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.IPPool != nil {
                        map["IPPool"] = self.IPPool!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IPPool") && dict["IPPool"] != nil {
                        self.IPPool = dict["IPPool"] as! [String]
                    }
                }
            }
            public var area_en: String?

            public var area_zh_cN: String?

            public var city: String?

            public var cityName_en: String?

            public var cityName_zh_cN: String?

            public var country: String?

            public var country_en: String?

            public var country_zh_cN: String?

            public var IPPool: DescribeSiteMonitorISPCityListResponseBody.IspCityList.IspCity.IPPool?

            public var IPV4ProbeCount: String?

            public var IPV6ProbeCount: String?

            public var isp: String?

            public var ispName_en: String?

            public var ispName_zh_cN: String?

            public var region: String?

            public var region_en: String?

            public var region_zh_cN: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.IPPool?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.area_en != nil {
                    map["Area.en"] = self.area_en!
                }
                if self.area_zh_cN != nil {
                    map["Area.zh_CN"] = self.area_zh_cN!
                }
                if self.city != nil {
                    map["City"] = self.city!
                }
                if self.cityName_en != nil {
                    map["CityName.en"] = self.cityName_en!
                }
                if self.cityName_zh_cN != nil {
                    map["CityName.zh_CN"] = self.cityName_zh_cN!
                }
                if self.country != nil {
                    map["Country"] = self.country!
                }
                if self.country_en != nil {
                    map["Country.en"] = self.country_en!
                }
                if self.country_zh_cN != nil {
                    map["Country.zh_CN"] = self.country_zh_cN!
                }
                if self.IPPool != nil {
                    map["IPPool"] = self.IPPool?.toMap()
                }
                if self.IPV4ProbeCount != nil {
                    map["IPV4ProbeCount"] = self.IPV4ProbeCount!
                }
                if self.IPV6ProbeCount != nil {
                    map["IPV6ProbeCount"] = self.IPV6ProbeCount!
                }
                if self.isp != nil {
                    map["Isp"] = self.isp!
                }
                if self.ispName_en != nil {
                    map["IspName.en"] = self.ispName_en!
                }
                if self.ispName_zh_cN != nil {
                    map["IspName.zh_CN"] = self.ispName_zh_cN!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.region_en != nil {
                    map["Region.en"] = self.region_en!
                }
                if self.region_zh_cN != nil {
                    map["Region.zh_CN"] = self.region_zh_cN!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Area.en") && dict["Area.en"] != nil {
                    self.area_en = dict["Area.en"] as! String
                }
                if dict.keys.contains("Area.zh_CN") && dict["Area.zh_CN"] != nil {
                    self.area_zh_cN = dict["Area.zh_CN"] as! String
                }
                if dict.keys.contains("City") && dict["City"] != nil {
                    self.city = dict["City"] as! String
                }
                if dict.keys.contains("CityName.en") && dict["CityName.en"] != nil {
                    self.cityName_en = dict["CityName.en"] as! String
                }
                if dict.keys.contains("CityName.zh_CN") && dict["CityName.zh_CN"] != nil {
                    self.cityName_zh_cN = dict["CityName.zh_CN"] as! String
                }
                if dict.keys.contains("Country") && dict["Country"] != nil {
                    self.country = dict["Country"] as! String
                }
                if dict.keys.contains("Country.en") && dict["Country.en"] != nil {
                    self.country_en = dict["Country.en"] as! String
                }
                if dict.keys.contains("Country.zh_CN") && dict["Country.zh_CN"] != nil {
                    self.country_zh_cN = dict["Country.zh_CN"] as! String
                }
                if dict.keys.contains("IPPool") && dict["IPPool"] != nil {
                    var model = DescribeSiteMonitorISPCityListResponseBody.IspCityList.IspCity.IPPool()
                    model.fromMap(dict["IPPool"] as! [String: Any])
                    self.IPPool = model
                }
                if dict.keys.contains("IPV4ProbeCount") && dict["IPV4ProbeCount"] != nil {
                    self.IPV4ProbeCount = dict["IPV4ProbeCount"] as! String
                }
                if dict.keys.contains("IPV6ProbeCount") && dict["IPV6ProbeCount"] != nil {
                    self.IPV6ProbeCount = dict["IPV6ProbeCount"] as! String
                }
                if dict.keys.contains("Isp") && dict["Isp"] != nil {
                    self.isp = dict["Isp"] as! String
                }
                if dict.keys.contains("IspName.en") && dict["IspName.en"] != nil {
                    self.ispName_en = dict["IspName.en"] as! String
                }
                if dict.keys.contains("IspName.zh_CN") && dict["IspName.zh_CN"] != nil {
                    self.ispName_zh_cN = dict["IspName.zh_CN"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Region.en") && dict["Region.en"] != nil {
                    self.region_en = dict["Region.en"] as! String
                }
                if dict.keys.contains("Region.zh_CN") && dict["Region.zh_CN"] != nil {
                    self.region_zh_cN = dict["Region.zh_CN"] as! String
                }
            }
        }
        public var ispCity: [DescribeSiteMonitorISPCityListResponseBody.IspCityList.IspCity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ispCity != nil {
                var tmp : [Any] = []
                for k in self.ispCity! {
                    tmp.append(k.toMap())
                }
                map["IspCity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IspCity") && dict["IspCity"] != nil {
                var tmp : [DescribeSiteMonitorISPCityListResponseBody.IspCityList.IspCity] = []
                for v in dict["IspCity"] as! [Any] {
                    var model = DescribeSiteMonitorISPCityListResponseBody.IspCityList.IspCity()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ispCity = tmp
            }
        }
    }
    public var code: String?

    public var ispCityList: DescribeSiteMonitorISPCityListResponseBody.IspCityList?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ispCityList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ispCityList != nil {
            map["IspCityList"] = self.ispCityList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("IspCityList") && dict["IspCityList"] != nil {
            var model = DescribeSiteMonitorISPCityListResponseBody.IspCityList()
            model.fromMap(dict["IspCityList"] as! [String: Any])
            self.ispCityList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeSiteMonitorISPCityListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSiteMonitorISPCityListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSiteMonitorISPCityListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSiteMonitorListRequest : Tea.TeaModel {
    public var keyword: String?

    public var page: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var taskId: String?

    public var taskState: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskState != nil {
            map["TaskState"] = self.taskState!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Page") && dict["Page"] != nil {
            self.page = dict["Page"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskState") && dict["TaskState"] != nil {
            self.taskState = dict["TaskState"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class DescribeSiteMonitorListResponseBody : Tea.TeaModel {
    public class SiteMonitors : Tea.TeaModel {
        public class SiteMonitor : Tea.TeaModel {
            public class OptionsJson : Tea.TeaModel {
                public class Assertions : Tea.TeaModel {
                    public class Assertions : Tea.TeaModel {
                        public var operator_: String?

                        public var property: String?

                        public var target: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.operator_ != nil {
                                map["operator"] = self.operator_!
                            }
                            if self.property != nil {
                                map["property"] = self.property!
                            }
                            if self.target != nil {
                                map["target"] = self.target!
                            }
                            if self.type != nil {
                                map["type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("operator") && dict["operator"] != nil {
                                self.operator_ = dict["operator"] as! String
                            }
                            if dict.keys.contains("property") && dict["property"] != nil {
                                self.property = dict["property"] as! String
                            }
                            if dict.keys.contains("target") && dict["target"] != nil {
                                self.target = dict["target"] as! String
                            }
                            if dict.keys.contains("type") && dict["type"] != nil {
                                self.type = dict["type"] as! String
                            }
                        }
                    }
                    public var assertions: [DescribeSiteMonitorListResponseBody.SiteMonitors.SiteMonitor.OptionsJson.Assertions.Assertions]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.assertions != nil {
                            var tmp : [Any] = []
                            for k in self.assertions! {
                                tmp.append(k.toMap())
                            }
                            map["assertions"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("assertions") && dict["assertions"] != nil {
                            var tmp : [DescribeSiteMonitorListResponseBody.SiteMonitors.SiteMonitor.OptionsJson.Assertions.Assertions] = []
                            for v in dict["assertions"] as! [Any] {
                                var model = DescribeSiteMonitorListResponseBody.SiteMonitors.SiteMonitor.OptionsJson.Assertions.Assertions()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.assertions = tmp
                        }
                    }
                }
                public var acceptableResponseCode: String?

                public var assertions: DescribeSiteMonitorListResponseBody.SiteMonitors.SiteMonitor.OptionsJson.Assertions?

                public var attempts: Int64?

                public var authentication: Int32?

                public var certVerify: Bool?

                public var cookie: String?

                public var diagnosisMtr: Bool?

                public var diagnosisPing: Bool?

                public var dnsMatchRule: String?

                public var dnsServer: String?

                public var dnsType: String?

                public var enableOperatorDns: Bool?

                public var failureRate: Double?

                public var header: String?

                public var httpMethod: String?

                public var isBase64Encode: String?

                public var matchRule: Int32?

                public var password: String?

                public var pingNum: Int32?

                public var port: Int32?

                public var protocol_: String?

                public var proxyProtocol: Bool?

                public var requestContent: String?

                public var requestFormat: String?

                public var responseContent: String?

                public var responseFormat: String?

                public var retryDelay: Int32?

                public var timeOut: Int64?

                public var unfollowRedirect: Bool?

                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.assertions?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.acceptableResponseCode != nil {
                        map["acceptable_response_code"] = self.acceptableResponseCode!
                    }
                    if self.assertions != nil {
                        map["assertions"] = self.assertions?.toMap()
                    }
                    if self.attempts != nil {
                        map["attempts"] = self.attempts!
                    }
                    if self.authentication != nil {
                        map["authentication"] = self.authentication!
                    }
                    if self.certVerify != nil {
                        map["cert_verify"] = self.certVerify!
                    }
                    if self.cookie != nil {
                        map["cookie"] = self.cookie!
                    }
                    if self.diagnosisMtr != nil {
                        map["diagnosis_mtr"] = self.diagnosisMtr!
                    }
                    if self.diagnosisPing != nil {
                        map["diagnosis_ping"] = self.diagnosisPing!
                    }
                    if self.dnsMatchRule != nil {
                        map["dns_match_rule"] = self.dnsMatchRule!
                    }
                    if self.dnsServer != nil {
                        map["dns_server"] = self.dnsServer!
                    }
                    if self.dnsType != nil {
                        map["dns_type"] = self.dnsType!
                    }
                    if self.enableOperatorDns != nil {
                        map["enable_operator_dns"] = self.enableOperatorDns!
                    }
                    if self.failureRate != nil {
                        map["failure_rate"] = self.failureRate!
                    }
                    if self.header != nil {
                        map["header"] = self.header!
                    }
                    if self.httpMethod != nil {
                        map["http_method"] = self.httpMethod!
                    }
                    if self.isBase64Encode != nil {
                        map["isBase64Encode"] = self.isBase64Encode!
                    }
                    if self.matchRule != nil {
                        map["match_rule"] = self.matchRule!
                    }
                    if self.password != nil {
                        map["password"] = self.password!
                    }
                    if self.pingNum != nil {
                        map["ping_num"] = self.pingNum!
                    }
                    if self.port != nil {
                        map["port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["protocol"] = self.protocol_!
                    }
                    if self.proxyProtocol != nil {
                        map["proxy_protocol"] = self.proxyProtocol!
                    }
                    if self.requestContent != nil {
                        map["request_content"] = self.requestContent!
                    }
                    if self.requestFormat != nil {
                        map["request_format"] = self.requestFormat!
                    }
                    if self.responseContent != nil {
                        map["response_content"] = self.responseContent!
                    }
                    if self.responseFormat != nil {
                        map["response_format"] = self.responseFormat!
                    }
                    if self.retryDelay != nil {
                        map["retry_delay"] = self.retryDelay!
                    }
                    if self.timeOut != nil {
                        map["time_out"] = self.timeOut!
                    }
                    if self.unfollowRedirect != nil {
                        map["unfollow_redirect"] = self.unfollowRedirect!
                    }
                    if self.username != nil {
                        map["username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("acceptable_response_code") && dict["acceptable_response_code"] != nil {
                        self.acceptableResponseCode = dict["acceptable_response_code"] as! String
                    }
                    if dict.keys.contains("assertions") && dict["assertions"] != nil {
                        var model = DescribeSiteMonitorListResponseBody.SiteMonitors.SiteMonitor.OptionsJson.Assertions()
                        model.fromMap(dict["assertions"] as! [String: Any])
                        self.assertions = model
                    }
                    if dict.keys.contains("attempts") && dict["attempts"] != nil {
                        self.attempts = dict["attempts"] as! Int64
                    }
                    if dict.keys.contains("authentication") && dict["authentication"] != nil {
                        self.authentication = dict["authentication"] as! Int32
                    }
                    if dict.keys.contains("cert_verify") && dict["cert_verify"] != nil {
                        self.certVerify = dict["cert_verify"] as! Bool
                    }
                    if dict.keys.contains("cookie") && dict["cookie"] != nil {
                        self.cookie = dict["cookie"] as! String
                    }
                    if dict.keys.contains("diagnosis_mtr") && dict["diagnosis_mtr"] != nil {
                        self.diagnosisMtr = dict["diagnosis_mtr"] as! Bool
                    }
                    if dict.keys.contains("diagnosis_ping") && dict["diagnosis_ping"] != nil {
                        self.diagnosisPing = dict["diagnosis_ping"] as! Bool
                    }
                    if dict.keys.contains("dns_match_rule") && dict["dns_match_rule"] != nil {
                        self.dnsMatchRule = dict["dns_match_rule"] as! String
                    }
                    if dict.keys.contains("dns_server") && dict["dns_server"] != nil {
                        self.dnsServer = dict["dns_server"] as! String
                    }
                    if dict.keys.contains("dns_type") && dict["dns_type"] != nil {
                        self.dnsType = dict["dns_type"] as! String
                    }
                    if dict.keys.contains("enable_operator_dns") && dict["enable_operator_dns"] != nil {
                        self.enableOperatorDns = dict["enable_operator_dns"] as! Bool
                    }
                    if dict.keys.contains("failure_rate") && dict["failure_rate"] != nil {
                        self.failureRate = dict["failure_rate"] as! Double
                    }
                    if dict.keys.contains("header") && dict["header"] != nil {
                        self.header = dict["header"] as! String
                    }
                    if dict.keys.contains("http_method") && dict["http_method"] != nil {
                        self.httpMethod = dict["http_method"] as! String
                    }
                    if dict.keys.contains("isBase64Encode") && dict["isBase64Encode"] != nil {
                        self.isBase64Encode = dict["isBase64Encode"] as! String
                    }
                    if dict.keys.contains("match_rule") && dict["match_rule"] != nil {
                        self.matchRule = dict["match_rule"] as! Int32
                    }
                    if dict.keys.contains("password") && dict["password"] != nil {
                        self.password = dict["password"] as! String
                    }
                    if dict.keys.contains("ping_num") && dict["ping_num"] != nil {
                        self.pingNum = dict["ping_num"] as! Int32
                    }
                    if dict.keys.contains("port") && dict["port"] != nil {
                        self.port = dict["port"] as! Int32
                    }
                    if dict.keys.contains("protocol") && dict["protocol"] != nil {
                        self.protocol_ = dict["protocol"] as! String
                    }
                    if dict.keys.contains("proxy_protocol") && dict["proxy_protocol"] != nil {
                        self.proxyProtocol = dict["proxy_protocol"] as! Bool
                    }
                    if dict.keys.contains("request_content") && dict["request_content"] != nil {
                        self.requestContent = dict["request_content"] as! String
                    }
                    if dict.keys.contains("request_format") && dict["request_format"] != nil {
                        self.requestFormat = dict["request_format"] as! String
                    }
                    if dict.keys.contains("response_content") && dict["response_content"] != nil {
                        self.responseContent = dict["response_content"] as! String
                    }
                    if dict.keys.contains("response_format") && dict["response_format"] != nil {
                        self.responseFormat = dict["response_format"] as! String
                    }
                    if dict.keys.contains("retry_delay") && dict["retry_delay"] != nil {
                        self.retryDelay = dict["retry_delay"] as! Int32
                    }
                    if dict.keys.contains("time_out") && dict["time_out"] != nil {
                        self.timeOut = dict["time_out"] as! Int64
                    }
                    if dict.keys.contains("unfollow_redirect") && dict["unfollow_redirect"] != nil {
                        self.unfollowRedirect = dict["unfollow_redirect"] as! Bool
                    }
                    if dict.keys.contains("username") && dict["username"] != nil {
                        self.username = dict["username"] as! String
                    }
                }
            }
            public var address: String?

            public var agentGroup: String?

            public var createTime: String?

            public var interval: String?

            public var optionsJson: DescribeSiteMonitorListResponseBody.SiteMonitors.SiteMonitor.OptionsJson?

            public var taskId: String?

            public var taskName: String?

            public var taskState: String?

            public var taskType: String?

            public var updateTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.optionsJson?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.agentGroup != nil {
                    map["AgentGroup"] = self.agentGroup!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.optionsJson != nil {
                    map["OptionsJson"] = self.optionsJson?.toMap()
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskName != nil {
                    map["TaskName"] = self.taskName!
                }
                if self.taskState != nil {
                    map["TaskState"] = self.taskState!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") && dict["Address"] != nil {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("AgentGroup") && dict["AgentGroup"] != nil {
                    self.agentGroup = dict["AgentGroup"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("Interval") && dict["Interval"] != nil {
                    self.interval = dict["Interval"] as! String
                }
                if dict.keys.contains("OptionsJson") && dict["OptionsJson"] != nil {
                    var model = DescribeSiteMonitorListResponseBody.SiteMonitors.SiteMonitor.OptionsJson()
                    model.fromMap(dict["OptionsJson"] as! [String: Any])
                    self.optionsJson = model
                }
                if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                    self.taskName = dict["TaskName"] as! String
                }
                if dict.keys.contains("TaskState") && dict["TaskState"] != nil {
                    self.taskState = dict["TaskState"] as! String
                }
                if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                    self.taskType = dict["TaskType"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! String
                }
            }
        }
        public var siteMonitor: [DescribeSiteMonitorListResponseBody.SiteMonitors.SiteMonitor]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.siteMonitor != nil {
                var tmp : [Any] = []
                for k in self.siteMonitor! {
                    tmp.append(k.toMap())
                }
                map["SiteMonitor"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SiteMonitor") && dict["SiteMonitor"] != nil {
                var tmp : [DescribeSiteMonitorListResponseBody.SiteMonitors.SiteMonitor] = []
                for v in dict["SiteMonitor"] as! [Any] {
                    var model = DescribeSiteMonitorListResponseBody.SiteMonitors.SiteMonitor()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.siteMonitor = tmp
            }
        }
    }
    public var code: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var siteMonitors: DescribeSiteMonitorListResponseBody.SiteMonitors?

    public var success: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.siteMonitors?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.siteMonitors != nil {
            map["SiteMonitors"] = self.siteMonitors?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SiteMonitors") && dict["SiteMonitors"] != nil {
            var model = DescribeSiteMonitorListResponseBody.SiteMonitors()
            model.fromMap(dict["SiteMonitors"] as! [String: Any])
            self.siteMonitors = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSiteMonitorListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSiteMonitorListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSiteMonitorListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSiteMonitorLogRequest : Tea.TeaModel {
    public var browser: String?

    public var browserInfo: String?

    public var city: String?

    public var device: String?

    public var endTime: String?

    public var filter: String?

    public var isp: String?

    public var length: Int32?

    public var metricName: String?

    public var nextToken: String?

    public var regionId: String?

    public var startTime: String?

    public var taskIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.browser != nil {
            map["Browser"] = self.browser!
        }
        if self.browserInfo != nil {
            map["BrowserInfo"] = self.browserInfo!
        }
        if self.city != nil {
            map["City"] = self.city!
        }
        if self.device != nil {
            map["Device"] = self.device!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filter != nil {
            map["Filter"] = self.filter!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.length != nil {
            map["Length"] = self.length!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Browser") && dict["Browser"] != nil {
            self.browser = dict["Browser"] as! String
        }
        if dict.keys.contains("BrowserInfo") && dict["BrowserInfo"] != nil {
            self.browserInfo = dict["BrowserInfo"] as! String
        }
        if dict.keys.contains("City") && dict["City"] != nil {
            self.city = dict["City"] as! String
        }
        if dict.keys.contains("Device") && dict["Device"] != nil {
            self.device = dict["Device"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Filter") && dict["Filter"] != nil {
            self.filter = dict["Filter"] as! String
        }
        if dict.keys.contains("Isp") && dict["Isp"] != nil {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("Length") && dict["Length"] != nil {
            self.length = dict["Length"] as! Int32
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TaskIds") && dict["TaskIds"] != nil {
            self.taskIds = dict["TaskIds"] as! String
        }
    }
}

public class DescribeSiteMonitorLogResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var nextToken: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeSiteMonitorLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSiteMonitorLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSiteMonitorLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSiteMonitorQuotaRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeSiteMonitorQuotaResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var secondMonitor: Bool?

        public var siteMonitorIdcQuota: Int32?

        public var siteMonitorOperatorQuotaQuota: Int32?

        public var siteMonitorQuotaTaskUsed: Int32?

        public var siteMonitorTaskQuota: Int32?

        public var siteMonitorVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.secondMonitor != nil {
                map["SecondMonitor"] = self.secondMonitor!
            }
            if self.siteMonitorIdcQuota != nil {
                map["SiteMonitorIdcQuota"] = self.siteMonitorIdcQuota!
            }
            if self.siteMonitorOperatorQuotaQuota != nil {
                map["SiteMonitorOperatorQuotaQuota"] = self.siteMonitorOperatorQuotaQuota!
            }
            if self.siteMonitorQuotaTaskUsed != nil {
                map["SiteMonitorQuotaTaskUsed"] = self.siteMonitorQuotaTaskUsed!
            }
            if self.siteMonitorTaskQuota != nil {
                map["SiteMonitorTaskQuota"] = self.siteMonitorTaskQuota!
            }
            if self.siteMonitorVersion != nil {
                map["SiteMonitorVersion"] = self.siteMonitorVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecondMonitor") && dict["SecondMonitor"] != nil {
                self.secondMonitor = dict["SecondMonitor"] as! Bool
            }
            if dict.keys.contains("SiteMonitorIdcQuota") && dict["SiteMonitorIdcQuota"] != nil {
                self.siteMonitorIdcQuota = dict["SiteMonitorIdcQuota"] as! Int32
            }
            if dict.keys.contains("SiteMonitorOperatorQuotaQuota") && dict["SiteMonitorOperatorQuotaQuota"] != nil {
                self.siteMonitorOperatorQuotaQuota = dict["SiteMonitorOperatorQuotaQuota"] as! Int32
            }
            if dict.keys.contains("SiteMonitorQuotaTaskUsed") && dict["SiteMonitorQuotaTaskUsed"] != nil {
                self.siteMonitorQuotaTaskUsed = dict["SiteMonitorQuotaTaskUsed"] as! Int32
            }
            if dict.keys.contains("SiteMonitorTaskQuota") && dict["SiteMonitorTaskQuota"] != nil {
                self.siteMonitorTaskQuota = dict["SiteMonitorTaskQuota"] as! Int32
            }
            if dict.keys.contains("SiteMonitorVersion") && dict["SiteMonitorVersion"] != nil {
                self.siteMonitorVersion = dict["SiteMonitorVersion"] as! String
            }
        }
    }
    public var code: String?

    public var data: DescribeSiteMonitorQuotaResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DescribeSiteMonitorQuotaResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeSiteMonitorQuotaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSiteMonitorQuotaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSiteMonitorQuotaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSiteMonitorStatisticsRequest : Tea.TeaModel {
    public var metricName: String?

    public var regionId: String?

    public var startTime: String?

    public var taskId: String?

    public var timeRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.timeRange != nil {
            map["TimeRange"] = self.timeRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TimeRange") && dict["TimeRange"] != nil {
            self.timeRange = dict["TimeRange"] as! String
        }
    }
}

public class DescribeSiteMonitorStatisticsResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeSiteMonitorStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSiteMonitorStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSiteMonitorStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSystemEventAttributeRequest : Tea.TeaModel {
    public var endTime: String?

    public var eventType: String?

    public var groupId: String?

    public var level: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var product: String?

    public var regionId: String?

    public var searchKeywords: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.product != nil {
            map["Product"] = self.product!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.searchKeywords != nil {
            map["SearchKeywords"] = self.searchKeywords!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EventType") && dict["EventType"] != nil {
            self.eventType = dict["EventType"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Level") && dict["Level"] != nil {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Product") && dict["Product"] != nil {
            self.product = dict["Product"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SearchKeywords") && dict["SearchKeywords"] != nil {
            self.searchKeywords = dict["SearchKeywords"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeSystemEventAttributeResponseBody : Tea.TeaModel {
    public class SystemEvents : Tea.TeaModel {
        public class SystemEvent : Tea.TeaModel {
            public var content: String?

            public var groupId: String?

            public var instanceName: String?

            public var level: String?

            public var name: String?

            public var product: String?

            public var regionId: String?

            public var resourceId: String?

            public var status: String?

            public var time: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.product != nil {
                    map["Product"] = self.product!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") && dict["Content"] != nil {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("Level") && dict["Level"] != nil {
                    self.level = dict["Level"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Product") && dict["Product"] != nil {
                    self.product = dict["Product"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Time") && dict["Time"] != nil {
                    self.time = dict["Time"] as! Int64
                }
            }
        }
        public var systemEvent: [DescribeSystemEventAttributeResponseBody.SystemEvents.SystemEvent]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.systemEvent != nil {
                var tmp : [Any] = []
                for k in self.systemEvent! {
                    tmp.append(k.toMap())
                }
                map["SystemEvent"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SystemEvent") && dict["SystemEvent"] != nil {
                var tmp : [DescribeSystemEventAttributeResponseBody.SystemEvents.SystemEvent] = []
                for v in dict["SystemEvent"] as! [Any] {
                    var model = DescribeSystemEventAttributeResponseBody.SystemEvents.SystemEvent()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.systemEvent = tmp
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var systemEvents: DescribeSystemEventAttributeResponseBody.SystemEvents?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemEvents?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.systemEvents != nil {
            map["SystemEvents"] = self.systemEvents?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("SystemEvents") && dict["SystemEvents"] != nil {
            var model = DescribeSystemEventAttributeResponseBody.SystemEvents()
            model.fromMap(dict["SystemEvents"] as! [String: Any])
            self.systemEvents = model
        }
    }
}

public class DescribeSystemEventAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSystemEventAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSystemEventAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSystemEventCountRequest : Tea.TeaModel {
    public var endTime: String?

    public var eventType: String?

    public var groupId: String?

    public var level: String?

    public var name: String?

    public var product: String?

    public var regionId: String?

    public var searchKeywords: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.product != nil {
            map["Product"] = self.product!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.searchKeywords != nil {
            map["SearchKeywords"] = self.searchKeywords!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EventType") && dict["EventType"] != nil {
            self.eventType = dict["EventType"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Level") && dict["Level"] != nil {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Product") && dict["Product"] != nil {
            self.product = dict["Product"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SearchKeywords") && dict["SearchKeywords"] != nil {
            self.searchKeywords = dict["SearchKeywords"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeSystemEventCountResponseBody : Tea.TeaModel {
    public class SystemEventCounts : Tea.TeaModel {
        public class SystemEventCount : Tea.TeaModel {
            public var content: String?

            public var groupId: String?

            public var instanceName: String?

            public var level: String?

            public var name: String?

            public var num: Int64?

            public var product: String?

            public var regionId: String?

            public var resourceId: String?

            public var status: String?

            public var time: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.num != nil {
                    map["Num"] = self.num!
                }
                if self.product != nil {
                    map["Product"] = self.product!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") && dict["Content"] != nil {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("Level") && dict["Level"] != nil {
                    self.level = dict["Level"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Num") && dict["Num"] != nil {
                    self.num = dict["Num"] as! Int64
                }
                if dict.keys.contains("Product") && dict["Product"] != nil {
                    self.product = dict["Product"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Time") && dict["Time"] != nil {
                    self.time = dict["Time"] as! Int64
                }
            }
        }
        public var systemEventCount: [DescribeSystemEventCountResponseBody.SystemEventCounts.SystemEventCount]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.systemEventCount != nil {
                var tmp : [Any] = []
                for k in self.systemEventCount! {
                    tmp.append(k.toMap())
                }
                map["SystemEventCount"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SystemEventCount") && dict["SystemEventCount"] != nil {
                var tmp : [DescribeSystemEventCountResponseBody.SystemEventCounts.SystemEventCount] = []
                for v in dict["SystemEventCount"] as! [Any] {
                    var model = DescribeSystemEventCountResponseBody.SystemEventCounts.SystemEventCount()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.systemEventCount = tmp
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var systemEventCounts: DescribeSystemEventCountResponseBody.SystemEventCounts?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemEventCounts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.systemEventCounts != nil {
            map["SystemEventCounts"] = self.systemEventCounts?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("SystemEventCounts") && dict["SystemEventCounts"] != nil {
            var model = DescribeSystemEventCountResponseBody.SystemEventCounts()
            model.fromMap(dict["SystemEventCounts"] as! [String: Any])
            self.systemEventCounts = model
        }
    }
}

public class DescribeSystemEventCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSystemEventCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSystemEventCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSystemEventHistogramRequest : Tea.TeaModel {
    public var endTime: String?

    public var eventType: String?

    public var groupId: String?

    public var level: String?

    public var name: String?

    public var product: String?

    public var regionId: String?

    public var searchKeywords: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.product != nil {
            map["Product"] = self.product!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.searchKeywords != nil {
            map["SearchKeywords"] = self.searchKeywords!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EventType") && dict["EventType"] != nil {
            self.eventType = dict["EventType"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Level") && dict["Level"] != nil {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Product") && dict["Product"] != nil {
            self.product = dict["Product"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SearchKeywords") && dict["SearchKeywords"] != nil {
            self.searchKeywords = dict["SearchKeywords"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeSystemEventHistogramResponseBody : Tea.TeaModel {
    public class SystemEventHistograms : Tea.TeaModel {
        public class SystemEventHistogram : Tea.TeaModel {
            public var count: Int64?

            public var endTime: Int64?

            public var startTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") && dict["Count"] != nil {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! Int64
                }
            }
        }
        public var systemEventHistogram: [DescribeSystemEventHistogramResponseBody.SystemEventHistograms.SystemEventHistogram]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.systemEventHistogram != nil {
                var tmp : [Any] = []
                for k in self.systemEventHistogram! {
                    tmp.append(k.toMap())
                }
                map["SystemEventHistogram"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SystemEventHistogram") && dict["SystemEventHistogram"] != nil {
                var tmp : [DescribeSystemEventHistogramResponseBody.SystemEventHistograms.SystemEventHistogram] = []
                for v in dict["SystemEventHistogram"] as! [Any] {
                    var model = DescribeSystemEventHistogramResponseBody.SystemEventHistograms.SystemEventHistogram()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.systemEventHistogram = tmp
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var systemEventHistograms: DescribeSystemEventHistogramResponseBody.SystemEventHistograms?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemEventHistograms?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.systemEventHistograms != nil {
            map["SystemEventHistograms"] = self.systemEventHistograms?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("SystemEventHistograms") && dict["SystemEventHistograms"] != nil {
            var model = DescribeSystemEventHistogramResponseBody.SystemEventHistograms()
            model.fromMap(dict["SystemEventHistograms"] as! [String: Any])
            self.systemEventHistograms = model
        }
    }
}

public class DescribeSystemEventHistogramResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSystemEventHistogramResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSystemEventHistogramResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSystemEventMetaListRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeSystemEventMetaListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Resource : Tea.TeaModel {
            public var eventType: String?

            public var level: String?

            public var name: String?

            public var nameDesc: String?

            public var nameDesc_en: String?

            public var product: String?

            public var status: String?

            public var statusDesc: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventType != nil {
                    map["EventType"] = self.eventType!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nameDesc != nil {
                    map["NameDesc"] = self.nameDesc!
                }
                if self.nameDesc_en != nil {
                    map["NameDesc.En"] = self.nameDesc_en!
                }
                if self.product != nil {
                    map["Product"] = self.product!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.statusDesc != nil {
                    map["StatusDesc"] = self.statusDesc!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EventType") && dict["EventType"] != nil {
                    self.eventType = dict["EventType"] as! String
                }
                if dict.keys.contains("Level") && dict["Level"] != nil {
                    self.level = dict["Level"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NameDesc") && dict["NameDesc"] != nil {
                    self.nameDesc = dict["NameDesc"] as! String
                }
                if dict.keys.contains("NameDesc.En") && dict["NameDesc.En"] != nil {
                    self.nameDesc_en = dict["NameDesc.En"] as! String
                }
                if dict.keys.contains("Product") && dict["Product"] != nil {
                    self.product = dict["Product"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StatusDesc") && dict["StatusDesc"] != nil {
                    self.statusDesc = dict["StatusDesc"] as! String
                }
            }
        }
        public var resource: [DescribeSystemEventMetaListResponseBody.Data.Resource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resource != nil {
                var tmp : [Any] = []
                for k in self.resource! {
                    tmp.append(k.toMap())
                }
                map["Resource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Resource") && dict["Resource"] != nil {
                var tmp : [DescribeSystemEventMetaListResponseBody.Data.Resource] = []
                for v in dict["Resource"] as! [Any] {
                    var model = DescribeSystemEventMetaListResponseBody.Data.Resource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resource = tmp
            }
        }
    }
    public var code: Int32?

    public var data: DescribeSystemEventMetaListResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DescribeSystemEventMetaListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeSystemEventMetaListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSystemEventMetaListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSystemEventMetaListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagKeyListRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeTagKeyListResponseBody : Tea.TeaModel {
    public class TagKeys : Tea.TeaModel {
        public var tagKey: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
                self.tagKey = dict["TagKey"] as! [String]
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var tagKeys: DescribeTagKeyListResponseBody.TagKeys?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagKeys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TagKeys") && dict["TagKeys"] != nil {
            var model = DescribeTagKeyListResponseBody.TagKeys()
            model.fromMap(dict["TagKeys"] as! [String: Any])
            self.tagKeys = model
        }
    }
}

public class DescribeTagKeyListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagKeyListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeTagKeyListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagValueListRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var tagKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
            self.tagKey = dict["TagKey"] as! String
        }
    }
}

public class DescribeTagValueListResponseBody : Tea.TeaModel {
    public class TagValues : Tea.TeaModel {
        public var tagValue: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
                self.tagValue = dict["TagValue"] as! [String]
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var tagValues: DescribeTagValueListResponseBody.TagValues?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagValues?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tagValues != nil {
            map["TagValues"] = self.tagValues?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TagValues") && dict["TagValues"] != nil {
            var model = DescribeTagValueListResponseBody.TagValues()
            model.fromMap(dict["TagValues"] as! [String: Any])
            self.tagValues = model
        }
    }
}

public class DescribeTagValueListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagValueListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeTagValueListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUnhealthyHostAvailabilityRequest : Tea.TeaModel {
    public var id: [Int64]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! [Int64]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeUnhealthyHostAvailabilityResponseBody : Tea.TeaModel {
    public class UnhealthyList : Tea.TeaModel {
        public class NodeTaskInstance : Tea.TeaModel {
            public class InstanceList : Tea.TeaModel {
                public var string: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.string != nil {
                        map["String"] = self.string!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("String") && dict["String"] != nil {
                        self.string = dict["String"] as! [String]
                    }
                }
            }
            public var id: Int64?

            public var instanceList: DescribeUnhealthyHostAvailabilityResponseBody.UnhealthyList.NodeTaskInstance.InstanceList?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.instanceList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.instanceList != nil {
                    map["InstanceList"] = self.instanceList?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InstanceList") && dict["InstanceList"] != nil {
                    var model = DescribeUnhealthyHostAvailabilityResponseBody.UnhealthyList.NodeTaskInstance.InstanceList()
                    model.fromMap(dict["InstanceList"] as! [String: Any])
                    self.instanceList = model
                }
            }
        }
        public var nodeTaskInstance: [DescribeUnhealthyHostAvailabilityResponseBody.UnhealthyList.NodeTaskInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeTaskInstance != nil {
                var tmp : [Any] = []
                for k in self.nodeTaskInstance! {
                    tmp.append(k.toMap())
                }
                map["NodeTaskInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NodeTaskInstance") && dict["NodeTaskInstance"] != nil {
                var tmp : [DescribeUnhealthyHostAvailabilityResponseBody.UnhealthyList.NodeTaskInstance] = []
                for v in dict["NodeTaskInstance"] as! [Any] {
                    var model = DescribeUnhealthyHostAvailabilityResponseBody.UnhealthyList.NodeTaskInstance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeTaskInstance = tmp
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var unhealthyList: DescribeUnhealthyHostAvailabilityResponseBody.UnhealthyList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.unhealthyList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.unhealthyList != nil {
            map["UnhealthyList"] = self.unhealthyList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("UnhealthyList") && dict["UnhealthyList"] != nil {
            var model = DescribeUnhealthyHostAvailabilityResponseBody.UnhealthyList()
            model.fromMap(dict["UnhealthyList"] as! [String: Any])
            self.unhealthyList = model
        }
    }
}

public class DescribeUnhealthyHostAvailabilityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUnhealthyHostAvailabilityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeUnhealthyHostAvailabilityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableActiveMetricRuleRequest : Tea.TeaModel {
    public var product: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.product != nil {
            map["Product"] = self.product!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Product") && dict["Product"] != nil {
            self.product = dict["Product"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DisableActiveMetricRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DisableActiveMetricRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableActiveMetricRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DisableActiveMetricRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableEventRulesRequest : Tea.TeaModel {
    public var regionId: String?

    public var ruleNames: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleNames != nil {
            map["RuleNames"] = self.ruleNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleNames") && dict["RuleNames"] != nil {
            self.ruleNames = dict["RuleNames"] as! [String]
        }
    }
}

public class DisableEventRulesResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DisableEventRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableEventRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DisableEventRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableHostAvailabilityRequest : Tea.TeaModel {
    public var id: [Int64]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! [Int64]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DisableHostAvailabilityResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DisableHostAvailabilityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableHostAvailabilityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DisableHostAvailabilityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableMetricRulesRequest : Tea.TeaModel {
    public var regionId: String?

    public var ruleId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! [String]
        }
    }
}

public class DisableMetricRulesResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DisableMetricRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableMetricRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DisableMetricRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableSiteMonitorsRequest : Tea.TeaModel {
    public var regionId: String?

    public var taskIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskIds") && dict["TaskIds"] != nil {
            self.taskIds = dict["TaskIds"] as! String
        }
    }
}

public class DisableSiteMonitorsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var count: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["count"] = self.count!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("count") && dict["count"] != nil {
                self.count = dict["count"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: DisableSiteMonitorsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DisableSiteMonitorsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class DisableSiteMonitorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableSiteMonitorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DisableSiteMonitorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableActiveMetricRuleRequest : Tea.TeaModel {
    public var product: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.product != nil {
            map["Product"] = self.product!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Product") && dict["Product"] != nil {
            self.product = dict["Product"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class EnableActiveMetricRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EnableActiveMetricRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableActiveMetricRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableActiveMetricRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableEventRulesRequest : Tea.TeaModel {
    public var regionId: String?

    public var ruleNames: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleNames != nil {
            map["RuleNames"] = self.ruleNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleNames") && dict["RuleNames"] != nil {
            self.ruleNames = dict["RuleNames"] as! [String]
        }
    }
}

public class EnableEventRulesResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EnableEventRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableEventRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableEventRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableHostAvailabilityRequest : Tea.TeaModel {
    public var id: [Int64]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! [Int64]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class EnableHostAvailabilityResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EnableHostAvailabilityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableHostAvailabilityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableHostAvailabilityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableMetricRuleBlackListRequest : Tea.TeaModel {
    public var id: String?

    public var isEnable: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.isEnable != nil {
            map["IsEnable"] = self.isEnable!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("IsEnable") && dict["IsEnable"] != nil {
            self.isEnable = dict["IsEnable"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class EnableMetricRuleBlackListResponseBody : Tea.TeaModel {
    public var code: String?

    public var count: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EnableMetricRuleBlackListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableMetricRuleBlackListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableMetricRuleBlackListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableMetricRulesRequest : Tea.TeaModel {
    public var regionId: String?

    public var ruleId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! [String]
        }
    }
}

public class EnableMetricRulesResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EnableMetricRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableMetricRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableMetricRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableSiteMonitorsRequest : Tea.TeaModel {
    public var regionId: String?

    public var taskIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskIds") && dict["TaskIds"] != nil {
            self.taskIds = dict["TaskIds"] as! String
        }
    }
}

public class EnableSiteMonitorsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var count: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["count"] = self.count!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("count") && dict["count"] != nil {
                self.count = dict["count"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: EnableSiteMonitorsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = EnableSiteMonitorsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class EnableSiteMonitorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableSiteMonitorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableSiteMonitorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallMonitoringAgentRequest : Tea.TeaModel {
    public var force: Bool?

    public var installCommand: String?

    public var instanceIds: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.installCommand != nil {
            map["InstallCommand"] = self.installCommand!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Force") && dict["Force"] != nil {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("InstallCommand") && dict["InstallCommand"] != nil {
            self.installCommand = dict["InstallCommand"] as! String
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class InstallMonitoringAgentResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class InstallMonitoringAgentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallMonitoringAgentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InstallMonitoringAgentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyGroupMonitoringAgentProcessRequest : Tea.TeaModel {
    public class AlertConfig : Tea.TeaModel {
        public class TargetList : Tea.TeaModel {
            public var arn: String?

            public var id: String?

            public var jsonParams: String?

            public var level: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.arn != nil {
                    map["Arn"] = self.arn!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.jsonParams != nil {
                    map["JsonParams"] = self.jsonParams!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Arn") && dict["Arn"] != nil {
                    self.arn = dict["Arn"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("JsonParams") && dict["JsonParams"] != nil {
                    self.jsonParams = dict["JsonParams"] as! String
                }
                if dict.keys.contains("Level") && dict["Level"] != nil {
                    self.level = dict["Level"] as! String
                }
            }
        }
        public var comparisonOperator: String?

        public var effectiveInterval: String?

        public var escalationsLevel: String?

        public var noEffectiveInterval: String?

        public var silenceTime: String?

        public var statistics: String?

        public var targetList: [ModifyGroupMonitoringAgentProcessRequest.AlertConfig.TargetList]?

        public var threshold: String?

        public var times: String?

        public var webhook: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comparisonOperator != nil {
                map["ComparisonOperator"] = self.comparisonOperator!
            }
            if self.effectiveInterval != nil {
                map["EffectiveInterval"] = self.effectiveInterval!
            }
            if self.escalationsLevel != nil {
                map["EscalationsLevel"] = self.escalationsLevel!
            }
            if self.noEffectiveInterval != nil {
                map["NoEffectiveInterval"] = self.noEffectiveInterval!
            }
            if self.silenceTime != nil {
                map["SilenceTime"] = self.silenceTime!
            }
            if self.statistics != nil {
                map["Statistics"] = self.statistics!
            }
            if self.targetList != nil {
                var tmp : [Any] = []
                for k in self.targetList! {
                    tmp.append(k.toMap())
                }
                map["TargetList"] = tmp
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            if self.times != nil {
                map["Times"] = self.times!
            }
            if self.webhook != nil {
                map["Webhook"] = self.webhook!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                self.comparisonOperator = dict["ComparisonOperator"] as! String
            }
            if dict.keys.contains("EffectiveInterval") && dict["EffectiveInterval"] != nil {
                self.effectiveInterval = dict["EffectiveInterval"] as! String
            }
            if dict.keys.contains("EscalationsLevel") && dict["EscalationsLevel"] != nil {
                self.escalationsLevel = dict["EscalationsLevel"] as! String
            }
            if dict.keys.contains("NoEffectiveInterval") && dict["NoEffectiveInterval"] != nil {
                self.noEffectiveInterval = dict["NoEffectiveInterval"] as! String
            }
            if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
                self.silenceTime = dict["SilenceTime"] as! String
            }
            if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                self.statistics = dict["Statistics"] as! String
            }
            if dict.keys.contains("TargetList") && dict["TargetList"] != nil {
                var tmp : [ModifyGroupMonitoringAgentProcessRequest.AlertConfig.TargetList] = []
                for v in dict["TargetList"] as! [Any] {
                    var model = ModifyGroupMonitoringAgentProcessRequest.AlertConfig.TargetList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.targetList = tmp
            }
            if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                self.threshold = dict["Threshold"] as! String
            }
            if dict.keys.contains("Times") && dict["Times"] != nil {
                self.times = dict["Times"] as! String
            }
            if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
                self.webhook = dict["Webhook"] as! String
            }
        }
    }
    public var alertConfig: [ModifyGroupMonitoringAgentProcessRequest.AlertConfig]?

    public var groupId: String?

    public var id: String?

    public var matchExpressFilterRelation: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertConfig != nil {
            var tmp : [Any] = []
            for k in self.alertConfig! {
                tmp.append(k.toMap())
            }
            map["AlertConfig"] = tmp
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.matchExpressFilterRelation != nil {
            map["MatchExpressFilterRelation"] = self.matchExpressFilterRelation!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertConfig") && dict["AlertConfig"] != nil {
            var tmp : [ModifyGroupMonitoringAgentProcessRequest.AlertConfig] = []
            for v in dict["AlertConfig"] as! [Any] {
                var model = ModifyGroupMonitoringAgentProcessRequest.AlertConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alertConfig = tmp
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("MatchExpressFilterRelation") && dict["MatchExpressFilterRelation"] != nil {
            self.matchExpressFilterRelation = dict["MatchExpressFilterRelation"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyGroupMonitoringAgentProcessResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyGroupMonitoringAgentProcessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyGroupMonitoringAgentProcessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyGroupMonitoringAgentProcessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyHostAvailabilityRequest : Tea.TeaModel {
    public class AlertConfig : Tea.TeaModel {
        public var endTime: Int32?

        public var notifyType: Int32?

        public var silenceTime: Int32?

        public var startTime: Int32?

        public var webHook: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.notifyType != nil {
                map["NotifyType"] = self.notifyType!
            }
            if self.silenceTime != nil {
                map["SilenceTime"] = self.silenceTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.webHook != nil {
                map["WebHook"] = self.webHook!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! Int32
            }
            if dict.keys.contains("NotifyType") && dict["NotifyType"] != nil {
                self.notifyType = dict["NotifyType"] as! Int32
            }
            if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
                self.silenceTime = dict["SilenceTime"] as! Int32
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int32
            }
            if dict.keys.contains("WebHook") && dict["WebHook"] != nil {
                self.webHook = dict["WebHook"] as! String
            }
        }
    }
    public class TaskOption : Tea.TeaModel {
        public var httpHeader: String?

        public var httpMethod: String?

        public var httpNegative: Bool?

        public var httpPostContent: String?

        public var httpResponseCharset: String?

        public var httpResponseMatchContent: String?

        public var httpURI: String?

        public var interval: Int32?

        public var telnetOrPingHost: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.httpHeader != nil {
                map["HttpHeader"] = self.httpHeader!
            }
            if self.httpMethod != nil {
                map["HttpMethod"] = self.httpMethod!
            }
            if self.httpNegative != nil {
                map["HttpNegative"] = self.httpNegative!
            }
            if self.httpPostContent != nil {
                map["HttpPostContent"] = self.httpPostContent!
            }
            if self.httpResponseCharset != nil {
                map["HttpResponseCharset"] = self.httpResponseCharset!
            }
            if self.httpResponseMatchContent != nil {
                map["HttpResponseMatchContent"] = self.httpResponseMatchContent!
            }
            if self.httpURI != nil {
                map["HttpURI"] = self.httpURI!
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.telnetOrPingHost != nil {
                map["TelnetOrPingHost"] = self.telnetOrPingHost!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HttpHeader") && dict["HttpHeader"] != nil {
                self.httpHeader = dict["HttpHeader"] as! String
            }
            if dict.keys.contains("HttpMethod") && dict["HttpMethod"] != nil {
                self.httpMethod = dict["HttpMethod"] as! String
            }
            if dict.keys.contains("HttpNegative") && dict["HttpNegative"] != nil {
                self.httpNegative = dict["HttpNegative"] as! Bool
            }
            if dict.keys.contains("HttpPostContent") && dict["HttpPostContent"] != nil {
                self.httpPostContent = dict["HttpPostContent"] as! String
            }
            if dict.keys.contains("HttpResponseCharset") && dict["HttpResponseCharset"] != nil {
                self.httpResponseCharset = dict["HttpResponseCharset"] as! String
            }
            if dict.keys.contains("HttpResponseMatchContent") && dict["HttpResponseMatchContent"] != nil {
                self.httpResponseMatchContent = dict["HttpResponseMatchContent"] as! String
            }
            if dict.keys.contains("HttpURI") && dict["HttpURI"] != nil {
                self.httpURI = dict["HttpURI"] as! String
            }
            if dict.keys.contains("Interval") && dict["Interval"] != nil {
                self.interval = dict["Interval"] as! Int32
            }
            if dict.keys.contains("TelnetOrPingHost") && dict["TelnetOrPingHost"] != nil {
                self.telnetOrPingHost = dict["TelnetOrPingHost"] as! String
            }
        }
    }
    public class AlertConfigEscalationList : Tea.TeaModel {
        public var aggregate: String?

        public var metricName: String?

        public var operator_: String?

        public var times: Int32?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aggregate != nil {
                map["Aggregate"] = self.aggregate!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.times != nil {
                map["Times"] = self.times!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Aggregate") && dict["Aggregate"] != nil {
                self.aggregate = dict["Aggregate"] as! String
            }
            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Operator") && dict["Operator"] != nil {
                self.operator_ = dict["Operator"] as! String
            }
            if dict.keys.contains("Times") && dict["Times"] != nil {
                self.times = dict["Times"] as! Int32
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class AlertConfigTargetList : Tea.TeaModel {
        public var arn: String?

        public var id: String?

        public var jsonParams: String?

        public var level: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.arn != nil {
                map["Arn"] = self.arn!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.jsonParams != nil {
                map["JsonParams"] = self.jsonParams!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Arn") && dict["Arn"] != nil {
                self.arn = dict["Arn"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("JsonParams") && dict["JsonParams"] != nil {
                self.jsonParams = dict["JsonParams"] as! String
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
        }
    }
    public var alertConfig: ModifyHostAvailabilityRequest.AlertConfig?

    public var taskOption: ModifyHostAvailabilityRequest.TaskOption?

    public var alertConfigEscalationList: [ModifyHostAvailabilityRequest.AlertConfigEscalationList]?

    public var alertConfigTargetList: [ModifyHostAvailabilityRequest.AlertConfigTargetList]?

    public var groupId: Int64?

    public var id: Int64?

    public var instanceList: [String]?

    public var regionId: String?

    public var taskName: String?

    public var taskScope: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertConfig?.validate()
        try self.taskOption?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertConfig != nil {
            map["AlertConfig"] = self.alertConfig?.toMap()
        }
        if self.taskOption != nil {
            map["TaskOption"] = self.taskOption?.toMap()
        }
        if self.alertConfigEscalationList != nil {
            var tmp : [Any] = []
            for k in self.alertConfigEscalationList! {
                tmp.append(k.toMap())
            }
            map["AlertConfigEscalationList"] = tmp
        }
        if self.alertConfigTargetList != nil {
            var tmp : [Any] = []
            for k in self.alertConfigTargetList! {
                tmp.append(k.toMap())
            }
            map["AlertConfigTargetList"] = tmp
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceList != nil {
            map["InstanceList"] = self.instanceList!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskScope != nil {
            map["TaskScope"] = self.taskScope!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertConfig") && dict["AlertConfig"] != nil {
            var model = ModifyHostAvailabilityRequest.AlertConfig()
            model.fromMap(dict["AlertConfig"] as! [String: Any])
            self.alertConfig = model
        }
        if dict.keys.contains("TaskOption") && dict["TaskOption"] != nil {
            var model = ModifyHostAvailabilityRequest.TaskOption()
            model.fromMap(dict["TaskOption"] as! [String: Any])
            self.taskOption = model
        }
        if dict.keys.contains("AlertConfigEscalationList") && dict["AlertConfigEscalationList"] != nil {
            var tmp : [ModifyHostAvailabilityRequest.AlertConfigEscalationList] = []
            for v in dict["AlertConfigEscalationList"] as! [Any] {
                var model = ModifyHostAvailabilityRequest.AlertConfigEscalationList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alertConfigEscalationList = tmp
        }
        if dict.keys.contains("AlertConfigTargetList") && dict["AlertConfigTargetList"] != nil {
            var tmp : [ModifyHostAvailabilityRequest.AlertConfigTargetList] = []
            for v in dict["AlertConfigTargetList"] as! [Any] {
                var model = ModifyHostAvailabilityRequest.AlertConfigTargetList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alertConfigTargetList = tmp
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("InstanceList") && dict["InstanceList"] != nil {
            self.instanceList = dict["InstanceList"] as! [String]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskScope") && dict["TaskScope"] != nil {
            self.taskScope = dict["TaskScope"] as! String
        }
    }
}

public class ModifyHostAvailabilityResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyHostAvailabilityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyHostAvailabilityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyHostAvailabilityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyHostInfoRequest : Tea.TeaModel {
    public var hostName: String?

    public var instanceId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyHostInfoResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyHostInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyHostInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyHostInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyHybridMonitorNamespaceRequest : Tea.TeaModel {
    public var description_: String?

    public var namespace: String?

    public var regionId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Spec") && dict["Spec"] != nil {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class ModifyHybridMonitorNamespaceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class ModifyHybridMonitorNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyHybridMonitorNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyHybridMonitorNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyHybridMonitorSLSGroupRequest : Tea.TeaModel {
    public class SLSGroupConfig : Tea.TeaModel {
        public var SLSLogstore: String?

        public var SLSProject: String?

        public var SLSRegion: String?

        public var SLSUserId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.SLSLogstore != nil {
                map["SLSLogstore"] = self.SLSLogstore!
            }
            if self.SLSProject != nil {
                map["SLSProject"] = self.SLSProject!
            }
            if self.SLSRegion != nil {
                map["SLSRegion"] = self.SLSRegion!
            }
            if self.SLSUserId != nil {
                map["SLSUserId"] = self.SLSUserId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SLSLogstore") && dict["SLSLogstore"] != nil {
                self.SLSLogstore = dict["SLSLogstore"] as! String
            }
            if dict.keys.contains("SLSProject") && dict["SLSProject"] != nil {
                self.SLSProject = dict["SLSProject"] as! String
            }
            if dict.keys.contains("SLSRegion") && dict["SLSRegion"] != nil {
                self.SLSRegion = dict["SLSRegion"] as! String
            }
            if dict.keys.contains("SLSUserId") && dict["SLSUserId"] != nil {
                self.SLSUserId = dict["SLSUserId"] as! String
            }
        }
    }
    public var regionId: String?

    public var SLSGroupConfig: [ModifyHybridMonitorSLSGroupRequest.SLSGroupConfig]?

    public var SLSGroupDescription: String?

    public var SLSGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.SLSGroupConfig != nil {
            var tmp : [Any] = []
            for k in self.SLSGroupConfig! {
                tmp.append(k.toMap())
            }
            map["SLSGroupConfig"] = tmp
        }
        if self.SLSGroupDescription != nil {
            map["SLSGroupDescription"] = self.SLSGroupDescription!
        }
        if self.SLSGroupName != nil {
            map["SLSGroupName"] = self.SLSGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SLSGroupConfig") && dict["SLSGroupConfig"] != nil {
            var tmp : [ModifyHybridMonitorSLSGroupRequest.SLSGroupConfig] = []
            for v in dict["SLSGroupConfig"] as! [Any] {
                var model = ModifyHybridMonitorSLSGroupRequest.SLSGroupConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.SLSGroupConfig = tmp
        }
        if dict.keys.contains("SLSGroupDescription") && dict["SLSGroupDescription"] != nil {
            self.SLSGroupDescription = dict["SLSGroupDescription"] as! String
        }
        if dict.keys.contains("SLSGroupName") && dict["SLSGroupName"] != nil {
            self.SLSGroupName = dict["SLSGroupName"] as! String
        }
    }
}

public class ModifyHybridMonitorSLSGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class ModifyHybridMonitorSLSGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyHybridMonitorSLSGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyHybridMonitorSLSGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyHybridMonitorTaskRequest : Tea.TeaModel {
    public class AttachLabels : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class SLSProcessConfig : Tea.TeaModel {
        public class Express : Tea.TeaModel {
            public var alias: String?

            public var express: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.express != nil {
                    map["Express"] = self.express!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") && dict["Alias"] != nil {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("Express") && dict["Express"] != nil {
                    self.express = dict["Express"] as! String
                }
            }
        }
        public class Filter : Tea.TeaModel {
            public class Filters : Tea.TeaModel {
                public var operator_: String?

                public var SLSKeyName: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.SLSKeyName != nil {
                        map["SLSKeyName"] = self.SLSKeyName!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Operator") && dict["Operator"] != nil {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("SLSKeyName") && dict["SLSKeyName"] != nil {
                        self.SLSKeyName = dict["SLSKeyName"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var filters: [ModifyHybridMonitorTaskRequest.SLSProcessConfig.Filter.Filters]?

            public var relation: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.filters != nil {
                    var tmp : [Any] = []
                    for k in self.filters! {
                        tmp.append(k.toMap())
                    }
                    map["Filters"] = tmp
                }
                if self.relation != nil {
                    map["Relation"] = self.relation!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Filters") && dict["Filters"] != nil {
                    var tmp : [ModifyHybridMonitorTaskRequest.SLSProcessConfig.Filter.Filters] = []
                    for v in dict["Filters"] as! [Any] {
                        var model = ModifyHybridMonitorTaskRequest.SLSProcessConfig.Filter.Filters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.filters = tmp
                }
                if dict.keys.contains("Relation") && dict["Relation"] != nil {
                    self.relation = dict["Relation"] as! String
                }
            }
        }
        public class GroupBy : Tea.TeaModel {
            public var alias: String?

            public var SLSKeyName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.SLSKeyName != nil {
                    map["SLSKeyName"] = self.SLSKeyName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") && dict["Alias"] != nil {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("SLSKeyName") && dict["SLSKeyName"] != nil {
                    self.SLSKeyName = dict["SLSKeyName"] as! String
                }
            }
        }
        public class Statistics : Tea.TeaModel {
            public var alias: String?

            public var function: String?

            public var parameter1: String?

            public var parameter2: String?

            public var SLSKeyName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.function != nil {
                    map["Function"] = self.function!
                }
                if self.parameter1 != nil {
                    map["Parameter1"] = self.parameter1!
                }
                if self.parameter2 != nil {
                    map["Parameter2"] = self.parameter2!
                }
                if self.SLSKeyName != nil {
                    map["SLSKeyName"] = self.SLSKeyName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") && dict["Alias"] != nil {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("Function") && dict["Function"] != nil {
                    self.function = dict["Function"] as! String
                }
                if dict.keys.contains("Parameter1") && dict["Parameter1"] != nil {
                    self.parameter1 = dict["Parameter1"] as! String
                }
                if dict.keys.contains("Parameter2") && dict["Parameter2"] != nil {
                    self.parameter2 = dict["Parameter2"] as! String
                }
                if dict.keys.contains("SLSKeyName") && dict["SLSKeyName"] != nil {
                    self.SLSKeyName = dict["SLSKeyName"] as! String
                }
            }
        }
        public var express: [ModifyHybridMonitorTaskRequest.SLSProcessConfig.Express]?

        public var filter: ModifyHybridMonitorTaskRequest.SLSProcessConfig.Filter?

        public var groupBy: [ModifyHybridMonitorTaskRequest.SLSProcessConfig.GroupBy]?

        public var statistics: [ModifyHybridMonitorTaskRequest.SLSProcessConfig.Statistics]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.filter?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.express != nil {
                var tmp : [Any] = []
                for k in self.express! {
                    tmp.append(k.toMap())
                }
                map["Express"] = tmp
            }
            if self.filter != nil {
                map["Filter"] = self.filter?.toMap()
            }
            if self.groupBy != nil {
                var tmp : [Any] = []
                for k in self.groupBy! {
                    tmp.append(k.toMap())
                }
                map["GroupBy"] = tmp
            }
            if self.statistics != nil {
                var tmp : [Any] = []
                for k in self.statistics! {
                    tmp.append(k.toMap())
                }
                map["Statistics"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Express") && dict["Express"] != nil {
                var tmp : [ModifyHybridMonitorTaskRequest.SLSProcessConfig.Express] = []
                for v in dict["Express"] as! [Any] {
                    var model = ModifyHybridMonitorTaskRequest.SLSProcessConfig.Express()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.express = tmp
            }
            if dict.keys.contains("Filter") && dict["Filter"] != nil {
                var model = ModifyHybridMonitorTaskRequest.SLSProcessConfig.Filter()
                model.fromMap(dict["Filter"] as! [String: Any])
                self.filter = model
            }
            if dict.keys.contains("GroupBy") && dict["GroupBy"] != nil {
                var tmp : [ModifyHybridMonitorTaskRequest.SLSProcessConfig.GroupBy] = []
                for v in dict["GroupBy"] as! [Any] {
                    var model = ModifyHybridMonitorTaskRequest.SLSProcessConfig.GroupBy()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.groupBy = tmp
            }
            if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                var tmp : [ModifyHybridMonitorTaskRequest.SLSProcessConfig.Statistics] = []
                for v in dict["Statistics"] as! [Any] {
                    var model = ModifyHybridMonitorTaskRequest.SLSProcessConfig.Statistics()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.statistics = tmp
            }
        }
    }
    public var attachLabels: [ModifyHybridMonitorTaskRequest.AttachLabels]?

    public var collectInterval: String?

    public var description_: String?

    public var regionId: String?

    public var SLSProcessConfig: ModifyHybridMonitorTaskRequest.SLSProcessConfig?

    public var taskId: String?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.SLSProcessConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachLabels != nil {
            var tmp : [Any] = []
            for k in self.attachLabels! {
                tmp.append(k.toMap())
            }
            map["AttachLabels"] = tmp
        }
        if self.collectInterval != nil {
            map["CollectInterval"] = self.collectInterval!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.SLSProcessConfig != nil {
            map["SLSProcessConfig"] = self.SLSProcessConfig?.toMap()
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachLabels") && dict["AttachLabels"] != nil {
            var tmp : [ModifyHybridMonitorTaskRequest.AttachLabels] = []
            for v in dict["AttachLabels"] as! [Any] {
                var model = ModifyHybridMonitorTaskRequest.AttachLabels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attachLabels = tmp
        }
        if dict.keys.contains("CollectInterval") && dict["CollectInterval"] != nil {
            self.collectInterval = dict["CollectInterval"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SLSProcessConfig") && dict["SLSProcessConfig"] != nil {
            var model = ModifyHybridMonitorTaskRequest.SLSProcessConfig()
            model.fromMap(dict["SLSProcessConfig"] as! [String: Any])
            self.SLSProcessConfig = model
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
    }
}

public class ModifyHybridMonitorTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class ModifyHybridMonitorTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyHybridMonitorTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyHybridMonitorTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyMetricRuleBlackListRequest : Tea.TeaModel {
    public class Metrics : Tea.TeaModel {
        public var metricName: String?

        public var resource: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.resource != nil {
                map["Resource"] = self.resource!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Resource") && dict["Resource"] != nil {
                self.resource = dict["Resource"] as! String
            }
        }
    }
    public var category: String?

    public var effectiveTime: String?

    public var enableEndTime: String?

    public var enableStartTime: String?

    public var id: String?

    public var instances: [String]?

    public var metrics: [ModifyMetricRuleBlackListRequest.Metrics]?

    public var name: String?

    public var namespace: String?

    public var regionId: String?

    public var scopeType: String?

    public var scopeValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.effectiveTime != nil {
            map["EffectiveTime"] = self.effectiveTime!
        }
        if self.enableEndTime != nil {
            map["EnableEndTime"] = self.enableEndTime!
        }
        if self.enableStartTime != nil {
            map["EnableStartTime"] = self.enableStartTime!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instances != nil {
            map["Instances"] = self.instances!
        }
        if self.metrics != nil {
            var tmp : [Any] = []
            for k in self.metrics! {
                tmp.append(k.toMap())
            }
            map["Metrics"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scopeType != nil {
            map["ScopeType"] = self.scopeType!
        }
        if self.scopeValue != nil {
            map["ScopeValue"] = self.scopeValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") && dict["Category"] != nil {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("EffectiveTime") && dict["EffectiveTime"] != nil {
            self.effectiveTime = dict["EffectiveTime"] as! String
        }
        if dict.keys.contains("EnableEndTime") && dict["EnableEndTime"] != nil {
            self.enableEndTime = dict["EnableEndTime"] as! String
        }
        if dict.keys.contains("EnableStartTime") && dict["EnableStartTime"] != nil {
            self.enableStartTime = dict["EnableStartTime"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Instances") && dict["Instances"] != nil {
            self.instances = dict["Instances"] as! [String]
        }
        if dict.keys.contains("Metrics") && dict["Metrics"] != nil {
            var tmp : [ModifyMetricRuleBlackListRequest.Metrics] = []
            for v in dict["Metrics"] as! [Any] {
                var model = ModifyMetricRuleBlackListRequest.Metrics()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.metrics = tmp
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScopeType") && dict["ScopeType"] != nil {
            self.scopeType = dict["ScopeType"] as! String
        }
        if dict.keys.contains("ScopeValue") && dict["ScopeValue"] != nil {
            self.scopeValue = dict["ScopeValue"] as! String
        }
    }
}

public class ModifyMetricRuleBlackListResponseBody : Tea.TeaModel {
    public var code: String?

    public var count: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyMetricRuleBlackListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyMetricRuleBlackListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyMetricRuleBlackListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyMetricRuleTemplateRequest : Tea.TeaModel {
    public class AlertTemplates : Tea.TeaModel {
        public class Escalations : Tea.TeaModel {
            public class Critical : Tea.TeaModel {
                public var comparisonOperator: String?

                public var n: Int32?

                public var statistics: String?

                public var threshold: String?

                public var times: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.comparisonOperator != nil {
                        map["ComparisonOperator"] = self.comparisonOperator!
                    }
                    if self.n != nil {
                        map["N"] = self.n!
                    }
                    if self.statistics != nil {
                        map["Statistics"] = self.statistics!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    if self.times != nil {
                        map["Times"] = self.times!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                        self.comparisonOperator = dict["ComparisonOperator"] as! String
                    }
                    if dict.keys.contains("N") && dict["N"] != nil {
                        self.n = dict["N"] as! Int32
                    }
                    if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                        self.statistics = dict["Statistics"] as! String
                    }
                    if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                        self.threshold = dict["Threshold"] as! String
                    }
                    if dict.keys.contains("Times") && dict["Times"] != nil {
                        self.times = dict["Times"] as! Int32
                    }
                }
            }
            public class Info : Tea.TeaModel {
                public var comparisonOperator: String?

                public var n: Int32?

                public var statistics: String?

                public var threshold: String?

                public var times: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.comparisonOperator != nil {
                        map["ComparisonOperator"] = self.comparisonOperator!
                    }
                    if self.n != nil {
                        map["N"] = self.n!
                    }
                    if self.statistics != nil {
                        map["Statistics"] = self.statistics!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    if self.times != nil {
                        map["Times"] = self.times!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                        self.comparisonOperator = dict["ComparisonOperator"] as! String
                    }
                    if dict.keys.contains("N") && dict["N"] != nil {
                        self.n = dict["N"] as! Int32
                    }
                    if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                        self.statistics = dict["Statistics"] as! String
                    }
                    if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                        self.threshold = dict["Threshold"] as! String
                    }
                    if dict.keys.contains("Times") && dict["Times"] != nil {
                        self.times = dict["Times"] as! Int32
                    }
                }
            }
            public class Warn : Tea.TeaModel {
                public var comparisonOperator: String?

                public var n: Int32?

                public var statistics: String?

                public var threshold: String?

                public var times: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.comparisonOperator != nil {
                        map["ComparisonOperator"] = self.comparisonOperator!
                    }
                    if self.n != nil {
                        map["N"] = self.n!
                    }
                    if self.statistics != nil {
                        map["Statistics"] = self.statistics!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    if self.times != nil {
                        map["Times"] = self.times!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                        self.comparisonOperator = dict["ComparisonOperator"] as! String
                    }
                    if dict.keys.contains("N") && dict["N"] != nil {
                        self.n = dict["N"] as! Int32
                    }
                    if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                        self.statistics = dict["Statistics"] as! String
                    }
                    if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                        self.threshold = dict["Threshold"] as! String
                    }
                    if dict.keys.contains("Times") && dict["Times"] != nil {
                        self.times = dict["Times"] as! Int32
                    }
                }
            }
            public var critical: ModifyMetricRuleTemplateRequest.AlertTemplates.Escalations.Critical?

            public var info: ModifyMetricRuleTemplateRequest.AlertTemplates.Escalations.Info?

            public var warn: ModifyMetricRuleTemplateRequest.AlertTemplates.Escalations.Warn?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.critical?.validate()
                try self.info?.validate()
                try self.warn?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.critical != nil {
                    map["Critical"] = self.critical?.toMap()
                }
                if self.info != nil {
                    map["Info"] = self.info?.toMap()
                }
                if self.warn != nil {
                    map["Warn"] = self.warn?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Critical") && dict["Critical"] != nil {
                    var model = ModifyMetricRuleTemplateRequest.AlertTemplates.Escalations.Critical()
                    model.fromMap(dict["Critical"] as! [String: Any])
                    self.critical = model
                }
                if dict.keys.contains("Info") && dict["Info"] != nil {
                    var model = ModifyMetricRuleTemplateRequest.AlertTemplates.Escalations.Info()
                    model.fromMap(dict["Info"] as! [String: Any])
                    self.info = model
                }
                if dict.keys.contains("Warn") && dict["Warn"] != nil {
                    var model = ModifyMetricRuleTemplateRequest.AlertTemplates.Escalations.Warn()
                    model.fromMap(dict["Warn"] as! [String: Any])
                    self.warn = model
                }
            }
        }
        public var escalations: ModifyMetricRuleTemplateRequest.AlertTemplates.Escalations?

        public var category: String?

        public var metricName: String?

        public var namespace: String?

        public var period: Int32?

        public var ruleName: String?

        public var selector: String?

        public var webhook: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.escalations?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.escalations != nil {
                map["Escalations"] = self.escalations?.toMap()
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.selector != nil {
                map["Selector"] = self.selector!
            }
            if self.webhook != nil {
                map["Webhook"] = self.webhook!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Escalations") && dict["Escalations"] != nil {
                var model = ModifyMetricRuleTemplateRequest.AlertTemplates.Escalations()
                model.fromMap(dict["Escalations"] as! [String: Any])
                self.escalations = model
            }
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Period") && dict["Period"] != nil {
                self.period = dict["Period"] as! Int32
            }
            if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("Selector") && dict["Selector"] != nil {
                self.selector = dict["Selector"] as! String
            }
            if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
                self.webhook = dict["Webhook"] as! String
            }
        }
    }
    public var alertTemplates: [ModifyMetricRuleTemplateRequest.AlertTemplates]?

    public var description_: String?

    public var name: String?

    public var regionId: String?

    public var restVersion: Int64?

    public var templateId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertTemplates != nil {
            var tmp : [Any] = []
            for k in self.alertTemplates! {
                tmp.append(k.toMap())
            }
            map["AlertTemplates"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.restVersion != nil {
            map["RestVersion"] = self.restVersion!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertTemplates") && dict["AlertTemplates"] != nil {
            var tmp : [ModifyMetricRuleTemplateRequest.AlertTemplates] = []
            for v in dict["AlertTemplates"] as! [Any] {
                var model = ModifyMetricRuleTemplateRequest.AlertTemplates()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alertTemplates = tmp
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RestVersion") && dict["RestVersion"] != nil {
            self.restVersion = dict["RestVersion"] as! Int64
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! Int64
        }
    }
}

public class ModifyMetricRuleTemplateResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyMetricRuleTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyMetricRuleTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyMetricRuleTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyMonitorGroupRequest : Tea.TeaModel {
    public var contactGroups: String?

    public var groupId: String?

    public var groupName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroups != nil {
            map["ContactGroups"] = self.contactGroups!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
            self.contactGroups = dict["ContactGroups"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyMonitorGroupResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyMonitorGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyMonitorGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyMonitorGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyMonitorGroupInstancesRequest : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public var category: String?

        public var instanceId: String?

        public var instanceName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public var groupId: Int64?

    public var instances: [ModifyMonitorGroupInstancesRequest.Instances]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Instances") && dict["Instances"] != nil {
            var tmp : [ModifyMonitorGroupInstancesRequest.Instances] = []
            for v in dict["Instances"] as! [Any] {
                var model = ModifyMonitorGroupInstancesRequest.Instances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instances = tmp
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyMonitorGroupInstancesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyMonitorGroupInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyMonitorGroupInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyMonitorGroupInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySiteMonitorRequest : Tea.TeaModel {
    public var address: String?

    public var alertIds: String?

    public var customSchedule: String?

    public var interval: String?

    public var intervalUnit: String?

    public var ispCities: String?

    public var optionsJson: String?

    public var regionId: String?

    public var taskId: String?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.alertIds != nil {
            map["AlertIds"] = self.alertIds!
        }
        if self.customSchedule != nil {
            map["CustomSchedule"] = self.customSchedule!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.intervalUnit != nil {
            map["IntervalUnit"] = self.intervalUnit!
        }
        if self.ispCities != nil {
            map["IspCities"] = self.ispCities!
        }
        if self.optionsJson != nil {
            map["OptionsJson"] = self.optionsJson!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("AlertIds") && dict["AlertIds"] != nil {
            self.alertIds = dict["AlertIds"] as! String
        }
        if dict.keys.contains("CustomSchedule") && dict["CustomSchedule"] != nil {
            self.customSchedule = dict["CustomSchedule"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("IntervalUnit") && dict["IntervalUnit"] != nil {
            self.intervalUnit = dict["IntervalUnit"] as! String
        }
        if dict.keys.contains("IspCities") && dict["IspCities"] != nil {
            self.ispCities = dict["IspCities"] as! String
        }
        if dict.keys.contains("OptionsJson") && dict["OptionsJson"] != nil {
            self.optionsJson = dict["OptionsJson"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
    }
}

public class ModifySiteMonitorResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var count: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["count"] = self.count!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("count") && dict["count"] != nil {
                self.count = dict["count"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ModifySiteMonitorResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ModifySiteMonitorResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class ModifySiteMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySiteMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifySiteMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenCmsServiceResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OpenCmsServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenCmsServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenCmsServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutContactRequest : Tea.TeaModel {
    public class Channels : Tea.TeaModel {
        public var aliIM: String?

        public var dingWebHook: String?

        public var mail: String?

        public var SMS: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliIM != nil {
                map["AliIM"] = self.aliIM!
            }
            if self.dingWebHook != nil {
                map["DingWebHook"] = self.dingWebHook!
            }
            if self.mail != nil {
                map["Mail"] = self.mail!
            }
            if self.SMS != nil {
                map["SMS"] = self.SMS!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliIM") && dict["AliIM"] != nil {
                self.aliIM = dict["AliIM"] as! String
            }
            if dict.keys.contains("DingWebHook") && dict["DingWebHook"] != nil {
                self.dingWebHook = dict["DingWebHook"] as! String
            }
            if dict.keys.contains("Mail") && dict["Mail"] != nil {
                self.mail = dict["Mail"] as! String
            }
            if dict.keys.contains("SMS") && dict["SMS"] != nil {
                self.SMS = dict["SMS"] as! String
            }
        }
    }
    public var channels: PutContactRequest.Channels?

    public var contactName: String?

    public var describe: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.channels?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channels != nil {
            map["Channels"] = self.channels?.toMap()
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.describe != nil {
            map["Describe"] = self.describe!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Channels") && dict["Channels"] != nil {
            var model = PutContactRequest.Channels()
            model.fromMap(dict["Channels"] as! [String: Any])
            self.channels = model
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("Describe") && dict["Describe"] != nil {
            self.describe = dict["Describe"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class PutContactResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PutContactResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutContactResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutContactResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutContactGroupRequest : Tea.TeaModel {
    public var contactGroupName: String?

    public var contactNames: [String]?

    public var describe: String?

    public var enableSubscribed: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupName != nil {
            map["ContactGroupName"] = self.contactGroupName!
        }
        if self.contactNames != nil {
            map["ContactNames"] = self.contactNames!
        }
        if self.describe != nil {
            map["Describe"] = self.describe!
        }
        if self.enableSubscribed != nil {
            map["EnableSubscribed"] = self.enableSubscribed!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupName") && dict["ContactGroupName"] != nil {
            self.contactGroupName = dict["ContactGroupName"] as! String
        }
        if dict.keys.contains("ContactNames") && dict["ContactNames"] != nil {
            self.contactNames = dict["ContactNames"] as! [String]
        }
        if dict.keys.contains("Describe") && dict["Describe"] != nil {
            self.describe = dict["Describe"] as! String
        }
        if dict.keys.contains("EnableSubscribed") && dict["EnableSubscribed"] != nil {
            self.enableSubscribed = dict["EnableSubscribed"] as! Bool
        }
    }
}

public class PutContactGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PutContactGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutContactGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutContactGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutCustomEventRequest : Tea.TeaModel {
    public class EventInfo : Tea.TeaModel {
        public var content: String?

        public var eventName: String?

        public var groupId: String?

        public var time: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.eventName != nil {
                map["EventName"] = self.eventName!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") && dict["Content"] != nil {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("EventName") && dict["EventName"] != nil {
                self.eventName = dict["EventName"] as! String
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("Time") && dict["Time"] != nil {
                self.time = dict["Time"] as! String
            }
        }
    }
    public var eventInfo: [PutCustomEventRequest.EventInfo]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventInfo != nil {
            var tmp : [Any] = []
            for k in self.eventInfo! {
                tmp.append(k.toMap())
            }
            map["EventInfo"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventInfo") && dict["EventInfo"] != nil {
            var tmp : [PutCustomEventRequest.EventInfo] = []
            for v in dict["EventInfo"] as! [Any] {
                var model = PutCustomEventRequest.EventInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.eventInfo = tmp
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class PutCustomEventResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PutCustomEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutCustomEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutCustomEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutCustomEventRuleRequest : Tea.TeaModel {
    public var contactGroups: String?

    public var effectiveInterval: String?

    public var emailSubject: String?

    public var eventName: String?

    public var groupId: String?

    public var level: String?

    public var period: String?

    public var ruleId: String?

    public var ruleName: String?

    public var threshold: String?

    public var webhook: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroups != nil {
            map["ContactGroups"] = self.contactGroups!
        }
        if self.effectiveInterval != nil {
            map["EffectiveInterval"] = self.effectiveInterval!
        }
        if self.emailSubject != nil {
            map["EmailSubject"] = self.emailSubject!
        }
        if self.eventName != nil {
            map["EventName"] = self.eventName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        if self.webhook != nil {
            map["Webhook"] = self.webhook!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
            self.contactGroups = dict["ContactGroups"] as! String
        }
        if dict.keys.contains("EffectiveInterval") && dict["EffectiveInterval"] != nil {
            self.effectiveInterval = dict["EffectiveInterval"] as! String
        }
        if dict.keys.contains("EmailSubject") && dict["EmailSubject"] != nil {
            self.emailSubject = dict["EmailSubject"] as! String
        }
        if dict.keys.contains("EventName") && dict["EventName"] != nil {
            self.eventName = dict["EventName"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Level") && dict["Level"] != nil {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
            self.threshold = dict["Threshold"] as! String
        }
        if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
            self.webhook = dict["Webhook"] as! String
        }
    }
}

public class PutCustomEventRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PutCustomEventRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutCustomEventRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutCustomEventRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutCustomMetricRequest : Tea.TeaModel {
    public class MetricList : Tea.TeaModel {
        public var dimensions: String?

        public var groupId: String?

        public var metricName: String?

        public var period: String?

        public var time: String?

        public var type: String?

        public var values: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dimensions != nil {
                map["Dimensions"] = self.dimensions!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.values != nil {
                map["Values"] = self.values!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
                self.dimensions = dict["Dimensions"] as! String
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Period") && dict["Period"] != nil {
                self.period = dict["Period"] as! String
            }
            if dict.keys.contains("Time") && dict["Time"] != nil {
                self.time = dict["Time"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Values") && dict["Values"] != nil {
                self.values = dict["Values"] as! String
            }
        }
    }
    public var metricList: [PutCustomMetricRequest.MetricList]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.metricList != nil {
            var tmp : [Any] = []
            for k in self.metricList! {
                tmp.append(k.toMap())
            }
            map["MetricList"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MetricList") && dict["MetricList"] != nil {
            var tmp : [PutCustomMetricRequest.MetricList] = []
            for v in dict["MetricList"] as! [Any] {
                var model = PutCustomMetricRequest.MetricList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.metricList = tmp
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class PutCustomMetricResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PutCustomMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutCustomMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutCustomMetricResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutCustomMetricRuleRequest : Tea.TeaModel {
    public var comparisonOperator: String?

    public var contactGroups: String?

    public var effectiveInterval: String?

    public var emailSubject: String?

    public var evaluationCount: Int32?

    public var groupId: String?

    public var level: String?

    public var metricName: String?

    public var period: String?

    public var resources: String?

    public var ruleId: String?

    public var ruleName: String?

    public var silenceTime: Int32?

    public var statistics: String?

    public var threshold: String?

    public var webhook: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comparisonOperator != nil {
            map["ComparisonOperator"] = self.comparisonOperator!
        }
        if self.contactGroups != nil {
            map["ContactGroups"] = self.contactGroups!
        }
        if self.effectiveInterval != nil {
            map["EffectiveInterval"] = self.effectiveInterval!
        }
        if self.emailSubject != nil {
            map["EmailSubject"] = self.emailSubject!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.resources != nil {
            map["Resources"] = self.resources!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.silenceTime != nil {
            map["SilenceTime"] = self.silenceTime!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        if self.webhook != nil {
            map["Webhook"] = self.webhook!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
            self.comparisonOperator = dict["ComparisonOperator"] as! String
        }
        if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
            self.contactGroups = dict["ContactGroups"] as! String
        }
        if dict.keys.contains("EffectiveInterval") && dict["EffectiveInterval"] != nil {
            self.effectiveInterval = dict["EffectiveInterval"] as! String
        }
        if dict.keys.contains("EmailSubject") && dict["EmailSubject"] != nil {
            self.emailSubject = dict["EmailSubject"] as! String
        }
        if dict.keys.contains("EvaluationCount") && dict["EvaluationCount"] != nil {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Level") && dict["Level"] != nil {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("Resources") && dict["Resources"] != nil {
            self.resources = dict["Resources"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
            self.silenceTime = dict["SilenceTime"] as! Int32
        }
        if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
            self.statistics = dict["Statistics"] as! String
        }
        if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
            self.threshold = dict["Threshold"] as! String
        }
        if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
            self.webhook = dict["Webhook"] as! String
        }
    }
}

public class PutCustomMetricRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PutCustomMetricRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutCustomMetricRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutCustomMetricRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutEventRuleRequest : Tea.TeaModel {
    public class EventPattern : Tea.TeaModel {
        public var customFilters: String?

        public var eventTypeList: [String]?

        public var levelList: [String]?

        public var nameList: [String]?

        public var product: String?

        public var SQLFilter: String?

        public var statusList: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customFilters != nil {
                map["CustomFilters"] = self.customFilters!
            }
            if self.eventTypeList != nil {
                map["EventTypeList"] = self.eventTypeList!
            }
            if self.levelList != nil {
                map["LevelList"] = self.levelList!
            }
            if self.nameList != nil {
                map["NameList"] = self.nameList!
            }
            if self.product != nil {
                map["Product"] = self.product!
            }
            if self.SQLFilter != nil {
                map["SQLFilter"] = self.SQLFilter!
            }
            if self.statusList != nil {
                map["StatusList"] = self.statusList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomFilters") && dict["CustomFilters"] != nil {
                self.customFilters = dict["CustomFilters"] as! String
            }
            if dict.keys.contains("EventTypeList") && dict["EventTypeList"] != nil {
                self.eventTypeList = dict["EventTypeList"] as! [String]
            }
            if dict.keys.contains("LevelList") && dict["LevelList"] != nil {
                self.levelList = dict["LevelList"] as! [String]
            }
            if dict.keys.contains("NameList") && dict["NameList"] != nil {
                self.nameList = dict["NameList"] as! [String]
            }
            if dict.keys.contains("Product") && dict["Product"] != nil {
                self.product = dict["Product"] as! String
            }
            if dict.keys.contains("SQLFilter") && dict["SQLFilter"] != nil {
                self.SQLFilter = dict["SQLFilter"] as! String
            }
            if dict.keys.contains("StatusList") && dict["StatusList"] != nil {
                self.statusList = dict["StatusList"] as! [String]
            }
        }
    }
    public var description_: String?

    public var eventPattern: [PutEventRuleRequest.EventPattern]?

    public var eventType: String?

    public var groupId: String?

    public var regionId: String?

    public var ruleName: String?

    public var silenceTime: Int64?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eventPattern != nil {
            var tmp : [Any] = []
            for k in self.eventPattern! {
                tmp.append(k.toMap())
            }
            map["EventPattern"] = tmp
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.silenceTime != nil {
            map["SilenceTime"] = self.silenceTime!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EventPattern") && dict["EventPattern"] != nil {
            var tmp : [PutEventRuleRequest.EventPattern] = []
            for v in dict["EventPattern"] as! [Any] {
                var model = PutEventRuleRequest.EventPattern()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.eventPattern = tmp
        }
        if dict.keys.contains("EventType") && dict["EventType"] != nil {
            self.eventType = dict["EventType"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
            self.silenceTime = dict["SilenceTime"] as! Int64
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class PutEventRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PutEventRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutEventRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutEventRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutEventRuleTargetsRequest : Tea.TeaModel {
    public class ContactParameters : Tea.TeaModel {
        public var contactGroupName: String?

        public var id: String?

        public var level: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contactGroupName != nil {
                map["ContactGroupName"] = self.contactGroupName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContactGroupName") && dict["ContactGroupName"] != nil {
                self.contactGroupName = dict["ContactGroupName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
        }
    }
    public class FcParameters : Tea.TeaModel {
        public var functionName: String?

        public var id: String?

        public var region: String?

        public var serviceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.functionName != nil {
                map["FunctionName"] = self.functionName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FunctionName") && dict["FunctionName"] != nil {
                self.functionName = dict["FunctionName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                self.serviceName = dict["ServiceName"] as! String
            }
        }
    }
    public class MnsParameters : Tea.TeaModel {
        public var id: String?

        public var queue: String?

        public var region: String?

        public var topic: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.queue != nil {
                map["Queue"] = self.queue!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.topic != nil {
                map["Topic"] = self.topic!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Queue") && dict["Queue"] != nil {
                self.queue = dict["Queue"] as! String
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("Topic") && dict["Topic"] != nil {
                self.topic = dict["Topic"] as! String
            }
        }
    }
    public class OpenApiParameters : Tea.TeaModel {
        public var action: String?

        public var arn: String?

        public var id: String?

        public var jsonParams: String?

        public var product: String?

        public var region: String?

        public var role: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.arn != nil {
                map["Arn"] = self.arn!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.jsonParams != nil {
                map["JsonParams"] = self.jsonParams!
            }
            if self.product != nil {
                map["Product"] = self.product!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("Arn") && dict["Arn"] != nil {
                self.arn = dict["Arn"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("JsonParams") && dict["JsonParams"] != nil {
                self.jsonParams = dict["JsonParams"] as! String
            }
            if dict.keys.contains("Product") && dict["Product"] != nil {
                self.product = dict["Product"] as! String
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("Role") && dict["Role"] != nil {
                self.role = dict["Role"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
        }
    }
    public class SlsParameters : Tea.TeaModel {
        public var id: String?

        public var logStore: String?

        public var project: String?

        public var region: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.logStore != nil {
                map["LogStore"] = self.logStore!
            }
            if self.project != nil {
                map["Project"] = self.project!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("LogStore") && dict["LogStore"] != nil {
                self.logStore = dict["LogStore"] as! String
            }
            if dict.keys.contains("Project") && dict["Project"] != nil {
                self.project = dict["Project"] as! String
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
        }
    }
    public class WebhookParameters : Tea.TeaModel {
        public var id: String?

        public var method: String?

        public var protocol_: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.method != nil {
                map["Method"] = self.method!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Method") && dict["Method"] != nil {
                self.method = dict["Method"] as! String
            }
            if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var contactParameters: [PutEventRuleTargetsRequest.ContactParameters]?

    public var fcParameters: [PutEventRuleTargetsRequest.FcParameters]?

    public var mnsParameters: [PutEventRuleTargetsRequest.MnsParameters]?

    public var openApiParameters: [PutEventRuleTargetsRequest.OpenApiParameters]?

    public var regionId: String?

    public var ruleName: String?

    public var slsParameters: [PutEventRuleTargetsRequest.SlsParameters]?

    public var webhookParameters: [PutEventRuleTargetsRequest.WebhookParameters]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactParameters != nil {
            var tmp : [Any] = []
            for k in self.contactParameters! {
                tmp.append(k.toMap())
            }
            map["ContactParameters"] = tmp
        }
        if self.fcParameters != nil {
            var tmp : [Any] = []
            for k in self.fcParameters! {
                tmp.append(k.toMap())
            }
            map["FcParameters"] = tmp
        }
        if self.mnsParameters != nil {
            var tmp : [Any] = []
            for k in self.mnsParameters! {
                tmp.append(k.toMap())
            }
            map["MnsParameters"] = tmp
        }
        if self.openApiParameters != nil {
            var tmp : [Any] = []
            for k in self.openApiParameters! {
                tmp.append(k.toMap())
            }
            map["OpenApiParameters"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.slsParameters != nil {
            var tmp : [Any] = []
            for k in self.slsParameters! {
                tmp.append(k.toMap())
            }
            map["SlsParameters"] = tmp
        }
        if self.webhookParameters != nil {
            var tmp : [Any] = []
            for k in self.webhookParameters! {
                tmp.append(k.toMap())
            }
            map["WebhookParameters"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactParameters") && dict["ContactParameters"] != nil {
            var tmp : [PutEventRuleTargetsRequest.ContactParameters] = []
            for v in dict["ContactParameters"] as! [Any] {
                var model = PutEventRuleTargetsRequest.ContactParameters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.contactParameters = tmp
        }
        if dict.keys.contains("FcParameters") && dict["FcParameters"] != nil {
            var tmp : [PutEventRuleTargetsRequest.FcParameters] = []
            for v in dict["FcParameters"] as! [Any] {
                var model = PutEventRuleTargetsRequest.FcParameters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fcParameters = tmp
        }
        if dict.keys.contains("MnsParameters") && dict["MnsParameters"] != nil {
            var tmp : [PutEventRuleTargetsRequest.MnsParameters] = []
            for v in dict["MnsParameters"] as! [Any] {
                var model = PutEventRuleTargetsRequest.MnsParameters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mnsParameters = tmp
        }
        if dict.keys.contains("OpenApiParameters") && dict["OpenApiParameters"] != nil {
            var tmp : [PutEventRuleTargetsRequest.OpenApiParameters] = []
            for v in dict["OpenApiParameters"] as! [Any] {
                var model = PutEventRuleTargetsRequest.OpenApiParameters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.openApiParameters = tmp
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("SlsParameters") && dict["SlsParameters"] != nil {
            var tmp : [PutEventRuleTargetsRequest.SlsParameters] = []
            for v in dict["SlsParameters"] as! [Any] {
                var model = PutEventRuleTargetsRequest.SlsParameters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.slsParameters = tmp
        }
        if dict.keys.contains("WebhookParameters") && dict["WebhookParameters"] != nil {
            var tmp : [PutEventRuleTargetsRequest.WebhookParameters] = []
            for v in dict["WebhookParameters"] as! [Any] {
                var model = PutEventRuleTargetsRequest.WebhookParameters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.webhookParameters = tmp
        }
    }
}

public class PutEventRuleTargetsResponseBody : Tea.TeaModel {
    public class FailedContactParameters : Tea.TeaModel {
        public class ContactParameter : Tea.TeaModel {
            public var contactGroupName: String?

            public var id: Int32?

            public var level: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contactGroupName != nil {
                    map["ContactGroupName"] = self.contactGroupName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContactGroupName") && dict["ContactGroupName"] != nil {
                    self.contactGroupName = dict["ContactGroupName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int32
                }
                if dict.keys.contains("Level") && dict["Level"] != nil {
                    self.level = dict["Level"] as! String
                }
            }
        }
        public var contactParameter: [PutEventRuleTargetsResponseBody.FailedContactParameters.ContactParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contactParameter != nil {
                var tmp : [Any] = []
                for k in self.contactParameter! {
                    tmp.append(k.toMap())
                }
                map["ContactParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContactParameter") && dict["ContactParameter"] != nil {
                var tmp : [PutEventRuleTargetsResponseBody.FailedContactParameters.ContactParameter] = []
                for v in dict["ContactParameter"] as! [Any] {
                    var model = PutEventRuleTargetsResponseBody.FailedContactParameters.ContactParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.contactParameter = tmp
            }
        }
    }
    public class FailedFcParameters : Tea.TeaModel {
        public class FcParameter : Tea.TeaModel {
            public var functionName: String?

            public var id: Int32?

            public var region: String?

            public var serviceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.functionName != nil {
                    map["FunctionName"] = self.functionName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FunctionName") && dict["FunctionName"] != nil {
                    self.functionName = dict["FunctionName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int32
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
            }
        }
        public var fcParameter: [PutEventRuleTargetsResponseBody.FailedFcParameters.FcParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fcParameter != nil {
                var tmp : [Any] = []
                for k in self.fcParameter! {
                    tmp.append(k.toMap())
                }
                map["FcParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FcParameter") && dict["FcParameter"] != nil {
                var tmp : [PutEventRuleTargetsResponseBody.FailedFcParameters.FcParameter] = []
                for v in dict["FcParameter"] as! [Any] {
                    var model = PutEventRuleTargetsResponseBody.FailedFcParameters.FcParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fcParameter = tmp
            }
        }
    }
    public class FailedMnsParameters : Tea.TeaModel {
        public class MnsParameter : Tea.TeaModel {
            public var id: Int32?

            public var queue: String?

            public var region: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.queue != nil {
                    map["Queue"] = self.queue!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int32
                }
                if dict.keys.contains("Queue") && dict["Queue"] != nil {
                    self.queue = dict["Queue"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! String
                }
            }
        }
        public var mnsParameter: [PutEventRuleTargetsResponseBody.FailedMnsParameters.MnsParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mnsParameter != nil {
                var tmp : [Any] = []
                for k in self.mnsParameter! {
                    tmp.append(k.toMap())
                }
                map["MnsParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MnsParameter") && dict["MnsParameter"] != nil {
                var tmp : [PutEventRuleTargetsResponseBody.FailedMnsParameters.MnsParameter] = []
                for v in dict["MnsParameter"] as! [Any] {
                    var model = PutEventRuleTargetsResponseBody.FailedMnsParameters.MnsParameter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mnsParameter = tmp
            }
        }
    }
    public var code: String?

    public var failedContactParameters: PutEventRuleTargetsResponseBody.FailedContactParameters?

    public var failedFcParameters: PutEventRuleTargetsResponseBody.FailedFcParameters?

    public var failedMnsParameters: PutEventRuleTargetsResponseBody.FailedMnsParameters?

    public var failedParameterCount: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.failedContactParameters?.validate()
        try self.failedFcParameters?.validate()
        try self.failedMnsParameters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.failedContactParameters != nil {
            map["FailedContactParameters"] = self.failedContactParameters?.toMap()
        }
        if self.failedFcParameters != nil {
            map["FailedFcParameters"] = self.failedFcParameters?.toMap()
        }
        if self.failedMnsParameters != nil {
            map["FailedMnsParameters"] = self.failedMnsParameters?.toMap()
        }
        if self.failedParameterCount != nil {
            map["FailedParameterCount"] = self.failedParameterCount!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("FailedContactParameters") && dict["FailedContactParameters"] != nil {
            var model = PutEventRuleTargetsResponseBody.FailedContactParameters()
            model.fromMap(dict["FailedContactParameters"] as! [String: Any])
            self.failedContactParameters = model
        }
        if dict.keys.contains("FailedFcParameters") && dict["FailedFcParameters"] != nil {
            var model = PutEventRuleTargetsResponseBody.FailedFcParameters()
            model.fromMap(dict["FailedFcParameters"] as! [String: Any])
            self.failedFcParameters = model
        }
        if dict.keys.contains("FailedMnsParameters") && dict["FailedMnsParameters"] != nil {
            var model = PutEventRuleTargetsResponseBody.FailedMnsParameters()
            model.fromMap(dict["FailedMnsParameters"] as! [String: Any])
            self.failedMnsParameters = model
        }
        if dict.keys.contains("FailedParameterCount") && dict["FailedParameterCount"] != nil {
            self.failedParameterCount = dict["FailedParameterCount"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PutEventRuleTargetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutEventRuleTargetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutEventRuleTargetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutExporterOutputRequest : Tea.TeaModel {
    public var configJson: String?

    public var desc: String?

    public var destName: String?

    public var destType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configJson != nil {
            map["ConfigJson"] = self.configJson!
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.destName != nil {
            map["DestName"] = self.destName!
        }
        if self.destType != nil {
            map["DestType"] = self.destType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigJson") && dict["ConfigJson"] != nil {
            self.configJson = dict["ConfigJson"] as! String
        }
        if dict.keys.contains("Desc") && dict["Desc"] != nil {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("DestName") && dict["DestName"] != nil {
            self.destName = dict["DestName"] as! String
        }
        if dict.keys.contains("DestType") && dict["DestType"] != nil {
            self.destType = dict["DestType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class PutExporterOutputResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PutExporterOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutExporterOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutExporterOutputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutExporterRuleRequest : Tea.TeaModel {
    public var describe: String?

    public var dstNames: [String]?

    public var metricName: String?

    public var namespace: String?

    public var regionId: String?

    public var ruleName: String?

    public var targetWindows: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.describe != nil {
            map["Describe"] = self.describe!
        }
        if self.dstNames != nil {
            map["DstNames"] = self.dstNames!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.targetWindows != nil {
            map["TargetWindows"] = self.targetWindows!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Describe") && dict["Describe"] != nil {
            self.describe = dict["Describe"] as! String
        }
        if dict.keys.contains("DstNames") && dict["DstNames"] != nil {
            self.dstNames = dict["DstNames"] as! [String]
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("TargetWindows") && dict["TargetWindows"] != nil {
            self.targetWindows = dict["TargetWindows"] as! String
        }
    }
}

public class PutExporterRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PutExporterRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutExporterRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutExporterRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutGroupMetricRuleRequest : Tea.TeaModel {
    public class Escalations : Tea.TeaModel {
        public class Critical : Tea.TeaModel {
            public var comparisonOperator: String?

            public var statistics: String?

            public var threshold: String?

            public var times: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comparisonOperator != nil {
                    map["ComparisonOperator"] = self.comparisonOperator!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                if self.times != nil {
                    map["Times"] = self.times!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                    self.comparisonOperator = dict["ComparisonOperator"] as! String
                }
                if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                    self.statistics = dict["Statistics"] as! String
                }
                if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                    self.threshold = dict["Threshold"] as! String
                }
                if dict.keys.contains("Times") && dict["Times"] != nil {
                    self.times = dict["Times"] as! Int32
                }
            }
        }
        public class Info : Tea.TeaModel {
            public var comparisonOperator: String?

            public var statistics: String?

            public var threshold: String?

            public var times: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comparisonOperator != nil {
                    map["ComparisonOperator"] = self.comparisonOperator!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                if self.times != nil {
                    map["Times"] = self.times!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                    self.comparisonOperator = dict["ComparisonOperator"] as! String
                }
                if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                    self.statistics = dict["Statistics"] as! String
                }
                if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                    self.threshold = dict["Threshold"] as! String
                }
                if dict.keys.contains("Times") && dict["Times"] != nil {
                    self.times = dict["Times"] as! Int32
                }
            }
        }
        public class Warn : Tea.TeaModel {
            public var comparisonOperator: String?

            public var statistics: String?

            public var threshold: String?

            public var times: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comparisonOperator != nil {
                    map["ComparisonOperator"] = self.comparisonOperator!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                if self.times != nil {
                    map["Times"] = self.times!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                    self.comparisonOperator = dict["ComparisonOperator"] as! String
                }
                if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                    self.statistics = dict["Statistics"] as! String
                }
                if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                    self.threshold = dict["Threshold"] as! String
                }
                if dict.keys.contains("Times") && dict["Times"] != nil {
                    self.times = dict["Times"] as! Int32
                }
            }
        }
        public var critical: PutGroupMetricRuleRequest.Escalations.Critical?

        public var info: PutGroupMetricRuleRequest.Escalations.Info?

        public var warn: PutGroupMetricRuleRequest.Escalations.Warn?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.critical?.validate()
            try self.info?.validate()
            try self.warn?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.critical != nil {
                map["Critical"] = self.critical?.toMap()
            }
            if self.info != nil {
                map["Info"] = self.info?.toMap()
            }
            if self.warn != nil {
                map["Warn"] = self.warn?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Critical") && dict["Critical"] != nil {
                var model = PutGroupMetricRuleRequest.Escalations.Critical()
                model.fromMap(dict["Critical"] as! [String: Any])
                self.critical = model
            }
            if dict.keys.contains("Info") && dict["Info"] != nil {
                var model = PutGroupMetricRuleRequest.Escalations.Info()
                model.fromMap(dict["Info"] as! [String: Any])
                self.info = model
            }
            if dict.keys.contains("Warn") && dict["Warn"] != nil {
                var model = PutGroupMetricRuleRequest.Escalations.Warn()
                model.fromMap(dict["Warn"] as! [String: Any])
                self.warn = model
            }
        }
    }
    public class Labels : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var escalations: PutGroupMetricRuleRequest.Escalations?

    public var category: String?

    public var contactGroups: String?

    public var dimensions: String?

    public var effectiveInterval: String?

    public var emailSubject: String?

    public var extraDimensionJson: String?

    public var groupId: String?

    public var interval: String?

    public var labels: [PutGroupMetricRuleRequest.Labels]?

    public var metricName: String?

    public var namespace: String?

    public var noDataPolicy: String?

    public var noEffectiveInterval: String?

    public var period: String?

    public var ruleId: String?

    public var ruleName: String?

    public var silenceTime: Int32?

    public var webhook: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.escalations?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.escalations != nil {
            map["Escalations"] = self.escalations?.toMap()
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.contactGroups != nil {
            map["ContactGroups"] = self.contactGroups!
        }
        if self.dimensions != nil {
            map["Dimensions"] = self.dimensions!
        }
        if self.effectiveInterval != nil {
            map["EffectiveInterval"] = self.effectiveInterval!
        }
        if self.emailSubject != nil {
            map["EmailSubject"] = self.emailSubject!
        }
        if self.extraDimensionJson != nil {
            map["ExtraDimensionJson"] = self.extraDimensionJson!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.labels != nil {
            var tmp : [Any] = []
            for k in self.labels! {
                tmp.append(k.toMap())
            }
            map["Labels"] = tmp
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.noDataPolicy != nil {
            map["NoDataPolicy"] = self.noDataPolicy!
        }
        if self.noEffectiveInterval != nil {
            map["NoEffectiveInterval"] = self.noEffectiveInterval!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.silenceTime != nil {
            map["SilenceTime"] = self.silenceTime!
        }
        if self.webhook != nil {
            map["Webhook"] = self.webhook!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Escalations") && dict["Escalations"] != nil {
            var model = PutGroupMetricRuleRequest.Escalations()
            model.fromMap(dict["Escalations"] as! [String: Any])
            self.escalations = model
        }
        if dict.keys.contains("Category") && dict["Category"] != nil {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
            self.contactGroups = dict["ContactGroups"] as! String
        }
        if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
            self.dimensions = dict["Dimensions"] as! String
        }
        if dict.keys.contains("EffectiveInterval") && dict["EffectiveInterval"] != nil {
            self.effectiveInterval = dict["EffectiveInterval"] as! String
        }
        if dict.keys.contains("EmailSubject") && dict["EmailSubject"] != nil {
            self.emailSubject = dict["EmailSubject"] as! String
        }
        if dict.keys.contains("ExtraDimensionJson") && dict["ExtraDimensionJson"] != nil {
            self.extraDimensionJson = dict["ExtraDimensionJson"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("Labels") && dict["Labels"] != nil {
            var tmp : [PutGroupMetricRuleRequest.Labels] = []
            for v in dict["Labels"] as! [Any] {
                var model = PutGroupMetricRuleRequest.Labels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.labels = tmp
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("NoDataPolicy") && dict["NoDataPolicy"] != nil {
            self.noDataPolicy = dict["NoDataPolicy"] as! String
        }
        if dict.keys.contains("NoEffectiveInterval") && dict["NoEffectiveInterval"] != nil {
            self.noEffectiveInterval = dict["NoEffectiveInterval"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
            self.silenceTime = dict["SilenceTime"] as! Int32
        }
        if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
            self.webhook = dict["Webhook"] as! String
        }
    }
}

public class PutGroupMetricRuleResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var ruleId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var result: PutGroupMetricRuleResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            var model = PutGroupMetricRuleResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PutGroupMetricRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutGroupMetricRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutGroupMetricRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutHybridMonitorMetricDataRequest : Tea.TeaModel {
    public class MetricList : Tea.TeaModel {
        public class Labels : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var labels: [PutHybridMonitorMetricDataRequest.MetricList.Labels]?

        public var name: String?

        public var TS: Int64?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["Labels"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.TS != nil {
                map["TS"] = self.TS!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Labels") && dict["Labels"] != nil {
                var tmp : [PutHybridMonitorMetricDataRequest.MetricList.Labels] = []
                for v in dict["Labels"] as! [Any] {
                    var model = PutHybridMonitorMetricDataRequest.MetricList.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TS") && dict["TS"] != nil {
                self.TS = dict["TS"] as! Int64
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var metricList: [PutHybridMonitorMetricDataRequest.MetricList]?

    public var namespace: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.metricList != nil {
            var tmp : [Any] = []
            for k in self.metricList! {
                tmp.append(k.toMap())
            }
            map["MetricList"] = tmp
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MetricList") && dict["MetricList"] != nil {
            var tmp : [PutHybridMonitorMetricDataRequest.MetricList] = []
            for v in dict["MetricList"] as! [Any] {
                var model = PutHybridMonitorMetricDataRequest.MetricList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.metricList = tmp
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class PutHybridMonitorMetricDataResponseBody : Tea.TeaModel {
    public class ErrorDetail : Tea.TeaModel {
        public var errorMessage: String?

        public var index: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.index != nil {
                map["Index"] = self.index!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Index") && dict["Index"] != nil {
                self.index = dict["Index"] as! Int64
            }
        }
    }
    public var code: String?

    public var errorDetail: [PutHybridMonitorMetricDataResponseBody.ErrorDetail]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorDetail != nil {
            var tmp : [Any] = []
            for k in self.errorDetail! {
                tmp.append(k.toMap())
            }
            map["ErrorDetail"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ErrorDetail") && dict["ErrorDetail"] != nil {
            var tmp : [PutHybridMonitorMetricDataResponseBody.ErrorDetail] = []
            for v in dict["ErrorDetail"] as! [Any] {
                var model = PutHybridMonitorMetricDataResponseBody.ErrorDetail()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.errorDetail = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PutHybridMonitorMetricDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutHybridMonitorMetricDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutHybridMonitorMetricDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutLogMonitorRequest : Tea.TeaModel {
    public class Aggregates : Tea.TeaModel {
        public var alias: String?

        public var fieldName: String?

        public var function: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alias != nil {
                map["Alias"] = self.alias!
            }
            if self.fieldName != nil {
                map["FieldName"] = self.fieldName!
            }
            if self.function != nil {
                map["Function"] = self.function!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alias") && dict["Alias"] != nil {
                self.alias = dict["Alias"] as! String
            }
            if dict.keys.contains("FieldName") && dict["FieldName"] != nil {
                self.fieldName = dict["FieldName"] as! String
            }
            if dict.keys.contains("Function") && dict["Function"] != nil {
                self.function = dict["Function"] as! String
            }
        }
    }
    public class Groupbys : Tea.TeaModel {
        public var alias: String?

        public var fieldName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alias != nil {
                map["Alias"] = self.alias!
            }
            if self.fieldName != nil {
                map["FieldName"] = self.fieldName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alias") && dict["Alias"] != nil {
                self.alias = dict["Alias"] as! String
            }
            if dict.keys.contains("FieldName") && dict["FieldName"] != nil {
                self.fieldName = dict["FieldName"] as! String
            }
        }
    }
    public class ValueFilter : Tea.TeaModel {
        public var key: String?

        public var operator_: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Operator") && dict["Operator"] != nil {
                self.operator_ = dict["Operator"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var aggregates: [PutLogMonitorRequest.Aggregates]?

    public var groupId: String?

    public var groupbys: [PutLogMonitorRequest.Groupbys]?

    public var logId: String?

    public var metricExpress: String?

    public var metricName: String?

    public var regionId: String?

    public var slsLogstore: String?

    public var slsProject: String?

    public var slsRegionId: String?

    public var tumblingwindows: String?

    public var unit: String?

    public var valueFilter: [PutLogMonitorRequest.ValueFilter]?

    public var valueFilterRelation: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregates != nil {
            var tmp : [Any] = []
            for k in self.aggregates! {
                tmp.append(k.toMap())
            }
            map["Aggregates"] = tmp
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupbys != nil {
            var tmp : [Any] = []
            for k in self.groupbys! {
                tmp.append(k.toMap())
            }
            map["Groupbys"] = tmp
        }
        if self.logId != nil {
            map["LogId"] = self.logId!
        }
        if self.metricExpress != nil {
            map["MetricExpress"] = self.metricExpress!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.slsLogstore != nil {
            map["SlsLogstore"] = self.slsLogstore!
        }
        if self.slsProject != nil {
            map["SlsProject"] = self.slsProject!
        }
        if self.slsRegionId != nil {
            map["SlsRegionId"] = self.slsRegionId!
        }
        if self.tumblingwindows != nil {
            map["Tumblingwindows"] = self.tumblingwindows!
        }
        if self.unit != nil {
            map["Unit"] = self.unit!
        }
        if self.valueFilter != nil {
            var tmp : [Any] = []
            for k in self.valueFilter! {
                tmp.append(k.toMap())
            }
            map["ValueFilter"] = tmp
        }
        if self.valueFilterRelation != nil {
            map["ValueFilterRelation"] = self.valueFilterRelation!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Aggregates") && dict["Aggregates"] != nil {
            var tmp : [PutLogMonitorRequest.Aggregates] = []
            for v in dict["Aggregates"] as! [Any] {
                var model = PutLogMonitorRequest.Aggregates()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.aggregates = tmp
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Groupbys") && dict["Groupbys"] != nil {
            var tmp : [PutLogMonitorRequest.Groupbys] = []
            for v in dict["Groupbys"] as! [Any] {
                var model = PutLogMonitorRequest.Groupbys()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.groupbys = tmp
        }
        if dict.keys.contains("LogId") && dict["LogId"] != nil {
            self.logId = dict["LogId"] as! String
        }
        if dict.keys.contains("MetricExpress") && dict["MetricExpress"] != nil {
            self.metricExpress = dict["MetricExpress"] as! String
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SlsLogstore") && dict["SlsLogstore"] != nil {
            self.slsLogstore = dict["SlsLogstore"] as! String
        }
        if dict.keys.contains("SlsProject") && dict["SlsProject"] != nil {
            self.slsProject = dict["SlsProject"] as! String
        }
        if dict.keys.contains("SlsRegionId") && dict["SlsRegionId"] != nil {
            self.slsRegionId = dict["SlsRegionId"] as! String
        }
        if dict.keys.contains("Tumblingwindows") && dict["Tumblingwindows"] != nil {
            self.tumblingwindows = dict["Tumblingwindows"] as! String
        }
        if dict.keys.contains("Unit") && dict["Unit"] != nil {
            self.unit = dict["Unit"] as! String
        }
        if dict.keys.contains("ValueFilter") && dict["ValueFilter"] != nil {
            var tmp : [PutLogMonitorRequest.ValueFilter] = []
            for v in dict["ValueFilter"] as! [Any] {
                var model = PutLogMonitorRequest.ValueFilter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.valueFilter = tmp
        }
        if dict.keys.contains("ValueFilterRelation") && dict["ValueFilterRelation"] != nil {
            self.valueFilterRelation = dict["ValueFilterRelation"] as! String
        }
    }
}

public class PutLogMonitorResponseBody : Tea.TeaModel {
    public var code: String?

    public var logId: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logId != nil {
            map["LogId"] = self.logId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogId") && dict["LogId"] != nil {
            self.logId = dict["LogId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PutLogMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutLogMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutLogMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutMetricRuleTargetsRequest : Tea.TeaModel {
    public class Targets : Tea.TeaModel {
        public var arn: String?

        public var id: String?

        public var jsonParams: String?

        public var level: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.arn != nil {
                map["Arn"] = self.arn!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.jsonParams != nil {
                map["JsonParams"] = self.jsonParams!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Arn") && dict["Arn"] != nil {
                self.arn = dict["Arn"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("JsonParams") && dict["JsonParams"] != nil {
                self.jsonParams = dict["JsonParams"] as! String
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
        }
    }
    public var regionId: String?

    public var ruleId: String?

    public var targets: [PutMetricRuleTargetsRequest.Targets]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.targets != nil {
            var tmp : [Any] = []
            for k in self.targets! {
                tmp.append(k.toMap())
            }
            map["Targets"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("Targets") && dict["Targets"] != nil {
            var tmp : [PutMetricRuleTargetsRequest.Targets] = []
            for v in dict["Targets"] as! [Any] {
                var model = PutMetricRuleTargetsRequest.Targets()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.targets = tmp
        }
    }
}

public class PutMetricRuleTargetsResponseBody : Tea.TeaModel {
    public class FailData : Tea.TeaModel {
        public class Targets : Tea.TeaModel {
            public class Target : Tea.TeaModel {
                public var arn: String?

                public var id: String?

                public var level: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.arn != nil {
                        map["Arn"] = self.arn!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Arn") && dict["Arn"] != nil {
                        self.arn = dict["Arn"] as! String
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("Level") && dict["Level"] != nil {
                        self.level = dict["Level"] as! String
                    }
                }
            }
            public var target: [PutMetricRuleTargetsResponseBody.FailData.Targets.Target]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.target != nil {
                    var tmp : [Any] = []
                    for k in self.target! {
                        tmp.append(k.toMap())
                    }
                    map["Target"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Target") && dict["Target"] != nil {
                    var tmp : [PutMetricRuleTargetsResponseBody.FailData.Targets.Target] = []
                    for v in dict["Target"] as! [Any] {
                        var model = PutMetricRuleTargetsResponseBody.FailData.Targets.Target()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.target = tmp
                }
            }
        }
        public var targets: PutMetricRuleTargetsResponseBody.FailData.Targets?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.targets?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.targets != nil {
                map["Targets"] = self.targets?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Targets") && dict["Targets"] != nil {
                var model = PutMetricRuleTargetsResponseBody.FailData.Targets()
                model.fromMap(dict["Targets"] as! [String: Any])
                self.targets = model
            }
        }
    }
    public var code: String?

    public var failData: PutMetricRuleTargetsResponseBody.FailData?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.failData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.failData != nil {
            map["FailData"] = self.failData?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("FailData") && dict["FailData"] != nil {
            var model = PutMetricRuleTargetsResponseBody.FailData()
            model.fromMap(dict["FailData"] as! [String: Any])
            self.failData = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PutMetricRuleTargetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutMetricRuleTargetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutMetricRuleTargetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutMonitorGroupDynamicRuleRequest : Tea.TeaModel {
    public class GroupRules : Tea.TeaModel {
        public class Filters : Tea.TeaModel {
            public var function: String?

            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.function != nil {
                    map["Function"] = self.function!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Function") && dict["Function"] != nil {
                    self.function = dict["Function"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var category: String?

        public var filterRelation: String?

        public var filters: [PutMonitorGroupDynamicRuleRequest.GroupRules.Filters]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.filterRelation != nil {
                map["FilterRelation"] = self.filterRelation!
            }
            if self.filters != nil {
                var tmp : [Any] = []
                for k in self.filters! {
                    tmp.append(k.toMap())
                }
                map["Filters"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("FilterRelation") && dict["FilterRelation"] != nil {
                self.filterRelation = dict["FilterRelation"] as! String
            }
            if dict.keys.contains("Filters") && dict["Filters"] != nil {
                var tmp : [PutMonitorGroupDynamicRuleRequest.GroupRules.Filters] = []
                for v in dict["Filters"] as! [Any] {
                    var model = PutMonitorGroupDynamicRuleRequest.GroupRules.Filters()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.filters = tmp
            }
        }
    }
    public var groupId: Int64?

    public var groupRules: [PutMonitorGroupDynamicRuleRequest.GroupRules]?

    public var isAsync: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupRules != nil {
            var tmp : [Any] = []
            for k in self.groupRules! {
                tmp.append(k.toMap())
            }
            map["GroupRules"] = tmp
        }
        if self.isAsync != nil {
            map["IsAsync"] = self.isAsync!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("GroupRules") && dict["GroupRules"] != nil {
            var tmp : [PutMonitorGroupDynamicRuleRequest.GroupRules] = []
            for v in dict["GroupRules"] as! [Any] {
                var model = PutMonitorGroupDynamicRuleRequest.GroupRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.groupRules = tmp
        }
        if dict.keys.contains("IsAsync") && dict["IsAsync"] != nil {
            self.isAsync = dict["IsAsync"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class PutMonitorGroupDynamicRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PutMonitorGroupDynamicRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutMonitorGroupDynamicRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutMonitorGroupDynamicRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutMonitoringConfigRequest : Tea.TeaModel {
    public var autoInstall: Bool?

    public var enableInstallAgentNewECS: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoInstall != nil {
            map["AutoInstall"] = self.autoInstall!
        }
        if self.enableInstallAgentNewECS != nil {
            map["EnableInstallAgentNewECS"] = self.enableInstallAgentNewECS!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoInstall") && dict["AutoInstall"] != nil {
            self.autoInstall = dict["AutoInstall"] as! Bool
        }
        if dict.keys.contains("EnableInstallAgentNewECS") && dict["EnableInstallAgentNewECS"] != nil {
            self.enableInstallAgentNewECS = dict["EnableInstallAgentNewECS"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class PutMonitoringConfigResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PutMonitoringConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutMonitoringConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutMonitoringConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutResourceMetricRuleRequest : Tea.TeaModel {
    public class Escalations : Tea.TeaModel {
        public class Critical : Tea.TeaModel {
            public var comparisonOperator: String?

            public var statistics: String?

            public var threshold: String?

            public var times: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comparisonOperator != nil {
                    map["ComparisonOperator"] = self.comparisonOperator!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                if self.times != nil {
                    map["Times"] = self.times!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                    self.comparisonOperator = dict["ComparisonOperator"] as! String
                }
                if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                    self.statistics = dict["Statistics"] as! String
                }
                if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                    self.threshold = dict["Threshold"] as! String
                }
                if dict.keys.contains("Times") && dict["Times"] != nil {
                    self.times = dict["Times"] as! Int32
                }
            }
        }
        public class Info : Tea.TeaModel {
            public var comparisonOperator: String?

            public var statistics: String?

            public var threshold: String?

            public var times: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comparisonOperator != nil {
                    map["ComparisonOperator"] = self.comparisonOperator!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                if self.times != nil {
                    map["Times"] = self.times!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                    self.comparisonOperator = dict["ComparisonOperator"] as! String
                }
                if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                    self.statistics = dict["Statistics"] as! String
                }
                if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                    self.threshold = dict["Threshold"] as! String
                }
                if dict.keys.contains("Times") && dict["Times"] != nil {
                    self.times = dict["Times"] as! Int32
                }
            }
        }
        public class Warn : Tea.TeaModel {
            public var comparisonOperator: String?

            public var statistics: String?

            public var threshold: String?

            public var times: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comparisonOperator != nil {
                    map["ComparisonOperator"] = self.comparisonOperator!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                if self.times != nil {
                    map["Times"] = self.times!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                    self.comparisonOperator = dict["ComparisonOperator"] as! String
                }
                if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                    self.statistics = dict["Statistics"] as! String
                }
                if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                    self.threshold = dict["Threshold"] as! String
                }
                if dict.keys.contains("Times") && dict["Times"] != nil {
                    self.times = dict["Times"] as! Int32
                }
            }
        }
        public var critical: PutResourceMetricRuleRequest.Escalations.Critical?

        public var info: PutResourceMetricRuleRequest.Escalations.Info?

        public var warn: PutResourceMetricRuleRequest.Escalations.Warn?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.critical?.validate()
            try self.info?.validate()
            try self.warn?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.critical != nil {
                map["Critical"] = self.critical?.toMap()
            }
            if self.info != nil {
                map["Info"] = self.info?.toMap()
            }
            if self.warn != nil {
                map["Warn"] = self.warn?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Critical") && dict["Critical"] != nil {
                var model = PutResourceMetricRuleRequest.Escalations.Critical()
                model.fromMap(dict["Critical"] as! [String: Any])
                self.critical = model
            }
            if dict.keys.contains("Info") && dict["Info"] != nil {
                var model = PutResourceMetricRuleRequest.Escalations.Info()
                model.fromMap(dict["Info"] as! [String: Any])
                self.info = model
            }
            if dict.keys.contains("Warn") && dict["Warn"] != nil {
                var model = PutResourceMetricRuleRequest.Escalations.Warn()
                model.fromMap(dict["Warn"] as! [String: Any])
                self.warn = model
            }
        }
    }
    public class CompositeExpression : Tea.TeaModel {
        public class ExpressionList : Tea.TeaModel {
            public var comparisonOperator: String?

            public var metricName: String?

            public var period: Int64?

            public var statistics: String?

            public var threshold: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comparisonOperator != nil {
                    map["ComparisonOperator"] = self.comparisonOperator!
                }
                if self.metricName != nil {
                    map["MetricName"] = self.metricName!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                    self.comparisonOperator = dict["ComparisonOperator"] as! String
                }
                if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                    self.metricName = dict["MetricName"] as! String
                }
                if dict.keys.contains("Period") && dict["Period"] != nil {
                    self.period = dict["Period"] as! Int64
                }
                if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                    self.statistics = dict["Statistics"] as! String
                }
                if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                    self.threshold = dict["Threshold"] as! String
                }
            }
        }
        public var expressionList: [PutResourceMetricRuleRequest.CompositeExpression.ExpressionList]?

        public var expressionListJoin: String?

        public var expressionRaw: String?

        public var level: String?

        public var times: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expressionList != nil {
                var tmp : [Any] = []
                for k in self.expressionList! {
                    tmp.append(k.toMap())
                }
                map["ExpressionList"] = tmp
            }
            if self.expressionListJoin != nil {
                map["ExpressionListJoin"] = self.expressionListJoin!
            }
            if self.expressionRaw != nil {
                map["ExpressionRaw"] = self.expressionRaw!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.times != nil {
                map["Times"] = self.times!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExpressionList") && dict["ExpressionList"] != nil {
                var tmp : [PutResourceMetricRuleRequest.CompositeExpression.ExpressionList] = []
                for v in dict["ExpressionList"] as! [Any] {
                    var model = PutResourceMetricRuleRequest.CompositeExpression.ExpressionList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.expressionList = tmp
            }
            if dict.keys.contains("ExpressionListJoin") && dict["ExpressionListJoin"] != nil {
                self.expressionListJoin = dict["ExpressionListJoin"] as! String
            }
            if dict.keys.contains("ExpressionRaw") && dict["ExpressionRaw"] != nil {
                self.expressionRaw = dict["ExpressionRaw"] as! String
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Times") && dict["Times"] != nil {
                self.times = dict["Times"] as! Int32
            }
        }
    }
    public class Labels : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Prometheus : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var annotations: [PutResourceMetricRuleRequest.Prometheus.Annotations]?

        public var level: String?

        public var promQL: String?

        public var times: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["Annotations"] = tmp
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.promQL != nil {
                map["PromQL"] = self.promQL!
            }
            if self.times != nil {
                map["Times"] = self.times!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
                var tmp : [PutResourceMetricRuleRequest.Prometheus.Annotations] = []
                for v in dict["Annotations"] as! [Any] {
                    var model = PutResourceMetricRuleRequest.Prometheus.Annotations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.annotations = tmp
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("PromQL") && dict["PromQL"] != nil {
                self.promQL = dict["PromQL"] as! String
            }
            if dict.keys.contains("Times") && dict["Times"] != nil {
                self.times = dict["Times"] as! Int32
            }
        }
    }
    public var escalations: PutResourceMetricRuleRequest.Escalations?

    public var compositeExpression: PutResourceMetricRuleRequest.CompositeExpression?

    public var contactGroups: String?

    public var effectiveInterval: String?

    public var emailSubject: String?

    public var interval: String?

    public var labels: [PutResourceMetricRuleRequest.Labels]?

    public var metricName: String?

    public var namespace: String?

    public var noDataPolicy: String?

    public var noEffectiveInterval: String?

    public var period: String?

    public var prometheus: PutResourceMetricRuleRequest.Prometheus?

    public var resources: String?

    public var ruleId: String?

    public var ruleName: String?

    public var silenceTime: Int32?

    public var webhook: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.escalations?.validate()
        try self.compositeExpression?.validate()
        try self.prometheus?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.escalations != nil {
            map["Escalations"] = self.escalations?.toMap()
        }
        if self.compositeExpression != nil {
            map["CompositeExpression"] = self.compositeExpression?.toMap()
        }
        if self.contactGroups != nil {
            map["ContactGroups"] = self.contactGroups!
        }
        if self.effectiveInterval != nil {
            map["EffectiveInterval"] = self.effectiveInterval!
        }
        if self.emailSubject != nil {
            map["EmailSubject"] = self.emailSubject!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.labels != nil {
            var tmp : [Any] = []
            for k in self.labels! {
                tmp.append(k.toMap())
            }
            map["Labels"] = tmp
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.noDataPolicy != nil {
            map["NoDataPolicy"] = self.noDataPolicy!
        }
        if self.noEffectiveInterval != nil {
            map["NoEffectiveInterval"] = self.noEffectiveInterval!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.prometheus != nil {
            map["Prometheus"] = self.prometheus?.toMap()
        }
        if self.resources != nil {
            map["Resources"] = self.resources!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.silenceTime != nil {
            map["SilenceTime"] = self.silenceTime!
        }
        if self.webhook != nil {
            map["Webhook"] = self.webhook!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Escalations") && dict["Escalations"] != nil {
            var model = PutResourceMetricRuleRequest.Escalations()
            model.fromMap(dict["Escalations"] as! [String: Any])
            self.escalations = model
        }
        if dict.keys.contains("CompositeExpression") && dict["CompositeExpression"] != nil {
            var model = PutResourceMetricRuleRequest.CompositeExpression()
            model.fromMap(dict["CompositeExpression"] as! [String: Any])
            self.compositeExpression = model
        }
        if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
            self.contactGroups = dict["ContactGroups"] as! String
        }
        if dict.keys.contains("EffectiveInterval") && dict["EffectiveInterval"] != nil {
            self.effectiveInterval = dict["EffectiveInterval"] as! String
        }
        if dict.keys.contains("EmailSubject") && dict["EmailSubject"] != nil {
            self.emailSubject = dict["EmailSubject"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("Labels") && dict["Labels"] != nil {
            var tmp : [PutResourceMetricRuleRequest.Labels] = []
            for v in dict["Labels"] as! [Any] {
                var model = PutResourceMetricRuleRequest.Labels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.labels = tmp
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("NoDataPolicy") && dict["NoDataPolicy"] != nil {
            self.noDataPolicy = dict["NoDataPolicy"] as! String
        }
        if dict.keys.contains("NoEffectiveInterval") && dict["NoEffectiveInterval"] != nil {
            self.noEffectiveInterval = dict["NoEffectiveInterval"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("Prometheus") && dict["Prometheus"] != nil {
            var model = PutResourceMetricRuleRequest.Prometheus()
            model.fromMap(dict["Prometheus"] as! [String: Any])
            self.prometheus = model
        }
        if dict.keys.contains("Resources") && dict["Resources"] != nil {
            self.resources = dict["Resources"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
            self.silenceTime = dict["SilenceTime"] as! Int32
        }
        if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
            self.webhook = dict["Webhook"] as! String
        }
    }
}

public class PutResourceMetricRuleShrinkRequest : Tea.TeaModel {
    public class Escalations : Tea.TeaModel {
        public class Critical : Tea.TeaModel {
            public var comparisonOperator: String?

            public var statistics: String?

            public var threshold: String?

            public var times: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comparisonOperator != nil {
                    map["ComparisonOperator"] = self.comparisonOperator!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                if self.times != nil {
                    map["Times"] = self.times!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                    self.comparisonOperator = dict["ComparisonOperator"] as! String
                }
                if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                    self.statistics = dict["Statistics"] as! String
                }
                if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                    self.threshold = dict["Threshold"] as! String
                }
                if dict.keys.contains("Times") && dict["Times"] != nil {
                    self.times = dict["Times"] as! Int32
                }
            }
        }
        public class Info : Tea.TeaModel {
            public var comparisonOperator: String?

            public var statistics: String?

            public var threshold: String?

            public var times: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comparisonOperator != nil {
                    map["ComparisonOperator"] = self.comparisonOperator!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                if self.times != nil {
                    map["Times"] = self.times!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                    self.comparisonOperator = dict["ComparisonOperator"] as! String
                }
                if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                    self.statistics = dict["Statistics"] as! String
                }
                if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                    self.threshold = dict["Threshold"] as! String
                }
                if dict.keys.contains("Times") && dict["Times"] != nil {
                    self.times = dict["Times"] as! Int32
                }
            }
        }
        public class Warn : Tea.TeaModel {
            public var comparisonOperator: String?

            public var statistics: String?

            public var threshold: String?

            public var times: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comparisonOperator != nil {
                    map["ComparisonOperator"] = self.comparisonOperator!
                }
                if self.statistics != nil {
                    map["Statistics"] = self.statistics!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                if self.times != nil {
                    map["Times"] = self.times!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                    self.comparisonOperator = dict["ComparisonOperator"] as! String
                }
                if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                    self.statistics = dict["Statistics"] as! String
                }
                if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                    self.threshold = dict["Threshold"] as! String
                }
                if dict.keys.contains("Times") && dict["Times"] != nil {
                    self.times = dict["Times"] as! Int32
                }
            }
        }
        public var critical: PutResourceMetricRuleShrinkRequest.Escalations.Critical?

        public var info: PutResourceMetricRuleShrinkRequest.Escalations.Info?

        public var warn: PutResourceMetricRuleShrinkRequest.Escalations.Warn?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.critical?.validate()
            try self.info?.validate()
            try self.warn?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.critical != nil {
                map["Critical"] = self.critical?.toMap()
            }
            if self.info != nil {
                map["Info"] = self.info?.toMap()
            }
            if self.warn != nil {
                map["Warn"] = self.warn?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Critical") && dict["Critical"] != nil {
                var model = PutResourceMetricRuleShrinkRequest.Escalations.Critical()
                model.fromMap(dict["Critical"] as! [String: Any])
                self.critical = model
            }
            if dict.keys.contains("Info") && dict["Info"] != nil {
                var model = PutResourceMetricRuleShrinkRequest.Escalations.Info()
                model.fromMap(dict["Info"] as! [String: Any])
                self.info = model
            }
            if dict.keys.contains("Warn") && dict["Warn"] != nil {
                var model = PutResourceMetricRuleShrinkRequest.Escalations.Warn()
                model.fromMap(dict["Warn"] as! [String: Any])
                self.warn = model
            }
        }
    }
    public class Labels : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var escalations: PutResourceMetricRuleShrinkRequest.Escalations?

    public var compositeExpressionShrink: String?

    public var contactGroups: String?

    public var effectiveInterval: String?

    public var emailSubject: String?

    public var interval: String?

    public var labels: [PutResourceMetricRuleShrinkRequest.Labels]?

    public var metricName: String?

    public var namespace: String?

    public var noDataPolicy: String?

    public var noEffectiveInterval: String?

    public var period: String?

    public var prometheusShrink: String?

    public var resources: String?

    public var ruleId: String?

    public var ruleName: String?

    public var silenceTime: Int32?

    public var webhook: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.escalations?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.escalations != nil {
            map["Escalations"] = self.escalations?.toMap()
        }
        if self.compositeExpressionShrink != nil {
            map["CompositeExpression"] = self.compositeExpressionShrink!
        }
        if self.contactGroups != nil {
            map["ContactGroups"] = self.contactGroups!
        }
        if self.effectiveInterval != nil {
            map["EffectiveInterval"] = self.effectiveInterval!
        }
        if self.emailSubject != nil {
            map["EmailSubject"] = self.emailSubject!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.labels != nil {
            var tmp : [Any] = []
            for k in self.labels! {
                tmp.append(k.toMap())
            }
            map["Labels"] = tmp
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.noDataPolicy != nil {
            map["NoDataPolicy"] = self.noDataPolicy!
        }
        if self.noEffectiveInterval != nil {
            map["NoEffectiveInterval"] = self.noEffectiveInterval!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.prometheusShrink != nil {
            map["Prometheus"] = self.prometheusShrink!
        }
        if self.resources != nil {
            map["Resources"] = self.resources!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.silenceTime != nil {
            map["SilenceTime"] = self.silenceTime!
        }
        if self.webhook != nil {
            map["Webhook"] = self.webhook!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Escalations") && dict["Escalations"] != nil {
            var model = PutResourceMetricRuleShrinkRequest.Escalations()
            model.fromMap(dict["Escalations"] as! [String: Any])
            self.escalations = model
        }
        if dict.keys.contains("CompositeExpression") && dict["CompositeExpression"] != nil {
            self.compositeExpressionShrink = dict["CompositeExpression"] as! String
        }
        if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
            self.contactGroups = dict["ContactGroups"] as! String
        }
        if dict.keys.contains("EffectiveInterval") && dict["EffectiveInterval"] != nil {
            self.effectiveInterval = dict["EffectiveInterval"] as! String
        }
        if dict.keys.contains("EmailSubject") && dict["EmailSubject"] != nil {
            self.emailSubject = dict["EmailSubject"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("Labels") && dict["Labels"] != nil {
            var tmp : [PutResourceMetricRuleShrinkRequest.Labels] = []
            for v in dict["Labels"] as! [Any] {
                var model = PutResourceMetricRuleShrinkRequest.Labels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.labels = tmp
        }
        if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("NoDataPolicy") && dict["NoDataPolicy"] != nil {
            self.noDataPolicy = dict["NoDataPolicy"] as! String
        }
        if dict.keys.contains("NoEffectiveInterval") && dict["NoEffectiveInterval"] != nil {
            self.noEffectiveInterval = dict["NoEffectiveInterval"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("Prometheus") && dict["Prometheus"] != nil {
            self.prometheusShrink = dict["Prometheus"] as! String
        }
        if dict.keys.contains("Resources") && dict["Resources"] != nil {
            self.resources = dict["Resources"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
            self.silenceTime = dict["SilenceTime"] as! Int32
        }
        if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
            self.webhook = dict["Webhook"] as! String
        }
    }
}

public class PutResourceMetricRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PutResourceMetricRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutResourceMetricRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutResourceMetricRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutResourceMetricRulesRequest : Tea.TeaModel {
    public class Rules : Tea.TeaModel {
        public class Escalations : Tea.TeaModel {
            public class Critical : Tea.TeaModel {
                public var comparisonOperator: String?

                public var n: Int32?

                public var preCondition: String?

                public var statistics: String?

                public var threshold: String?

                public var times: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.comparisonOperator != nil {
                        map["ComparisonOperator"] = self.comparisonOperator!
                    }
                    if self.n != nil {
                        map["N"] = self.n!
                    }
                    if self.preCondition != nil {
                        map["PreCondition"] = self.preCondition!
                    }
                    if self.statistics != nil {
                        map["Statistics"] = self.statistics!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    if self.times != nil {
                        map["Times"] = self.times!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                        self.comparisonOperator = dict["ComparisonOperator"] as! String
                    }
                    if dict.keys.contains("N") && dict["N"] != nil {
                        self.n = dict["N"] as! Int32
                    }
                    if dict.keys.contains("PreCondition") && dict["PreCondition"] != nil {
                        self.preCondition = dict["PreCondition"] as! String
                    }
                    if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                        self.statistics = dict["Statistics"] as! String
                    }
                    if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                        self.threshold = dict["Threshold"] as! String
                    }
                    if dict.keys.contains("Times") && dict["Times"] != nil {
                        self.times = dict["Times"] as! Int32
                    }
                }
            }
            public class Info : Tea.TeaModel {
                public var comparisonOperator: String?

                public var n: Int32?

                public var preCondition: String?

                public var statistics: String?

                public var threshold: String?

                public var times: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.comparisonOperator != nil {
                        map["ComparisonOperator"] = self.comparisonOperator!
                    }
                    if self.n != nil {
                        map["N"] = self.n!
                    }
                    if self.preCondition != nil {
                        map["PreCondition"] = self.preCondition!
                    }
                    if self.statistics != nil {
                        map["Statistics"] = self.statistics!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    if self.times != nil {
                        map["Times"] = self.times!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                        self.comparisonOperator = dict["ComparisonOperator"] as! String
                    }
                    if dict.keys.contains("N") && dict["N"] != nil {
                        self.n = dict["N"] as! Int32
                    }
                    if dict.keys.contains("PreCondition") && dict["PreCondition"] != nil {
                        self.preCondition = dict["PreCondition"] as! String
                    }
                    if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                        self.statistics = dict["Statistics"] as! String
                    }
                    if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                        self.threshold = dict["Threshold"] as! String
                    }
                    if dict.keys.contains("Times") && dict["Times"] != nil {
                        self.times = dict["Times"] as! Int32
                    }
                }
            }
            public class Warn : Tea.TeaModel {
                public var comparisonOperator: String?

                public var n: Int32?

                public var preCondition: String?

                public var statistics: String?

                public var threshold: String?

                public var times: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.comparisonOperator != nil {
                        map["ComparisonOperator"] = self.comparisonOperator!
                    }
                    if self.n != nil {
                        map["N"] = self.n!
                    }
                    if self.preCondition != nil {
                        map["PreCondition"] = self.preCondition!
                    }
                    if self.statistics != nil {
                        map["Statistics"] = self.statistics!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    if self.times != nil {
                        map["Times"] = self.times!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                        self.comparisonOperator = dict["ComparisonOperator"] as! String
                    }
                    if dict.keys.contains("N") && dict["N"] != nil {
                        self.n = dict["N"] as! Int32
                    }
                    if dict.keys.contains("PreCondition") && dict["PreCondition"] != nil {
                        self.preCondition = dict["PreCondition"] as! String
                    }
                    if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                        self.statistics = dict["Statistics"] as! String
                    }
                    if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                        self.threshold = dict["Threshold"] as! String
                    }
                    if dict.keys.contains("Times") && dict["Times"] != nil {
                        self.times = dict["Times"] as! Int32
                    }
                }
            }
            public var critical: PutResourceMetricRulesRequest.Rules.Escalations.Critical?

            public var info: PutResourceMetricRulesRequest.Rules.Escalations.Info?

            public var warn: PutResourceMetricRulesRequest.Rules.Escalations.Warn?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.critical?.validate()
                try self.info?.validate()
                try self.warn?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.critical != nil {
                    map["Critical"] = self.critical?.toMap()
                }
                if self.info != nil {
                    map["Info"] = self.info?.toMap()
                }
                if self.warn != nil {
                    map["Warn"] = self.warn?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Critical") && dict["Critical"] != nil {
                    var model = PutResourceMetricRulesRequest.Rules.Escalations.Critical()
                    model.fromMap(dict["Critical"] as! [String: Any])
                    self.critical = model
                }
                if dict.keys.contains("Info") && dict["Info"] != nil {
                    var model = PutResourceMetricRulesRequest.Rules.Escalations.Info()
                    model.fromMap(dict["Info"] as! [String: Any])
                    self.info = model
                }
                if dict.keys.contains("Warn") && dict["Warn"] != nil {
                    var model = PutResourceMetricRulesRequest.Rules.Escalations.Warn()
                    model.fromMap(dict["Warn"] as! [String: Any])
                    self.warn = model
                }
            }
        }
        public class Labels : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var escalations: PutResourceMetricRulesRequest.Rules.Escalations?

        public var contactGroups: String?

        public var effectiveInterval: String?

        public var emailSubject: String?

        public var interval: String?

        public var labels: [PutResourceMetricRulesRequest.Rules.Labels]?

        public var metricName: String?

        public var namespace: String?

        public var noDataPolicy: String?

        public var noEffectiveInterval: String?

        public var period: String?

        public var resources: String?

        public var ruleId: String?

        public var ruleName: String?

        public var silenceTime: Int32?

        public var webhook: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.escalations?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.escalations != nil {
                map["Escalations"] = self.escalations?.toMap()
            }
            if self.contactGroups != nil {
                map["ContactGroups"] = self.contactGroups!
            }
            if self.effectiveInterval != nil {
                map["EffectiveInterval"] = self.effectiveInterval!
            }
            if self.emailSubject != nil {
                map["EmailSubject"] = self.emailSubject!
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["Labels"] = tmp
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.noDataPolicy != nil {
                map["NoDataPolicy"] = self.noDataPolicy!
            }
            if self.noEffectiveInterval != nil {
                map["NoEffectiveInterval"] = self.noEffectiveInterval!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.resources != nil {
                map["Resources"] = self.resources!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.silenceTime != nil {
                map["SilenceTime"] = self.silenceTime!
            }
            if self.webhook != nil {
                map["Webhook"] = self.webhook!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Escalations") && dict["Escalations"] != nil {
                var model = PutResourceMetricRulesRequest.Rules.Escalations()
                model.fromMap(dict["Escalations"] as! [String: Any])
                self.escalations = model
            }
            if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
                self.contactGroups = dict["ContactGroups"] as! String
            }
            if dict.keys.contains("EffectiveInterval") && dict["EffectiveInterval"] != nil {
                self.effectiveInterval = dict["EffectiveInterval"] as! String
            }
            if dict.keys.contains("EmailSubject") && dict["EmailSubject"] != nil {
                self.emailSubject = dict["EmailSubject"] as! String
            }
            if dict.keys.contains("Interval") && dict["Interval"] != nil {
                self.interval = dict["Interval"] as! String
            }
            if dict.keys.contains("Labels") && dict["Labels"] != nil {
                var tmp : [PutResourceMetricRulesRequest.Rules.Labels] = []
                for v in dict["Labels"] as! [Any] {
                    var model = PutResourceMetricRulesRequest.Rules.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NoDataPolicy") && dict["NoDataPolicy"] != nil {
                self.noDataPolicy = dict["NoDataPolicy"] as! String
            }
            if dict.keys.contains("NoEffectiveInterval") && dict["NoEffectiveInterval"] != nil {
                self.noEffectiveInterval = dict["NoEffectiveInterval"] as! String
            }
            if dict.keys.contains("Period") && dict["Period"] != nil {
                self.period = dict["Period"] as! String
            }
            if dict.keys.contains("Resources") && dict["Resources"] != nil {
                self.resources = dict["Resources"] as! String
            }
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! String
            }
            if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
                self.silenceTime = dict["SilenceTime"] as! Int32
            }
            if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
                self.webhook = dict["Webhook"] as! String
            }
        }
    }
    public var rules: [PutResourceMetricRulesRequest.Rules]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rules != nil {
            var tmp : [Any] = []
            for k in self.rules! {
                tmp.append(k.toMap())
            }
            map["Rules"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Rules") && dict["Rules"] != nil {
            var tmp : [PutResourceMetricRulesRequest.Rules] = []
            for v in dict["Rules"] as! [Any] {
                var model = PutResourceMetricRulesRequest.Rules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.rules = tmp
        }
    }
}

public class PutResourceMetricRulesResponseBody : Tea.TeaModel {
    public class FailedListResult : Tea.TeaModel {
        public class Target : Tea.TeaModel {
            public class Result : Tea.TeaModel {
                public var code: String?

                public var message: String?

                public var success: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.success != nil {
                        map["Success"] = self.success!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") && dict["Code"] != nil {
                        self.code = dict["Code"] as! String
                    }
                    if dict.keys.contains("Message") && dict["Message"] != nil {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("Success") && dict["Success"] != nil {
                        self.success = dict["Success"] as! Bool
                    }
                }
            }
            public var result: PutResourceMetricRulesResponseBody.FailedListResult.Target.Result?

            public var ruleId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.result?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.result != nil {
                    map["Result"] = self.result?.toMap()
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Result") && dict["Result"] != nil {
                    var model = PutResourceMetricRulesResponseBody.FailedListResult.Target.Result()
                    model.fromMap(dict["Result"] as! [String: Any])
                    self.result = model
                }
                if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                    self.ruleId = dict["RuleId"] as! String
                }
            }
        }
        public var target: [PutResourceMetricRulesResponseBody.FailedListResult.Target]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.target != nil {
                var tmp : [Any] = []
                for k in self.target! {
                    tmp.append(k.toMap())
                }
                map["Target"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Target") && dict["Target"] != nil {
                var tmp : [PutResourceMetricRulesResponseBody.FailedListResult.Target] = []
                for v in dict["Target"] as! [Any] {
                    var model = PutResourceMetricRulesResponseBody.FailedListResult.Target()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.target = tmp
            }
        }
    }
    public var code: String?

    public var failedListResult: PutResourceMetricRulesResponseBody.FailedListResult?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.failedListResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.failedListResult != nil {
            map["FailedListResult"] = self.failedListResult?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("FailedListResult") && dict["FailedListResult"] != nil {
            var model = PutResourceMetricRulesResponseBody.FailedListResult()
            model.fromMap(dict["FailedListResult"] as! [String: Any])
            self.failedListResult = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PutResourceMetricRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutResourceMetricRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutResourceMetricRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveTagsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var groupIds: [String]?

    public var regionId: String?

    public var tag: [RemoveTagsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupIds != nil {
            map["GroupIds"] = self.groupIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupIds") && dict["GroupIds"] != nil {
            self.groupIds = dict["GroupIds"] as! [String]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [RemoveTagsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = RemoveTagsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class RemoveTagsResponseBody : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var tags: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                self.tags = dict["Tags"] as! [String]
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var tag: RemoveTagsResponseBody.Tag?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tag?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tag != nil {
            map["Tag"] = self.tag?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var model = RemoveTagsResponseBody.Tag()
            model.fromMap(dict["Tag"] as! [String: Any])
            self.tag = model
        }
    }
}

public class RemoveTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendDryRunSystemEventRequest : Tea.TeaModel {
    public var eventContent: String?

    public var eventName: String?

    public var groupId: String?

    public var product: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventContent != nil {
            map["EventContent"] = self.eventContent!
        }
        if self.eventName != nil {
            map["EventName"] = self.eventName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.product != nil {
            map["Product"] = self.product!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventContent") && dict["EventContent"] != nil {
            self.eventContent = dict["EventContent"] as! String
        }
        if dict.keys.contains("EventName") && dict["EventName"] != nil {
            self.eventName = dict["EventName"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Product") && dict["Product"] != nil {
            self.product = dict["Product"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class SendDryRunSystemEventResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class SendDryRunSystemEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendDryRunSystemEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SendDryRunSystemEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UninstallMonitoringAgentRequest : Tea.TeaModel {
    public var instanceId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UninstallMonitoringAgentResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UninstallMonitoringAgentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UninstallMonitoringAgentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UninstallMonitoringAgentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
