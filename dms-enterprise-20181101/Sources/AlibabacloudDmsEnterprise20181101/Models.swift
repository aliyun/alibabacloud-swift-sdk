import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AsyncTaskVO : Tea.TeaModel {
    public var datasetId: String?

    public var id: Int64?

    public var remark: String?

    public var taskName: String?

    public var taskStatus: Int32?

    public var taskType: Int32?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("TaskName") {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskStatus") {
            self.taskStatus = dict["TaskStatus"] as! Int32
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! Int32
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class DLCatalog : Tea.TeaModel {
    public var description_: String?

    public var location: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class DLColumn : Tea.TeaModel {
    public var comment: String?

    public var name: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DLDatabase : Tea.TeaModel {
    public var catalogName: String?

    public var dbId: Int64?

    public var description_: String?

    public var location: String?

    public var name: String?

    public var parameters: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Parameters") {
            self.parameters = dict["Parameters"] as! [String: Any]
        }
    }
}

public class DLOrder : Tea.TeaModel {
    public var col: String?

    public var order: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.col != nil {
            map["Col"] = self.col!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Col") {
            self.col = dict["Col"] as! String
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! Int32
        }
    }
}

public class DLPartition : Tea.TeaModel {
    public var catalogName: String?

    public var createTime: Int32?

    public var dbName: String?

    public var lastAccessTime: Int32?

    public var parameters: [String: String]?

    public var sd: DLStorageDescriptor?

    public var tableName: String?

    public var values: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sd?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.lastAccessTime != nil {
            map["LastAccessTime"] = self.lastAccessTime!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.sd != nil {
            map["Sd"] = self.sd?.toMap()
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int32
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("LastAccessTime") {
            self.lastAccessTime = dict["LastAccessTime"] as! Int32
        }
        if dict.keys.contains("Parameters") {
            self.parameters = dict["Parameters"] as! [String: String]
        }
        if dict.keys.contains("Sd") {
            var model = DLStorageDescriptor()
            model.fromMap(dict["Sd"] as! [String: Any])
            self.sd = model
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Values") {
            self.values = dict["Values"] as! [String]
        }
    }
}

public class DLPartitionInput : Tea.TeaModel {
    public var createTime: Int32?

    public var lastAccessTime: Int32?

    public var parameters: [String: String]?

    public var storageDescriptor: DLStorageDescriptor?

    public var values: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.storageDescriptor?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.lastAccessTime != nil {
            map["LastAccessTime"] = self.lastAccessTime!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.storageDescriptor != nil {
            map["StorageDescriptor"] = self.storageDescriptor?.toMap()
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int32
        }
        if dict.keys.contains("LastAccessTime") {
            self.lastAccessTime = dict["LastAccessTime"] as! Int32
        }
        if dict.keys.contains("Parameters") {
            self.parameters = dict["Parameters"] as! [String: String]
        }
        if dict.keys.contains("StorageDescriptor") {
            var model = DLStorageDescriptor()
            model.fromMap(dict["StorageDescriptor"] as! [String: Any])
            self.storageDescriptor = model
        }
        if dict.keys.contains("Values") {
            self.values = dict["Values"] as! [String]
        }
    }
}

public class DLSerdeInfo : Tea.TeaModel {
    public var description_: String?

    public var deserializerClass: String?

    public var name: String?

    public var parameters: [String: Any]?

    public var serdeType: Int32?

    public var serializationLib: String?

    public var serializerClass: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.deserializerClass != nil {
            map["DeserializerClass"] = self.deserializerClass!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.serdeType != nil {
            map["SerdeType"] = self.serdeType!
        }
        if self.serializationLib != nil {
            map["SerializationLib"] = self.serializationLib!
        }
        if self.serializerClass != nil {
            map["SerializerClass"] = self.serializerClass!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DeserializerClass") {
            self.deserializerClass = dict["DeserializerClass"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Parameters") {
            self.parameters = dict["Parameters"] as! [String: Any]
        }
        if dict.keys.contains("SerdeType") {
            self.serdeType = dict["SerdeType"] as! Int32
        }
        if dict.keys.contains("SerializationLib") {
            self.serializationLib = dict["SerializationLib"] as! String
        }
        if dict.keys.contains("SerializerClass") {
            self.serializerClass = dict["SerializerClass"] as! String
        }
    }
}

public class DLSkewedInfo : Tea.TeaModel {
    public var skewedColNames: [String]?

    public var skewedColValueLocationMaps: [String: Any]?

    public var skewedColValues: [[String]]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.skewedColNames != nil {
            map["SkewedColNames"] = self.skewedColNames!
        }
        if self.skewedColValueLocationMaps != nil {
            map["SkewedColValueLocationMaps"] = self.skewedColValueLocationMaps!
        }
        if self.skewedColValues != nil {
            map["SkewedColValues"] = self.skewedColValues!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SkewedColNames") {
            self.skewedColNames = dict["SkewedColNames"] as! [String]
        }
        if dict.keys.contains("SkewedColValueLocationMaps") {
            self.skewedColValueLocationMaps = dict["SkewedColValueLocationMaps"] as! [String: Any]
        }
        if dict.keys.contains("SkewedColValues") {
            self.skewedColValues = dict["SkewedColValues"] as! [[String]]
        }
    }
}

public class DLStorageDescriptor : Tea.TeaModel {
    public var bucketCols: [String]?

    public var columns: [DLColumn]?

    public var inputFormat: String?

    public var isCompressed: Bool?

    public var location: String?

    public var numBuckets: Int32?

    public var originalColumns: [DLColumn]?

    public var outputFormat: String?

    public var parameters: [String: Any]?

    public var serdeInfo: DLSerdeInfo?

    public var skewedInfo: DLSkewedInfo?

    public var sortCols: [DLOrder]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.serdeInfo?.validate()
        try self.skewedInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketCols != nil {
            map["BucketCols"] = self.bucketCols!
        }
        if self.columns != nil {
            var tmp : [Any] = []
            for k in self.columns! {
                tmp.append(k.toMap())
            }
            map["Columns"] = tmp
        }
        if self.inputFormat != nil {
            map["InputFormat"] = self.inputFormat!
        }
        if self.isCompressed != nil {
            map["IsCompressed"] = self.isCompressed!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.numBuckets != nil {
            map["NumBuckets"] = self.numBuckets!
        }
        if self.originalColumns != nil {
            var tmp : [Any] = []
            for k in self.originalColumns! {
                tmp.append(k.toMap())
            }
            map["OriginalColumns"] = tmp
        }
        if self.outputFormat != nil {
            map["OutputFormat"] = self.outputFormat!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.serdeInfo != nil {
            map["SerdeInfo"] = self.serdeInfo?.toMap()
        }
        if self.skewedInfo != nil {
            map["SkewedInfo"] = self.skewedInfo?.toMap()
        }
        if self.sortCols != nil {
            var tmp : [Any] = []
            for k in self.sortCols! {
                tmp.append(k.toMap())
            }
            map["SortCols"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketCols") {
            self.bucketCols = dict["BucketCols"] as! [String]
        }
        if dict.keys.contains("Columns") {
            var tmp : [DLColumn] = []
            for v in dict["Columns"] as! [Any] {
                var model = DLColumn()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.columns = tmp
        }
        if dict.keys.contains("InputFormat") {
            self.inputFormat = dict["InputFormat"] as! String
        }
        if dict.keys.contains("IsCompressed") {
            self.isCompressed = dict["IsCompressed"] as! Bool
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("NumBuckets") {
            self.numBuckets = dict["NumBuckets"] as! Int32
        }
        if dict.keys.contains("OriginalColumns") {
            var tmp : [DLColumn] = []
            for v in dict["OriginalColumns"] as! [Any] {
                var model = DLColumn()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.originalColumns = tmp
        }
        if dict.keys.contains("OutputFormat") {
            self.outputFormat = dict["OutputFormat"] as! String
        }
        if dict.keys.contains("Parameters") {
            self.parameters = dict["Parameters"] as! [String: Any]
        }
        if dict.keys.contains("SerdeInfo") {
            var model = DLSerdeInfo()
            model.fromMap(dict["SerdeInfo"] as! [String: Any])
            self.serdeInfo = model
        }
        if dict.keys.contains("SkewedInfo") {
            var model = DLSkewedInfo()
            model.fromMap(dict["SkewedInfo"] as! [String: Any])
            self.skewedInfo = model
        }
        if dict.keys.contains("SortCols") {
            var tmp : [DLOrder] = []
            for v in dict["SortCols"] as! [Any] {
                var model = DLOrder()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sortCols = tmp
        }
    }
}

public class DLTable : Tea.TeaModel {
    public var catalogName: String?

    public var createTime: Int32?

    public var creatorId: Int64?

    public var dbId: Int64?

    public var dbName: String?

    public var description_: String?

    public var lastAccessTime: Int32?

    public var location: String?

    public var modifierId: Int64?

    public var name: String?

    public var owner: String?

    public var ownerType: String?

    public var parameters: [String: Any]?

    public var partitionKeys: [DLColumn]?

    public var retention: Int32?

    public var storageDescriptor: DLStorageDescriptor?

    public var tableType: String?

    public var viewExpandedText: String?

    public var viewOriginalText: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.storageDescriptor?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.creatorId != nil {
            map["CreatorId"] = self.creatorId!
        }
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.lastAccessTime != nil {
            map["LastAccessTime"] = self.lastAccessTime!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.modifierId != nil {
            map["ModifierId"] = self.modifierId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.ownerType != nil {
            map["OwnerType"] = self.ownerType!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.partitionKeys != nil {
            var tmp : [Any] = []
            for k in self.partitionKeys! {
                tmp.append(k.toMap())
            }
            map["PartitionKeys"] = tmp
        }
        if self.retention != nil {
            map["Retention"] = self.retention!
        }
        if self.storageDescriptor != nil {
            map["StorageDescriptor"] = self.storageDescriptor?.toMap()
        }
        if self.tableType != nil {
            map["TableType"] = self.tableType!
        }
        if self.viewExpandedText != nil {
            map["ViewExpandedText"] = self.viewExpandedText!
        }
        if self.viewOriginalText != nil {
            map["ViewOriginalText"] = self.viewOriginalText!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int32
        }
        if dict.keys.contains("CreatorId") {
            self.creatorId = dict["CreatorId"] as! Int64
        }
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! Int64
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("LastAccessTime") {
            self.lastAccessTime = dict["LastAccessTime"] as! Int32
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("ModifierId") {
            self.modifierId = dict["ModifierId"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("OwnerType") {
            self.ownerType = dict["OwnerType"] as! String
        }
        if dict.keys.contains("Parameters") {
            self.parameters = dict["Parameters"] as! [String: Any]
        }
        if dict.keys.contains("PartitionKeys") {
            var tmp : [DLColumn] = []
            for v in dict["PartitionKeys"] as! [Any] {
                var model = DLColumn()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.partitionKeys = tmp
        }
        if dict.keys.contains("Retention") {
            self.retention = dict["Retention"] as! Int32
        }
        if dict.keys.contains("StorageDescriptor") {
            var model = DLStorageDescriptor()
            model.fromMap(dict["StorageDescriptor"] as! [String: Any])
            self.storageDescriptor = model
        }
        if dict.keys.contains("TableType") {
            self.tableType = dict["TableType"] as! String
        }
        if dict.keys.contains("ViewExpandedText") {
            self.viewExpandedText = dict["ViewExpandedText"] as! String
        }
        if dict.keys.contains("ViewOriginalText") {
            self.viewOriginalText = dict["ViewOriginalText"] as! String
        }
    }
}

public class DLTablebaseInfo : Tea.TeaModel {
    public var catalogName: String?

    public var createTime: Int32?

    public var creatorId: Int64?

    public var dbId: Int64?

    public var dbName: String?

    public var description_: String?

    public var lastAccessTime: Int32?

    public var location: String?

    public var modifierId: Int64?

    public var name: String?

    public var owner: String?

    public var ownerType: String?

    public var parameters: [String: Any]?

    public var partitionKeys: [DLColumn]?

    public var retention: Int32?

    public var tableType: String?

    public var viewExpandedText: String?

    public var viewOriginalText: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.creatorId != nil {
            map["CreatorId"] = self.creatorId!
        }
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.lastAccessTime != nil {
            map["LastAccessTime"] = self.lastAccessTime!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.modifierId != nil {
            map["ModifierId"] = self.modifierId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.ownerType != nil {
            map["OwnerType"] = self.ownerType!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.partitionKeys != nil {
            var tmp : [Any] = []
            for k in self.partitionKeys! {
                tmp.append(k.toMap())
            }
            map["PartitionKeys"] = tmp
        }
        if self.retention != nil {
            map["Retention"] = self.retention!
        }
        if self.tableType != nil {
            map["TableType"] = self.tableType!
        }
        if self.viewExpandedText != nil {
            map["ViewExpandedText"] = self.viewExpandedText!
        }
        if self.viewOriginalText != nil {
            map["ViewOriginalText"] = self.viewOriginalText!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int32
        }
        if dict.keys.contains("CreatorId") {
            self.creatorId = dict["CreatorId"] as! Int64
        }
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! Int64
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("LastAccessTime") {
            self.lastAccessTime = dict["LastAccessTime"] as! Int32
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("ModifierId") {
            self.modifierId = dict["ModifierId"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("OwnerType") {
            self.ownerType = dict["OwnerType"] as! String
        }
        if dict.keys.contains("Parameters") {
            self.parameters = dict["Parameters"] as! [String: Any]
        }
        if dict.keys.contains("PartitionKeys") {
            var tmp : [DLColumn] = []
            for v in dict["PartitionKeys"] as! [Any] {
                var model = DLColumn()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.partitionKeys = tmp
        }
        if dict.keys.contains("Retention") {
            self.retention = dict["Retention"] as! Int32
        }
        if dict.keys.contains("TableType") {
            self.tableType = dict["TableType"] as! String
        }
        if dict.keys.contains("ViewExpandedText") {
            self.viewExpandedText = dict["ViewExpandedText"] as! String
        }
        if dict.keys.contains("ViewOriginalText") {
            self.viewOriginalText = dict["ViewOriginalText"] as! String
        }
    }
}

public class DatasetItemVO : Tea.TeaModel {
    public var asyncTaskList: [AsyncTaskVO]?

    public var datasetStatus: Int32?

    public var datasetType: Int32?

    public var digest: String?

    public var fileSystem: String?

    public var id: String?

    public var keyName: String?

    public var moreInfo: String?

    public var path: String?

    public var projectsLinked: [ProjectDetailsLiteVO]?

    public var recentTaskStatus: Int32?

    public var remark: String?

    public var schema: String?

    public var tableName: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asyncTaskList != nil {
            var tmp : [Any] = []
            for k in self.asyncTaskList! {
                tmp.append(k.toMap())
            }
            map["AsyncTaskList"] = tmp
        }
        if self.datasetStatus != nil {
            map["DatasetStatus"] = self.datasetStatus!
        }
        if self.datasetType != nil {
            map["DatasetType"] = self.datasetType!
        }
        if self.digest != nil {
            map["Digest"] = self.digest!
        }
        if self.fileSystem != nil {
            map["FileSystem"] = self.fileSystem!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.keyName != nil {
            map["KeyName"] = self.keyName!
        }
        if self.moreInfo != nil {
            map["MoreInfo"] = self.moreInfo!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.projectsLinked != nil {
            var tmp : [Any] = []
            for k in self.projectsLinked! {
                tmp.append(k.toMap())
            }
            map["ProjectsLinked"] = tmp
        }
        if self.recentTaskStatus != nil {
            map["RecentTaskStatus"] = self.recentTaskStatus!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AsyncTaskList") {
            var tmp : [AsyncTaskVO] = []
            for v in dict["AsyncTaskList"] as! [Any] {
                var model = AsyncTaskVO()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.asyncTaskList = tmp
        }
        if dict.keys.contains("DatasetStatus") {
            self.datasetStatus = dict["DatasetStatus"] as! Int32
        }
        if dict.keys.contains("DatasetType") {
            self.datasetType = dict["DatasetType"] as! Int32
        }
        if dict.keys.contains("Digest") {
            self.digest = dict["Digest"] as! String
        }
        if dict.keys.contains("FileSystem") {
            self.fileSystem = dict["FileSystem"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("KeyName") {
            self.keyName = dict["KeyName"] as! String
        }
        if dict.keys.contains("MoreInfo") {
            self.moreInfo = dict["MoreInfo"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("ProjectsLinked") {
            var tmp : [ProjectDetailsLiteVO] = []
            for v in dict["ProjectsLinked"] as! [Any] {
                var model = ProjectDetailsLiteVO()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.projectsLinked = tmp
        }
        if dict.keys.contains("RecentTaskStatus") {
            self.recentTaskStatus = dict["RecentTaskStatus"] as! Int32
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("Schema") {
            self.schema = dict["Schema"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class GetTableDataKeyVO : Tea.TeaModel {
    public var colName: String?

    public var dbName: String?

    public var mekId: Int64?

    public var schemaName: String?

    public var tblName: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.colName != nil {
            map["ColName"] = self.colName!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.mekId != nil {
            map["MekId"] = self.mekId!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tblName != nil {
            map["TblName"] = self.tblName!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColName") {
            self.colName = dict["ColName"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("MekId") {
            self.mekId = dict["MekId"] as! Int64
        }
        if dict.keys.contains("SchemaName") {
            self.schemaName = dict["SchemaName"] as! String
        }
        if dict.keys.contains("TblName") {
            self.tblName = dict["TblName"] as! String
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class ImportMasterKeyVO : Tea.TeaModel {
    public var encryptMekDataBase64: String?

    public var mekId: Int64?

    public var projectId: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.encryptMekDataBase64 != nil {
            map["EncryptMekDataBase64"] = self.encryptMekDataBase64!
        }
        if self.mekId != nil {
            map["MekId"] = self.mekId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EncryptMekDataBase64") {
            self.encryptMekDataBase64 = dict["EncryptMekDataBase64"] as! String
        }
        if dict.keys.contains("MekId") {
            self.mekId = dict["MekId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! [Int64]
        }
    }
}

public class PartitionError : Tea.TeaModel {
    public var errorDetail: String?

    public var values: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail!
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorDetail") {
            self.errorDetail = dict["ErrorDetail"] as! String
        }
        if dict.keys.contains("Values") {
            self.values = dict["Values"] as! [String]
        }
    }
}

public class ProjectDetailsLiteVO : Tea.TeaModel {
    public var id: Int64?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
    }
}

public class StsApplyVO : Tea.TeaModel {
    public var aliyunId: String?

    public var duration: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunId != nil {
            map["AliyunId"] = self.aliyunId!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunId") {
            self.aliyunId = dict["AliyunId"] as! String
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! Int64
        }
    }
}

public class StsTokenVO : Tea.TeaModel {
    public var accessKeyId: String?

    public var accessKeySecret: String?

    public var expiration: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessKeyId != nil {
            map["AccessKeyId"] = self.accessKeyId!
        }
        if self.accessKeySecret != nil {
            map["AccessKeySecret"] = self.accessKeySecret!
        }
        if self.expiration != nil {
            map["Expiration"] = self.expiration!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessKeyId") {
            self.accessKeyId = dict["AccessKeyId"] as! String
        }
        if dict.keys.contains("AccessKeySecret") {
            self.accessKeySecret = dict["AccessKeySecret"] as! String
        }
        if dict.keys.contains("Expiration") {
            self.expiration = dict["Expiration"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class TeeEvidenceVO : Tea.TeaModel {
    public var cipherSuite: String?

    public var enclaveData: String?

    public var encryptPublicKeyPem: String?

    public var encryptPublicKeyType: String?

    public var modifiedDate: String?

    public var publicKey: String?

    public var publicKeyRaBase64: String?

    public var publicKeyRaType: String?

    public var quoteReport: String?

    public var signPublicKeyPem: String?

    public var signPublicKeyType: String?

    public var trustedMrEnclave: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cipherSuite != nil {
            map["CipherSuite"] = self.cipherSuite!
        }
        if self.enclaveData != nil {
            map["EnclaveData"] = self.enclaveData!
        }
        if self.encryptPublicKeyPem != nil {
            map["EncryptPublicKeyPem"] = self.encryptPublicKeyPem!
        }
        if self.encryptPublicKeyType != nil {
            map["EncryptPublicKeyType"] = self.encryptPublicKeyType!
        }
        if self.modifiedDate != nil {
            map["ModifiedDate"] = self.modifiedDate!
        }
        if self.publicKey != nil {
            map["PublicKey"] = self.publicKey!
        }
        if self.publicKeyRaBase64 != nil {
            map["PublicKeyRaBase64"] = self.publicKeyRaBase64!
        }
        if self.publicKeyRaType != nil {
            map["PublicKeyRaType"] = self.publicKeyRaType!
        }
        if self.quoteReport != nil {
            map["QuoteReport"] = self.quoteReport!
        }
        if self.signPublicKeyPem != nil {
            map["SignPublicKeyPem"] = self.signPublicKeyPem!
        }
        if self.signPublicKeyType != nil {
            map["SignPublicKeyType"] = self.signPublicKeyType!
        }
        if self.trustedMrEnclave != nil {
            map["TrustedMrEnclave"] = self.trustedMrEnclave!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CipherSuite") {
            self.cipherSuite = dict["CipherSuite"] as! String
        }
        if dict.keys.contains("EnclaveData") {
            self.enclaveData = dict["EnclaveData"] as! String
        }
        if dict.keys.contains("EncryptPublicKeyPem") {
            self.encryptPublicKeyPem = dict["EncryptPublicKeyPem"] as! String
        }
        if dict.keys.contains("EncryptPublicKeyType") {
            self.encryptPublicKeyType = dict["EncryptPublicKeyType"] as! String
        }
        if dict.keys.contains("ModifiedDate") {
            self.modifiedDate = dict["ModifiedDate"] as! String
        }
        if dict.keys.contains("PublicKey") {
            self.publicKey = dict["PublicKey"] as! String
        }
        if dict.keys.contains("PublicKeyRaBase64") {
            self.publicKeyRaBase64 = dict["PublicKeyRaBase64"] as! String
        }
        if dict.keys.contains("PublicKeyRaType") {
            self.publicKeyRaType = dict["PublicKeyRaType"] as! String
        }
        if dict.keys.contains("QuoteReport") {
            self.quoteReport = dict["QuoteReport"] as! String
        }
        if dict.keys.contains("SignPublicKeyPem") {
            self.signPublicKeyPem = dict["SignPublicKeyPem"] as! String
        }
        if dict.keys.contains("SignPublicKeyType") {
            self.signPublicKeyType = dict["SignPublicKeyType"] as! String
        }
        if dict.keys.contains("TrustedMrEnclave") {
            self.trustedMrEnclave = dict["TrustedMrEnclave"] as! [String]
        }
    }
}

public class UsersDetailsVO : Tea.TeaModel {
    public var approvalSignatureBase64: String?

    public var approvalSqlTemplate: String?

    public var approvalStatus: String?

    public var creator: Int32?

    public var dataReady: Int32?

    public var id: Int64?

    public var mekid: Int64?

    public var pathPrefix: String?

    public var resultParty: Int32?

    public var uid: String?

    public var userConfirmed: Int32?

    public var userName: String?

    public var userPublicKeyPem: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.approvalSignatureBase64 != nil {
            map["ApprovalSignatureBase64"] = self.approvalSignatureBase64!
        }
        if self.approvalSqlTemplate != nil {
            map["ApprovalSqlTemplate"] = self.approvalSqlTemplate!
        }
        if self.approvalStatus != nil {
            map["ApprovalStatus"] = self.approvalStatus!
        }
        if self.creator != nil {
            map["Creator"] = self.creator!
        }
        if self.dataReady != nil {
            map["DataReady"] = self.dataReady!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mekid != nil {
            map["Mekid"] = self.mekid!
        }
        if self.pathPrefix != nil {
            map["PathPrefix"] = self.pathPrefix!
        }
        if self.resultParty != nil {
            map["ResultParty"] = self.resultParty!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        if self.userConfirmed != nil {
            map["UserConfirmed"] = self.userConfirmed!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        if self.userPublicKeyPem != nil {
            map["UserPublicKeyPem"] = self.userPublicKeyPem!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApprovalSignatureBase64") {
            self.approvalSignatureBase64 = dict["ApprovalSignatureBase64"] as! String
        }
        if dict.keys.contains("ApprovalSqlTemplate") {
            self.approvalSqlTemplate = dict["ApprovalSqlTemplate"] as! String
        }
        if dict.keys.contains("ApprovalStatus") {
            self.approvalStatus = dict["ApprovalStatus"] as! String
        }
        if dict.keys.contains("Creator") {
            self.creator = dict["Creator"] as! Int32
        }
        if dict.keys.contains("DataReady") {
            self.dataReady = dict["DataReady"] as! Int32
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Mekid") {
            self.mekid = dict["Mekid"] as! Int64
        }
        if dict.keys.contains("PathPrefix") {
            self.pathPrefix = dict["PathPrefix"] as! String
        }
        if dict.keys.contains("ResultParty") {
            self.resultParty = dict["ResultParty"] as! Int32
        }
        if dict.keys.contains("Uid") {
            self.uid = dict["Uid"] as! String
        }
        if dict.keys.contains("UserConfirmed") {
            self.userConfirmed = dict["UserConfirmed"] as! Int32
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
        if dict.keys.contains("UserPublicKeyPem") {
            self.userPublicKeyPem = dict["UserPublicKeyPem"] as! String
        }
    }
}

public class OpenStructDLTableInput : Tea.TeaModel {
    public var createTime: Int32?

    public var creatorId: Int64?

    public var description_: String?

    public var lastAccessTime: Int32?

    public var location: String?

    public var modifierId: Int64?

    public var name: String?

    public var owner: String?

    public var ownerType: String?

    public var parameters: [String: String]?

    public var partitionKeys: [DLColumn]?

    public var retention: Int32?

    public var storageDescriptor: DLStorageDescriptor?

    public var tableType: String?

    public var viewExpandedText: String?

    public var viewOriginalText: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.storageDescriptor?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.creatorId != nil {
            map["CreatorId"] = self.creatorId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.lastAccessTime != nil {
            map["LastAccessTime"] = self.lastAccessTime!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.modifierId != nil {
            map["ModifierId"] = self.modifierId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.ownerType != nil {
            map["OwnerType"] = self.ownerType!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.partitionKeys != nil {
            var tmp : [Any] = []
            for k in self.partitionKeys! {
                tmp.append(k.toMap())
            }
            map["PartitionKeys"] = tmp
        }
        if self.retention != nil {
            map["Retention"] = self.retention!
        }
        if self.storageDescriptor != nil {
            map["StorageDescriptor"] = self.storageDescriptor?.toMap()
        }
        if self.tableType != nil {
            map["TableType"] = self.tableType!
        }
        if self.viewExpandedText != nil {
            map["ViewExpandedText"] = self.viewExpandedText!
        }
        if self.viewOriginalText != nil {
            map["ViewOriginalText"] = self.viewOriginalText!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int32
        }
        if dict.keys.contains("CreatorId") {
            self.creatorId = dict["CreatorId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("LastAccessTime") {
            self.lastAccessTime = dict["LastAccessTime"] as! Int32
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("ModifierId") {
            self.modifierId = dict["ModifierId"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("OwnerType") {
            self.ownerType = dict["OwnerType"] as! String
        }
        if dict.keys.contains("Parameters") {
            self.parameters = dict["Parameters"] as! [String: String]
        }
        if dict.keys.contains("PartitionKeys") {
            var tmp : [DLColumn] = []
            for v in dict["PartitionKeys"] as! [Any] {
                var model = DLColumn()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.partitionKeys = tmp
        }
        if dict.keys.contains("Retention") {
            self.retention = dict["Retention"] as! Int32
        }
        if dict.keys.contains("StorageDescriptor") {
            var model = DLStorageDescriptor()
            model.fromMap(dict["StorageDescriptor"] as! [String: Any])
            self.storageDescriptor = model
        }
        if dict.keys.contains("TableType") {
            self.tableType = dict["TableType"] as! String
        }
        if dict.keys.contains("ViewExpandedText") {
            self.viewExpandedText = dict["ViewExpandedText"] as! String
        }
        if dict.keys.contains("ViewOriginalText") {
            self.viewOriginalText = dict["ViewOriginalText"] as! String
        }
    }
}

public class AddAuthorityTemplateItemsRequest : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var dbId: Int32?

        public var instanceId: Int32?

        public var permissionTypes: [String]?

        public var resourceType: String?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.permissionTypes != nil {
                map["PermissionTypes"] = self.permissionTypes!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbId") {
                self.dbId = dict["DbId"] as! Int32
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int32
            }
            if dict.keys.contains("PermissionTypes") {
                self.permissionTypes = dict["PermissionTypes"] as! [String]
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
        }
    }
    public var items: [AddAuthorityTemplateItemsRequest.Items]?

    public var templateId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Items") {
            var tmp : [AddAuthorityTemplateItemsRequest.Items] = []
            for v in dict["Items"] as! [Any] {
                var model = AddAuthorityTemplateItemsRequest.Items()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.items = tmp
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class AddAuthorityTemplateItemsShrinkRequest : Tea.TeaModel {
    public var itemsShrink: String?

    public var templateId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.itemsShrink != nil {
            map["Items"] = self.itemsShrink!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Items") {
            self.itemsShrink = dict["Items"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class AddAuthorityTemplateItemsResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddAuthorityTemplateItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAuthorityTemplateItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddAuthorityTemplateItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDesensitizationRuleRequest : Tea.TeaModel {
    public var functionParams: [[String: String]]?

    public var functionType: String?

    public var ruleDescription: String?

    public var ruleName: String?

    public var ruleType: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.functionParams != nil {
            map["FunctionParams"] = self.functionParams!
        }
        if self.functionType != nil {
            map["FunctionType"] = self.functionType!
        }
        if self.ruleDescription != nil {
            map["RuleDescription"] = self.ruleDescription!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.ruleType != nil {
            map["RuleType"] = self.ruleType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FunctionParams") {
            self.functionParams = dict["FunctionParams"] as! [[String: String]]
        }
        if dict.keys.contains("FunctionType") {
            self.functionType = dict["FunctionType"] as! String
        }
        if dict.keys.contains("RuleDescription") {
            self.ruleDescription = dict["RuleDescription"] as! String
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("RuleType") {
            self.ruleType = dict["RuleType"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class AddDesensitizationRuleResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var ruleId: Int32?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! Int32
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddDesensitizationRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDesensitizationRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDesensitizationRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddInstanceRequest : Tea.TeaModel {
    public var dataLinkName: String?

    public var databasePassword: String?

    public var databaseUser: String?

    public var dbaId: Int64?

    public var ddlOnline: Int32?

    public var ecsInstanceId: String?

    public var ecsRegion: String?

    public var enableSellCommon: String?

    public var enableSellSitd: String?

    public var enableSellStable: String?

    public var enableSellTrust: String?

    public var envType: String?

    public var exportTimeout: Int32?

    public var host: String?

    public var instanceAlias: String?

    public var instanceSource: String?

    public var instanceType: String?

    public var networkType: String?

    public var port: Int32?

    public var queryTimeout: Int32?

    public var safeRule: String?

    public var sid: String?

    public var skipTest: Bool?

    public var templateId: Int64?

    public var templateType: String?

    public var tid: Int64?

    public var useDsql: Int32?

    public var useSsl: Int32?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataLinkName != nil {
            map["DataLinkName"] = self.dataLinkName!
        }
        if self.databasePassword != nil {
            map["DatabasePassword"] = self.databasePassword!
        }
        if self.databaseUser != nil {
            map["DatabaseUser"] = self.databaseUser!
        }
        if self.dbaId != nil {
            map["DbaId"] = self.dbaId!
        }
        if self.ddlOnline != nil {
            map["DdlOnline"] = self.ddlOnline!
        }
        if self.ecsInstanceId != nil {
            map["EcsInstanceId"] = self.ecsInstanceId!
        }
        if self.ecsRegion != nil {
            map["EcsRegion"] = self.ecsRegion!
        }
        if self.enableSellCommon != nil {
            map["EnableSellCommon"] = self.enableSellCommon!
        }
        if self.enableSellSitd != nil {
            map["EnableSellSitd"] = self.enableSellSitd!
        }
        if self.enableSellStable != nil {
            map["EnableSellStable"] = self.enableSellStable!
        }
        if self.enableSellTrust != nil {
            map["EnableSellTrust"] = self.enableSellTrust!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.exportTimeout != nil {
            map["ExportTimeout"] = self.exportTimeout!
        }
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.instanceAlias != nil {
            map["InstanceAlias"] = self.instanceAlias!
        }
        if self.instanceSource != nil {
            map["InstanceSource"] = self.instanceSource!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.queryTimeout != nil {
            map["QueryTimeout"] = self.queryTimeout!
        }
        if self.safeRule != nil {
            map["SafeRule"] = self.safeRule!
        }
        if self.sid != nil {
            map["Sid"] = self.sid!
        }
        if self.skipTest != nil {
            map["SkipTest"] = self.skipTest!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.useDsql != nil {
            map["UseDsql"] = self.useDsql!
        }
        if self.useSsl != nil {
            map["UseSsl"] = self.useSsl!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataLinkName") {
            self.dataLinkName = dict["DataLinkName"] as! String
        }
        if dict.keys.contains("DatabasePassword") {
            self.databasePassword = dict["DatabasePassword"] as! String
        }
        if dict.keys.contains("DatabaseUser") {
            self.databaseUser = dict["DatabaseUser"] as! String
        }
        if dict.keys.contains("DbaId") {
            self.dbaId = dict["DbaId"] as! Int64
        }
        if dict.keys.contains("DdlOnline") {
            self.ddlOnline = dict["DdlOnline"] as! Int32
        }
        if dict.keys.contains("EcsInstanceId") {
            self.ecsInstanceId = dict["EcsInstanceId"] as! String
        }
        if dict.keys.contains("EcsRegion") {
            self.ecsRegion = dict["EcsRegion"] as! String
        }
        if dict.keys.contains("EnableSellCommon") {
            self.enableSellCommon = dict["EnableSellCommon"] as! String
        }
        if dict.keys.contains("EnableSellSitd") {
            self.enableSellSitd = dict["EnableSellSitd"] as! String
        }
        if dict.keys.contains("EnableSellStable") {
            self.enableSellStable = dict["EnableSellStable"] as! String
        }
        if dict.keys.contains("EnableSellTrust") {
            self.enableSellTrust = dict["EnableSellTrust"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("ExportTimeout") {
            self.exportTimeout = dict["ExportTimeout"] as! Int32
        }
        if dict.keys.contains("Host") {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("InstanceAlias") {
            self.instanceAlias = dict["InstanceAlias"] as! String
        }
        if dict.keys.contains("InstanceSource") {
            self.instanceSource = dict["InstanceSource"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("QueryTimeout") {
            self.queryTimeout = dict["QueryTimeout"] as! Int32
        }
        if dict.keys.contains("SafeRule") {
            self.safeRule = dict["SafeRule"] as! String
        }
        if dict.keys.contains("Sid") {
            self.sid = dict["Sid"] as! String
        }
        if dict.keys.contains("SkipTest") {
            self.skipTest = dict["SkipTest"] as! Bool
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UseDsql") {
            self.useDsql = dict["UseDsql"] as! Int32
        }
        if dict.keys.contains("UseSsl") {
            self.useSsl = dict["UseSsl"] as! Int32
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class AddInstanceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLhMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var roles: [String]?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.roles != nil {
                map["Roles"] = self.roles!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Roles") {
                self.roles = dict["Roles"] as! [String]
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! Int64
            }
        }
    }
    public var members: [AddLhMembersRequest.Members]?

    public var objectId: Int64?

    public var objectType: Int32?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.objectId != nil {
            map["ObjectId"] = self.objectId!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") {
            var tmp : [AddLhMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = AddLhMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("ObjectId") {
            self.objectId = dict["ObjectId"] as! Int64
        }
        if dict.keys.contains("ObjectType") {
            self.objectType = dict["ObjectType"] as! Int32
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class AddLhMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var objectId: Int64?

    public var objectType: Int32?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.objectId != nil {
            map["ObjectId"] = self.objectId!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("ObjectId") {
            self.objectId = dict["ObjectId"] as! Int64
        }
        if dict.keys.contains("ObjectType") {
            self.objectType = dict["ObjectType"] as! Int32
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class AddLhMembersResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddLhMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLhMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddLhMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLogicTableRouteConfigRequest : Tea.TeaModel {
    public var routeExpr: String?

    public var routeKey: String?

    public var tableId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.routeExpr != nil {
            map["RouteExpr"] = self.routeExpr!
        }
        if self.routeKey != nil {
            map["RouteKey"] = self.routeKey!
        }
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RouteExpr") {
            self.routeExpr = dict["RouteExpr"] as! String
        }
        if dict.keys.contains("RouteKey") {
            self.routeKey = dict["RouteKey"] as! String
        }
        if dict.keys.contains("TableId") {
            self.tableId = dict["TableId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class AddLogicTableRouteConfigResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddLogicTableRouteConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLogicTableRouteConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddLogicTableRouteConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddTaskFlowEdgesRequest : Tea.TeaModel {
    public class Edges : Tea.TeaModel {
        public var nodeEnd: Int64?

        public var nodeFrom: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeEnd != nil {
                map["NodeEnd"] = self.nodeEnd!
            }
            if self.nodeFrom != nil {
                map["NodeFrom"] = self.nodeFrom!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NodeEnd") {
                self.nodeEnd = dict["NodeEnd"] as! Int64
            }
            if dict.keys.contains("NodeFrom") {
                self.nodeFrom = dict["NodeFrom"] as! Int64
            }
        }
    }
    public var dagId: Int64?

    public var edges: [AddTaskFlowEdgesRequest.Edges]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.edges != nil {
            var tmp : [Any] = []
            for k in self.edges! {
                tmp.append(k.toMap())
            }
            map["Edges"] = tmp
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Edges") {
            var tmp : [AddTaskFlowEdgesRequest.Edges] = []
            for v in dict["Edges"] as! [Any] {
                var model = AddTaskFlowEdgesRequest.Edges()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.edges = tmp
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class AddTaskFlowEdgesShrinkRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var edgesShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.edgesShrink != nil {
            map["Edges"] = self.edgesShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Edges") {
            self.edgesShrink = dict["Edges"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class AddTaskFlowEdgesResponseBody : Tea.TeaModel {
    public class EdgeIds : Tea.TeaModel {
        public var edgeId: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.edgeId != nil {
                map["EdgeId"] = self.edgeId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EdgeId") {
                self.edgeId = dict["EdgeId"] as! [Int64]
            }
        }
    }
    public var edgeIds: AddTaskFlowEdgesResponseBody.EdgeIds?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.edgeIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.edgeIds != nil {
            map["EdgeIds"] = self.edgeIds?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EdgeIds") {
            var model = AddTaskFlowEdgesResponseBody.EdgeIds()
            model.fromMap(dict["EdgeIds"] as! [String: Any])
            self.edgeIds = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddTaskFlowEdgesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTaskFlowEdgesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddTaskFlowEdgesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AnalyzeSQLLineageRequest : Tea.TeaModel {
    public var dbId: Int64?

    public var sqlContent: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.sqlContent != nil {
            map["SqlContent"] = self.sqlContent!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! Int64
        }
        if dict.keys.contains("SqlContent") {
            self.sqlContent = dict["SqlContent"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class AnalyzeSQLLineageResponseBody : Tea.TeaModel {
    public class LineageResult : Tea.TeaModel {
        public class Lineages : Tea.TeaModel {
            public class ProcessDetail : Tea.TeaModel {
                public var calWay: String?

                public var code: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.calWay != nil {
                        map["CalWay"] = self.calWay!
                    }
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CalWay") {
                        self.calWay = dict["CalWay"] as! String
                    }
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! String
                    }
                }
            }
            public var dst: String?

            public var lineageType: String?

            public var operType: String?

            public var processDetail: AnalyzeSQLLineageResponseBody.LineageResult.Lineages.ProcessDetail?

            public var src: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.processDetail?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dst != nil {
                    map["Dst"] = self.dst!
                }
                if self.lineageType != nil {
                    map["LineageType"] = self.lineageType!
                }
                if self.operType != nil {
                    map["OperType"] = self.operType!
                }
                if self.processDetail != nil {
                    map["ProcessDetail"] = self.processDetail?.toMap()
                }
                if self.src != nil {
                    map["Src"] = self.src!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Dst") {
                    self.dst = dict["Dst"] as! String
                }
                if dict.keys.contains("LineageType") {
                    self.lineageType = dict["LineageType"] as! String
                }
                if dict.keys.contains("OperType") {
                    self.operType = dict["OperType"] as! String
                }
                if dict.keys.contains("ProcessDetail") {
                    var model = AnalyzeSQLLineageResponseBody.LineageResult.Lineages.ProcessDetail()
                    model.fromMap(dict["ProcessDetail"] as! [String: Any])
                    self.processDetail = model
                }
                if dict.keys.contains("Src") {
                    self.src = dict["Src"] as! String
                }
            }
        }
        public class ObjectMetadata : Tea.TeaModel {
            public class Fields : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var fields: [AnalyzeSQLLineageResponseBody.LineageResult.ObjectMetadata.Fields]?

            public var name: String?

            public var source: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fields != nil {
                    var tmp : [Any] = []
                    for k in self.fields! {
                        tmp.append(k.toMap())
                    }
                    map["Fields"] = tmp
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Fields") {
                    var tmp : [AnalyzeSQLLineageResponseBody.LineageResult.ObjectMetadata.Fields] = []
                    for v in dict["Fields"] as! [Any] {
                        var model = AnalyzeSQLLineageResponseBody.LineageResult.ObjectMetadata.Fields()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.fields = tmp
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var lineages: [AnalyzeSQLLineageResponseBody.LineageResult.Lineages]?

        public var objectMetadata: [AnalyzeSQLLineageResponseBody.LineageResult.ObjectMetadata]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lineages != nil {
                var tmp : [Any] = []
                for k in self.lineages! {
                    tmp.append(k.toMap())
                }
                map["Lineages"] = tmp
            }
            if self.objectMetadata != nil {
                var tmp : [Any] = []
                for k in self.objectMetadata! {
                    tmp.append(k.toMap())
                }
                map["ObjectMetadata"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Lineages") {
                var tmp : [AnalyzeSQLLineageResponseBody.LineageResult.Lineages] = []
                for v in dict["Lineages"] as! [Any] {
                    var model = AnalyzeSQLLineageResponseBody.LineageResult.Lineages()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.lineages = tmp
            }
            if dict.keys.contains("ObjectMetadata") {
                var tmp : [AnalyzeSQLLineageResponseBody.LineageResult.ObjectMetadata] = []
                for v in dict["ObjectMetadata"] as! [Any] {
                    var model = AnalyzeSQLLineageResponseBody.LineageResult.ObjectMetadata()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.objectMetadata = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var lineageResult: AnalyzeSQLLineageResponseBody.LineageResult?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lineageResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.lineageResult != nil {
            map["LineageResult"] = self.lineageResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("LineageResult") {
            var model = AnalyzeSQLLineageResponseBody.LineageResult()
            model.fromMap(dict["LineageResult"] as! [String: Any])
            self.lineageResult = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AnalyzeSQLLineageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AnalyzeSQLLineageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AnalyzeSQLLineageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApproveOrderRequest : Tea.TeaModel {
    public var approvalNodeId: Int64?

    public var approvalNodePos: String?

    public var approvalType: String?

    public var comment: String?

    public var newApprover: Int64?

    public var newApproverList: String?

    public var oldApprover: Int64?

    public var realLoginUserUid: String?

    public var tid: Int64?

    public var workflowInstanceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.approvalNodeId != nil {
            map["ApprovalNodeId"] = self.approvalNodeId!
        }
        if self.approvalNodePos != nil {
            map["ApprovalNodePos"] = self.approvalNodePos!
        }
        if self.approvalType != nil {
            map["ApprovalType"] = self.approvalType!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.newApprover != nil {
            map["NewApprover"] = self.newApprover!
        }
        if self.newApproverList != nil {
            map["NewApproverList"] = self.newApproverList!
        }
        if self.oldApprover != nil {
            map["OldApprover"] = self.oldApprover!
        }
        if self.realLoginUserUid != nil {
            map["RealLoginUserUid"] = self.realLoginUserUid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.workflowInstanceId != nil {
            map["WorkflowInstanceId"] = self.workflowInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApprovalNodeId") {
            self.approvalNodeId = dict["ApprovalNodeId"] as! Int64
        }
        if dict.keys.contains("ApprovalNodePos") {
            self.approvalNodePos = dict["ApprovalNodePos"] as! String
        }
        if dict.keys.contains("ApprovalType") {
            self.approvalType = dict["ApprovalType"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("NewApprover") {
            self.newApprover = dict["NewApprover"] as! Int64
        }
        if dict.keys.contains("NewApproverList") {
            self.newApproverList = dict["NewApproverList"] as! String
        }
        if dict.keys.contains("OldApprover") {
            self.oldApprover = dict["OldApprover"] as! Int64
        }
        if dict.keys.contains("RealLoginUserUid") {
            self.realLoginUserUid = dict["RealLoginUserUid"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("WorkflowInstanceId") {
            self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
        }
    }
}

public class ApproveOrderResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ApproveOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApproveOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApproveOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BackFillRequest : Tea.TeaModel {
    public var asc: Bool?

    public var backFillDate: String?

    public var backFillDateBegin: String?

    public var backFillDateEnd: String?

    public var dagId: Int64?

    public var filterNodeIds: [Int64]?

    public var historyDagId: Int64?

    public var interval: Int32?

    public var isTriggerSubTree: Bool?

    public var startNodeIds: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.backFillDate != nil {
            map["BackFillDate"] = self.backFillDate!
        }
        if self.backFillDateBegin != nil {
            map["BackFillDateBegin"] = self.backFillDateBegin!
        }
        if self.backFillDateEnd != nil {
            map["BackFillDateEnd"] = self.backFillDateEnd!
        }
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.filterNodeIds != nil {
            map["FilterNodeIds"] = self.filterNodeIds!
        }
        if self.historyDagId != nil {
            map["HistoryDagId"] = self.historyDagId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.isTriggerSubTree != nil {
            map["IsTriggerSubTree"] = self.isTriggerSubTree!
        }
        if self.startNodeIds != nil {
            map["StartNodeIds"] = self.startNodeIds!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Asc") {
            self.asc = dict["Asc"] as! Bool
        }
        if dict.keys.contains("BackFillDate") {
            self.backFillDate = dict["BackFillDate"] as! String
        }
        if dict.keys.contains("BackFillDateBegin") {
            self.backFillDateBegin = dict["BackFillDateBegin"] as! String
        }
        if dict.keys.contains("BackFillDateEnd") {
            self.backFillDateEnd = dict["BackFillDateEnd"] as! String
        }
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("FilterNodeIds") {
            self.filterNodeIds = dict["FilterNodeIds"] as! [Int64]
        }
        if dict.keys.contains("HistoryDagId") {
            self.historyDagId = dict["HistoryDagId"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IsTriggerSubTree") {
            self.isTriggerSubTree = dict["IsTriggerSubTree"] as! Bool
        }
        if dict.keys.contains("StartNodeIds") {
            self.startNodeIds = dict["StartNodeIds"] as! [Int64]
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class BackFillShrinkRequest : Tea.TeaModel {
    public var asc: Bool?

    public var backFillDate: String?

    public var backFillDateBegin: String?

    public var backFillDateEnd: String?

    public var dagId: Int64?

    public var filterNodeIdsShrink: String?

    public var historyDagId: Int64?

    public var interval: Int32?

    public var isTriggerSubTree: Bool?

    public var startNodeIdsShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.backFillDate != nil {
            map["BackFillDate"] = self.backFillDate!
        }
        if self.backFillDateBegin != nil {
            map["BackFillDateBegin"] = self.backFillDateBegin!
        }
        if self.backFillDateEnd != nil {
            map["BackFillDateEnd"] = self.backFillDateEnd!
        }
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.filterNodeIdsShrink != nil {
            map["FilterNodeIds"] = self.filterNodeIdsShrink!
        }
        if self.historyDagId != nil {
            map["HistoryDagId"] = self.historyDagId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.isTriggerSubTree != nil {
            map["IsTriggerSubTree"] = self.isTriggerSubTree!
        }
        if self.startNodeIdsShrink != nil {
            map["StartNodeIds"] = self.startNodeIdsShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Asc") {
            self.asc = dict["Asc"] as! Bool
        }
        if dict.keys.contains("BackFillDate") {
            self.backFillDate = dict["BackFillDate"] as! String
        }
        if dict.keys.contains("BackFillDateBegin") {
            self.backFillDateBegin = dict["BackFillDateBegin"] as! String
        }
        if dict.keys.contains("BackFillDateEnd") {
            self.backFillDateEnd = dict["BackFillDateEnd"] as! String
        }
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("FilterNodeIds") {
            self.filterNodeIdsShrink = dict["FilterNodeIds"] as! String
        }
        if dict.keys.contains("HistoryDagId") {
            self.historyDagId = dict["HistoryDagId"] as! Int64
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IsTriggerSubTree") {
            self.isTriggerSubTree = dict["IsTriggerSubTree"] as! Bool
        }
        if dict.keys.contains("StartNodeIds") {
            self.startNodeIdsShrink = dict["StartNodeIds"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class BackFillResponseBody : Tea.TeaModel {
    public var dagInstanceId: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var nodeId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagInstanceId != nil {
            map["DagInstanceId"] = self.dagInstanceId!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagInstanceId") {
            self.dagInstanceId = dict["DagInstanceId"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class BackFillResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BackFillResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BackFillResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchCreateDataLakePartitionsRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var ifNotExists: Bool?

    public var needResult: Bool?

    public var partitionInputs: [DLPartitionInput]?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.ifNotExists != nil {
            map["IfNotExists"] = self.ifNotExists!
        }
        if self.needResult != nil {
            map["NeedResult"] = self.needResult!
        }
        if self.partitionInputs != nil {
            var tmp : [Any] = []
            for k in self.partitionInputs! {
                tmp.append(k.toMap())
            }
            map["PartitionInputs"] = tmp
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("IfNotExists") {
            self.ifNotExists = dict["IfNotExists"] as! Bool
        }
        if dict.keys.contains("NeedResult") {
            self.needResult = dict["NeedResult"] as! Bool
        }
        if dict.keys.contains("PartitionInputs") {
            var tmp : [DLPartitionInput] = []
            for v in dict["PartitionInputs"] as! [Any] {
                var model = DLPartitionInput()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.partitionInputs = tmp
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class BatchCreateDataLakePartitionsShrinkRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var ifNotExists: Bool?

    public var needResult: Bool?

    public var partitionInputsShrink: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.ifNotExists != nil {
            map["IfNotExists"] = self.ifNotExists!
        }
        if self.needResult != nil {
            map["NeedResult"] = self.needResult!
        }
        if self.partitionInputsShrink != nil {
            map["PartitionInputs"] = self.partitionInputsShrink!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("IfNotExists") {
            self.ifNotExists = dict["IfNotExists"] as! Bool
        }
        if dict.keys.contains("NeedResult") {
            self.needResult = dict["NeedResult"] as! Bool
        }
        if dict.keys.contains("PartitionInputs") {
            self.partitionInputsShrink = dict["PartitionInputs"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class BatchCreateDataLakePartitionsResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var partitions: [DLPartition]?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.partitions != nil {
            var tmp : [Any] = []
            for k in self.partitions! {
                tmp.append(k.toMap())
            }
            map["Partitions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("Partitions") {
            var tmp : [DLPartition] = []
            for v in dict["Partitions"] as! [Any] {
                var model = DLPartition()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.partitions = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class BatchCreateDataLakePartitionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchCreateDataLakePartitionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchCreateDataLakePartitionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchDeleteDataLakePartitionsRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var ifExists: Bool?

    public var partitionValuesList: [[String]]?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.ifExists != nil {
            map["IfExists"] = self.ifExists!
        }
        if self.partitionValuesList != nil {
            map["PartitionValuesList"] = self.partitionValuesList!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("IfExists") {
            self.ifExists = dict["IfExists"] as! Bool
        }
        if dict.keys.contains("PartitionValuesList") {
            self.partitionValuesList = dict["PartitionValuesList"] as! [[String]]
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class BatchDeleteDataLakePartitionsResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var partitionErrors: [PartitionError]?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.partitionErrors != nil {
            var tmp : [Any] = []
            for k in self.partitionErrors! {
                tmp.append(k.toMap())
            }
            map["PartitionErrors"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("PartitionErrors") {
            var tmp : [PartitionError] = []
            for v in dict["PartitionErrors"] as! [Any] {
                var model = PartitionError()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.partitionErrors = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class BatchDeleteDataLakePartitionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchDeleteDataLakePartitionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchDeleteDataLakePartitionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchUpdateDataLakePartitionsRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var partitionInputs: [DLPartitionInput]?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.partitionInputs != nil {
            var tmp : [Any] = []
            for k in self.partitionInputs! {
                tmp.append(k.toMap())
            }
            map["PartitionInputs"] = tmp
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("PartitionInputs") {
            var tmp : [DLPartitionInput] = []
            for v in dict["PartitionInputs"] as! [Any] {
                var model = DLPartitionInput()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.partitionInputs = tmp
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class BatchUpdateDataLakePartitionsShrinkRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var partitionInputsShrink: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.partitionInputsShrink != nil {
            map["PartitionInputs"] = self.partitionInputsShrink!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("PartitionInputs") {
            self.partitionInputsShrink = dict["PartitionInputs"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class BatchUpdateDataLakePartitionsResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var partitionErrors: [PartitionError]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.partitionErrors != nil {
            var tmp : [Any] = []
            for k in self.partitionErrors! {
                tmp.append(k.toMap())
            }
            map["PartitionErrors"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("PartitionErrors") {
            var tmp : [PartitionError] = []
            for v in dict["PartitionErrors"] as! [Any] {
                var model = PartitionError()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.partitionErrors = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class BatchUpdateDataLakePartitionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchUpdateDataLakePartitionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchUpdateDataLakePartitionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BuyPayAsYouGoOrderRequest : Tea.TeaModel {
    public var commodityType: String?

    public var insNum: Int32?

    public var tid: Int64?

    public var versionType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commodityType != nil {
            map["CommodityType"] = self.commodityType!
        }
        if self.insNum != nil {
            map["InsNum"] = self.insNum!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.versionType != nil {
            map["VersionType"] = self.versionType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommodityType") {
            self.commodityType = dict["CommodityType"] as! String
        }
        if dict.keys.contains("InsNum") {
            self.insNum = dict["InsNum"] as! Int32
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("VersionType") {
            self.versionType = dict["VersionType"] as! String
        }
    }
}

public class BuyPayAsYouGoOrderResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var instanceId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class BuyPayAsYouGoOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BuyPayAsYouGoOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BuyPayAsYouGoOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeColumnSecLevelRequest : Tea.TeaModel {
    public var columnName: String?

    public var dbId: Int64?

    public var isLogic: Bool?

    public var newLevel: String?

    public var schemaName: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnName != nil {
            map["ColumnName"] = self.columnName!
        }
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.isLogic != nil {
            map["IsLogic"] = self.isLogic!
        }
        if self.newLevel != nil {
            map["NewLevel"] = self.newLevel!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnName") {
            self.columnName = dict["ColumnName"] as! String
        }
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! Int64
        }
        if dict.keys.contains("IsLogic") {
            self.isLogic = dict["IsLogic"] as! Bool
        }
        if dict.keys.contains("NewLevel") {
            self.newLevel = dict["NewLevel"] as! String
        }
        if dict.keys.contains("SchemaName") {
            self.schemaName = dict["SchemaName"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ChangeColumnSecLevelResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ChangeColumnSecLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeColumnSecLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ChangeColumnSecLevelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeColumnSecurityLevelRequest : Tea.TeaModel {
    public var columnName: String?

    public var dbId: Int64?

    public var isLogic: Bool?

    public var newSensitivityLevel: String?

    public var schemaName: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnName != nil {
            map["ColumnName"] = self.columnName!
        }
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.isLogic != nil {
            map["IsLogic"] = self.isLogic!
        }
        if self.newSensitivityLevel != nil {
            map["NewSensitivityLevel"] = self.newSensitivityLevel!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnName") {
            self.columnName = dict["ColumnName"] as! String
        }
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! Int64
        }
        if dict.keys.contains("IsLogic") {
            self.isLogic = dict["IsLogic"] as! Bool
        }
        if dict.keys.contains("NewSensitivityLevel") {
            self.newSensitivityLevel = dict["NewSensitivityLevel"] as! String
        }
        if dict.keys.contains("SchemaName") {
            self.schemaName = dict["SchemaName"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ChangeColumnSecurityLevelResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ChangeColumnSecurityLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeColumnSecurityLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ChangeColumnSecurityLevelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeLhDagOwnerRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var ownerUserId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.ownerUserId != nil {
            map["OwnerUserId"] = self.ownerUserId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("OwnerUserId") {
            self.ownerUserId = dict["OwnerUserId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ChangeLhDagOwnerResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ChangeLhDagOwnerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeLhDagOwnerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ChangeLhDagOwnerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CloseOrderRequest : Tea.TeaModel {
    public var closeReason: String?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.closeReason != nil {
            map["CloseReason"] = self.closeReason!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CloseReason") {
            self.closeReason = dict["CloseReason"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CloseOrderResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CloseOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloseOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CloseOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAbacAuthorizationRequest : Tea.TeaModel {
    public var identityType: String?

    public var policyId: Int64?

    public var roleId: Int64?

    public var tid: Int64?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.identityType != nil {
            map["IdentityType"] = self.identityType!
        }
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        if self.roleId != nil {
            map["RoleId"] = self.roleId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IdentityType") {
            self.identityType = dict["IdentityType"] as! String
        }
        if dict.keys.contains("PolicyId") {
            self.policyId = dict["PolicyId"] as! Int64
        }
        if dict.keys.contains("RoleId") {
            self.roleId = dict["RoleId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class CreateAbacAuthorizationResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateAbacAuthorizationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAbacAuthorizationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAbacAuthorizationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAbacPolicyRequest : Tea.TeaModel {
    public var abacPolicyContent: String?

    public var abacPolicyDesc: String?

    public var abacPolicyName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.abacPolicyContent != nil {
            map["AbacPolicyContent"] = self.abacPolicyContent!
        }
        if self.abacPolicyDesc != nil {
            map["AbacPolicyDesc"] = self.abacPolicyDesc!
        }
        if self.abacPolicyName != nil {
            map["AbacPolicyName"] = self.abacPolicyName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AbacPolicyContent") {
            self.abacPolicyContent = dict["AbacPolicyContent"] as! String
        }
        if dict.keys.contains("AbacPolicyDesc") {
            self.abacPolicyDesc = dict["AbacPolicyDesc"] as! String
        }
        if dict.keys.contains("AbacPolicyName") {
            self.abacPolicyName = dict["AbacPolicyName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateAbacPolicyResponseBody : Tea.TeaModel {
    public var createPolicyResult: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createPolicyResult != nil {
            map["CreatePolicyResult"] = self.createPolicyResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreatePolicyResult") {
            self.createPolicyResult = dict["CreatePolicyResult"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateAbacPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAbacPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAbacPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAuthorityTemplateRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateAuthorityTemplateResponseBody : Tea.TeaModel {
    public class AuthorityTemplateView : Tea.TeaModel {
        public var createTime: String?

        public var creatorId: Int64?

        public var description_: String?

        public var name: String?

        public var templateId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! Int64
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! Int64
            }
        }
    }
    public var authorityTemplateView: CreateAuthorityTemplateResponseBody.AuthorityTemplateView?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authorityTemplateView?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorityTemplateView != nil {
            map["AuthorityTemplateView"] = self.authorityTemplateView?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorityTemplateView") {
            var model = CreateAuthorityTemplateResponseBody.AuthorityTemplateView()
            model.fromMap(dict["AuthorityTemplateView"] as! [String: Any])
            self.authorityTemplateView = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateAuthorityTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAuthorityTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAuthorityTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataArchiveOrderRequest : Tea.TeaModel {
    public class Param : Tea.TeaModel {
        public class TableIncludes : Tea.TeaModel {
            public var tableName: String?

            public var tableWhere: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.tableWhere != nil {
                    map["TableWhere"] = self.tableWhere!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("TableWhere") {
                    self.tableWhere = dict["TableWhere"] as! String
                }
            }
        }
        public class Variables : Tea.TeaModel {
            public var name: String?

            public var pattern: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.pattern != nil {
                    map["Pattern"] = self.pattern!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Pattern") {
                    self.pattern = dict["Pattern"] as! String
                }
            }
        }
        public var archiveMethod: String?

        public var cronStr: String?

        public var databaseId: String?

        public var logic: Bool?

        public var orderAfter: [String]?

        public var runMethod: String?

        public var sourceCatalogName: String?

        public var sourceInstanceName: String?

        public var sourceSchemaName: String?

        public var tableIncludes: [CreateDataArchiveOrderRequest.Param.TableIncludes]?

        public var tableMapping: [String]?

        public var targetInstanceHost: String?

        public var variables: [CreateDataArchiveOrderRequest.Param.Variables]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.archiveMethod != nil {
                map["ArchiveMethod"] = self.archiveMethod!
            }
            if self.cronStr != nil {
                map["CronStr"] = self.cronStr!
            }
            if self.databaseId != nil {
                map["DatabaseId"] = self.databaseId!
            }
            if self.logic != nil {
                map["Logic"] = self.logic!
            }
            if self.orderAfter != nil {
                map["OrderAfter"] = self.orderAfter!
            }
            if self.runMethod != nil {
                map["RunMethod"] = self.runMethod!
            }
            if self.sourceCatalogName != nil {
                map["SourceCatalogName"] = self.sourceCatalogName!
            }
            if self.sourceInstanceName != nil {
                map["SourceInstanceName"] = self.sourceInstanceName!
            }
            if self.sourceSchemaName != nil {
                map["SourceSchemaName"] = self.sourceSchemaName!
            }
            if self.tableIncludes != nil {
                var tmp : [Any] = []
                for k in self.tableIncludes! {
                    tmp.append(k.toMap())
                }
                map["TableIncludes"] = tmp
            }
            if self.tableMapping != nil {
                map["TableMapping"] = self.tableMapping!
            }
            if self.targetInstanceHost != nil {
                map["TargetInstanceHost"] = self.targetInstanceHost!
            }
            if self.variables != nil {
                var tmp : [Any] = []
                for k in self.variables! {
                    tmp.append(k.toMap())
                }
                map["Variables"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ArchiveMethod") {
                self.archiveMethod = dict["ArchiveMethod"] as! String
            }
            if dict.keys.contains("CronStr") {
                self.cronStr = dict["CronStr"] as! String
            }
            if dict.keys.contains("DatabaseId") {
                self.databaseId = dict["DatabaseId"] as! String
            }
            if dict.keys.contains("Logic") {
                self.logic = dict["Logic"] as! Bool
            }
            if dict.keys.contains("OrderAfter") {
                self.orderAfter = dict["OrderAfter"] as! [String]
            }
            if dict.keys.contains("RunMethod") {
                self.runMethod = dict["RunMethod"] as! String
            }
            if dict.keys.contains("SourceCatalogName") {
                self.sourceCatalogName = dict["SourceCatalogName"] as! String
            }
            if dict.keys.contains("SourceInstanceName") {
                self.sourceInstanceName = dict["SourceInstanceName"] as! String
            }
            if dict.keys.contains("SourceSchemaName") {
                self.sourceSchemaName = dict["SourceSchemaName"] as! String
            }
            if dict.keys.contains("TableIncludes") {
                var tmp : [CreateDataArchiveOrderRequest.Param.TableIncludes] = []
                for v in dict["TableIncludes"] as! [Any] {
                    var model = CreateDataArchiveOrderRequest.Param.TableIncludes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tableIncludes = tmp
            }
            if dict.keys.contains("TableMapping") {
                self.tableMapping = dict["TableMapping"] as! [String]
            }
            if dict.keys.contains("TargetInstanceHost") {
                self.targetInstanceHost = dict["TargetInstanceHost"] as! String
            }
            if dict.keys.contains("Variables") {
                var tmp : [CreateDataArchiveOrderRequest.Param.Variables] = []
                for v in dict["Variables"] as! [Any] {
                    var model = CreateDataArchiveOrderRequest.Param.Variables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.variables = tmp
            }
        }
    }
    public var comment: String?

    public var param: CreateDataArchiveOrderRequest.Param?

    public var parentId: Int64?

    public var pluginType: String?

    public var relatedUserList: [String]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.param?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.param != nil {
            map["Param"] = self.param?.toMap()
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.pluginType != nil {
            map["PluginType"] = self.pluginType!
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") {
            var model = CreateDataArchiveOrderRequest.Param()
            model.fromMap(dict["Param"] as! [String: Any])
            self.param = model
        }
        if dict.keys.contains("ParentId") {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("PluginType") {
            self.pluginType = dict["PluginType"] as! String
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserList = dict["RelatedUserList"] as! [String]
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataArchiveOrderShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var paramShrink: String?

    public var parentId: Int64?

    public var pluginType: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.paramShrink != nil {
            map["Param"] = self.paramShrink!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.pluginType != nil {
            map["PluginType"] = self.pluginType!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") {
            self.paramShrink = dict["Param"] as! String
        }
        if dict.keys.contains("ParentId") {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("PluginType") {
            self.pluginType = dict["PluginType"] as! String
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataArchiveOrderResponseBody : Tea.TeaModel {
    public var createOrderResult: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") {
            self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDataArchiveOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataArchiveOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataArchiveOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataCorrectOrderRequest : Tea.TeaModel {
    public class Param : Tea.TeaModel {
        public class DbItemList : Tea.TeaModel {
            public var dbId: Int64?

            public var instanceId: Int64?

            public var logic: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
            }
        }
        public var attachmentName: String?

        public var classify: String?

        public var dbItemList: [CreateDataCorrectOrderRequest.Param.DbItemList]?

        public var estimateAffectRows: Int64?

        public var execMode: String?

        public var execSQL: String?

        public var rollbackAttachmentName: String?

        public var rollbackSQL: String?

        public var rollbackSqlType: String?

        public var sqlType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachmentName != nil {
                map["AttachmentName"] = self.attachmentName!
            }
            if self.classify != nil {
                map["Classify"] = self.classify!
            }
            if self.dbItemList != nil {
                var tmp : [Any] = []
                for k in self.dbItemList! {
                    tmp.append(k.toMap())
                }
                map["DbItemList"] = tmp
            }
            if self.estimateAffectRows != nil {
                map["EstimateAffectRows"] = self.estimateAffectRows!
            }
            if self.execMode != nil {
                map["ExecMode"] = self.execMode!
            }
            if self.execSQL != nil {
                map["ExecSQL"] = self.execSQL!
            }
            if self.rollbackAttachmentName != nil {
                map["RollbackAttachmentName"] = self.rollbackAttachmentName!
            }
            if self.rollbackSQL != nil {
                map["RollbackSQL"] = self.rollbackSQL!
            }
            if self.rollbackSqlType != nil {
                map["RollbackSqlType"] = self.rollbackSqlType!
            }
            if self.sqlType != nil {
                map["SqlType"] = self.sqlType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachmentName") {
                self.attachmentName = dict["AttachmentName"] as! String
            }
            if dict.keys.contains("Classify") {
                self.classify = dict["Classify"] as! String
            }
            if dict.keys.contains("DbItemList") {
                var tmp : [CreateDataCorrectOrderRequest.Param.DbItemList] = []
                for v in dict["DbItemList"] as! [Any] {
                    var model = CreateDataCorrectOrderRequest.Param.DbItemList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dbItemList = tmp
            }
            if dict.keys.contains("EstimateAffectRows") {
                self.estimateAffectRows = dict["EstimateAffectRows"] as! Int64
            }
            if dict.keys.contains("ExecMode") {
                self.execMode = dict["ExecMode"] as! String
            }
            if dict.keys.contains("ExecSQL") {
                self.execSQL = dict["ExecSQL"] as! String
            }
            if dict.keys.contains("RollbackAttachmentName") {
                self.rollbackAttachmentName = dict["RollbackAttachmentName"] as! String
            }
            if dict.keys.contains("RollbackSQL") {
                self.rollbackSQL = dict["RollbackSQL"] as! String
            }
            if dict.keys.contains("RollbackSqlType") {
                self.rollbackSqlType = dict["RollbackSqlType"] as! String
            }
            if dict.keys.contains("SqlType") {
                self.sqlType = dict["SqlType"] as! String
            }
        }
    }
    public var attachmentKey: String?

    public var comment: String?

    public var param: CreateDataCorrectOrderRequest.Param?

    public var realLoginUserUid: String?

    public var relatedUserList: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.param?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.param != nil {
            map["Param"] = self.param?.toMap()
        }
        if self.realLoginUserUid != nil {
            map["RealLoginUserUid"] = self.realLoginUserUid!
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") {
            var model = CreateDataCorrectOrderRequest.Param()
            model.fromMap(dict["Param"] as! [String: Any])
            self.param = model
        }
        if dict.keys.contains("RealLoginUserUid") {
            self.realLoginUserUid = dict["RealLoginUserUid"] as! String
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserList = dict["RelatedUserList"] as! [Int64]
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataCorrectOrderShrinkRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var paramShrink: String?

    public var realLoginUserUid: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.paramShrink != nil {
            map["Param"] = self.paramShrink!
        }
        if self.realLoginUserUid != nil {
            map["RealLoginUserUid"] = self.realLoginUserUid!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") {
            self.paramShrink = dict["Param"] as! String
        }
        if dict.keys.contains("RealLoginUserUid") {
            self.realLoginUserUid = dict["RealLoginUserUid"] as! String
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataCorrectOrderResponseBody : Tea.TeaModel {
    public var createOrderResult: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") {
            self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDataCorrectOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataCorrectOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataCorrectOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataCronClearOrderRequest : Tea.TeaModel {
    public class Param : Tea.TeaModel {
        public class CronClearItemList : Tea.TeaModel {
            public var columnName: String?

            public var filterSQL: String?

            public var remainDays: Int64?

            public var tableName: String?

            public var timeUnit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.filterSQL != nil {
                    map["FilterSQL"] = self.filterSQL!
                }
                if self.remainDays != nil {
                    map["RemainDays"] = self.remainDays!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.timeUnit != nil {
                    map["TimeUnit"] = self.timeUnit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColumnName") {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("FilterSQL") {
                    self.filterSQL = dict["FilterSQL"] as! String
                }
                if dict.keys.contains("RemainDays") {
                    self.remainDays = dict["RemainDays"] as! Int64
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("TimeUnit") {
                    self.timeUnit = dict["TimeUnit"] as! String
                }
            }
        }
        public class DbItemList : Tea.TeaModel {
            public var dbId: Int64?

            public var logic: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
            }
        }
        public var classify: String?

        public var cronClearItemList: [CreateDataCronClearOrderRequest.Param.CronClearItemList]?

        public var cronFormat: String?

        public var dbItemList: [CreateDataCronClearOrderRequest.Param.DbItemList]?

        public var durationHour: Int64?

        public var specifyDuration: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classify != nil {
                map["Classify"] = self.classify!
            }
            if self.cronClearItemList != nil {
                var tmp : [Any] = []
                for k in self.cronClearItemList! {
                    tmp.append(k.toMap())
                }
                map["CronClearItemList"] = tmp
            }
            if self.cronFormat != nil {
                map["CronFormat"] = self.cronFormat!
            }
            if self.dbItemList != nil {
                var tmp : [Any] = []
                for k in self.dbItemList! {
                    tmp.append(k.toMap())
                }
                map["DbItemList"] = tmp
            }
            if self.durationHour != nil {
                map["DurationHour"] = self.durationHour!
            }
            if self.specifyDuration != nil {
                map["specifyDuration"] = self.specifyDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Classify") {
                self.classify = dict["Classify"] as! String
            }
            if dict.keys.contains("CronClearItemList") {
                var tmp : [CreateDataCronClearOrderRequest.Param.CronClearItemList] = []
                for v in dict["CronClearItemList"] as! [Any] {
                    var model = CreateDataCronClearOrderRequest.Param.CronClearItemList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.cronClearItemList = tmp
            }
            if dict.keys.contains("CronFormat") {
                self.cronFormat = dict["CronFormat"] as! String
            }
            if dict.keys.contains("DbItemList") {
                var tmp : [CreateDataCronClearOrderRequest.Param.DbItemList] = []
                for v in dict["DbItemList"] as! [Any] {
                    var model = CreateDataCronClearOrderRequest.Param.DbItemList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dbItemList = tmp
            }
            if dict.keys.contains("DurationHour") {
                self.durationHour = dict["DurationHour"] as! Int64
            }
            if dict.keys.contains("specifyDuration") {
                self.specifyDuration = dict["specifyDuration"] as! Bool
            }
        }
    }
    public var attachmentKey: String?

    public var comment: String?

    public var param: CreateDataCronClearOrderRequest.Param?

    public var relatedUserList: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.param?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.param != nil {
            map["Param"] = self.param?.toMap()
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") {
            var model = CreateDataCronClearOrderRequest.Param()
            model.fromMap(dict["Param"] as! [String: Any])
            self.param = model
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserList = dict["RelatedUserList"] as! [Int64]
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataCronClearOrderShrinkRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var paramShrink: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.paramShrink != nil {
            map["Param"] = self.paramShrink!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") {
            self.paramShrink = dict["Param"] as! String
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataCronClearOrderResponseBody : Tea.TeaModel {
    public var createOrderResult: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") {
            self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDataCronClearOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataCronClearOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataCronClearOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataExportOrderRequest : Tea.TeaModel {
    public class PluginParam : Tea.TeaModel {
        public class Watermark : Tea.TeaModel {
            public var columnName: String?

            public var dataWatermark: String?

            public var fileWatermark: String?

            public var keys: [String]?

            public var watermarkTypes: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.dataWatermark != nil {
                    map["DataWatermark"] = self.dataWatermark!
                }
                if self.fileWatermark != nil {
                    map["FileWatermark"] = self.fileWatermark!
                }
                if self.keys != nil {
                    map["Keys"] = self.keys!
                }
                if self.watermarkTypes != nil {
                    map["WatermarkTypes"] = self.watermarkTypes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColumnName") {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("DataWatermark") {
                    self.dataWatermark = dict["DataWatermark"] as! String
                }
                if dict.keys.contains("FileWatermark") {
                    self.fileWatermark = dict["FileWatermark"] as! String
                }
                if dict.keys.contains("Keys") {
                    self.keys = dict["Keys"] as! [String]
                }
                if dict.keys.contains("WatermarkTypes") {
                    self.watermarkTypes = dict["WatermarkTypes"] as! [String]
                }
            }
        }
        public var affectRows: Int64?

        public var classify: String?

        public var dbId: Int64?

        public var exeSQL: String?

        public var ignoreAffectRows: Bool?

        public var ignoreAffectRowsReason: String?

        public var instanceId: Int64?

        public var logic: Bool?

        public var watermark: CreateDataExportOrderRequest.PluginParam.Watermark?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.watermark?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.affectRows != nil {
                map["AffectRows"] = self.affectRows!
            }
            if self.classify != nil {
                map["Classify"] = self.classify!
            }
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.exeSQL != nil {
                map["ExeSQL"] = self.exeSQL!
            }
            if self.ignoreAffectRows != nil {
                map["IgnoreAffectRows"] = self.ignoreAffectRows!
            }
            if self.ignoreAffectRowsReason != nil {
                map["IgnoreAffectRowsReason"] = self.ignoreAffectRowsReason!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.logic != nil {
                map["Logic"] = self.logic!
            }
            if self.watermark != nil {
                map["Watermark"] = self.watermark?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AffectRows") {
                self.affectRows = dict["AffectRows"] as! Int64
            }
            if dict.keys.contains("Classify") {
                self.classify = dict["Classify"] as! String
            }
            if dict.keys.contains("DbId") {
                self.dbId = dict["DbId"] as! Int64
            }
            if dict.keys.contains("ExeSQL") {
                self.exeSQL = dict["ExeSQL"] as! String
            }
            if dict.keys.contains("IgnoreAffectRows") {
                self.ignoreAffectRows = dict["IgnoreAffectRows"] as! Bool
            }
            if dict.keys.contains("IgnoreAffectRowsReason") {
                self.ignoreAffectRowsReason = dict["IgnoreAffectRowsReason"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("Logic") {
                self.logic = dict["Logic"] as! Bool
            }
            if dict.keys.contains("Watermark") {
                var model = CreateDataExportOrderRequest.PluginParam.Watermark()
                model.fromMap(dict["Watermark"] as! [String: Any])
                self.watermark = model
            }
        }
    }
    public var attachmentKey: String?

    public var comment: String?

    public var parentId: Int64?

    public var pluginParam: CreateDataExportOrderRequest.PluginParam?

    public var realLoginUserUid: String?

    public var relatedUserList: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pluginParam?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.pluginParam != nil {
            map["PluginParam"] = self.pluginParam?.toMap()
        }
        if self.realLoginUserUid != nil {
            map["RealLoginUserUid"] = self.realLoginUserUid!
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("ParentId") {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("PluginParam") {
            var model = CreateDataExportOrderRequest.PluginParam()
            model.fromMap(dict["PluginParam"] as! [String: Any])
            self.pluginParam = model
        }
        if dict.keys.contains("RealLoginUserUid") {
            self.realLoginUserUid = dict["RealLoginUserUid"] as! String
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserList = dict["RelatedUserList"] as! [Int64]
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataExportOrderShrinkRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var parentId: Int64?

    public var pluginParamShrink: String?

    public var realLoginUserUid: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.pluginParamShrink != nil {
            map["PluginParam"] = self.pluginParamShrink!
        }
        if self.realLoginUserUid != nil {
            map["RealLoginUserUid"] = self.realLoginUserUid!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("ParentId") {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("PluginParam") {
            self.pluginParamShrink = dict["PluginParam"] as! String
        }
        if dict.keys.contains("RealLoginUserUid") {
            self.realLoginUserUid = dict["RealLoginUserUid"] as! String
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataExportOrderResponseBody : Tea.TeaModel {
    public class CreateOrderResult : Tea.TeaModel {
        public var createOrderResult: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createOrderResult != nil {
                map["CreateOrderResult"] = self.createOrderResult!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateOrderResult") {
                self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
            }
        }
    }
    public var createOrderResult: CreateDataExportOrderResponseBody.CreateOrderResult?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createOrderResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") {
            var model = CreateDataExportOrderResponseBody.CreateOrderResult()
            model.fromMap(dict["CreateOrderResult"] as! [String: Any])
            self.createOrderResult = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDataExportOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataExportOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataExportOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataImportOrderRequest : Tea.TeaModel {
    public class Param : Tea.TeaModel {
        public class DbItemList : Tea.TeaModel {
            public var dbId: Int64?

            public var logic: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
            }
        }
        public var attachmentName: String?

        public var classify: String?

        public var csvFirstRowIsColumnDef: Bool?

        public var dbItemList: [CreateDataImportOrderRequest.Param.DbItemList]?

        public var execMode: String?

        public var fileEncoding: String?

        public var fileType: String?

        public var ignoreError: Bool?

        public var importMode: String?

        public var insertType: String?

        public var rollbackAttachmentName: String?

        public var rollbackSQL: String?

        public var rollbackSqlType: String?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachmentName != nil {
                map["AttachmentName"] = self.attachmentName!
            }
            if self.classify != nil {
                map["Classify"] = self.classify!
            }
            if self.csvFirstRowIsColumnDef != nil {
                map["CsvFirstRowIsColumnDef"] = self.csvFirstRowIsColumnDef!
            }
            if self.dbItemList != nil {
                var tmp : [Any] = []
                for k in self.dbItemList! {
                    tmp.append(k.toMap())
                }
                map["DbItemList"] = tmp
            }
            if self.execMode != nil {
                map["ExecMode"] = self.execMode!
            }
            if self.fileEncoding != nil {
                map["FileEncoding"] = self.fileEncoding!
            }
            if self.fileType != nil {
                map["FileType"] = self.fileType!
            }
            if self.ignoreError != nil {
                map["IgnoreError"] = self.ignoreError!
            }
            if self.importMode != nil {
                map["ImportMode"] = self.importMode!
            }
            if self.insertType != nil {
                map["InsertType"] = self.insertType!
            }
            if self.rollbackAttachmentName != nil {
                map["RollbackAttachmentName"] = self.rollbackAttachmentName!
            }
            if self.rollbackSQL != nil {
                map["RollbackSQL"] = self.rollbackSQL!
            }
            if self.rollbackSqlType != nil {
                map["RollbackSqlType"] = self.rollbackSqlType!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachmentName") {
                self.attachmentName = dict["AttachmentName"] as! String
            }
            if dict.keys.contains("Classify") {
                self.classify = dict["Classify"] as! String
            }
            if dict.keys.contains("CsvFirstRowIsColumnDef") {
                self.csvFirstRowIsColumnDef = dict["CsvFirstRowIsColumnDef"] as! Bool
            }
            if dict.keys.contains("DbItemList") {
                var tmp : [CreateDataImportOrderRequest.Param.DbItemList] = []
                for v in dict["DbItemList"] as! [Any] {
                    var model = CreateDataImportOrderRequest.Param.DbItemList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dbItemList = tmp
            }
            if dict.keys.contains("ExecMode") {
                self.execMode = dict["ExecMode"] as! String
            }
            if dict.keys.contains("FileEncoding") {
                self.fileEncoding = dict["FileEncoding"] as! String
            }
            if dict.keys.contains("FileType") {
                self.fileType = dict["FileType"] as! String
            }
            if dict.keys.contains("IgnoreError") {
                self.ignoreError = dict["IgnoreError"] as! Bool
            }
            if dict.keys.contains("ImportMode") {
                self.importMode = dict["ImportMode"] as! String
            }
            if dict.keys.contains("InsertType") {
                self.insertType = dict["InsertType"] as! String
            }
            if dict.keys.contains("RollbackAttachmentName") {
                self.rollbackAttachmentName = dict["RollbackAttachmentName"] as! String
            }
            if dict.keys.contains("RollbackSQL") {
                self.rollbackSQL = dict["RollbackSQL"] as! String
            }
            if dict.keys.contains("RollbackSqlType") {
                self.rollbackSqlType = dict["RollbackSqlType"] as! String
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
        }
    }
    public var attachmentKey: String?

    public var comment: String?

    public var param: CreateDataImportOrderRequest.Param?

    public var relatedUserList: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.param?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.param != nil {
            map["Param"] = self.param?.toMap()
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") {
            var model = CreateDataImportOrderRequest.Param()
            model.fromMap(dict["Param"] as! [String: Any])
            self.param = model
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserList = dict["RelatedUserList"] as! [Int64]
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataImportOrderShrinkRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var paramShrink: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.paramShrink != nil {
            map["Param"] = self.paramShrink!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") {
            self.paramShrink = dict["Param"] as! String
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataImportOrderResponseBody : Tea.TeaModel {
    public var createOrderResult: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") {
            self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDataImportOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataImportOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataImportOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataLakeDatabaseRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var description_: String?

    public var location: String?

    public var parameters: [String: String]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("Parameters") {
            self.parameters = dict["Parameters"] as! [String: String]
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataLakeDatabaseShrinkRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var description_: String?

    public var location: String?

    public var parametersShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.parametersShrink != nil {
            map["Parameters"] = self.parametersShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("Parameters") {
            self.parametersShrink = dict["Parameters"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataLakeDatabaseResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDataLakeDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataLakeDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataLakeDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataLakePartitionRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var ifNotExists: Bool?

    public var needResult: Bool?

    public var partitionInput: DLPartitionInput?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.partitionInput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.ifNotExists != nil {
            map["IfNotExists"] = self.ifNotExists!
        }
        if self.needResult != nil {
            map["NeedResult"] = self.needResult!
        }
        if self.partitionInput != nil {
            map["PartitionInput"] = self.partitionInput?.toMap()
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("IfNotExists") {
            self.ifNotExists = dict["IfNotExists"] as! Bool
        }
        if dict.keys.contains("NeedResult") {
            self.needResult = dict["NeedResult"] as! Bool
        }
        if dict.keys.contains("PartitionInput") {
            var model = DLPartitionInput()
            model.fromMap(dict["PartitionInput"] as! [String: Any])
            self.partitionInput = model
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataLakePartitionShrinkRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var ifNotExists: Bool?

    public var needResult: Bool?

    public var partitionInputShrink: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.ifNotExists != nil {
            map["IfNotExists"] = self.ifNotExists!
        }
        if self.needResult != nil {
            map["NeedResult"] = self.needResult!
        }
        if self.partitionInputShrink != nil {
            map["PartitionInput"] = self.partitionInputShrink!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("IfNotExists") {
            self.ifNotExists = dict["IfNotExists"] as! Bool
        }
        if dict.keys.contains("NeedResult") {
            self.needResult = dict["NeedResult"] as! Bool
        }
        if dict.keys.contains("PartitionInput") {
            self.partitionInputShrink = dict["PartitionInput"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataLakePartitionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var partition: DLPartition?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.partition?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.partition != nil {
            map["Partition"] = self.partition?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("Partition") {
            var model = DLPartition()
            model.fromMap(dict["Partition"] as! [String: Any])
            self.partition = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDataLakePartitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataLakePartitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataLakePartitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataLakeTableRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var tableInput: OpenStructDLTableInput?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tableInput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.tableInput != nil {
            map["TableInput"] = self.tableInput?.toMap()
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("TableInput") {
            var model = OpenStructDLTableInput()
            model.fromMap(dict["TableInput"] as! [String: Any])
            self.tableInput = model
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataLakeTableShrinkRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var tableInputShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.tableInputShrink != nil {
            map["TableInput"] = self.tableInputShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("TableInput") {
            self.tableInputShrink = dict["TableInput"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataLakeTableResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var table: DLTable?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.table?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.table != nil {
            map["Table"] = self.table?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Table") {
            var model = DLTable()
            model.fromMap(dict["Table"] as! [String: Any])
            self.table = model
        }
    }
}

public class CreateDataLakeTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataLakeTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataLakeTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataTrackOrderRequest : Tea.TeaModel {
    public class Param : Tea.TeaModel {
        public var dbId: String?

        public var jobEndTime: String?

        public var jobStartTime: String?

        public var tableNames: [String]?

        public var trackTypes: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.jobEndTime != nil {
                map["JobEndTime"] = self.jobEndTime!
            }
            if self.jobStartTime != nil {
                map["JobStartTime"] = self.jobStartTime!
            }
            if self.tableNames != nil {
                map["TableNames"] = self.tableNames!
            }
            if self.trackTypes != nil {
                map["TrackTypes"] = self.trackTypes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbId") {
                self.dbId = dict["DbId"] as! String
            }
            if dict.keys.contains("JobEndTime") {
                self.jobEndTime = dict["JobEndTime"] as! String
            }
            if dict.keys.contains("JobStartTime") {
                self.jobStartTime = dict["JobStartTime"] as! String
            }
            if dict.keys.contains("TableNames") {
                self.tableNames = dict["TableNames"] as! [String]
            }
            if dict.keys.contains("TrackTypes") {
                self.trackTypes = dict["TrackTypes"] as! [String]
            }
        }
    }
    public var comment: String?

    public var param: CreateDataTrackOrderRequest.Param?

    public var relatedUserList: [String]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.param?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.param != nil {
            map["Param"] = self.param?.toMap()
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") {
            var model = CreateDataTrackOrderRequest.Param()
            model.fromMap(dict["Param"] as! [String: Any])
            self.param = model
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserList = dict["RelatedUserList"] as! [String]
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataTrackOrderShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var paramShrink: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.paramShrink != nil {
            map["Param"] = self.paramShrink!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") {
            self.paramShrink = dict["Param"] as! String
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataTrackOrderResponseBody : Tea.TeaModel {
    public var createOrderResult: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") {
            self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDataTrackOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataTrackOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataTrackOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDatabaseExportOrderRequest : Tea.TeaModel {
    public class PluginParam : Tea.TeaModel {
        public class Config : Tea.TeaModel {
            public var dataOption: [String]?

            public var exportContent: String?

            public var exportTypes: [String]?

            public var SQLExtOption: [String]?

            public var selectedTables: [String]?

            public var tables: [String: String]?

            public var targetOption: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataOption != nil {
                    map["DataOption"] = self.dataOption!
                }
                if self.exportContent != nil {
                    map["ExportContent"] = self.exportContent!
                }
                if self.exportTypes != nil {
                    map["ExportTypes"] = self.exportTypes!
                }
                if self.SQLExtOption != nil {
                    map["SQLExtOption"] = self.SQLExtOption!
                }
                if self.selectedTables != nil {
                    map["SelectedTables"] = self.selectedTables!
                }
                if self.tables != nil {
                    map["Tables"] = self.tables!
                }
                if self.targetOption != nil {
                    map["TargetOption"] = self.targetOption!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataOption") {
                    self.dataOption = dict["DataOption"] as! [String]
                }
                if dict.keys.contains("ExportContent") {
                    self.exportContent = dict["ExportContent"] as! String
                }
                if dict.keys.contains("ExportTypes") {
                    self.exportTypes = dict["ExportTypes"] as! [String]
                }
                if dict.keys.contains("SQLExtOption") {
                    self.SQLExtOption = dict["SQLExtOption"] as! [String]
                }
                if dict.keys.contains("SelectedTables") {
                    self.selectedTables = dict["SelectedTables"] as! [String]
                }
                if dict.keys.contains("Tables") {
                    self.tables = dict["Tables"] as! [String: String]
                }
                if dict.keys.contains("TargetOption") {
                    self.targetOption = dict["TargetOption"] as! String
                }
            }
        }
        public var classify: String?

        public var config: CreateDatabaseExportOrderRequest.PluginParam.Config?

        public var dbId: Int64?

        public var instanceId: Int64?

        public var logic: Bool?

        public var searchName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.config?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classify != nil {
                map["Classify"] = self.classify!
            }
            if self.config != nil {
                map["Config"] = self.config?.toMap()
            }
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.logic != nil {
                map["Logic"] = self.logic!
            }
            if self.searchName != nil {
                map["SearchName"] = self.searchName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Classify") {
                self.classify = dict["Classify"] as! String
            }
            if dict.keys.contains("Config") {
                var model = CreateDatabaseExportOrderRequest.PluginParam.Config()
                model.fromMap(dict["Config"] as! [String: Any])
                self.config = model
            }
            if dict.keys.contains("DbId") {
                self.dbId = dict["DbId"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("Logic") {
                self.logic = dict["Logic"] as! Bool
            }
            if dict.keys.contains("SearchName") {
                self.searchName = dict["SearchName"] as! String
            }
        }
    }
    public var attachmentKey: String?

    public var comment: String?

    public var parentId: Int64?

    public var pluginParam: CreateDatabaseExportOrderRequest.PluginParam?

    public var relatedUserList: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pluginParam?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.pluginParam != nil {
            map["PluginParam"] = self.pluginParam?.toMap()
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("ParentId") {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("PluginParam") {
            var model = CreateDatabaseExportOrderRequest.PluginParam()
            model.fromMap(dict["PluginParam"] as! [String: Any])
            self.pluginParam = model
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserList = dict["RelatedUserList"] as! [Int64]
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDatabaseExportOrderShrinkRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var parentId: Int64?

    public var pluginParamShrink: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.pluginParamShrink != nil {
            map["PluginParam"] = self.pluginParamShrink!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("ParentId") {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("PluginParam") {
            self.pluginParamShrink = dict["PluginParam"] as! String
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDatabaseExportOrderResponseBody : Tea.TeaModel {
    public class CreateOrderResult : Tea.TeaModel {
        public var createOrderResult: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createOrderResult != nil {
                map["CreateOrderResult"] = self.createOrderResult!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateOrderResult") {
                self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
            }
        }
    }
    public var createOrderResult: CreateDatabaseExportOrderResponseBody.CreateOrderResult?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createOrderResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") {
            var model = CreateDatabaseExportOrderResponseBody.CreateOrderResult()
            model.fromMap(dict["CreateOrderResult"] as! [String: Any])
            self.createOrderResult = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDatabaseExportOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDatabaseExportOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDatabaseExportOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDifyInstanceRequest : Tea.TeaModel {
    public var adbpgInstanceMode: String?

    public var clientToken: String?

    public var dataRegion: String?

    public var databaseOption: String?

    public var dbEngineType: String?

    public var dbEngineVersion: String?

    public var dbInstanceAccount: String?

    public var dbInstanceCategory: String?

    public var dbInstanceClass: String?

    public var dbInstancePassword: String?

    public var dbResourceId: Int32?

    public var dbStorageSize: String?

    public var dbStorageType: String?

    public var dryRun: Bool?

    public var kvStoreAccount: String?

    public var kvStoreEngineVersion: String?

    public var kvStoreInstanceClass: String?

    public var kvStoreNodeType: String?

    public var kvStoreOption: String?

    public var kvStorePassword: String?

    public var kvStoreResourceId: Int32?

    public var kvStoreType: String?

    public var ossPath: String?

    public var ossResourceId: Int32?

    public var payPeriod: Int32?

    public var payPeriodType: String?

    public var payType: String?

    public var replicas: Int32?

    public var resourceQuota: String?

    public var securityGroupId: String?

    public var segDiskPerformanceLevel: String?

    public var segNodeNum: Int32?

    public var storageType: String?

    public var vSwitchId: String?

    public var vectordbAccount: String?

    public var vectordbCategory: String?

    public var vectordbEngineVersion: String?

    public var vectordbInstanceSpec: String?

    public var vectordbOption: String?

    public var vectordbPassword: String?

    public var vectordbResourceId: Int32?

    public var vectordbStorageSize: String?

    public var vectordbStorageType: String?

    public var vectordbType: String?

    public var vpcId: String?

    public var workspaceDescription: String?

    public var workspaceId: String?

    public var workspaceName: String?

    public var workspaceOption: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adbpgInstanceMode != nil {
            map["AdbpgInstanceMode"] = self.adbpgInstanceMode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.databaseOption != nil {
            map["DatabaseOption"] = self.databaseOption!
        }
        if self.dbEngineType != nil {
            map["DbEngineType"] = self.dbEngineType!
        }
        if self.dbEngineVersion != nil {
            map["DbEngineVersion"] = self.dbEngineVersion!
        }
        if self.dbInstanceAccount != nil {
            map["DbInstanceAccount"] = self.dbInstanceAccount!
        }
        if self.dbInstanceCategory != nil {
            map["DbInstanceCategory"] = self.dbInstanceCategory!
        }
        if self.dbInstanceClass != nil {
            map["DbInstanceClass"] = self.dbInstanceClass!
        }
        if self.dbInstancePassword != nil {
            map["DbInstancePassword"] = self.dbInstancePassword!
        }
        if self.dbResourceId != nil {
            map["DbResourceId"] = self.dbResourceId!
        }
        if self.dbStorageSize != nil {
            map["DbStorageSize"] = self.dbStorageSize!
        }
        if self.dbStorageType != nil {
            map["DbStorageType"] = self.dbStorageType!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.kvStoreAccount != nil {
            map["KvStoreAccount"] = self.kvStoreAccount!
        }
        if self.kvStoreEngineVersion != nil {
            map["KvStoreEngineVersion"] = self.kvStoreEngineVersion!
        }
        if self.kvStoreInstanceClass != nil {
            map["KvStoreInstanceClass"] = self.kvStoreInstanceClass!
        }
        if self.kvStoreNodeType != nil {
            map["KvStoreNodeType"] = self.kvStoreNodeType!
        }
        if self.kvStoreOption != nil {
            map["KvStoreOption"] = self.kvStoreOption!
        }
        if self.kvStorePassword != nil {
            map["KvStorePassword"] = self.kvStorePassword!
        }
        if self.kvStoreResourceId != nil {
            map["KvStoreResourceId"] = self.kvStoreResourceId!
        }
        if self.kvStoreType != nil {
            map["KvStoreType"] = self.kvStoreType!
        }
        if self.ossPath != nil {
            map["OssPath"] = self.ossPath!
        }
        if self.ossResourceId != nil {
            map["OssResourceId"] = self.ossResourceId!
        }
        if self.payPeriod != nil {
            map["PayPeriod"] = self.payPeriod!
        }
        if self.payPeriodType != nil {
            map["PayPeriodType"] = self.payPeriodType!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.resourceQuota != nil {
            map["ResourceQuota"] = self.resourceQuota!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.segDiskPerformanceLevel != nil {
            map["SegDiskPerformanceLevel"] = self.segDiskPerformanceLevel!
        }
        if self.segNodeNum != nil {
            map["SegNodeNum"] = self.segNodeNum!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vectordbAccount != nil {
            map["VectordbAccount"] = self.vectordbAccount!
        }
        if self.vectordbCategory != nil {
            map["VectordbCategory"] = self.vectordbCategory!
        }
        if self.vectordbEngineVersion != nil {
            map["VectordbEngineVersion"] = self.vectordbEngineVersion!
        }
        if self.vectordbInstanceSpec != nil {
            map["VectordbInstanceSpec"] = self.vectordbInstanceSpec!
        }
        if self.vectordbOption != nil {
            map["VectordbOption"] = self.vectordbOption!
        }
        if self.vectordbPassword != nil {
            map["VectordbPassword"] = self.vectordbPassword!
        }
        if self.vectordbResourceId != nil {
            map["VectordbResourceId"] = self.vectordbResourceId!
        }
        if self.vectordbStorageSize != nil {
            map["VectordbStorageSize"] = self.vectordbStorageSize!
        }
        if self.vectordbStorageType != nil {
            map["VectordbStorageType"] = self.vectordbStorageType!
        }
        if self.vectordbType != nil {
            map["VectordbType"] = self.vectordbType!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.workspaceDescription != nil {
            map["WorkspaceDescription"] = self.workspaceDescription!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        if self.workspaceName != nil {
            map["WorkspaceName"] = self.workspaceName!
        }
        if self.workspaceOption != nil {
            map["WorkspaceOption"] = self.workspaceOption!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdbpgInstanceMode") {
            self.adbpgInstanceMode = dict["AdbpgInstanceMode"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DatabaseOption") {
            self.databaseOption = dict["DatabaseOption"] as! String
        }
        if dict.keys.contains("DbEngineType") {
            self.dbEngineType = dict["DbEngineType"] as! String
        }
        if dict.keys.contains("DbEngineVersion") {
            self.dbEngineVersion = dict["DbEngineVersion"] as! String
        }
        if dict.keys.contains("DbInstanceAccount") {
            self.dbInstanceAccount = dict["DbInstanceAccount"] as! String
        }
        if dict.keys.contains("DbInstanceCategory") {
            self.dbInstanceCategory = dict["DbInstanceCategory"] as! String
        }
        if dict.keys.contains("DbInstanceClass") {
            self.dbInstanceClass = dict["DbInstanceClass"] as! String
        }
        if dict.keys.contains("DbInstancePassword") {
            self.dbInstancePassword = dict["DbInstancePassword"] as! String
        }
        if dict.keys.contains("DbResourceId") {
            self.dbResourceId = dict["DbResourceId"] as! Int32
        }
        if dict.keys.contains("DbStorageSize") {
            self.dbStorageSize = dict["DbStorageSize"] as! String
        }
        if dict.keys.contains("DbStorageType") {
            self.dbStorageType = dict["DbStorageType"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("KvStoreAccount") {
            self.kvStoreAccount = dict["KvStoreAccount"] as! String
        }
        if dict.keys.contains("KvStoreEngineVersion") {
            self.kvStoreEngineVersion = dict["KvStoreEngineVersion"] as! String
        }
        if dict.keys.contains("KvStoreInstanceClass") {
            self.kvStoreInstanceClass = dict["KvStoreInstanceClass"] as! String
        }
        if dict.keys.contains("KvStoreNodeType") {
            self.kvStoreNodeType = dict["KvStoreNodeType"] as! String
        }
        if dict.keys.contains("KvStoreOption") {
            self.kvStoreOption = dict["KvStoreOption"] as! String
        }
        if dict.keys.contains("KvStorePassword") {
            self.kvStorePassword = dict["KvStorePassword"] as! String
        }
        if dict.keys.contains("KvStoreResourceId") {
            self.kvStoreResourceId = dict["KvStoreResourceId"] as! Int32
        }
        if dict.keys.contains("KvStoreType") {
            self.kvStoreType = dict["KvStoreType"] as! String
        }
        if dict.keys.contains("OssPath") {
            self.ossPath = dict["OssPath"] as! String
        }
        if dict.keys.contains("OssResourceId") {
            self.ossResourceId = dict["OssResourceId"] as! Int32
        }
        if dict.keys.contains("PayPeriod") {
            self.payPeriod = dict["PayPeriod"] as! Int32
        }
        if dict.keys.contains("PayPeriodType") {
            self.payPeriodType = dict["PayPeriodType"] as! String
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("Replicas") {
            self.replicas = dict["Replicas"] as! Int32
        }
        if dict.keys.contains("ResourceQuota") {
            self.resourceQuota = dict["ResourceQuota"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SegDiskPerformanceLevel") {
            self.segDiskPerformanceLevel = dict["SegDiskPerformanceLevel"] as! String
        }
        if dict.keys.contains("SegNodeNum") {
            self.segNodeNum = dict["SegNodeNum"] as! Int32
        }
        if dict.keys.contains("StorageType") {
            self.storageType = dict["StorageType"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VectordbAccount") {
            self.vectordbAccount = dict["VectordbAccount"] as! String
        }
        if dict.keys.contains("VectordbCategory") {
            self.vectordbCategory = dict["VectordbCategory"] as! String
        }
        if dict.keys.contains("VectordbEngineVersion") {
            self.vectordbEngineVersion = dict["VectordbEngineVersion"] as! String
        }
        if dict.keys.contains("VectordbInstanceSpec") {
            self.vectordbInstanceSpec = dict["VectordbInstanceSpec"] as! String
        }
        if dict.keys.contains("VectordbOption") {
            self.vectordbOption = dict["VectordbOption"] as! String
        }
        if dict.keys.contains("VectordbPassword") {
            self.vectordbPassword = dict["VectordbPassword"] as! String
        }
        if dict.keys.contains("VectordbResourceId") {
            self.vectordbResourceId = dict["VectordbResourceId"] as! Int32
        }
        if dict.keys.contains("VectordbStorageSize") {
            self.vectordbStorageSize = dict["VectordbStorageSize"] as! String
        }
        if dict.keys.contains("VectordbStorageType") {
            self.vectordbStorageType = dict["VectordbStorageType"] as! String
        }
        if dict.keys.contains("VectordbType") {
            self.vectordbType = dict["VectordbType"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("WorkspaceDescription") {
            self.workspaceDescription = dict["WorkspaceDescription"] as! String
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
        if dict.keys.contains("WorkspaceName") {
            self.workspaceName = dict["WorkspaceName"] as! String
        }
        if dict.keys.contains("WorkspaceOption") {
            self.workspaceOption = dict["WorkspaceOption"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateDifyInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var instanceId: String?

        public var replicas: Int32?

        public var resourceQuota: String?

        public var securityGroupId: String?

        public var status: String?

        public var vSwitchId: String?

        public var vpcId: String?

        public var workspaceId: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.replicas != nil {
                map["Replicas"] = self.replicas!
            }
            if self.resourceQuota != nil {
                map["ResourceQuota"] = self.resourceQuota!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Replicas") {
                self.replicas = dict["Replicas"] as! Int32
            }
            if dict.keys.contains("ResourceQuota") {
                self.resourceQuota = dict["ResourceQuota"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
            if dict.keys.contains("WorkspaceId") {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateDifyInstanceResponseBody.Data?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateDifyInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDifyInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDifyInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDifyInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFreeLockCorrectOrderRequest : Tea.TeaModel {
    public class Param : Tea.TeaModel {
        public class DbItemList : Tea.TeaModel {
            public var dbId: Int64?

            public var logic: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
            }
        }
        public var attachmentName: String?

        public var classify: String?

        public var dbItemList: [CreateFreeLockCorrectOrderRequest.Param.DbItemList]?

        public var execMode: String?

        public var execSQL: String?

        public var rollbackAttachmentName: String?

        public var rollbackSQL: String?

        public var rollbackSqlType: String?

        public var sqlType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachmentName != nil {
                map["AttachmentName"] = self.attachmentName!
            }
            if self.classify != nil {
                map["Classify"] = self.classify!
            }
            if self.dbItemList != nil {
                var tmp : [Any] = []
                for k in self.dbItemList! {
                    tmp.append(k.toMap())
                }
                map["DbItemList"] = tmp
            }
            if self.execMode != nil {
                map["ExecMode"] = self.execMode!
            }
            if self.execSQL != nil {
                map["ExecSQL"] = self.execSQL!
            }
            if self.rollbackAttachmentName != nil {
                map["RollbackAttachmentName"] = self.rollbackAttachmentName!
            }
            if self.rollbackSQL != nil {
                map["RollbackSQL"] = self.rollbackSQL!
            }
            if self.rollbackSqlType != nil {
                map["RollbackSqlType"] = self.rollbackSqlType!
            }
            if self.sqlType != nil {
                map["SqlType"] = self.sqlType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachmentName") {
                self.attachmentName = dict["AttachmentName"] as! String
            }
            if dict.keys.contains("Classify") {
                self.classify = dict["Classify"] as! String
            }
            if dict.keys.contains("DbItemList") {
                var tmp : [CreateFreeLockCorrectOrderRequest.Param.DbItemList] = []
                for v in dict["DbItemList"] as! [Any] {
                    var model = CreateFreeLockCorrectOrderRequest.Param.DbItemList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dbItemList = tmp
            }
            if dict.keys.contains("ExecMode") {
                self.execMode = dict["ExecMode"] as! String
            }
            if dict.keys.contains("ExecSQL") {
                self.execSQL = dict["ExecSQL"] as! String
            }
            if dict.keys.contains("RollbackAttachmentName") {
                self.rollbackAttachmentName = dict["RollbackAttachmentName"] as! String
            }
            if dict.keys.contains("RollbackSQL") {
                self.rollbackSQL = dict["RollbackSQL"] as! String
            }
            if dict.keys.contains("RollbackSqlType") {
                self.rollbackSqlType = dict["RollbackSqlType"] as! String
            }
            if dict.keys.contains("SqlType") {
                self.sqlType = dict["SqlType"] as! String
            }
        }
    }
    public var attachmentKey: String?

    public var comment: String?

    public var param: CreateFreeLockCorrectOrderRequest.Param?

    public var realLoginUserUid: String?

    public var relatedUserList: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.param?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.param != nil {
            map["Param"] = self.param?.toMap()
        }
        if self.realLoginUserUid != nil {
            map["RealLoginUserUid"] = self.realLoginUserUid!
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") {
            var model = CreateFreeLockCorrectOrderRequest.Param()
            model.fromMap(dict["Param"] as! [String: Any])
            self.param = model
        }
        if dict.keys.contains("RealLoginUserUid") {
            self.realLoginUserUid = dict["RealLoginUserUid"] as! String
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserList = dict["RelatedUserList"] as! [Int64]
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateFreeLockCorrectOrderShrinkRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var paramShrink: String?

    public var realLoginUserUid: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.paramShrink != nil {
            map["Param"] = self.paramShrink!
        }
        if self.realLoginUserUid != nil {
            map["RealLoginUserUid"] = self.realLoginUserUid!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") {
            self.paramShrink = dict["Param"] as! String
        }
        if dict.keys.contains("RealLoginUserUid") {
            self.realLoginUserUid = dict["RealLoginUserUid"] as! String
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateFreeLockCorrectOrderResponseBody : Tea.TeaModel {
    public var createOrderResult: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") {
            self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateFreeLockCorrectOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFreeLockCorrectOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateFreeLockCorrectOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLakeHouseSpaceRequest : Tea.TeaModel {
    public var description_: String?

    public var devDbId: String?

    public var dwDbType: String?

    public var mode: String?

    public var prodDbId: String?

    public var spaceConfig: String?

    public var spaceName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.devDbId != nil {
            map["DevDbId"] = self.devDbId!
        }
        if self.dwDbType != nil {
            map["DwDbType"] = self.dwDbType!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.prodDbId != nil {
            map["ProdDbId"] = self.prodDbId!
        }
        if self.spaceConfig != nil {
            map["SpaceConfig"] = self.spaceConfig!
        }
        if self.spaceName != nil {
            map["SpaceName"] = self.spaceName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DevDbId") {
            self.devDbId = dict["DevDbId"] as! String
        }
        if dict.keys.contains("DwDbType") {
            self.dwDbType = dict["DwDbType"] as! String
        }
        if dict.keys.contains("Mode") {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("ProdDbId") {
            self.prodDbId = dict["ProdDbId"] as! String
        }
        if dict.keys.contains("SpaceConfig") {
            self.spaceConfig = dict["SpaceConfig"] as! String
        }
        if dict.keys.contains("SpaceName") {
            self.spaceName = dict["SpaceName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateLakeHouseSpaceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var spaceId: Int64?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SpaceId") {
            self.spaceId = dict["SpaceId"] as! Int64
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateLakeHouseSpaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLakeHouseSpaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLakeHouseSpaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLogicDatabaseRequest : Tea.TeaModel {
    public var alias: String?

    public var databaseIds: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alias != nil {
            map["Alias"] = self.alias!
        }
        if self.databaseIds != nil {
            map["DatabaseIds"] = self.databaseIds!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Alias") {
            self.alias = dict["Alias"] as! String
        }
        if dict.keys.contains("DatabaseIds") {
            self.databaseIds = dict["DatabaseIds"] as! [Int64]
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateLogicDatabaseShrinkRequest : Tea.TeaModel {
    public var alias: String?

    public var databaseIdsShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alias != nil {
            map["Alias"] = self.alias!
        }
        if self.databaseIdsShrink != nil {
            map["DatabaseIds"] = self.databaseIdsShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Alias") {
            self.alias = dict["Alias"] as! String
        }
        if dict.keys.contains("DatabaseIds") {
            self.databaseIdsShrink = dict["DatabaseIds"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateLogicDatabaseResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var logicDbId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.logicDbId != nil {
            map["LogicDbId"] = self.logicDbId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("LogicDbId") {
            self.logicDbId = dict["LogicDbId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateLogicDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLogicDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLogicDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrderRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var pluginParam: [String: Any]?

    public var pluginType: String?

    public var relatedUserList: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.pluginParam != nil {
            map["PluginParam"] = self.pluginParam!
        }
        if self.pluginType != nil {
            map["PluginType"] = self.pluginType!
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("PluginParam") {
            self.pluginParam = dict["PluginParam"] as! [String: Any]
        }
        if dict.keys.contains("PluginType") {
            self.pluginType = dict["PluginType"] as! String
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserList = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateOrderShrinkRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var pluginParamShrink: String?

    public var pluginType: String?

    public var relatedUserList: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.pluginParamShrink != nil {
            map["PluginParam"] = self.pluginParamShrink!
        }
        if self.pluginType != nil {
            map["PluginType"] = self.pluginType!
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("PluginParam") {
            self.pluginParamShrink = dict["PluginParam"] as! String
        }
        if dict.keys.contains("PluginType") {
            self.pluginType = dict["PluginType"] as! String
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserList = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateOrderResponseBody : Tea.TeaModel {
    public class CreateOrderResult : Tea.TeaModel {
        public var orderIds: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.orderIds != nil {
                map["OrderIds"] = self.orderIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OrderIds") {
                self.orderIds = dict["OrderIds"] as! [Int64]
            }
        }
    }
    public var createOrderResult: CreateOrderResponseBody.CreateOrderResult?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createOrderResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") {
            var model = CreateOrderResponseBody.CreateOrderResult()
            model.fromMap(dict["CreateOrderResult"] as! [String: Any])
            self.createOrderResult = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProcCorrectOrderRequest : Tea.TeaModel {
    public class Param : Tea.TeaModel {
        public class DbItemList : Tea.TeaModel {
            public var dbId: Int64?

            public var logic: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
            }
        }
        public var classify: String?

        public var dbItemList: [CreateProcCorrectOrderRequest.Param.DbItemList]?

        public var execMode: String?

        public var execSQL: String?

        public var rollbackAttachmentName: String?

        public var rollbackSQL: String?

        public var rollbackSqlType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classify != nil {
                map["Classify"] = self.classify!
            }
            if self.dbItemList != nil {
                var tmp : [Any] = []
                for k in self.dbItemList! {
                    tmp.append(k.toMap())
                }
                map["DbItemList"] = tmp
            }
            if self.execMode != nil {
                map["ExecMode"] = self.execMode!
            }
            if self.execSQL != nil {
                map["ExecSQL"] = self.execSQL!
            }
            if self.rollbackAttachmentName != nil {
                map["RollbackAttachmentName"] = self.rollbackAttachmentName!
            }
            if self.rollbackSQL != nil {
                map["RollbackSQL"] = self.rollbackSQL!
            }
            if self.rollbackSqlType != nil {
                map["RollbackSqlType"] = self.rollbackSqlType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Classify") {
                self.classify = dict["Classify"] as! String
            }
            if dict.keys.contains("DbItemList") {
                var tmp : [CreateProcCorrectOrderRequest.Param.DbItemList] = []
                for v in dict["DbItemList"] as! [Any] {
                    var model = CreateProcCorrectOrderRequest.Param.DbItemList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dbItemList = tmp
            }
            if dict.keys.contains("ExecMode") {
                self.execMode = dict["ExecMode"] as! String
            }
            if dict.keys.contains("ExecSQL") {
                self.execSQL = dict["ExecSQL"] as! String
            }
            if dict.keys.contains("RollbackAttachmentName") {
                self.rollbackAttachmentName = dict["RollbackAttachmentName"] as! String
            }
            if dict.keys.contains("RollbackSQL") {
                self.rollbackSQL = dict["RollbackSQL"] as! String
            }
            if dict.keys.contains("RollbackSqlType") {
                self.rollbackSqlType = dict["RollbackSqlType"] as! String
            }
        }
    }
    public var attachmentKey: String?

    public var comment: String?

    public var param: CreateProcCorrectOrderRequest.Param?

    public var relatedUserList: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.param?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.param != nil {
            map["Param"] = self.param?.toMap()
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") {
            var model = CreateProcCorrectOrderRequest.Param()
            model.fromMap(dict["Param"] as! [String: Any])
            self.param = model
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserList = dict["RelatedUserList"] as! [Int64]
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateProcCorrectOrderShrinkRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var paramShrink: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.paramShrink != nil {
            map["Param"] = self.paramShrink!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") {
            self.paramShrink = dict["Param"] as! String
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateProcCorrectOrderResponseBody : Tea.TeaModel {
    public var createOrderResult: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") {
            self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateProcCorrectOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProcCorrectOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateProcCorrectOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProxyRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var password: String?

    public var tid: Int64?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("Username") {
            self.username = dict["Username"] as! String
        }
    }
}

public class CreateProxyResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var proxyId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.proxyId != nil {
            map["ProxyId"] = self.proxyId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("ProxyId") {
            self.proxyId = dict["ProxyId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateProxyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProxyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateProxyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProxyAccessRequest : Tea.TeaModel {
    public var indepAccount: String?

    public var indepPassword: String?

    public var proxyId: Int64?

    public var tid: Int64?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.indepAccount != nil {
            map["IndepAccount"] = self.indepAccount!
        }
        if self.indepPassword != nil {
            map["IndepPassword"] = self.indepPassword!
        }
        if self.proxyId != nil {
            map["ProxyId"] = self.proxyId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IndepAccount") {
            self.indepAccount = dict["IndepAccount"] as! String
        }
        if dict.keys.contains("IndepPassword") {
            self.indepPassword = dict["IndepPassword"] as! String
        }
        if dict.keys.contains("ProxyId") {
            self.proxyId = dict["ProxyId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class CreateProxyAccessResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var proxyAccessId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.proxyAccessId != nil {
            map["ProxyAccessId"] = self.proxyAccessId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("ProxyAccessId") {
            self.proxyAccessId = dict["ProxyAccessId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateProxyAccessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProxyAccessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateProxyAccessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePublishGroupTaskRequest : Tea.TeaModel {
    public var dbId: Int32?

    public var logic: Bool?

    public var orderId: Int64?

    public var planTime: String?

    public var publishStrategy: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.planTime != nil {
            map["PlanTime"] = self.planTime!
        }
        if self.publishStrategy != nil {
            map["PublishStrategy"] = self.publishStrategy!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! Int32
        }
        if dict.keys.contains("Logic") {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("PlanTime") {
            self.planTime = dict["PlanTime"] as! String
        }
        if dict.keys.contains("PublishStrategy") {
            self.publishStrategy = dict["PublishStrategy"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreatePublishGroupTaskResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class CreatePublishGroupTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePublishGroupTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePublishGroupTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSQLReviewOrderRequest : Tea.TeaModel {
    public class Param : Tea.TeaModel {
        public var attachmentKeyList: [String]?

        public var dbId: Int64?

        public var projectName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachmentKeyList != nil {
                map["AttachmentKeyList"] = self.attachmentKeyList!
            }
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachmentKeyList") {
                self.attachmentKeyList = dict["AttachmentKeyList"] as! [String]
            }
            if dict.keys.contains("DbId") {
                self.dbId = dict["DbId"] as! Int64
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
        }
    }
    public var comment: String?

    public var param: CreateSQLReviewOrderRequest.Param?

    public var relatedUserList: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.param?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.param != nil {
            map["Param"] = self.param?.toMap()
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") {
            var model = CreateSQLReviewOrderRequest.Param()
            model.fromMap(dict["Param"] as! [String: Any])
            self.param = model
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserList = dict["RelatedUserList"] as! [Int64]
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateSQLReviewOrderShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var paramShrink: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.paramShrink != nil {
            map["Param"] = self.paramShrink!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") {
            self.paramShrink = dict["Param"] as! String
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateSQLReviewOrderResponseBody : Tea.TeaModel {
    public var createOrderResult: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") {
            self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateSQLReviewOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSQLReviewOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSQLReviewOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScenarioRequest : Tea.TeaModel {
    public var description_: String?

    public var scenarioName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.scenarioName != nil {
            map["ScenarioName"] = self.scenarioName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ScenarioName") {
            self.scenarioName = dict["ScenarioName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateScenarioResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var scenarioId: Int64?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScenarioId") {
            self.scenarioId = dict["ScenarioId"] as! Int64
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateScenarioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScenarioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateScenarioResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateStandardGroupRequest : Tea.TeaModel {
    public var dbType: String?

    public var description_: String?

    public var groupName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbType != nil {
            map["DbType"] = self.dbType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbType") {
            self.dbType = dict["DbType"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateStandardGroupResponseBody : Tea.TeaModel {
    public class StandardGroup : Tea.TeaModel {
        public var dbType: String?

        public var description_: String?

        public var groupId: Int64?

        public var groupMode: String?

        public var groupName: String?

        public var lastMenderId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupMode != nil {
                map["GroupMode"] = self.groupMode!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.lastMenderId != nil {
                map["LastMenderId"] = self.lastMenderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbType") {
                self.dbType = dict["DbType"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! Int64
            }
            if dict.keys.contains("GroupMode") {
                self.groupMode = dict["GroupMode"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("LastMenderId") {
                self.lastMenderId = dict["LastMenderId"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var standardGroup: CreateStandardGroupResponseBody.StandardGroup?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.standardGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.standardGroup != nil {
            map["StandardGroup"] = self.standardGroup?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StandardGroup") {
            var model = CreateStandardGroupResponseBody.StandardGroup()
            model.fromMap(dict["StandardGroup"] as! [String: Any])
            self.standardGroup = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateStandardGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateStandardGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateStandardGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateStructSyncOrderRequest : Tea.TeaModel {
    public class Param : Tea.TeaModel {
        public class Source : Tea.TeaModel {
            public var dbId: Int64?

            public var dbSearchName: String?

            public var logic: Bool?

            public var versionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbSearchName != nil {
                    map["DbSearchName"] = self.dbSearchName!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.versionId != nil {
                    map["VersionId"] = self.versionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("DbSearchName") {
                    self.dbSearchName = dict["DbSearchName"] as! String
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("VersionId") {
                    self.versionId = dict["VersionId"] as! String
                }
            }
        }
        public class TableInfoList : Tea.TeaModel {
            public var sourceTableName: String?

            public var targetTableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sourceTableName != nil {
                    map["SourceTableName"] = self.sourceTableName!
                }
                if self.targetTableName != nil {
                    map["TargetTableName"] = self.targetTableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SourceTableName") {
                    self.sourceTableName = dict["SourceTableName"] as! String
                }
                if dict.keys.contains("TargetTableName") {
                    self.targetTableName = dict["TargetTableName"] as! String
                }
            }
        }
        public class Target : Tea.TeaModel {
            public var dbId: Int64?

            public var dbSearchName: String?

            public var logic: Bool?

            public var versionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbSearchName != nil {
                    map["DbSearchName"] = self.dbSearchName!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.versionId != nil {
                    map["VersionId"] = self.versionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("DbSearchName") {
                    self.dbSearchName = dict["DbSearchName"] as! String
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("VersionId") {
                    self.versionId = dict["VersionId"] as! String
                }
            }
        }
        public var ignoreError: Bool?

        public var source: CreateStructSyncOrderRequest.Param.Source?

        public var tableInfoList: [CreateStructSyncOrderRequest.Param.TableInfoList]?

        public var target: CreateStructSyncOrderRequest.Param.Target?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.source?.validate()
            try self.target?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ignoreError != nil {
                map["IgnoreError"] = self.ignoreError!
            }
            if self.source != nil {
                map["Source"] = self.source?.toMap()
            }
            if self.tableInfoList != nil {
                var tmp : [Any] = []
                for k in self.tableInfoList! {
                    tmp.append(k.toMap())
                }
                map["TableInfoList"] = tmp
            }
            if self.target != nil {
                map["Target"] = self.target?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IgnoreError") {
                self.ignoreError = dict["IgnoreError"] as! Bool
            }
            if dict.keys.contains("Source") {
                var model = CreateStructSyncOrderRequest.Param.Source()
                model.fromMap(dict["Source"] as! [String: Any])
                self.source = model
            }
            if dict.keys.contains("TableInfoList") {
                var tmp : [CreateStructSyncOrderRequest.Param.TableInfoList] = []
                for v in dict["TableInfoList"] as! [Any] {
                    var model = CreateStructSyncOrderRequest.Param.TableInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tableInfoList = tmp
            }
            if dict.keys.contains("Target") {
                var model = CreateStructSyncOrderRequest.Param.Target()
                model.fromMap(dict["Target"] as! [String: Any])
                self.target = model
            }
        }
    }
    public var attachmentKey: String?

    public var comment: String?

    public var param: CreateStructSyncOrderRequest.Param?

    public var relatedUserList: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.param?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.param != nil {
            map["Param"] = self.param?.toMap()
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") {
            var model = CreateStructSyncOrderRequest.Param()
            model.fromMap(dict["Param"] as! [String: Any])
            self.param = model
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserList = dict["RelatedUserList"] as! [Int64]
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateStructSyncOrderShrinkRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var paramShrink: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.paramShrink != nil {
            map["Param"] = self.paramShrink!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") {
            self.paramShrink = dict["Param"] as! String
        }
        if dict.keys.contains("RelatedUserList") {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateStructSyncOrderResponseBody : Tea.TeaModel {
    public var createOrderResult: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") {
            self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateStructSyncOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateStructSyncOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateStructSyncOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTaskRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var graphParam: String?

    public var nodeContent: String?

    public var nodeName: String?

    public var nodeOutput: String?

    public var nodeType: String?

    public var tid: Int64?

    public var timeVariables: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.graphParam != nil {
            map["GraphParam"] = self.graphParam!
        }
        if self.nodeContent != nil {
            map["NodeContent"] = self.nodeContent!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.nodeOutput != nil {
            map["NodeOutput"] = self.nodeOutput!
        }
        if self.nodeType != nil {
            map["NodeType"] = self.nodeType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.timeVariables != nil {
            map["TimeVariables"] = self.timeVariables!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("GraphParam") {
            self.graphParam = dict["GraphParam"] as! String
        }
        if dict.keys.contains("NodeContent") {
            self.nodeContent = dict["NodeContent"] as! String
        }
        if dict.keys.contains("NodeName") {
            self.nodeName = dict["NodeName"] as! String
        }
        if dict.keys.contains("NodeOutput") {
            self.nodeOutput = dict["NodeOutput"] as! String
        }
        if dict.keys.contains("NodeType") {
            self.nodeType = dict["NodeType"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("TimeVariables") {
            self.timeVariables = dict["TimeVariables"] as! String
        }
    }
}

public class CreateTaskResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var nodeId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTaskFlowRequest : Tea.TeaModel {
    public var dagName: String?

    public var description_: String?

    public var scenarioId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagName != nil {
            map["DagName"] = self.dagName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagName") {
            self.dagName = dict["DagName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ScenarioId") {
            self.scenarioId = dict["ScenarioId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateTaskFlowResponseBody : Tea.TeaModel {
    public var dagId: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateTaskFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTaskFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTaskFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUploadFileJobRequest : Tea.TeaModel {
    public var fileName: String?

    public var fileSource: String?

    public var tid: Int64?

    public var uploadURL: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileSource != nil {
            map["FileSource"] = self.fileSource!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.uploadURL != nil {
            map["UploadURL"] = self.uploadURL!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileSource") {
            self.fileSource = dict["FileSource"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UploadURL") {
            self.uploadURL = dict["UploadURL"] as! String
        }
    }
}

public class CreateUploadFileJobResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var jobKey: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.jobKey != nil {
            map["JobKey"] = self.jobKey!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("JobKey") {
            self.jobKey = dict["JobKey"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateUploadFileJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUploadFileJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateUploadFileJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUploadOSSFileJobRequest : Tea.TeaModel {
    public class UploadTarget : Tea.TeaModel {
        public var bucketName: String?

        public var endpoint: String?

        public var objectName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucketName != nil {
                map["BucketName"] = self.bucketName!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.objectName != nil {
                map["ObjectName"] = self.objectName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BucketName") {
                self.bucketName = dict["BucketName"] as! String
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("ObjectName") {
                self.objectName = dict["ObjectName"] as! String
            }
        }
    }
    public var fileName: String?

    public var fileSource: String?

    public var tid: Int64?

    public var uploadTarget: CreateUploadOSSFileJobRequest.UploadTarget?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.uploadTarget?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileSource != nil {
            map["FileSource"] = self.fileSource!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.uploadTarget != nil {
            map["UploadTarget"] = self.uploadTarget?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileSource") {
            self.fileSource = dict["FileSource"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UploadTarget") {
            var model = CreateUploadOSSFileJobRequest.UploadTarget()
            model.fromMap(dict["UploadTarget"] as! [String: Any])
            self.uploadTarget = model
        }
    }
}

public class CreateUploadOSSFileJobShrinkRequest : Tea.TeaModel {
    public var fileName: String?

    public var fileSource: String?

    public var tid: Int64?

    public var uploadTargetShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileSource != nil {
            map["FileSource"] = self.fileSource!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.uploadTargetShrink != nil {
            map["UploadTarget"] = self.uploadTargetShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileSource") {
            self.fileSource = dict["FileSource"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UploadTarget") {
            self.uploadTargetShrink = dict["UploadTarget"] as! String
        }
    }
}

public class CreateUploadOSSFileJobResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var jobKey: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.jobKey != nil {
            map["JobKey"] = self.jobKey!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("JobKey") {
            self.jobKey = dict["JobKey"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateUploadOSSFileJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUploadOSSFileJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateUploadOSSFileJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAbacAuthorizationRequest : Tea.TeaModel {
    public var authorizationId: Int64?

    public var identityType: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorizationId != nil {
            map["AuthorizationId"] = self.authorizationId!
        }
        if self.identityType != nil {
            map["IdentityType"] = self.identityType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorizationId") {
            self.authorizationId = dict["AuthorizationId"] as! Int64
        }
        if dict.keys.contains("IdentityType") {
            self.identityType = dict["IdentityType"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteAbacAuthorizationResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteAbacAuthorizationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAbacAuthorizationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAbacAuthorizationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAbacPolicyRequest : Tea.TeaModel {
    public var abacPolicyId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.abacPolicyId != nil {
            map["AbacPolicyId"] = self.abacPolicyId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AbacPolicyId") {
            self.abacPolicyId = dict["AbacPolicyId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteAbacPolicyResponseBody : Tea.TeaModel {
    public var deletePolicyResult: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deletePolicyResult != nil {
            map["DeletePolicyResult"] = self.deletePolicyResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeletePolicyResult") {
            self.deletePolicyResult = dict["DeletePolicyResult"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteAbacPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAbacPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAbacPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAuthorityTemplateRequest : Tea.TeaModel {
    public var templateId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteAuthorityTemplateResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteAuthorityTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAuthorityTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAuthorityTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDataLakeDatabaseRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteDataLakeDatabaseResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDataLakeDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataLakeDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDataLakeDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDataLakePartitionRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var ifExists: Bool?

    public var partitionValues: [String]?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.ifExists != nil {
            map["IfExists"] = self.ifExists!
        }
        if self.partitionValues != nil {
            map["PartitionValues"] = self.partitionValues!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("IfExists") {
            self.ifExists = dict["IfExists"] as! Bool
        }
        if dict.keys.contains("PartitionValues") {
            self.partitionValues = dict["PartitionValues"] as! [String]
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteDataLakePartitionShrinkRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var ifExists: Bool?

    public var partitionValuesShrink: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.ifExists != nil {
            map["IfExists"] = self.ifExists!
        }
        if self.partitionValuesShrink != nil {
            map["PartitionValues"] = self.partitionValuesShrink!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("IfExists") {
            self.ifExists = dict["IfExists"] as! Bool
        }
        if dict.keys.contains("PartitionValues") {
            self.partitionValuesShrink = dict["PartitionValues"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteDataLakePartitionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDataLakePartitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataLakePartitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDataLakePartitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDataLakeTableRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteDataLakeTableResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDataLakeTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataLakeTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDataLakeTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteInstanceRequest : Tea.TeaModel {
    public var host: String?

    public var port: Int32?

    public var sid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.sid != nil {
            map["Sid"] = self.sid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Host") {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("Sid") {
            self.sid = dict["Sid"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteInstanceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLakeHouseSpaceRequest : Tea.TeaModel {
    public var spaceId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SpaceId") {
            self.spaceId = dict["SpaceId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteLakeHouseSpaceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteLakeHouseSpaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLakeHouseSpaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLakeHouseSpaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLhMembersRequest : Tea.TeaModel {
    public var memberIds: [Int32]?

    public var objectId: Int64?

    public var objectType: Int32?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.memberIds != nil {
            map["MemberIds"] = self.memberIds!
        }
        if self.objectId != nil {
            map["ObjectId"] = self.objectId!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MemberIds") {
            self.memberIds = dict["MemberIds"] as! [Int32]
        }
        if dict.keys.contains("ObjectId") {
            self.objectId = dict["ObjectId"] as! Int64
        }
        if dict.keys.contains("ObjectType") {
            self.objectType = dict["ObjectType"] as! Int32
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteLhMembersShrinkRequest : Tea.TeaModel {
    public var memberIdsShrink: String?

    public var objectId: Int64?

    public var objectType: Int32?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.memberIdsShrink != nil {
            map["MemberIds"] = self.memberIdsShrink!
        }
        if self.objectId != nil {
            map["ObjectId"] = self.objectId!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MemberIds") {
            self.memberIdsShrink = dict["MemberIds"] as! String
        }
        if dict.keys.contains("ObjectId") {
            self.objectId = dict["ObjectId"] as! Int64
        }
        if dict.keys.contains("ObjectType") {
            self.objectType = dict["ObjectType"] as! Int32
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteLhMembersResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteLhMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLhMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLhMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLogicDatabaseRequest : Tea.TeaModel {
    public var logicDbId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logicDbId != nil {
            map["LogicDbId"] = self.logicDbId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogicDbId") {
            self.logicDbId = dict["LogicDbId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteLogicDatabaseResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteLogicDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLogicDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLogicDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLogicTableRouteConfigRequest : Tea.TeaModel {
    public var routeKey: String?

    public var tableId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.routeKey != nil {
            map["RouteKey"] = self.routeKey!
        }
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RouteKey") {
            self.routeKey = dict["RouteKey"] as! String
        }
        if dict.keys.contains("TableId") {
            self.tableId = dict["TableId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteLogicTableRouteConfigResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteLogicTableRouteConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLogicTableRouteConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLogicTableRouteConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProxyRequest : Tea.TeaModel {
    public var proxyId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.proxyId != nil {
            map["ProxyId"] = self.proxyId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProxyId") {
            self.proxyId = dict["ProxyId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteProxyResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteProxyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProxyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteProxyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProxyAccessRequest : Tea.TeaModel {
    public var proxyAccessId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.proxyAccessId != nil {
            map["ProxyAccessId"] = self.proxyAccessId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProxyAccessId") {
            self.proxyAccessId = dict["ProxyAccessId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteProxyAccessResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteProxyAccessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProxyAccessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteProxyAccessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScenarioRequest : Tea.TeaModel {
    public var scenarioId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ScenarioId") {
            self.scenarioId = dict["ScenarioId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteScenarioResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteScenarioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScenarioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteScenarioResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteStandardGroupRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteStandardGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteStandardGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteStandardGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteStandardGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTaskRequest : Tea.TeaModel {
    public var nodeId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteTaskResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTaskFlowRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteTaskFlowResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteTaskFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTaskFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTaskFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTaskFlowEdgesByConditionRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var id: Int64?

    public var nodeEnd: Int64?

    public var nodeFrom: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.nodeEnd != nil {
            map["NodeEnd"] = self.nodeEnd!
        }
        if self.nodeFrom != nil {
            map["NodeFrom"] = self.nodeFrom!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("NodeEnd") {
            self.nodeEnd = dict["NodeEnd"] as! Int64
        }
        if dict.keys.contains("NodeFrom") {
            self.nodeFrom = dict["NodeFrom"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteTaskFlowEdgesByConditionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteTaskFlowEdgesByConditionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTaskFlowEdgesByConditionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTaskFlowEdgesByConditionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteUserRequest : Tea.TeaModel {
    public var tid: Int64?

    public var uid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("Uid") {
            self.uid = dict["Uid"] as! String
        }
    }
}

public class DeleteUserResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDifyDefaultVpcRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dataRegion: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DescribeDifyDefaultVpcResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var defaultVpcId: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultVpcId != nil {
                map["DefaultVpcId"] = self.defaultVpcId!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefaultVpcId") {
                self.defaultVpcId = dict["DefaultVpcId"] as! String
            }
            if dict.keys.contains("WorkspaceId") {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var code: String?

    public var data: DescribeDifyDefaultVpcResponseBody.Data?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeDifyDefaultVpcResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeDifyDefaultVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDifyDefaultVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDifyDefaultVpcResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableUserRequest : Tea.TeaModel {
    public var tid: Int64?

    public var uid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("Uid") {
            self.uid = dict["Uid"] as! String
        }
    }
}

public class DisableUserResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DisableUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DownloadDataTrackResultRequest : Tea.TeaModel {
    public class ColumnFilter : Tea.TeaModel {
        public var betweenEnd: String?

        public var betweenStart: String?

        public var columnName: String?

        public var inList: [String]?

        public var operator_: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.betweenEnd != nil {
                map["BetweenEnd"] = self.betweenEnd!
            }
            if self.betweenStart != nil {
                map["BetweenStart"] = self.betweenStart!
            }
            if self.columnName != nil {
                map["ColumnName"] = self.columnName!
            }
            if self.inList != nil {
                map["InList"] = self.inList!
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BetweenEnd") {
                self.betweenEnd = dict["BetweenEnd"] as! String
            }
            if dict.keys.contains("BetweenStart") {
                self.betweenStart = dict["BetweenStart"] as! String
            }
            if dict.keys.contains("ColumnName") {
                self.columnName = dict["ColumnName"] as! String
            }
            if dict.keys.contains("InList") {
                self.inList = dict["InList"] as! [String]
            }
            if dict.keys.contains("Operator") {
                self.operator_ = dict["Operator"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var columnFilter: DownloadDataTrackResultRequest.ColumnFilter?

    public var eventIdList: [Int64]?

    public var filterEndTime: String?

    public var filterStartTime: String?

    public var filterTableList: [String]?

    public var filterTypeList: [String]?

    public var orderId: Int64?

    public var rollbackSQLType: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.columnFilter?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnFilter != nil {
            map["ColumnFilter"] = self.columnFilter?.toMap()
        }
        if self.eventIdList != nil {
            map["EventIdList"] = self.eventIdList!
        }
        if self.filterEndTime != nil {
            map["FilterEndTime"] = self.filterEndTime!
        }
        if self.filterStartTime != nil {
            map["FilterStartTime"] = self.filterStartTime!
        }
        if self.filterTableList != nil {
            map["FilterTableList"] = self.filterTableList!
        }
        if self.filterTypeList != nil {
            map["FilterTypeList"] = self.filterTypeList!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.rollbackSQLType != nil {
            map["RollbackSQLType"] = self.rollbackSQLType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnFilter") {
            var model = DownloadDataTrackResultRequest.ColumnFilter()
            model.fromMap(dict["ColumnFilter"] as! [String: Any])
            self.columnFilter = model
        }
        if dict.keys.contains("EventIdList") {
            self.eventIdList = dict["EventIdList"] as! [Int64]
        }
        if dict.keys.contains("FilterEndTime") {
            self.filterEndTime = dict["FilterEndTime"] as! String
        }
        if dict.keys.contains("FilterStartTime") {
            self.filterStartTime = dict["FilterStartTime"] as! String
        }
        if dict.keys.contains("FilterTableList") {
            self.filterTableList = dict["FilterTableList"] as! [String]
        }
        if dict.keys.contains("FilterTypeList") {
            self.filterTypeList = dict["FilterTypeList"] as! [String]
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RollbackSQLType") {
            self.rollbackSQLType = dict["RollbackSQLType"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DownloadDataTrackResultShrinkRequest : Tea.TeaModel {
    public var columnFilterShrink: String?

    public var eventIdListShrink: String?

    public var filterEndTime: String?

    public var filterStartTime: String?

    public var filterTableListShrink: String?

    public var filterTypeListShrink: String?

    public var orderId: Int64?

    public var rollbackSQLType: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnFilterShrink != nil {
            map["ColumnFilter"] = self.columnFilterShrink!
        }
        if self.eventIdListShrink != nil {
            map["EventIdList"] = self.eventIdListShrink!
        }
        if self.filterEndTime != nil {
            map["FilterEndTime"] = self.filterEndTime!
        }
        if self.filterStartTime != nil {
            map["FilterStartTime"] = self.filterStartTime!
        }
        if self.filterTableListShrink != nil {
            map["FilterTableList"] = self.filterTableListShrink!
        }
        if self.filterTypeListShrink != nil {
            map["FilterTypeList"] = self.filterTypeListShrink!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.rollbackSQLType != nil {
            map["RollbackSQLType"] = self.rollbackSQLType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnFilter") {
            self.columnFilterShrink = dict["ColumnFilter"] as! String
        }
        if dict.keys.contains("EventIdList") {
            self.eventIdListShrink = dict["EventIdList"] as! String
        }
        if dict.keys.contains("FilterEndTime") {
            self.filterEndTime = dict["FilterEndTime"] as! String
        }
        if dict.keys.contains("FilterStartTime") {
            self.filterStartTime = dict["FilterStartTime"] as! String
        }
        if dict.keys.contains("FilterTableList") {
            self.filterTableListShrink = dict["FilterTableList"] as! String
        }
        if dict.keys.contains("FilterTypeList") {
            self.filterTypeListShrink = dict["FilterTypeList"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RollbackSQLType") {
            self.rollbackSQLType = dict["RollbackSQLType"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DownloadDataTrackResultResponseBody : Tea.TeaModel {
    public var downloadKeyId: String?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadKeyId != nil {
            map["DownloadKeyId"] = self.downloadKeyId!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadKeyId") {
            self.downloadKeyId = dict["DownloadKeyId"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DownloadDataTrackResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadDataTrackResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DownloadDataTrackResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EditLogicDatabaseRequest : Tea.TeaModel {
    public var alias: String?

    public var databaseIds: [Int64]?

    public var logicDbId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alias != nil {
            map["Alias"] = self.alias!
        }
        if self.databaseIds != nil {
            map["DatabaseIds"] = self.databaseIds!
        }
        if self.logicDbId != nil {
            map["LogicDbId"] = self.logicDbId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Alias") {
            self.alias = dict["Alias"] as! String
        }
        if dict.keys.contains("DatabaseIds") {
            self.databaseIds = dict["DatabaseIds"] as! [Int64]
        }
        if dict.keys.contains("LogicDbId") {
            self.logicDbId = dict["LogicDbId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class EditLogicDatabaseShrinkRequest : Tea.TeaModel {
    public var alias: String?

    public var databaseIdsShrink: String?

    public var logicDbId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alias != nil {
            map["Alias"] = self.alias!
        }
        if self.databaseIdsShrink != nil {
            map["DatabaseIds"] = self.databaseIdsShrink!
        }
        if self.logicDbId != nil {
            map["LogicDbId"] = self.logicDbId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Alias") {
            self.alias = dict["Alias"] as! String
        }
        if dict.keys.contains("DatabaseIds") {
            self.databaseIdsShrink = dict["DatabaseIds"] as! String
        }
        if dict.keys.contains("LogicDbId") {
            self.logicDbId = dict["LogicDbId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class EditLogicDatabaseResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EditLogicDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EditLogicDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EditLogicDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableUserRequest : Tea.TeaModel {
    public var tid: Int64?

    public var uid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("Uid") {
            self.uid = dict["Uid"] as! String
        }
    }
}

public class EnableUserResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EnableUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecuteDataCorrectRequest : Tea.TeaModel {
    public var actionDetail: [String: Any]?

    public var orderId: Int64?

    public var realLoginUserUid: String?

    public var tid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionDetail != nil {
            map["ActionDetail"] = self.actionDetail!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.realLoginUserUid != nil {
            map["RealLoginUserUid"] = self.realLoginUserUid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionDetail") {
            self.actionDetail = dict["ActionDetail"] as! [String: Any]
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RealLoginUserUid") {
            self.realLoginUserUid = dict["RealLoginUserUid"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! String
        }
    }
}

public class ExecuteDataCorrectShrinkRequest : Tea.TeaModel {
    public var actionDetailShrink: String?

    public var orderId: Int64?

    public var realLoginUserUid: String?

    public var tid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionDetailShrink != nil {
            map["ActionDetail"] = self.actionDetailShrink!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.realLoginUserUid != nil {
            map["RealLoginUserUid"] = self.realLoginUserUid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionDetail") {
            self.actionDetailShrink = dict["ActionDetail"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RealLoginUserUid") {
            self.realLoginUserUid = dict["RealLoginUserUid"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! String
        }
    }
}

public class ExecuteDataCorrectResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ExecuteDataCorrectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteDataCorrectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExecuteDataCorrectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecuteDataExportRequest : Tea.TeaModel {
    public var actionDetail: [String: Any]?

    public var orderId: Int64?

    public var realLoginUserUid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionDetail != nil {
            map["ActionDetail"] = self.actionDetail!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.realLoginUserUid != nil {
            map["RealLoginUserUid"] = self.realLoginUserUid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionDetail") {
            self.actionDetail = dict["ActionDetail"] as! [String: Any]
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RealLoginUserUid") {
            self.realLoginUserUid = dict["RealLoginUserUid"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ExecuteDataExportShrinkRequest : Tea.TeaModel {
    public var actionDetailShrink: String?

    public var orderId: Int64?

    public var realLoginUserUid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionDetailShrink != nil {
            map["ActionDetail"] = self.actionDetailShrink!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.realLoginUserUid != nil {
            map["RealLoginUserUid"] = self.realLoginUserUid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionDetail") {
            self.actionDetailShrink = dict["ActionDetail"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RealLoginUserUid") {
            self.realLoginUserUid = dict["RealLoginUserUid"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ExecuteDataExportResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ExecuteDataExportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteDataExportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExecuteDataExportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecuteScriptRequest : Tea.TeaModel {
    public var dbId: Int32?

    public var logic: Bool?

    public var script: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.script != nil {
            map["Script"] = self.script!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! Int32
        }
        if dict.keys.contains("Logic") {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("Script") {
            self.script = dict["Script"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ExecuteScriptResponseBody : Tea.TeaModel {
    public class Results : Tea.TeaModel {
        public var columnNames: [String]?

        public var message: String?

        public var rowCount: Int64?

        public var rows: [[String: Any]]?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columnNames != nil {
                map["ColumnNames"] = self.columnNames!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.rowCount != nil {
                map["RowCount"] = self.rowCount!
            }
            if self.rows != nil {
                map["Rows"] = self.rows!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ColumnNames") {
                self.columnNames = dict["ColumnNames"] as! [String]
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("RowCount") {
                self.rowCount = dict["RowCount"] as! Int64
            }
            if dict.keys.contains("Rows") {
                self.rows = dict["Rows"] as! [[String: Any]]
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var results: [ExecuteScriptResponseBody.Results]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.results != nil {
            var tmp : [Any] = []
            for k in self.results! {
                tmp.append(k.toMap())
            }
            map["Results"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Results") {
            var tmp : [ExecuteScriptResponseBody.Results] = []
            for v in dict["Results"] as! [Any] {
                var model = ExecuteScriptResponseBody.Results()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.results = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ExecuteScriptResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteScriptResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExecuteScriptResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecuteStructSyncRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ExecuteStructSyncResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ExecuteStructSyncResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteStructSyncResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExecuteStructSyncResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAbacPolicyRequest : Tea.TeaModel {
    public var abacPolicyId: Int64?

    public var abacPolicyName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.abacPolicyId != nil {
            map["AbacPolicyId"] = self.abacPolicyId!
        }
        if self.abacPolicyName != nil {
            map["AbacPolicyName"] = self.abacPolicyName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AbacPolicyId") {
            self.abacPolicyId = dict["AbacPolicyId"] as! Int64
        }
        if dict.keys.contains("AbacPolicyName") {
            self.abacPolicyName = dict["AbacPolicyName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetAbacPolicyResponseBody : Tea.TeaModel {
    public class Policy : Tea.TeaModel {
        public var authorizedQuantity: String?

        public var creatorId: Int64?

        public var policyContent: String?

        public var policyDesc: String?

        public var policyId: Int64?

        public var policyName: String?

        public var policySource: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorizedQuantity != nil {
                map["AuthorizedQuantity"] = self.authorizedQuantity!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.policyContent != nil {
                map["PolicyContent"] = self.policyContent!
            }
            if self.policyDesc != nil {
                map["PolicyDesc"] = self.policyDesc!
            }
            if self.policyId != nil {
                map["PolicyId"] = self.policyId!
            }
            if self.policyName != nil {
                map["PolicyName"] = self.policyName!
            }
            if self.policySource != nil {
                map["PolicySource"] = self.policySource!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorizedQuantity") {
                self.authorizedQuantity = dict["AuthorizedQuantity"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! Int64
            }
            if dict.keys.contains("PolicyContent") {
                self.policyContent = dict["PolicyContent"] as! String
            }
            if dict.keys.contains("PolicyDesc") {
                self.policyDesc = dict["PolicyDesc"] as! String
            }
            if dict.keys.contains("PolicyId") {
                self.policyId = dict["PolicyId"] as! Int64
            }
            if dict.keys.contains("PolicyName") {
                self.policyName = dict["PolicyName"] as! String
            }
            if dict.keys.contains("PolicySource") {
                self.policySource = dict["PolicySource"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var policy: GetAbacPolicyResponseBody.Policy?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.policy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.policy != nil {
            map["Policy"] = self.policy?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("Policy") {
            var model = GetAbacPolicyResponseBody.Policy()
            model.fromMap(dict["Policy"] as! [String: Any])
            self.policy = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAbacPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAbacPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAbacPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetApprovalDetailRequest : Tea.TeaModel {
    public var tid: Int64?

    public var workflowInstanceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.workflowInstanceId != nil {
            map["WorkflowInstanceId"] = self.workflowInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("WorkflowInstanceId") {
            self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
        }
    }
}

public class GetApprovalDetailResponseBody : Tea.TeaModel {
    public class ApprovalDetail : Tea.TeaModel {
        public class CurrentHandlers : Tea.TeaModel {
            public class CurrentHandler : Tea.TeaModel {
                public var id: Int64?

                public var nickName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.nickName != nil {
                        map["NickName"] = self.nickName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("NickName") {
                        self.nickName = dict["NickName"] as! String
                    }
                }
            }
            public var currentHandler: [GetApprovalDetailResponseBody.ApprovalDetail.CurrentHandlers.CurrentHandler]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currentHandler != nil {
                    var tmp : [Any] = []
                    for k in self.currentHandler! {
                        tmp.append(k.toMap())
                    }
                    map["CurrentHandler"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CurrentHandler") {
                    var tmp : [GetApprovalDetailResponseBody.ApprovalDetail.CurrentHandlers.CurrentHandler] = []
                    for v in dict["CurrentHandler"] as! [Any] {
                        var model = GetApprovalDetailResponseBody.ApprovalDetail.CurrentHandlers.CurrentHandler()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.currentHandler = tmp
                }
            }
        }
        public class ReasonList : Tea.TeaModel {
            public var reasons: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.reasons != nil {
                    map["Reasons"] = self.reasons!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Reasons") {
                    self.reasons = dict["Reasons"] as! [String]
                }
            }
        }
        public class WorkflowNodes : Tea.TeaModel {
            public class WorkflowNode : Tea.TeaModel {
                public class AuditUserIdList : Tea.TeaModel {
                    public var auditUserIds: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.auditUserIds != nil {
                            map["AuditUserIds"] = self.auditUserIds!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AuditUserIds") {
                            self.auditUserIds = dict["AuditUserIds"] as! [String]
                        }
                    }
                }
                public var auditUserIdList: GetApprovalDetailResponseBody.ApprovalDetail.WorkflowNodes.WorkflowNode.AuditUserIdList?

                public var nodeName: String?

                public var operateComment: String?

                public var operateTime: String?

                public var operatorId: Int64?

                public var workflowInsCode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.auditUserIdList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.auditUserIdList != nil {
                        map["AuditUserIdList"] = self.auditUserIdList?.toMap()
                    }
                    if self.nodeName != nil {
                        map["NodeName"] = self.nodeName!
                    }
                    if self.operateComment != nil {
                        map["OperateComment"] = self.operateComment!
                    }
                    if self.operateTime != nil {
                        map["OperateTime"] = self.operateTime!
                    }
                    if self.operatorId != nil {
                        map["OperatorId"] = self.operatorId!
                    }
                    if self.workflowInsCode != nil {
                        map["WorkflowInsCode"] = self.workflowInsCode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AuditUserIdList") {
                        var model = GetApprovalDetailResponseBody.ApprovalDetail.WorkflowNodes.WorkflowNode.AuditUserIdList()
                        model.fromMap(dict["AuditUserIdList"] as! [String: Any])
                        self.auditUserIdList = model
                    }
                    if dict.keys.contains("NodeName") {
                        self.nodeName = dict["NodeName"] as! String
                    }
                    if dict.keys.contains("OperateComment") {
                        self.operateComment = dict["OperateComment"] as! String
                    }
                    if dict.keys.contains("OperateTime") {
                        self.operateTime = dict["OperateTime"] as! String
                    }
                    if dict.keys.contains("OperatorId") {
                        self.operatorId = dict["OperatorId"] as! Int64
                    }
                    if dict.keys.contains("WorkflowInsCode") {
                        self.workflowInsCode = dict["WorkflowInsCode"] as! String
                    }
                }
            }
            public var workflowNode: [GetApprovalDetailResponseBody.ApprovalDetail.WorkflowNodes.WorkflowNode]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.workflowNode != nil {
                    var tmp : [Any] = []
                    for k in self.workflowNode! {
                        tmp.append(k.toMap())
                    }
                    map["WorkflowNode"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("WorkflowNode") {
                    var tmp : [GetApprovalDetailResponseBody.ApprovalDetail.WorkflowNodes.WorkflowNode] = []
                    for v in dict["WorkflowNode"] as! [Any] {
                        var model = GetApprovalDetailResponseBody.ApprovalDetail.WorkflowNodes.WorkflowNode()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.workflowNode = tmp
                }
            }
        }
        public var auditId: Int64?

        public var createTime: String?

        public var currentHandlers: GetApprovalDetailResponseBody.ApprovalDetail.CurrentHandlers?

        public var description_: String?

        public var orderId: Int64?

        public var orderType: String?

        public var reasonList: GetApprovalDetailResponseBody.ApprovalDetail.ReasonList?

        public var templateId: Int64?

        public var thirdpartyWorkflowComment: String?

        public var thirdpartyWorkflowUrl: String?

        public var title: String?

        public var workflowInsCode: String?

        public var workflowNodes: GetApprovalDetailResponseBody.ApprovalDetail.WorkflowNodes?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.currentHandlers?.validate()
            try self.reasonList?.validate()
            try self.workflowNodes?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.auditId != nil {
                map["AuditId"] = self.auditId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.currentHandlers != nil {
                map["CurrentHandlers"] = self.currentHandlers?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            if self.orderType != nil {
                map["OrderType"] = self.orderType!
            }
            if self.reasonList != nil {
                map["ReasonList"] = self.reasonList?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.thirdpartyWorkflowComment != nil {
                map["ThirdpartyWorkflowComment"] = self.thirdpartyWorkflowComment!
            }
            if self.thirdpartyWorkflowUrl != nil {
                map["ThirdpartyWorkflowUrl"] = self.thirdpartyWorkflowUrl!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.workflowInsCode != nil {
                map["WorkflowInsCode"] = self.workflowInsCode!
            }
            if self.workflowNodes != nil {
                map["WorkflowNodes"] = self.workflowNodes?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuditId") {
                self.auditId = dict["AuditId"] as! Int64
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CurrentHandlers") {
                var model = GetApprovalDetailResponseBody.ApprovalDetail.CurrentHandlers()
                model.fromMap(dict["CurrentHandlers"] as! [String: Any])
                self.currentHandlers = model
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("OrderId") {
                self.orderId = dict["OrderId"] as! Int64
            }
            if dict.keys.contains("OrderType") {
                self.orderType = dict["OrderType"] as! String
            }
            if dict.keys.contains("ReasonList") {
                var model = GetApprovalDetailResponseBody.ApprovalDetail.ReasonList()
                model.fromMap(dict["ReasonList"] as! [String: Any])
                self.reasonList = model
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! Int64
            }
            if dict.keys.contains("ThirdpartyWorkflowComment") {
                self.thirdpartyWorkflowComment = dict["ThirdpartyWorkflowComment"] as! String
            }
            if dict.keys.contains("ThirdpartyWorkflowUrl") {
                self.thirdpartyWorkflowUrl = dict["ThirdpartyWorkflowUrl"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("WorkflowInsCode") {
                self.workflowInsCode = dict["WorkflowInsCode"] as! String
            }
            if dict.keys.contains("WorkflowNodes") {
                var model = GetApprovalDetailResponseBody.ApprovalDetail.WorkflowNodes()
                model.fromMap(dict["WorkflowNodes"] as! [String: Any])
                self.workflowNodes = model
            }
        }
    }
    public var approvalDetail: GetApprovalDetailResponseBody.ApprovalDetail?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.approvalDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.approvalDetail != nil {
            map["ApprovalDetail"] = self.approvalDetail?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApprovalDetail") {
            var model = GetApprovalDetailResponseBody.ApprovalDetail()
            model.fromMap(dict["ApprovalDetail"] as! [String: Any])
            self.approvalDetail = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetApprovalDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApprovalDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetApprovalDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAuthorityTemplateRequest : Tea.TeaModel {
    public var templateId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetAuthorityTemplateResponseBody : Tea.TeaModel {
    public class AuthorityTemplateView : Tea.TeaModel {
        public class AuthorityTemplateItemList : Tea.TeaModel {
            public class AuthorityTemplateItem : Tea.TeaModel {
                public var attribute: String?

                public var dbId: Int64?

                public var instanceId: Int64?

                public var itemId: Int64?

                public var modifierId: Int64?

                public var resourceType: String?

                public var tableName: String?

                public var templateId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.attribute != nil {
                        map["Attribute"] = self.attribute!
                    }
                    if self.dbId != nil {
                        map["DbId"] = self.dbId!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.itemId != nil {
                        map["ItemId"] = self.itemId!
                    }
                    if self.modifierId != nil {
                        map["ModifierId"] = self.modifierId!
                    }
                    if self.resourceType != nil {
                        map["ResourceType"] = self.resourceType!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Attribute") {
                        self.attribute = dict["Attribute"] as! String
                    }
                    if dict.keys.contains("DbId") {
                        self.dbId = dict["DbId"] as! Int64
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! Int64
                    }
                    if dict.keys.contains("ItemId") {
                        self.itemId = dict["ItemId"] as! Int64
                    }
                    if dict.keys.contains("ModifierId") {
                        self.modifierId = dict["ModifierId"] as! Int64
                    }
                    if dict.keys.contains("ResourceType") {
                        self.resourceType = dict["ResourceType"] as! String
                    }
                    if dict.keys.contains("TableName") {
                        self.tableName = dict["TableName"] as! String
                    }
                    if dict.keys.contains("TemplateId") {
                        self.templateId = dict["TemplateId"] as! Int64
                    }
                }
            }
            public var authorityTemplateItem: [GetAuthorityTemplateResponseBody.AuthorityTemplateView.AuthorityTemplateItemList.AuthorityTemplateItem]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorityTemplateItem != nil {
                    var tmp : [Any] = []
                    for k in self.authorityTemplateItem! {
                        tmp.append(k.toMap())
                    }
                    map["AuthorityTemplateItem"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuthorityTemplateItem") {
                    var tmp : [GetAuthorityTemplateResponseBody.AuthorityTemplateView.AuthorityTemplateItemList.AuthorityTemplateItem] = []
                    for v in dict["AuthorityTemplateItem"] as! [Any] {
                        var model = GetAuthorityTemplateResponseBody.AuthorityTemplateView.AuthorityTemplateItemList.AuthorityTemplateItem()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.authorityTemplateItem = tmp
                }
            }
        }
        public var authorityTemplateItemList: GetAuthorityTemplateResponseBody.AuthorityTemplateView.AuthorityTemplateItemList?

        public var createTime: String?

        public var creatorId: Int64?

        public var description_: String?

        public var name: String?

        public var templateId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.authorityTemplateItemList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorityTemplateItemList != nil {
                map["AuthorityTemplateItemList"] = self.authorityTemplateItemList?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorityTemplateItemList") {
                var model = GetAuthorityTemplateResponseBody.AuthorityTemplateView.AuthorityTemplateItemList()
                model.fromMap(dict["AuthorityTemplateItemList"] as! [String: Any])
                self.authorityTemplateItemList = model
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! Int64
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! Int64
            }
        }
    }
    public var authorityTemplateView: GetAuthorityTemplateResponseBody.AuthorityTemplateView?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authorityTemplateView?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorityTemplateView != nil {
            map["AuthorityTemplateView"] = self.authorityTemplateView?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorityTemplateView") {
            var model = GetAuthorityTemplateResponseBody.AuthorityTemplateView()
            model.fromMap(dict["AuthorityTemplateView"] as! [String: Any])
            self.authorityTemplateView = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetAuthorityTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAuthorityTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAuthorityTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAuthorityTemplateItemRequest : Tea.TeaModel {
    public var templateId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetAuthorityTemplateItemResponseBody : Tea.TeaModel {
    public class AuthorityTemplateItemList : Tea.TeaModel {
        public class AuthorityTemplateItem : Tea.TeaModel {
            public var attribute: String?

            public var dbId: Int64?

            public var instanceId: Int64?

            public var itemId: Int64?

            public var modifierId: Int64?

            public var resourceType: String?

            public var tableName: String?

            public var templateId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attribute != nil {
                    map["Attribute"] = self.attribute!
                }
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.modifierId != nil {
                    map["ModifierId"] = self.modifierId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Attribute") {
                    self.attribute = dict["Attribute"] as! String
                }
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("ItemId") {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("ModifierId") {
                    self.modifierId = dict["ModifierId"] as! Int64
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("TemplateId") {
                    self.templateId = dict["TemplateId"] as! Int64
                }
            }
        }
        public var authorityTemplateItem: [GetAuthorityTemplateItemResponseBody.AuthorityTemplateItemList.AuthorityTemplateItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorityTemplateItem != nil {
                var tmp : [Any] = []
                for k in self.authorityTemplateItem! {
                    tmp.append(k.toMap())
                }
                map["AuthorityTemplateItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorityTemplateItem") {
                var tmp : [GetAuthorityTemplateItemResponseBody.AuthorityTemplateItemList.AuthorityTemplateItem] = []
                for v in dict["AuthorityTemplateItem"] as! [Any] {
                    var model = GetAuthorityTemplateItemResponseBody.AuthorityTemplateItemList.AuthorityTemplateItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.authorityTemplateItem = tmp
            }
        }
    }
    public var authorityTemplateItemList: GetAuthorityTemplateItemResponseBody.AuthorityTemplateItemList?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authorityTemplateItemList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorityTemplateItemList != nil {
            map["AuthorityTemplateItemList"] = self.authorityTemplateItemList?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorityTemplateItemList") {
            var model = GetAuthorityTemplateItemResponseBody.AuthorityTemplateItemList()
            model.fromMap(dict["AuthorityTemplateItemList"] as! [String: Any])
            self.authorityTemplateItemList = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetAuthorityTemplateItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAuthorityTemplateItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAuthorityTemplateItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetClassificationTemplateRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetClassificationTemplateResponseBody : Tea.TeaModel {
    public class ClassificationResourceTemplateMap : Tea.TeaModel {
        public var resourceId: Int64?

        public var resourceType: String?

        public var templateId: Int64?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! Int64
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! Int64
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
        }
    }
    public var classificationResourceTemplateMap: GetClassificationTemplateResponseBody.ClassificationResourceTemplateMap?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.classificationResourceTemplateMap?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.classificationResourceTemplateMap != nil {
            map["ClassificationResourceTemplateMap"] = self.classificationResourceTemplateMap?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClassificationResourceTemplateMap") {
            var model = GetClassificationTemplateResponseBody.ClassificationResourceTemplateMap()
            model.fromMap(dict["ClassificationResourceTemplateMap"] as! [String: Any])
            self.classificationResourceTemplateMap = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetClassificationTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetClassificationTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetClassificationTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDBTaskSQLJobLogRequest : Tea.TeaModel {
    public var jobId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDBTaskSQLJobLogResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var log: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.log != nil {
            map["Log"] = self.log!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("Log") {
            self.log = dict["Log"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDBTaskSQLJobLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDBTaskSQLJobLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDBTaskSQLJobLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDBTopologyRequest : Tea.TeaModel {
    public var logicDbId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logicDbId != nil {
            map["LogicDbId"] = self.logicDbId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogicDbId") {
            self.logicDbId = dict["LogicDbId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDBTopologyResponseBody : Tea.TeaModel {
    public class DBTopology : Tea.TeaModel {
        public class DBTopologyInfoList : Tea.TeaModel {
            public var catalogName: String?

            public var dbId: Int64?

            public var dbType: String?

            public var envType: String?

            public var instanceId: Int64?

            public var instanceResourceId: String?

            public var instanceSource: String?

            public var regionId: String?

            public var schemaName: String?

            public var searchName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.catalogName != nil {
                    map["CatalogName"] = self.catalogName!
                }
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceResourceId != nil {
                    map["InstanceResourceId"] = self.instanceResourceId!
                }
                if self.instanceSource != nil {
                    map["InstanceSource"] = self.instanceSource!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CatalogName") {
                    self.catalogName = dict["CatalogName"] as! String
                }
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("DbType") {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("EnvType") {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("InstanceResourceId") {
                    self.instanceResourceId = dict["InstanceResourceId"] as! String
                }
                if dict.keys.contains("InstanceSource") {
                    self.instanceSource = dict["InstanceSource"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SchemaName") {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SearchName") {
                    self.searchName = dict["SearchName"] as! String
                }
            }
        }
        public var alias: String?

        public var DBTopologyInfoList: [GetDBTopologyResponseBody.DBTopology.DBTopologyInfoList]?

        public var dbType: String?

        public var envType: String?

        public var logicDbId: Int64?

        public var logicDbName: String?

        public var searchName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alias != nil {
                map["Alias"] = self.alias!
            }
            if self.DBTopologyInfoList != nil {
                var tmp : [Any] = []
                for k in self.DBTopologyInfoList! {
                    tmp.append(k.toMap())
                }
                map["DBTopologyInfoList"] = tmp
            }
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.logicDbId != nil {
                map["LogicDbId"] = self.logicDbId!
            }
            if self.logicDbName != nil {
                map["LogicDbName"] = self.logicDbName!
            }
            if self.searchName != nil {
                map["SearchName"] = self.searchName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alias") {
                self.alias = dict["Alias"] as! String
            }
            if dict.keys.contains("DBTopologyInfoList") {
                var tmp : [GetDBTopologyResponseBody.DBTopology.DBTopologyInfoList] = []
                for v in dict["DBTopologyInfoList"] as! [Any] {
                    var model = GetDBTopologyResponseBody.DBTopology.DBTopologyInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.DBTopologyInfoList = tmp
            }
            if dict.keys.contains("DbType") {
                self.dbType = dict["DbType"] as! String
            }
            if dict.keys.contains("EnvType") {
                self.envType = dict["EnvType"] as! String
            }
            if dict.keys.contains("LogicDbId") {
                self.logicDbId = dict["LogicDbId"] as! Int64
            }
            if dict.keys.contains("LogicDbName") {
                self.logicDbName = dict["LogicDbName"] as! String
            }
            if dict.keys.contains("SearchName") {
                self.searchName = dict["SearchName"] as! String
            }
        }
    }
    public var DBTopology: GetDBTopologyResponseBody.DBTopology?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DBTopology?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBTopology != nil {
            map["DBTopology"] = self.DBTopology?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBTopology") {
            var model = GetDBTopologyResponseBody.DBTopology()
            model.fromMap(dict["DBTopology"] as! [String: Any])
            self.DBTopology = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDBTopologyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDBTopologyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDBTopologyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataArchiveCountRequest : Tea.TeaModel {
    public var orderResultType: String?

    public var pluginType: String?

    public var searchDateType: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderResultType != nil {
            map["OrderResultType"] = self.orderResultType!
        }
        if self.pluginType != nil {
            map["PluginType"] = self.pluginType!
        }
        if self.searchDateType != nil {
            map["SearchDateType"] = self.searchDateType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderResultType") {
            self.orderResultType = dict["OrderResultType"] as! String
        }
        if dict.keys.contains("PluginType") {
            self.pluginType = dict["PluginType"] as! String
        }
        if dict.keys.contains("SearchDateType") {
            self.searchDateType = dict["SearchDateType"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataArchiveCountResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var failCount: Int64?

        public var processingCount: Int64?

        public var successCount: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failCount != nil {
                map["FailCount"] = self.failCount!
            }
            if self.processingCount != nil {
                map["ProcessingCount"] = self.processingCount!
            }
            if self.successCount != nil {
                map["SuccessCount"] = self.successCount!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailCount") {
                self.failCount = dict["FailCount"] as! Int64
            }
            if dict.keys.contains("ProcessingCount") {
                self.processingCount = dict["ProcessingCount"] as! Int64
            }
            if dict.keys.contains("SuccessCount") {
                self.successCount = dict["SuccessCount"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: GetDataArchiveCountResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetDataArchiveCountResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataArchiveCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataArchiveCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataArchiveCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataArchiveOrderDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataArchiveOrderDetailResponseBody : Tea.TeaModel {
    public class DataArchiveOrderDetail : Tea.TeaModel {
        public class PluginExtraData : Tea.TeaModel {
            public class DagInfo : Tea.TeaModel {
                public var creatorId: String?

                public var cronBeginDate: String?

                public var cronEndDate: String?

                public var cronTrigger: Bool?

                public var DWDevelop: Bool?

                public var dagName: String?

                public var dagOwnerId: String?

                public var deployId: Int64?

                public var description_: String?

                public var editDagId: Int64?

                public var gmtCreate: String?

                public var gmtModified: String?

                public var id: Int64?

                public var isPublic: Int64?

                public var legacy: Bool?

                public var system: Bool?

                public var tenantId: String?

                public var triggerOnce: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.creatorId != nil {
                        map["CreatorId"] = self.creatorId!
                    }
                    if self.cronBeginDate != nil {
                        map["CronBeginDate"] = self.cronBeginDate!
                    }
                    if self.cronEndDate != nil {
                        map["CronEndDate"] = self.cronEndDate!
                    }
                    if self.cronTrigger != nil {
                        map["CronTrigger"] = self.cronTrigger!
                    }
                    if self.DWDevelop != nil {
                        map["DWDevelop"] = self.DWDevelop!
                    }
                    if self.dagName != nil {
                        map["DagName"] = self.dagName!
                    }
                    if self.dagOwnerId != nil {
                        map["DagOwnerId"] = self.dagOwnerId!
                    }
                    if self.deployId != nil {
                        map["DeployId"] = self.deployId!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.editDagId != nil {
                        map["EditDagId"] = self.editDagId!
                    }
                    if self.gmtCreate != nil {
                        map["GmtCreate"] = self.gmtCreate!
                    }
                    if self.gmtModified != nil {
                        map["GmtModified"] = self.gmtModified!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.isPublic != nil {
                        map["IsPublic"] = self.isPublic!
                    }
                    if self.legacy != nil {
                        map["Legacy"] = self.legacy!
                    }
                    if self.system != nil {
                        map["System"] = self.system!
                    }
                    if self.tenantId != nil {
                        map["TenantId"] = self.tenantId!
                    }
                    if self.triggerOnce != nil {
                        map["TriggerOnce"] = self.triggerOnce!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CreatorId") {
                        self.creatorId = dict["CreatorId"] as! String
                    }
                    if dict.keys.contains("CronBeginDate") {
                        self.cronBeginDate = dict["CronBeginDate"] as! String
                    }
                    if dict.keys.contains("CronEndDate") {
                        self.cronEndDate = dict["CronEndDate"] as! String
                    }
                    if dict.keys.contains("CronTrigger") {
                        self.cronTrigger = dict["CronTrigger"] as! Bool
                    }
                    if dict.keys.contains("DWDevelop") {
                        self.DWDevelop = dict["DWDevelop"] as! Bool
                    }
                    if dict.keys.contains("DagName") {
                        self.dagName = dict["DagName"] as! String
                    }
                    if dict.keys.contains("DagOwnerId") {
                        self.dagOwnerId = dict["DagOwnerId"] as! String
                    }
                    if dict.keys.contains("DeployId") {
                        self.deployId = dict["DeployId"] as! Int64
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("EditDagId") {
                        self.editDagId = dict["EditDagId"] as! Int64
                    }
                    if dict.keys.contains("GmtCreate") {
                        self.gmtCreate = dict["GmtCreate"] as! String
                    }
                    if dict.keys.contains("GmtModified") {
                        self.gmtModified = dict["GmtModified"] as! String
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("IsPublic") {
                        self.isPublic = dict["IsPublic"] as! Int64
                    }
                    if dict.keys.contains("Legacy") {
                        self.legacy = dict["Legacy"] as! Bool
                    }
                    if dict.keys.contains("System") {
                        self.system = dict["System"] as! Bool
                    }
                    if dict.keys.contains("TenantId") {
                        self.tenantId = dict["TenantId"] as! String
                    }
                    if dict.keys.contains("TriggerOnce") {
                        self.triggerOnce = dict["TriggerOnce"] as! Bool
                    }
                }
            }
            public class DbBaseInfo : Tea.TeaModel {
                public class StandardGroup : Tea.TeaModel {
                    public var dbType: String?

                    public var description_: String?

                    public var freeOrStable: Bool?

                    public var gmtCreate: String?

                    public var gmtModified: String?

                    public var groupMode: String?

                    public var groupName: String?

                    public var id: Int64?

                    public var lastMenderId: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.dbType != nil {
                            map["DbType"] = self.dbType!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.freeOrStable != nil {
                            map["FreeOrStable"] = self.freeOrStable!
                        }
                        if self.gmtCreate != nil {
                            map["GmtCreate"] = self.gmtCreate!
                        }
                        if self.gmtModified != nil {
                            map["GmtModified"] = self.gmtModified!
                        }
                        if self.groupMode != nil {
                            map["GroupMode"] = self.groupMode!
                        }
                        if self.groupName != nil {
                            map["GroupName"] = self.groupName!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.lastMenderId != nil {
                            map["LastMenderId"] = self.lastMenderId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DbType") {
                            self.dbType = dict["DbType"] as! String
                        }
                        if dict.keys.contains("Description") {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("FreeOrStable") {
                            self.freeOrStable = dict["FreeOrStable"] as! Bool
                        }
                        if dict.keys.contains("GmtCreate") {
                            self.gmtCreate = dict["GmtCreate"] as! String
                        }
                        if dict.keys.contains("GmtModified") {
                            self.gmtModified = dict["GmtModified"] as! String
                        }
                        if dict.keys.contains("GroupMode") {
                            self.groupMode = dict["GroupMode"] as! String
                        }
                        if dict.keys.contains("GroupName") {
                            self.groupName = dict["GroupName"] as! String
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! Int64
                        }
                        if dict.keys.contains("LastMenderId") {
                            self.lastMenderId = dict["LastMenderId"] as! Int64
                        }
                    }
                }
                public var alias: String?

                public var alterTimeout: Int64?

                public var assetControl: Bool?

                public var catalogName: String?

                public var clusterNode: String?

                public var dbId: Int64?

                public var dbType: String?

                public var dbaId: Int64?

                public var dbaName: String?

                public var description_: String?

                public var encoding: String?

                public var envType: String?

                public var follow: Bool?

                public var host: String?

                public var idc: String?

                public var idcTitle: String?

                public var instanceId: Int64?

                public var instanceSource: String?

                public var lastSyncTime: String?

                public var level: String?

                public var logic: Bool?

                public var ownerIds: [Int64]?

                public var ownerNames: [String]?

                public var port: Int64?

                public var schemaName: String?

                public var searchName: String?

                public var standardGroup: GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.DbBaseInfo.StandardGroup?

                public var state: String?

                public var tableCount: Int64?

                public var tnsName: String?

                public var unitType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.standardGroup?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alias != nil {
                        map["Alias"] = self.alias!
                    }
                    if self.alterTimeout != nil {
                        map["AlterTimeout"] = self.alterTimeout!
                    }
                    if self.assetControl != nil {
                        map["AssetControl"] = self.assetControl!
                    }
                    if self.catalogName != nil {
                        map["CatalogName"] = self.catalogName!
                    }
                    if self.clusterNode != nil {
                        map["ClusterNode"] = self.clusterNode!
                    }
                    if self.dbId != nil {
                        map["DbId"] = self.dbId!
                    }
                    if self.dbType != nil {
                        map["DbType"] = self.dbType!
                    }
                    if self.dbaId != nil {
                        map["DbaId"] = self.dbaId!
                    }
                    if self.dbaName != nil {
                        map["DbaName"] = self.dbaName!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.encoding != nil {
                        map["Encoding"] = self.encoding!
                    }
                    if self.envType != nil {
                        map["EnvType"] = self.envType!
                    }
                    if self.follow != nil {
                        map["Follow"] = self.follow!
                    }
                    if self.host != nil {
                        map["Host"] = self.host!
                    }
                    if self.idc != nil {
                        map["Idc"] = self.idc!
                    }
                    if self.idcTitle != nil {
                        map["IdcTitle"] = self.idcTitle!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.instanceSource != nil {
                        map["InstanceSource"] = self.instanceSource!
                    }
                    if self.lastSyncTime != nil {
                        map["LastSyncTime"] = self.lastSyncTime!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.logic != nil {
                        map["Logic"] = self.logic!
                    }
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    if self.ownerNames != nil {
                        map["OwnerNames"] = self.ownerNames!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.schemaName != nil {
                        map["SchemaName"] = self.schemaName!
                    }
                    if self.searchName != nil {
                        map["SearchName"] = self.searchName!
                    }
                    if self.standardGroup != nil {
                        map["StandardGroup"] = self.standardGroup?.toMap()
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    if self.tableCount != nil {
                        map["TableCount"] = self.tableCount!
                    }
                    if self.tnsName != nil {
                        map["TnsName"] = self.tnsName!
                    }
                    if self.unitType != nil {
                        map["UnitType"] = self.unitType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Alias") {
                        self.alias = dict["Alias"] as! String
                    }
                    if dict.keys.contains("AlterTimeout") {
                        self.alterTimeout = dict["AlterTimeout"] as! Int64
                    }
                    if dict.keys.contains("AssetControl") {
                        self.assetControl = dict["AssetControl"] as! Bool
                    }
                    if dict.keys.contains("CatalogName") {
                        self.catalogName = dict["CatalogName"] as! String
                    }
                    if dict.keys.contains("ClusterNode") {
                        self.clusterNode = dict["ClusterNode"] as! String
                    }
                    if dict.keys.contains("DbId") {
                        self.dbId = dict["DbId"] as! Int64
                    }
                    if dict.keys.contains("DbType") {
                        self.dbType = dict["DbType"] as! String
                    }
                    if dict.keys.contains("DbaId") {
                        self.dbaId = dict["DbaId"] as! Int64
                    }
                    if dict.keys.contains("DbaName") {
                        self.dbaName = dict["DbaName"] as! String
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Encoding") {
                        self.encoding = dict["Encoding"] as! String
                    }
                    if dict.keys.contains("EnvType") {
                        self.envType = dict["EnvType"] as! String
                    }
                    if dict.keys.contains("Follow") {
                        self.follow = dict["Follow"] as! Bool
                    }
                    if dict.keys.contains("Host") {
                        self.host = dict["Host"] as! String
                    }
                    if dict.keys.contains("Idc") {
                        self.idc = dict["Idc"] as! String
                    }
                    if dict.keys.contains("IdcTitle") {
                        self.idcTitle = dict["IdcTitle"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! Int64
                    }
                    if dict.keys.contains("InstanceSource") {
                        self.instanceSource = dict["InstanceSource"] as! String
                    }
                    if dict.keys.contains("LastSyncTime") {
                        self.lastSyncTime = dict["LastSyncTime"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Logic") {
                        self.logic = dict["Logic"] as! Bool
                    }
                    if dict.keys.contains("OwnerIds") {
                        self.ownerIds = dict["OwnerIds"] as! [Int64]
                    }
                    if dict.keys.contains("OwnerNames") {
                        self.ownerNames = dict["OwnerNames"] as! [String]
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! Int64
                    }
                    if dict.keys.contains("SchemaName") {
                        self.schemaName = dict["SchemaName"] as! String
                    }
                    if dict.keys.contains("SearchName") {
                        self.searchName = dict["SearchName"] as! String
                    }
                    if dict.keys.contains("StandardGroup") {
                        var model = GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.DbBaseInfo.StandardGroup()
                        model.fromMap(dict["StandardGroup"] as! [String: Any])
                        self.standardGroup = model
                    }
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                    if dict.keys.contains("TableCount") {
                        self.tableCount = dict["TableCount"] as! Int64
                    }
                    if dict.keys.contains("TnsName") {
                        self.tnsName = dict["TnsName"] as! String
                    }
                    if dict.keys.contains("UnitType") {
                        self.unitType = dict["UnitType"] as! String
                    }
                }
            }
            public class Instances : Tea.TeaModel {
                public var businessTime: String?

                public var dagId: Int64?

                public var endTime: String?

                public var gmtCreate: String?

                public var gmtModified: String?

                public var historyDagId: Int64?

                public var id: Int64?

                public var lastRunningContext: String?

                public var msg: String?

                public var status: Int64?

                public var tenantId: String?

                public var triggerType: Int64?

                public var version: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.businessTime != nil {
                        map["BusinessTime"] = self.businessTime!
                    }
                    if self.dagId != nil {
                        map["DagId"] = self.dagId!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.gmtCreate != nil {
                        map["GmtCreate"] = self.gmtCreate!
                    }
                    if self.gmtModified != nil {
                        map["GmtModified"] = self.gmtModified!
                    }
                    if self.historyDagId != nil {
                        map["HistoryDagId"] = self.historyDagId!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.lastRunningContext != nil {
                        map["LastRunningContext"] = self.lastRunningContext!
                    }
                    if self.msg != nil {
                        map["Msg"] = self.msg!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.tenantId != nil {
                        map["TenantId"] = self.tenantId!
                    }
                    if self.triggerType != nil {
                        map["TriggerType"] = self.triggerType!
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BusinessTime") {
                        self.businessTime = dict["BusinessTime"] as! String
                    }
                    if dict.keys.contains("DagId") {
                        self.dagId = dict["DagId"] as! Int64
                    }
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! String
                    }
                    if dict.keys.contains("GmtCreate") {
                        self.gmtCreate = dict["GmtCreate"] as! String
                    }
                    if dict.keys.contains("GmtModified") {
                        self.gmtModified = dict["GmtModified"] as! String
                    }
                    if dict.keys.contains("HistoryDagId") {
                        self.historyDagId = dict["HistoryDagId"] as! Int64
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("LastRunningContext") {
                        self.lastRunningContext = dict["LastRunningContext"] as! String
                    }
                    if dict.keys.contains("Msg") {
                        self.msg = dict["Msg"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! Int64
                    }
                    if dict.keys.contains("TenantId") {
                        self.tenantId = dict["TenantId"] as! String
                    }
                    if dict.keys.contains("TriggerType") {
                        self.triggerType = dict["TriggerType"] as! Int64
                    }
                    if dict.keys.contains("Version") {
                        self.version = dict["Version"] as! String
                    }
                }
            }
            public class NextFireTimeResult : Tea.TeaModel {
                public var cronFireType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cronFireType != nil {
                        map["CronFireType"] = self.cronFireType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CronFireType") {
                        self.cronFireType = dict["CronFireType"] as! String
                    }
                }
            }
            public var dagInfo: GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.DagInfo?

            public var dbBaseInfo: GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.DbBaseInfo?

            public var instanceTotal: Int64?

            public var instances: [GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.Instances]?

            public var nextFireTimeResult: GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.NextFireTimeResult?

            public var pageIndex: Int64?

            public var pageSize: Int64?

            public var tempTableNameMap: [String: Any]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dagInfo?.validate()
                try self.dbBaseInfo?.validate()
                try self.nextFireTimeResult?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dagInfo != nil {
                    map["DagInfo"] = self.dagInfo?.toMap()
                }
                if self.dbBaseInfo != nil {
                    map["DbBaseInfo"] = self.dbBaseInfo?.toMap()
                }
                if self.instanceTotal != nil {
                    map["InstanceTotal"] = self.instanceTotal!
                }
                if self.instances != nil {
                    var tmp : [Any] = []
                    for k in self.instances! {
                        tmp.append(k.toMap())
                    }
                    map["Instances"] = tmp
                }
                if self.nextFireTimeResult != nil {
                    map["NextFireTimeResult"] = self.nextFireTimeResult?.toMap()
                }
                if self.pageIndex != nil {
                    map["PageIndex"] = self.pageIndex!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.tempTableNameMap != nil {
                    map["TempTableNameMap"] = self.tempTableNameMap!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DagInfo") {
                    var model = GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.DagInfo()
                    model.fromMap(dict["DagInfo"] as! [String: Any])
                    self.dagInfo = model
                }
                if dict.keys.contains("DbBaseInfo") {
                    var model = GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.DbBaseInfo()
                    model.fromMap(dict["DbBaseInfo"] as! [String: Any])
                    self.dbBaseInfo = model
                }
                if dict.keys.contains("InstanceTotal") {
                    self.instanceTotal = dict["InstanceTotal"] as! Int64
                }
                if dict.keys.contains("Instances") {
                    var tmp : [GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.Instances] = []
                    for v in dict["Instances"] as! [Any] {
                        var model = GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.Instances()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.instances = tmp
                }
                if dict.keys.contains("NextFireTimeResult") {
                    var model = GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.NextFireTimeResult()
                    model.fromMap(dict["NextFireTimeResult"] as! [String: Any])
                    self.nextFireTimeResult = model
                }
                if dict.keys.contains("PageIndex") {
                    self.pageIndex = dict["PageIndex"] as! Int64
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int64
                }
                if dict.keys.contains("TempTableNameMap") {
                    self.tempTableNameMap = dict["TempTableNameMap"] as! [String: Any]
                }
            }
        }
        public class PluginParam : Tea.TeaModel {
            public class TableIncludes : Tea.TeaModel {
                public var tableName: String?

                public var tableWhere: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    if self.tableWhere != nil {
                        map["TableWhere"] = self.tableWhere!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TableName") {
                        self.tableName = dict["TableName"] as! String
                    }
                    if dict.keys.contains("TableWhere") {
                        self.tableWhere = dict["TableWhere"] as! String
                    }
                }
            }
            public var archiveMethod: String?

            public var dbSchema: String?

            public var logic: Bool?

            public var orderAfter: [String]?

            public var runMethod: String?

            public var sourceDatabaseId: Int64?

            public var tableIncludes: [GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginParam.TableIncludes]?

            public var tableMapping: [String]?

            public var targetInstanceId: String?

            public var variables: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.archiveMethod != nil {
                    map["ArchiveMethod"] = self.archiveMethod!
                }
                if self.dbSchema != nil {
                    map["DbSchema"] = self.dbSchema!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.orderAfter != nil {
                    map["OrderAfter"] = self.orderAfter!
                }
                if self.runMethod != nil {
                    map["RunMethod"] = self.runMethod!
                }
                if self.sourceDatabaseId != nil {
                    map["SourceDatabaseId"] = self.sourceDatabaseId!
                }
                if self.tableIncludes != nil {
                    var tmp : [Any] = []
                    for k in self.tableIncludes! {
                        tmp.append(k.toMap())
                    }
                    map["TableIncludes"] = tmp
                }
                if self.tableMapping != nil {
                    map["TableMapping"] = self.tableMapping!
                }
                if self.targetInstanceId != nil {
                    map["TargetInstanceId"] = self.targetInstanceId!
                }
                if self.variables != nil {
                    map["Variables"] = self.variables!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ArchiveMethod") {
                    self.archiveMethod = dict["ArchiveMethod"] as! String
                }
                if dict.keys.contains("DbSchema") {
                    self.dbSchema = dict["DbSchema"] as! String
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("OrderAfter") {
                    self.orderAfter = dict["OrderAfter"] as! [String]
                }
                if dict.keys.contains("RunMethod") {
                    self.runMethod = dict["RunMethod"] as! String
                }
                if dict.keys.contains("SourceDatabaseId") {
                    self.sourceDatabaseId = dict["SourceDatabaseId"] as! Int64
                }
                if dict.keys.contains("TableIncludes") {
                    var tmp : [GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginParam.TableIncludes] = []
                    for v in dict["TableIncludes"] as! [Any] {
                        var model = GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginParam.TableIncludes()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tableIncludes = tmp
                }
                if dict.keys.contains("TableMapping") {
                    self.tableMapping = dict["TableMapping"] as! [String]
                }
                if dict.keys.contains("TargetInstanceId") {
                    self.targetInstanceId = dict["TargetInstanceId"] as! String
                }
                if dict.keys.contains("Variables") {
                    self.variables = dict["Variables"] as! [String]
                }
            }
        }
        public var comment: String?

        public var committer: String?

        public var committerId: Int64?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var pluginExtraData: GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData?

        public var pluginParam: GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginParam?

        public var pluginType: String?

        public var relatedUserList: [Int64]?

        public var relatedUserNickList: [String]?

        public var statusCode: String?

        public var statusDesc: String?

        public var workflowInstanceId: Int64?

        public var workflowStatusDesc: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pluginExtraData?.validate()
            try self.pluginParam?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.committer != nil {
                map["Committer"] = self.committer!
            }
            if self.committerId != nil {
                map["CommitterId"] = self.committerId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.pluginExtraData != nil {
                map["PluginExtraData"] = self.pluginExtraData?.toMap()
            }
            if self.pluginParam != nil {
                map["PluginParam"] = self.pluginParam?.toMap()
            }
            if self.pluginType != nil {
                map["PluginType"] = self.pluginType!
            }
            if self.relatedUserList != nil {
                map["RelatedUserList"] = self.relatedUserList!
            }
            if self.relatedUserNickList != nil {
                map["RelatedUserNickList"] = self.relatedUserNickList!
            }
            if self.statusCode != nil {
                map["StatusCode"] = self.statusCode!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.workflowInstanceId != nil {
                map["WorkflowInstanceId"] = self.workflowInstanceId!
            }
            if self.workflowStatusDesc != nil {
                map["WorkflowStatusDesc"] = self.workflowStatusDesc!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("Committer") {
                self.committer = dict["Committer"] as! String
            }
            if dict.keys.contains("CommitterId") {
                self.committerId = dict["CommitterId"] as! Int64
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("PluginExtraData") {
                var model = GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData()
                model.fromMap(dict["PluginExtraData"] as! [String: Any])
                self.pluginExtraData = model
            }
            if dict.keys.contains("PluginParam") {
                var model = GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginParam()
                model.fromMap(dict["PluginParam"] as! [String: Any])
                self.pluginParam = model
            }
            if dict.keys.contains("PluginType") {
                self.pluginType = dict["PluginType"] as! String
            }
            if dict.keys.contains("RelatedUserList") {
                self.relatedUserList = dict["RelatedUserList"] as! [Int64]
            }
            if dict.keys.contains("RelatedUserNickList") {
                self.relatedUserNickList = dict["RelatedUserNickList"] as! [String]
            }
            if dict.keys.contains("StatusCode") {
                self.statusCode = dict["StatusCode"] as! String
            }
            if dict.keys.contains("StatusDesc") {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("WorkflowInstanceId") {
                self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
            }
            if dict.keys.contains("WorkflowStatusDesc") {
                self.workflowStatusDesc = dict["WorkflowStatusDesc"] as! String
            }
        }
    }
    public var dataArchiveOrderDetail: GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataArchiveOrderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataArchiveOrderDetail != nil {
            map["DataArchiveOrderDetail"] = self.dataArchiveOrderDetail?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataArchiveOrderDetail") {
            var model = GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail()
            model.fromMap(dict["DataArchiveOrderDetail"] as! [String: Any])
            self.dataArchiveOrderDetail = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class GetDataArchiveOrderDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataArchiveOrderDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataArchiveOrderDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataCorrectBackupFilesRequest : Tea.TeaModel {
    public var actionDetail: [String: Any]?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionDetail != nil {
            map["ActionDetail"] = self.actionDetail!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionDetail") {
            self.actionDetail = dict["ActionDetail"] as! [String: Any]
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataCorrectBackupFilesShrinkRequest : Tea.TeaModel {
    public var actionDetailShrink: String?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionDetailShrink != nil {
            map["ActionDetail"] = self.actionDetailShrink!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionDetail") {
            self.actionDetailShrink = dict["ActionDetail"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataCorrectBackupFilesResponseBody : Tea.TeaModel {
    public class DataCorrectBackupFiles : Tea.TeaModel {
        public var fileUrl: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileUrl") {
                self.fileUrl = dict["FileUrl"] as! [String]
            }
        }
    }
    public var dataCorrectBackupFiles: GetDataCorrectBackupFilesResponseBody.DataCorrectBackupFiles?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataCorrectBackupFiles?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataCorrectBackupFiles != nil {
            map["DataCorrectBackupFiles"] = self.dataCorrectBackupFiles?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataCorrectBackupFiles") {
            var model = GetDataCorrectBackupFilesResponseBody.DataCorrectBackupFiles()
            model.fromMap(dict["DataCorrectBackupFiles"] as! [String: Any])
            self.dataCorrectBackupFiles = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataCorrectBackupFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataCorrectBackupFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataCorrectBackupFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataCorrectOrderDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataCorrectOrderDetailResponseBody : Tea.TeaModel {
    public class DataCorrectOrderDetail : Tea.TeaModel {
        public class ConfigDetail : Tea.TeaModel {
            public class CronExtConfig : Tea.TeaModel {
                public var currentClearTaskCount: Int32?

                public var optimizeTableAfterEveryClearTimes: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.currentClearTaskCount != nil {
                        map["CurrentClearTaskCount"] = self.currentClearTaskCount!
                    }
                    if self.optimizeTableAfterEveryClearTimes != nil {
                        map["OptimizeTableAfterEveryClearTimes"] = self.optimizeTableAfterEveryClearTimes!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CurrentClearTaskCount") {
                        self.currentClearTaskCount = dict["CurrentClearTaskCount"] as! Int32
                    }
                    if dict.keys.contains("OptimizeTableAfterEveryClearTimes") {
                        self.optimizeTableAfterEveryClearTimes = dict["OptimizeTableAfterEveryClearTimes"] as! Int32
                    }
                }
            }
            public class ImportExtConfig : Tea.TeaModel {
                public var csvFirstRowIsColumnDef: Bool?

                public var ignoreError: Bool?

                public var importMode: String?

                public var insertType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.csvFirstRowIsColumnDef != nil {
                        map["CsvFirstRowIsColumnDef"] = self.csvFirstRowIsColumnDef!
                    }
                    if self.ignoreError != nil {
                        map["IgnoreError"] = self.ignoreError!
                    }
                    if self.importMode != nil {
                        map["ImportMode"] = self.importMode!
                    }
                    if self.insertType != nil {
                        map["InsertType"] = self.insertType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CsvFirstRowIsColumnDef") {
                        self.csvFirstRowIsColumnDef = dict["CsvFirstRowIsColumnDef"] as! Bool
                    }
                    if dict.keys.contains("IgnoreError") {
                        self.ignoreError = dict["IgnoreError"] as! Bool
                    }
                    if dict.keys.contains("ImportMode") {
                        self.importMode = dict["ImportMode"] as! String
                    }
                    if dict.keys.contains("InsertType") {
                        self.insertType = dict["InsertType"] as! String
                    }
                }
            }
            public var cron: Bool?

            public var cronCallTimes: Int32?

            public var cronExtConfig: GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.ConfigDetail.CronExtConfig?

            public var cronFormat: String?

            public var cronLastCallStartTime: String?

            public var cronNextCallTime: String?

            public var cronStatus: String?

            public var csvTableName: String?

            public var currentTaskId: Int64?

            public var detailType: String?

            public var duration: Int32?

            public var fileEncoding: String?

            public var fileType: String?

            public var importExtConfig: GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.ConfigDetail.ImportExtConfig?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.cronExtConfig?.validate()
                try self.importExtConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cron != nil {
                    map["Cron"] = self.cron!
                }
                if self.cronCallTimes != nil {
                    map["CronCallTimes"] = self.cronCallTimes!
                }
                if self.cronExtConfig != nil {
                    map["CronExtConfig"] = self.cronExtConfig?.toMap()
                }
                if self.cronFormat != nil {
                    map["CronFormat"] = self.cronFormat!
                }
                if self.cronLastCallStartTime != nil {
                    map["CronLastCallStartTime"] = self.cronLastCallStartTime!
                }
                if self.cronNextCallTime != nil {
                    map["CronNextCallTime"] = self.cronNextCallTime!
                }
                if self.cronStatus != nil {
                    map["CronStatus"] = self.cronStatus!
                }
                if self.csvTableName != nil {
                    map["CsvTableName"] = self.csvTableName!
                }
                if self.currentTaskId != nil {
                    map["CurrentTaskId"] = self.currentTaskId!
                }
                if self.detailType != nil {
                    map["DetailType"] = self.detailType!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.fileEncoding != nil {
                    map["FileEncoding"] = self.fileEncoding!
                }
                if self.fileType != nil {
                    map["FileType"] = self.fileType!
                }
                if self.importExtConfig != nil {
                    map["ImportExtConfig"] = self.importExtConfig?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cron") {
                    self.cron = dict["Cron"] as! Bool
                }
                if dict.keys.contains("CronCallTimes") {
                    self.cronCallTimes = dict["CronCallTimes"] as! Int32
                }
                if dict.keys.contains("CronExtConfig") {
                    var model = GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.ConfigDetail.CronExtConfig()
                    model.fromMap(dict["CronExtConfig"] as! [String: Any])
                    self.cronExtConfig = model
                }
                if dict.keys.contains("CronFormat") {
                    self.cronFormat = dict["CronFormat"] as! String
                }
                if dict.keys.contains("CronLastCallStartTime") {
                    self.cronLastCallStartTime = dict["CronLastCallStartTime"] as! String
                }
                if dict.keys.contains("CronNextCallTime") {
                    self.cronNextCallTime = dict["CronNextCallTime"] as! String
                }
                if dict.keys.contains("CronStatus") {
                    self.cronStatus = dict["CronStatus"] as! String
                }
                if dict.keys.contains("CsvTableName") {
                    self.csvTableName = dict["CsvTableName"] as! String
                }
                if dict.keys.contains("CurrentTaskId") {
                    self.currentTaskId = dict["CurrentTaskId"] as! Int64
                }
                if dict.keys.contains("DetailType") {
                    self.detailType = dict["DetailType"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Int32
                }
                if dict.keys.contains("FileEncoding") {
                    self.fileEncoding = dict["FileEncoding"] as! String
                }
                if dict.keys.contains("FileType") {
                    self.fileType = dict["FileType"] as! String
                }
                if dict.keys.contains("ImportExtConfig") {
                    var model = GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.ConfigDetail.ImportExtConfig()
                    model.fromMap(dict["ImportExtConfig"] as! [String: Any])
                    self.importExtConfig = model
                }
            }
        }
        public class DatabaseList : Tea.TeaModel {
            public class Database : Tea.TeaModel {
                public var dbId: Int32?

                public var dbType: String?

                public var envType: String?

                public var logic: Bool?

                public var searchName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dbId != nil {
                        map["DbId"] = self.dbId!
                    }
                    if self.dbType != nil {
                        map["DbType"] = self.dbType!
                    }
                    if self.envType != nil {
                        map["EnvType"] = self.envType!
                    }
                    if self.logic != nil {
                        map["Logic"] = self.logic!
                    }
                    if self.searchName != nil {
                        map["SearchName"] = self.searchName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DbId") {
                        self.dbId = dict["DbId"] as! Int32
                    }
                    if dict.keys.contains("DbType") {
                        self.dbType = dict["DbType"] as! String
                    }
                    if dict.keys.contains("EnvType") {
                        self.envType = dict["EnvType"] as! String
                    }
                    if dict.keys.contains("Logic") {
                        self.logic = dict["Logic"] as! Bool
                    }
                    if dict.keys.contains("SearchName") {
                        self.searchName = dict["SearchName"] as! String
                    }
                }
            }
            public var database: [GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.DatabaseList.Database]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.database != nil {
                    var tmp : [Any] = []
                    for k in self.database! {
                        tmp.append(k.toMap())
                    }
                    map["Database"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Database") {
                    var tmp : [GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.DatabaseList.Database] = []
                    for v in dict["Database"] as! [Any] {
                        var model = GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.DatabaseList.Database()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.database = tmp
                }
            }
        }
        public class OrderDetail : Tea.TeaModel {
            public var actualAffectRows: Int64?

            public var attachmentName: String?

            public var classify: String?

            public var estimateAffectRows: Int64?

            public var exeSQL: String?

            public var ignoreAffectRows: Bool?

            public var ignoreAffectRowsReason: String?

            public var rbAttachmentName: String?

            public var rbSQL: String?

            public var rbSQLType: String?

            public var sqlType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actualAffectRows != nil {
                    map["ActualAffectRows"] = self.actualAffectRows!
                }
                if self.attachmentName != nil {
                    map["AttachmentName"] = self.attachmentName!
                }
                if self.classify != nil {
                    map["Classify"] = self.classify!
                }
                if self.estimateAffectRows != nil {
                    map["EstimateAffectRows"] = self.estimateAffectRows!
                }
                if self.exeSQL != nil {
                    map["ExeSQL"] = self.exeSQL!
                }
                if self.ignoreAffectRows != nil {
                    map["IgnoreAffectRows"] = self.ignoreAffectRows!
                }
                if self.ignoreAffectRowsReason != nil {
                    map["IgnoreAffectRowsReason"] = self.ignoreAffectRowsReason!
                }
                if self.rbAttachmentName != nil {
                    map["RbAttachmentName"] = self.rbAttachmentName!
                }
                if self.rbSQL != nil {
                    map["RbSQL"] = self.rbSQL!
                }
                if self.rbSQLType != nil {
                    map["RbSQLType"] = self.rbSQLType!
                }
                if self.sqlType != nil {
                    map["SqlType"] = self.sqlType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActualAffectRows") {
                    self.actualAffectRows = dict["ActualAffectRows"] as! Int64
                }
                if dict.keys.contains("AttachmentName") {
                    self.attachmentName = dict["AttachmentName"] as! String
                }
                if dict.keys.contains("Classify") {
                    self.classify = dict["Classify"] as! String
                }
                if dict.keys.contains("EstimateAffectRows") {
                    self.estimateAffectRows = dict["EstimateAffectRows"] as! Int64
                }
                if dict.keys.contains("ExeSQL") {
                    self.exeSQL = dict["ExeSQL"] as! String
                }
                if dict.keys.contains("IgnoreAffectRows") {
                    self.ignoreAffectRows = dict["IgnoreAffectRows"] as! Bool
                }
                if dict.keys.contains("IgnoreAffectRowsReason") {
                    self.ignoreAffectRowsReason = dict["IgnoreAffectRowsReason"] as! String
                }
                if dict.keys.contains("RbAttachmentName") {
                    self.rbAttachmentName = dict["RbAttachmentName"] as! String
                }
                if dict.keys.contains("RbSQL") {
                    self.rbSQL = dict["RbSQL"] as! String
                }
                if dict.keys.contains("RbSQLType") {
                    self.rbSQLType = dict["RbSQLType"] as! String
                }
                if dict.keys.contains("SqlType") {
                    self.sqlType = dict["SqlType"] as! String
                }
            }
        }
        public class PreCheckDetail : Tea.TeaModel {
            public class TaskCheckDO : Tea.TeaModel {
                public var checkStatus: String?

                public var checkStep: String?

                public var userTip: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkStatus != nil {
                        map["CheckStatus"] = self.checkStatus!
                    }
                    if self.checkStep != nil {
                        map["CheckStep"] = self.checkStep!
                    }
                    if self.userTip != nil {
                        map["UserTip"] = self.userTip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CheckStatus") {
                        self.checkStatus = dict["CheckStatus"] as! String
                    }
                    if dict.keys.contains("CheckStep") {
                        self.checkStep = dict["CheckStep"] as! String
                    }
                    if dict.keys.contains("UserTip") {
                        self.userTip = dict["UserTip"] as! String
                    }
                }
            }
            public var taskCheckDO: [GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.PreCheckDetail.TaskCheckDO]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.taskCheckDO != nil {
                    var tmp : [Any] = []
                    for k in self.taskCheckDO! {
                        tmp.append(k.toMap())
                    }
                    map["TaskCheckDO"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TaskCheckDO") {
                    var tmp : [GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.PreCheckDetail.TaskCheckDO] = []
                    for v in dict["TaskCheckDO"] as! [Any] {
                        var model = GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.PreCheckDetail.TaskCheckDO()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.taskCheckDO = tmp
                }
            }
        }
        public var configDetail: GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.ConfigDetail?

        public var databaseList: GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.DatabaseList?

        public var execMode: String?

        public var orderDetail: GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.OrderDetail?

        public var preCheckDetail: GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.PreCheckDetail?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.configDetail?.validate()
            try self.databaseList?.validate()
            try self.orderDetail?.validate()
            try self.preCheckDetail?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configDetail != nil {
                map["ConfigDetail"] = self.configDetail?.toMap()
            }
            if self.databaseList != nil {
                map["DatabaseList"] = self.databaseList?.toMap()
            }
            if self.execMode != nil {
                map["ExecMode"] = self.execMode!
            }
            if self.orderDetail != nil {
                map["OrderDetail"] = self.orderDetail?.toMap()
            }
            if self.preCheckDetail != nil {
                map["PreCheckDetail"] = self.preCheckDetail?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigDetail") {
                var model = GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.ConfigDetail()
                model.fromMap(dict["ConfigDetail"] as! [String: Any])
                self.configDetail = model
            }
            if dict.keys.contains("DatabaseList") {
                var model = GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.DatabaseList()
                model.fromMap(dict["DatabaseList"] as! [String: Any])
                self.databaseList = model
            }
            if dict.keys.contains("ExecMode") {
                self.execMode = dict["ExecMode"] as! String
            }
            if dict.keys.contains("OrderDetail") {
                var model = GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.OrderDetail()
                model.fromMap(dict["OrderDetail"] as! [String: Any])
                self.orderDetail = model
            }
            if dict.keys.contains("PreCheckDetail") {
                var model = GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.PreCheckDetail()
                model.fromMap(dict["PreCheckDetail"] as! [String: Any])
                self.preCheckDetail = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var dataCorrectOrderDetail: GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataCorrectOrderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataCorrectOrderDetail != nil {
            map["DataCorrectOrderDetail"] = self.dataCorrectOrderDetail?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataCorrectOrderDetail") {
            var model = GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail()
            model.fromMap(dict["DataCorrectOrderDetail"] as! [String: Any])
            self.dataCorrectOrderDetail = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataCorrectOrderDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataCorrectOrderDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataCorrectOrderDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataCorrectRollbackFileRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataCorrectRollbackFileResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var fileUrl: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("FileUrl") {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataCorrectRollbackFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataCorrectRollbackFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataCorrectRollbackFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataCorrectSQLFileRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataCorrectSQLFileResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var fileUrl: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("FileUrl") {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataCorrectSQLFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataCorrectSQLFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataCorrectSQLFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataCorrectTaskDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataCorrectTaskDetailResponseBody : Tea.TeaModel {
    public class DataCorrectTaskDetail : Tea.TeaModel {
        public var actualAffectRows: Int64?

        public var createTime: String?

        public var DBTaskGroupId: Int64?

        public var jobStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualAffectRows != nil {
                map["ActualAffectRows"] = self.actualAffectRows!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.DBTaskGroupId != nil {
                map["DBTaskGroupId"] = self.DBTaskGroupId!
            }
            if self.jobStatus != nil {
                map["jobStatus"] = self.jobStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActualAffectRows") {
                self.actualAffectRows = dict["ActualAffectRows"] as! Int64
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DBTaskGroupId") {
                self.DBTaskGroupId = dict["DBTaskGroupId"] as! Int64
            }
            if dict.keys.contains("jobStatus") {
                self.jobStatus = dict["jobStatus"] as! String
            }
        }
    }
    public var dataCorrectTaskDetail: GetDataCorrectTaskDetailResponseBody.DataCorrectTaskDetail?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataCorrectTaskDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataCorrectTaskDetail != nil {
            map["DataCorrectTaskDetail"] = self.dataCorrectTaskDetail?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataCorrectTaskDetail") {
            var model = GetDataCorrectTaskDetailResponseBody.DataCorrectTaskDetail()
            model.fromMap(dict["DataCorrectTaskDetail"] as! [String: Any])
            self.dataCorrectTaskDetail = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataCorrectTaskDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataCorrectTaskDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataCorrectTaskDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataCronClearConfigRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataCronClearConfigResponseBody : Tea.TeaModel {
    public class DataCronClearConfig : Tea.TeaModel {
        public var cronCallTimes: String?

        public var cronFormat: String?

        public var cronLastCallStartTime: String?

        public var cronNextCallTime: String?

        public var cronStatus: String?

        public var currentClearTaskCount: Int64?

        public var duration: String?

        public var optimizeTableAfterEveryClearTimes: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cronCallTimes != nil {
                map["CronCallTimes"] = self.cronCallTimes!
            }
            if self.cronFormat != nil {
                map["CronFormat"] = self.cronFormat!
            }
            if self.cronLastCallStartTime != nil {
                map["CronLastCallStartTime"] = self.cronLastCallStartTime!
            }
            if self.cronNextCallTime != nil {
                map["CronNextCallTime"] = self.cronNextCallTime!
            }
            if self.cronStatus != nil {
                map["CronStatus"] = self.cronStatus!
            }
            if self.currentClearTaskCount != nil {
                map["CurrentClearTaskCount"] = self.currentClearTaskCount!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.optimizeTableAfterEveryClearTimes != nil {
                map["OptimizeTableAfterEveryClearTimes"] = self.optimizeTableAfterEveryClearTimes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CronCallTimes") {
                self.cronCallTimes = dict["CronCallTimes"] as! String
            }
            if dict.keys.contains("CronFormat") {
                self.cronFormat = dict["CronFormat"] as! String
            }
            if dict.keys.contains("CronLastCallStartTime") {
                self.cronLastCallStartTime = dict["CronLastCallStartTime"] as! String
            }
            if dict.keys.contains("CronNextCallTime") {
                self.cronNextCallTime = dict["CronNextCallTime"] as! String
            }
            if dict.keys.contains("CronStatus") {
                self.cronStatus = dict["CronStatus"] as! String
            }
            if dict.keys.contains("CurrentClearTaskCount") {
                self.currentClearTaskCount = dict["CurrentClearTaskCount"] as! Int64
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("OptimizeTableAfterEveryClearTimes") {
                self.optimizeTableAfterEveryClearTimes = dict["OptimizeTableAfterEveryClearTimes"] as! Int64
            }
        }
    }
    public var dataCronClearConfig: GetDataCronClearConfigResponseBody.DataCronClearConfig?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataCronClearConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataCronClearConfig != nil {
            map["DataCronClearConfig"] = self.dataCronClearConfig?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataCronClearConfig") {
            var model = GetDataCronClearConfigResponseBody.DataCronClearConfig()
            model.fromMap(dict["DataCronClearConfig"] as! [String: Any])
            self.dataCronClearConfig = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataCronClearConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataCronClearConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataCronClearConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataCronClearTaskDetailListRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataCronClearTaskDetailListResponseBody : Tea.TeaModel {
    public class DataCronClearTaskDetailList : Tea.TeaModel {
        public var actualAffectRows: Int64?

        public var createTime: String?

        public var DBTaskGroupId: Int64?

        public var jobStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualAffectRows != nil {
                map["ActualAffectRows"] = self.actualAffectRows!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.DBTaskGroupId != nil {
                map["DBTaskGroupId"] = self.DBTaskGroupId!
            }
            if self.jobStatus != nil {
                map["jobStatus"] = self.jobStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActualAffectRows") {
                self.actualAffectRows = dict["ActualAffectRows"] as! Int64
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DBTaskGroupId") {
                self.DBTaskGroupId = dict["DBTaskGroupId"] as! Int64
            }
            if dict.keys.contains("jobStatus") {
                self.jobStatus = dict["jobStatus"] as! String
            }
        }
    }
    public var dataCronClearTaskDetailList: [GetDataCronClearTaskDetailListResponseBody.DataCronClearTaskDetailList]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataCronClearTaskDetailList != nil {
            var tmp : [Any] = []
            for k in self.dataCronClearTaskDetailList! {
                tmp.append(k.toMap())
            }
            map["DataCronClearTaskDetailList"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataCronClearTaskDetailList") {
            var tmp : [GetDataCronClearTaskDetailListResponseBody.DataCronClearTaskDetailList] = []
            for v in dict["DataCronClearTaskDetailList"] as! [Any] {
                var model = GetDataCronClearTaskDetailListResponseBody.DataCronClearTaskDetailList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataCronClearTaskDetailList = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class GetDataCronClearTaskDetailListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataCronClearTaskDetailListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataCronClearTaskDetailListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataExportDownloadURLRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var realLoginUserUid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.realLoginUserUid != nil {
            map["RealLoginUserUid"] = self.realLoginUserUid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RealLoginUserUid") {
            self.realLoginUserUid = dict["RealLoginUserUid"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataExportDownloadURLResponseBody : Tea.TeaModel {
    public class DownloadURLResult : Tea.TeaModel {
        public var hasResult: Bool?

        public var tipMessage: String?

        public var URL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hasResult != nil {
                map["HasResult"] = self.hasResult!
            }
            if self.tipMessage != nil {
                map["TipMessage"] = self.tipMessage!
            }
            if self.URL != nil {
                map["URL"] = self.URL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HasResult") {
                self.hasResult = dict["HasResult"] as! Bool
            }
            if dict.keys.contains("TipMessage") {
                self.tipMessage = dict["TipMessage"] as! String
            }
            if dict.keys.contains("URL") {
                self.URL = dict["URL"] as! String
            }
        }
    }
    public var downloadURLResult: GetDataExportDownloadURLResponseBody.DownloadURLResult?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.downloadURLResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadURLResult != nil {
            map["DownloadURLResult"] = self.downloadURLResult?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadURLResult") {
            var model = GetDataExportDownloadURLResponseBody.DownloadURLResult()
            model.fromMap(dict["DownloadURLResult"] as! [String: Any])
            self.downloadURLResult = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataExportDownloadURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataExportDownloadURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataExportDownloadURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataExportOrderDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataExportOrderDetailResponseBody : Tea.TeaModel {
    public class DataExportOrderDetail : Tea.TeaModel {
        public class KeyInfo : Tea.TeaModel {
            public var jobId: Int64?

            public var jobStatus: String?

            public var preCheckId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.jobStatus != nil {
                    map["JobStatus"] = self.jobStatus!
                }
                if self.preCheckId != nil {
                    map["PreCheckId"] = self.preCheckId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! Int64
                }
                if dict.keys.contains("JobStatus") {
                    self.jobStatus = dict["JobStatus"] as! String
                }
                if dict.keys.contains("PreCheckId") {
                    self.preCheckId = dict["PreCheckId"] as! Int64
                }
            }
        }
        public class OrderDetail : Tea.TeaModel {
            public var actualAffectRows: Int64?

            public var classify: String?

            public var database: String?

            public var dbId: Int32?

            public var envType: String?

            public var exeSQL: String?

            public var ignoreAffectRows: Bool?

            public var ignoreAffectRowsReason: String?

            public var logic: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actualAffectRows != nil {
                    map["ActualAffectRows"] = self.actualAffectRows!
                }
                if self.classify != nil {
                    map["Classify"] = self.classify!
                }
                if self.database != nil {
                    map["Database"] = self.database!
                }
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.exeSQL != nil {
                    map["ExeSQL"] = self.exeSQL!
                }
                if self.ignoreAffectRows != nil {
                    map["IgnoreAffectRows"] = self.ignoreAffectRows!
                }
                if self.ignoreAffectRowsReason != nil {
                    map["IgnoreAffectRowsReason"] = self.ignoreAffectRowsReason!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActualAffectRows") {
                    self.actualAffectRows = dict["ActualAffectRows"] as! Int64
                }
                if dict.keys.contains("Classify") {
                    self.classify = dict["Classify"] as! String
                }
                if dict.keys.contains("Database") {
                    self.database = dict["Database"] as! String
                }
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! Int32
                }
                if dict.keys.contains("EnvType") {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("ExeSQL") {
                    self.exeSQL = dict["ExeSQL"] as! String
                }
                if dict.keys.contains("IgnoreAffectRows") {
                    self.ignoreAffectRows = dict["IgnoreAffectRows"] as! Bool
                }
                if dict.keys.contains("IgnoreAffectRowsReason") {
                    self.ignoreAffectRowsReason = dict["IgnoreAffectRowsReason"] as! String
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
            }
        }
        public var keyInfo: GetDataExportOrderDetailResponseBody.DataExportOrderDetail.KeyInfo?

        public var orderDetail: GetDataExportOrderDetailResponseBody.DataExportOrderDetail.OrderDetail?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.keyInfo?.validate()
            try self.orderDetail?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.keyInfo != nil {
                map["KeyInfo"] = self.keyInfo?.toMap()
            }
            if self.orderDetail != nil {
                map["OrderDetail"] = self.orderDetail?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("KeyInfo") {
                var model = GetDataExportOrderDetailResponseBody.DataExportOrderDetail.KeyInfo()
                model.fromMap(dict["KeyInfo"] as! [String: Any])
                self.keyInfo = model
            }
            if dict.keys.contains("OrderDetail") {
                var model = GetDataExportOrderDetailResponseBody.DataExportOrderDetail.OrderDetail()
                model.fromMap(dict["OrderDetail"] as! [String: Any])
                self.orderDetail = model
            }
        }
    }
    public var dataExportOrderDetail: GetDataExportOrderDetailResponseBody.DataExportOrderDetail?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataExportOrderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataExportOrderDetail != nil {
            map["DataExportOrderDetail"] = self.dataExportOrderDetail?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataExportOrderDetail") {
            var model = GetDataExportOrderDetailResponseBody.DataExportOrderDetail()
            model.fromMap(dict["DataExportOrderDetail"] as! [String: Any])
            self.dataExportOrderDetail = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataExportOrderDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataExportOrderDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataExportOrderDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataExportPreCheckDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataExportPreCheckDetailResponseBody : Tea.TeaModel {
    public class PreCheckResult : Tea.TeaModel {
        public class PreCheckDetailList : Tea.TeaModel {
            public class PreCheckDetailList : Tea.TeaModel {
                public var affectRows: Int64?

                public var SQL: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.affectRows != nil {
                        map["AffectRows"] = self.affectRows!
                    }
                    if self.SQL != nil {
                        map["SQL"] = self.SQL!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AffectRows") {
                        self.affectRows = dict["AffectRows"] as! Int64
                    }
                    if dict.keys.contains("SQL") {
                        self.SQL = dict["SQL"] as! String
                    }
                }
            }
            public var preCheckDetailList: [GetDataExportPreCheckDetailResponseBody.PreCheckResult.PreCheckDetailList.PreCheckDetailList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.preCheckDetailList != nil {
                    var tmp : [Any] = []
                    for k in self.preCheckDetailList! {
                        tmp.append(k.toMap())
                    }
                    map["PreCheckDetailList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PreCheckDetailList") {
                    var tmp : [GetDataExportPreCheckDetailResponseBody.PreCheckResult.PreCheckDetailList.PreCheckDetailList] = []
                    for v in dict["PreCheckDetailList"] as! [Any] {
                        var model = GetDataExportPreCheckDetailResponseBody.PreCheckResult.PreCheckDetailList.PreCheckDetailList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.preCheckDetailList = tmp
                }
            }
        }
        public var ignoreAffectRows: Bool?

        public var preCheckDetailList: GetDataExportPreCheckDetailResponseBody.PreCheckResult.PreCheckDetailList?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.preCheckDetailList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ignoreAffectRows != nil {
                map["IgnoreAffectRows"] = self.ignoreAffectRows!
            }
            if self.preCheckDetailList != nil {
                map["PreCheckDetailList"] = self.preCheckDetailList?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IgnoreAffectRows") {
                self.ignoreAffectRows = dict["IgnoreAffectRows"] as! Bool
            }
            if dict.keys.contains("PreCheckDetailList") {
                var model = GetDataExportPreCheckDetailResponseBody.PreCheckResult.PreCheckDetailList()
                model.fromMap(dict["PreCheckDetailList"] as! [String: Any])
                self.preCheckDetailList = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var preCheckResult: GetDataExportPreCheckDetailResponseBody.PreCheckResult?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.preCheckResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.preCheckResult != nil {
            map["PreCheckResult"] = self.preCheckResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("PreCheckResult") {
            var model = GetDataExportPreCheckDetailResponseBody.PreCheckResult()
            model.fromMap(dict["PreCheckResult"] as! [String: Any])
            self.preCheckResult = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataExportPreCheckDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataExportPreCheckDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataExportPreCheckDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataImportSQLRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var sqlId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("SqlId") {
            self.sqlId = dict["SqlId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataImportSQLResponseBody : Tea.TeaModel {
    public class SQLDetail : Tea.TeaModel {
        public var execSql: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.execSql != nil {
                map["ExecSql"] = self.execSql!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExecSql") {
                self.execSql = dict["ExecSql"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var SQLDetail: GetDataImportSQLResponseBody.SQLDetail?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.SQLDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SQLDetail != nil {
            map["SQLDetail"] = self.SQLDetail?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SQLDetail") {
            var model = GetDataImportSQLResponseBody.SQLDetail()
            model.fromMap(dict["SQLDetail"] as! [String: Any])
            self.SQLDetail = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataImportSQLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataImportSQLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataImportSQLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataLakeCatalogRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataLakeCatalogResponseBody : Tea.TeaModel {
    public var catalog: DLCatalog?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.catalog?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalog != nil {
            map["Catalog"] = self.catalog?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Catalog") {
            var model = DLCatalog()
            model.fromMap(dict["Catalog"] as! [String: Any])
            self.catalog = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataLakeCatalogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataLakeCatalogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataLakeCatalogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataLakeDatabaseRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var name: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataLakeDatabaseResponseBody : Tea.TeaModel {
    public var database: DLDatabase?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.database?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.database != nil {
            map["Database"] = self.database?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Database") {
            var model = DLDatabase()
            model.fromMap(dict["Database"] as! [String: Any])
            self.database = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataLakeDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataLakeDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataLakeDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataLakePartitionRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var partitionValues: [String]?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.partitionValues != nil {
            map["PartitionValues"] = self.partitionValues!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("PartitionValues") {
            self.partitionValues = dict["PartitionValues"] as! [String]
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataLakePartitionShrinkRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var partitionValuesShrink: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.partitionValuesShrink != nil {
            map["PartitionValues"] = self.partitionValuesShrink!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("PartitionValues") {
            self.partitionValuesShrink = dict["PartitionValues"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataLakePartitionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var partition: DLPartition?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.partition?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.partition != nil {
            map["Partition"] = self.partition?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("Partition") {
            var model = DLPartition()
            model.fromMap(dict["Partition"] as! [String: Any])
            self.partition = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataLakePartitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataLakePartitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataLakePartitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataLakeTableRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var name: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataLakeTableResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: String?

    public var table: DLTable?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.table?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.table != nil {
            map["Table"] = self.table?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Table") {
            var model = DLTable()
            model.fromMap(dict["Table"] as! [String: Any])
            self.table = model
        }
    }
}

public class GetDataLakeTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataLakeTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataLakeTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataTrackJobDegreeRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataTrackJobDegreeResponseBody : Tea.TeaModel {
    public class JobDegree : Tea.TeaModel {
        public var downloadCompletionDegree: Double?

        public var filterCompletionDegree: Double?

        public var jobStatus: String?

        public var listCompletionDegree: Double?

        public var statusDesc: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadCompletionDegree != nil {
                map["DownloadCompletionDegree"] = self.downloadCompletionDegree!
            }
            if self.filterCompletionDegree != nil {
                map["FilterCompletionDegree"] = self.filterCompletionDegree!
            }
            if self.jobStatus != nil {
                map["JobStatus"] = self.jobStatus!
            }
            if self.listCompletionDegree != nil {
                map["ListCompletionDegree"] = self.listCompletionDegree!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DownloadCompletionDegree") {
                self.downloadCompletionDegree = dict["DownloadCompletionDegree"] as! Double
            }
            if dict.keys.contains("FilterCompletionDegree") {
                self.filterCompletionDegree = dict["FilterCompletionDegree"] as! Double
            }
            if dict.keys.contains("JobStatus") {
                self.jobStatus = dict["JobStatus"] as! String
            }
            if dict.keys.contains("ListCompletionDegree") {
                self.listCompletionDegree = dict["ListCompletionDegree"] as! Double
            }
            if dict.keys.contains("StatusDesc") {
                self.statusDesc = dict["StatusDesc"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var jobDegree: GetDataTrackJobDegreeResponseBody.JobDegree?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobDegree?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.jobDegree != nil {
            map["JobDegree"] = self.jobDegree?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("JobDegree") {
            var model = GetDataTrackJobDegreeResponseBody.JobDegree()
            model.fromMap(dict["JobDegree"] as! [String: Any])
            self.jobDegree = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataTrackJobDegreeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataTrackJobDegreeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataTrackJobDegreeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataTrackJobTableMetaRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataTrackJobTableMetaResponseBody : Tea.TeaModel {
    public class TableMetaList : Tea.TeaModel {
        public class Columns : Tea.TeaModel {
            public var charset: String?

            public var columnName: String?

            public var columnPosition: Int32?

            public var columnType: String?

            public var fictive: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.charset != nil {
                    map["Charset"] = self.charset!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.columnPosition != nil {
                    map["ColumnPosition"] = self.columnPosition!
                }
                if self.columnType != nil {
                    map["ColumnType"] = self.columnType!
                }
                if self.fictive != nil {
                    map["Fictive"] = self.fictive!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Charset") {
                    self.charset = dict["Charset"] as! String
                }
                if dict.keys.contains("ColumnName") {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("ColumnPosition") {
                    self.columnPosition = dict["ColumnPosition"] as! Int32
                }
                if dict.keys.contains("ColumnType") {
                    self.columnType = dict["ColumnType"] as! String
                }
                if dict.keys.contains("Fictive") {
                    self.fictive = dict["Fictive"] as! Bool
                }
            }
        }
        public var columns: [GetDataTrackJobTableMetaResponseBody.TableMetaList.Columns]?

        public var schemaName: String?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columns != nil {
                var tmp : [Any] = []
                for k in self.columns! {
                    tmp.append(k.toMap())
                }
                map["Columns"] = tmp
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Columns") {
                var tmp : [GetDataTrackJobTableMetaResponseBody.TableMetaList.Columns] = []
                for v in dict["Columns"] as! [Any] {
                    var model = GetDataTrackJobTableMetaResponseBody.TableMetaList.Columns()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.columns = tmp
            }
            if dict.keys.contains("SchemaName") {
                self.schemaName = dict["SchemaName"] as! String
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tableMetaList: [GetDataTrackJobTableMetaResponseBody.TableMetaList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tableMetaList != nil {
            var tmp : [Any] = []
            for k in self.tableMetaList! {
                tmp.append(k.toMap())
            }
            map["TableMetaList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TableMetaList") {
            var tmp : [GetDataTrackJobTableMetaResponseBody.TableMetaList] = []
            for v in dict["TableMetaList"] as! [Any] {
                var model = GetDataTrackJobTableMetaResponseBody.TableMetaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tableMetaList = tmp
        }
    }
}

public class GetDataTrackJobTableMetaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataTrackJobTableMetaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataTrackJobTableMetaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataTrackOrderDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataTrackOrderDetailResponseBody : Tea.TeaModel {
    public class DataTrackOrderDetail : Tea.TeaModel {
        public var databaseSearchName: String?

        public var dbId: Int64?

        public var jobEndTime: String?

        public var jobStartTime: String?

        public var jobStatus: String?

        public var logic: Bool?

        public var schemaName: String?

        public var statusDesc: String?

        public var tableNames: [String]?

        public var trackTypes: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseSearchName != nil {
                map["DatabaseSearchName"] = self.databaseSearchName!
            }
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.jobEndTime != nil {
                map["JobEndTime"] = self.jobEndTime!
            }
            if self.jobStartTime != nil {
                map["JobStartTime"] = self.jobStartTime!
            }
            if self.jobStatus != nil {
                map["JobStatus"] = self.jobStatus!
            }
            if self.logic != nil {
                map["Logic"] = self.logic!
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.tableNames != nil {
                map["TableNames"] = self.tableNames!
            }
            if self.trackTypes != nil {
                map["TrackTypes"] = self.trackTypes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DatabaseSearchName") {
                self.databaseSearchName = dict["DatabaseSearchName"] as! String
            }
            if dict.keys.contains("DbId") {
                self.dbId = dict["DbId"] as! Int64
            }
            if dict.keys.contains("JobEndTime") {
                self.jobEndTime = dict["JobEndTime"] as! String
            }
            if dict.keys.contains("JobStartTime") {
                self.jobStartTime = dict["JobStartTime"] as! String
            }
            if dict.keys.contains("JobStatus") {
                self.jobStatus = dict["JobStatus"] as! String
            }
            if dict.keys.contains("Logic") {
                self.logic = dict["Logic"] as! Bool
            }
            if dict.keys.contains("SchemaName") {
                self.schemaName = dict["SchemaName"] as! String
            }
            if dict.keys.contains("StatusDesc") {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("TableNames") {
                self.tableNames = dict["TableNames"] as! [String]
            }
            if dict.keys.contains("TrackTypes") {
                self.trackTypes = dict["TrackTypes"] as! [String]
            }
        }
    }
    public var dataTrackOrderDetail: GetDataTrackOrderDetailResponseBody.DataTrackOrderDetail?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataTrackOrderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataTrackOrderDetail != nil {
            map["DataTrackOrderDetail"] = self.dataTrackOrderDetail?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataTrackOrderDetail") {
            var model = GetDataTrackOrderDetailResponseBody.DataTrackOrderDetail()
            model.fromMap(dict["DataTrackOrderDetail"] as! [String: Any])
            self.dataTrackOrderDetail = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataTrackOrderDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataTrackOrderDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataTrackOrderDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDatabaseRequest : Tea.TeaModel {
    public var host: String?

    public var port: Int32?

    public var schemaName: String?

    public var sid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.sid != nil {
            map["Sid"] = self.sid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Host") {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("SchemaName") {
            self.schemaName = dict["SchemaName"] as! String
        }
        if dict.keys.contains("Sid") {
            self.sid = dict["Sid"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDatabaseResponseBody : Tea.TeaModel {
    public class Database : Tea.TeaModel {
        public class OwnerIdList : Tea.TeaModel {
            public var ownerIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ownerIds != nil {
                    map["OwnerIds"] = self.ownerIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OwnerIds") {
                    self.ownerIds = dict["OwnerIds"] as! [String]
                }
            }
        }
        public class OwnerNameList : Tea.TeaModel {
            public var ownerNames: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ownerNames != nil {
                    map["OwnerNames"] = self.ownerNames!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OwnerNames") {
                    self.ownerNames = dict["OwnerNames"] as! [String]
                }
            }
        }
        public var catalogName: String?

        public var databaseId: String?

        public var dbType: String?

        public var dbaId: String?

        public var dbaName: String?

        public var encoding: String?

        public var envType: String?

        public var host: String?

        public var instanceAlias: String?

        public var instanceId: String?

        public var ownerIdList: GetDatabaseResponseBody.Database.OwnerIdList?

        public var ownerNameList: GetDatabaseResponseBody.Database.OwnerNameList?

        public var port: Int32?

        public var schemaName: String?

        public var searchName: String?

        public var sid: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ownerIdList?.validate()
            try self.ownerNameList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.catalogName != nil {
                map["CatalogName"] = self.catalogName!
            }
            if self.databaseId != nil {
                map["DatabaseId"] = self.databaseId!
            }
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.dbaId != nil {
                map["DbaId"] = self.dbaId!
            }
            if self.dbaName != nil {
                map["DbaName"] = self.dbaName!
            }
            if self.encoding != nil {
                map["Encoding"] = self.encoding!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.instanceAlias != nil {
                map["InstanceAlias"] = self.instanceAlias!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.ownerIdList != nil {
                map["OwnerIdList"] = self.ownerIdList?.toMap()
            }
            if self.ownerNameList != nil {
                map["OwnerNameList"] = self.ownerNameList?.toMap()
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.searchName != nil {
                map["SearchName"] = self.searchName!
            }
            if self.sid != nil {
                map["Sid"] = self.sid!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CatalogName") {
                self.catalogName = dict["CatalogName"] as! String
            }
            if dict.keys.contains("DatabaseId") {
                self.databaseId = dict["DatabaseId"] as! String
            }
            if dict.keys.contains("DbType") {
                self.dbType = dict["DbType"] as! String
            }
            if dict.keys.contains("DbaId") {
                self.dbaId = dict["DbaId"] as! String
            }
            if dict.keys.contains("DbaName") {
                self.dbaName = dict["DbaName"] as! String
            }
            if dict.keys.contains("Encoding") {
                self.encoding = dict["Encoding"] as! String
            }
            if dict.keys.contains("EnvType") {
                self.envType = dict["EnvType"] as! String
            }
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("InstanceAlias") {
                self.instanceAlias = dict["InstanceAlias"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("OwnerIdList") {
                var model = GetDatabaseResponseBody.Database.OwnerIdList()
                model.fromMap(dict["OwnerIdList"] as! [String: Any])
                self.ownerIdList = model
            }
            if dict.keys.contains("OwnerNameList") {
                var model = GetDatabaseResponseBody.Database.OwnerNameList()
                model.fromMap(dict["OwnerNameList"] as! [String: Any])
                self.ownerNameList = model
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("SchemaName") {
                self.schemaName = dict["SchemaName"] as! String
            }
            if dict.keys.contains("SearchName") {
                self.searchName = dict["SearchName"] as! String
            }
            if dict.keys.contains("Sid") {
                self.sid = dict["Sid"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var database: GetDatabaseResponseBody.Database?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.database?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.database != nil {
            map["Database"] = self.database?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Database") {
            var model = GetDatabaseResponseBody.Database()
            model.fromMap(dict["Database"] as! [String: Any])
            self.database = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDatabaseExportOrderDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDatabaseExportOrderDetailResponseBody : Tea.TeaModel {
    public class DatabaseExportOrderDetail : Tea.TeaModel {
        public class KeyInfo : Tea.TeaModel {
            public class Config : Tea.TeaModel {
                public class ExportTypes : Tea.TeaModel {
                    public var exportTypes: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.exportTypes != nil {
                            map["ExportTypes"] = self.exportTypes!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ExportTypes") {
                            self.exportTypes = dict["ExportTypes"] as! [String]
                        }
                    }
                }
                public class SQLExtOption : Tea.TeaModel {
                    public var SQLExtOption: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.SQLExtOption != nil {
                            map["SQLExtOption"] = self.SQLExtOption!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("SQLExtOption") {
                            self.SQLExtOption = dict["SQLExtOption"] as! [String]
                        }
                    }
                }
                public class SelectedTables : Tea.TeaModel {
                    public var selectedTables: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.selectedTables != nil {
                            map["SelectedTables"] = self.selectedTables!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("SelectedTables") {
                            self.selectedTables = dict["SelectedTables"] as! [String]
                        }
                    }
                }
                public var dbName: String?

                public var exportContent: String?

                public var exportTypes: GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo.Config.ExportTypes?

                public var SQLExtOption: GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo.Config.SQLExtOption?

                public var selectedTables: GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo.Config.SelectedTables?

                public var targetOption: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.exportTypes?.validate()
                    try self.SQLExtOption?.validate()
                    try self.selectedTables?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dbName != nil {
                        map["DbName"] = self.dbName!
                    }
                    if self.exportContent != nil {
                        map["ExportContent"] = self.exportContent!
                    }
                    if self.exportTypes != nil {
                        map["ExportTypes"] = self.exportTypes?.toMap()
                    }
                    if self.SQLExtOption != nil {
                        map["SQLExtOption"] = self.SQLExtOption?.toMap()
                    }
                    if self.selectedTables != nil {
                        map["SelectedTables"] = self.selectedTables?.toMap()
                    }
                    if self.targetOption != nil {
                        map["TargetOption"] = self.targetOption!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DbName") {
                        self.dbName = dict["DbName"] as! String
                    }
                    if dict.keys.contains("ExportContent") {
                        self.exportContent = dict["ExportContent"] as! String
                    }
                    if dict.keys.contains("ExportTypes") {
                        var model = GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo.Config.ExportTypes()
                        model.fromMap(dict["ExportTypes"] as! [String: Any])
                        self.exportTypes = model
                    }
                    if dict.keys.contains("SQLExtOption") {
                        var model = GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo.Config.SQLExtOption()
                        model.fromMap(dict["SQLExtOption"] as! [String: Any])
                        self.SQLExtOption = model
                    }
                    if dict.keys.contains("SelectedTables") {
                        var model = GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo.Config.SelectedTables()
                        model.fromMap(dict["SelectedTables"] as! [String: Any])
                        self.selectedTables = model
                    }
                    if dict.keys.contains("TargetOption") {
                        self.targetOption = dict["TargetOption"] as! String
                    }
                }
            }
            public var auditDate: String?

            public var config: GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo.Config?

            public var dbId: Int64?

            public var downloadURL: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.config?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.auditDate != nil {
                    map["AuditDate"] = self.auditDate!
                }
                if self.config != nil {
                    map["Config"] = self.config?.toMap()
                }
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.downloadURL != nil {
                    map["DownloadURL"] = self.downloadURL!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuditDate") {
                    self.auditDate = dict["AuditDate"] as! String
                }
                if dict.keys.contains("Config") {
                    var model = GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo.Config()
                    model.fromMap(dict["Config"] as! [String: Any])
                    self.config = model
                }
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("DownloadURL") {
                    self.downloadURL = dict["DownloadURL"] as! String
                }
            }
        }
        public var comment: String?

        public var committer: String?

        public var committerId: String?

        public var id: Int64?

        public var keyInfo: GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo?

        public var log: String?

        public var searchName: String?

        public var statusDesc: String?

        public var workflowStatusDesc: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.keyInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.committer != nil {
                map["Committer"] = self.committer!
            }
            if self.committerId != nil {
                map["CommitterId"] = self.committerId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.keyInfo != nil {
                map["KeyInfo"] = self.keyInfo?.toMap()
            }
            if self.log != nil {
                map["Log"] = self.log!
            }
            if self.searchName != nil {
                map["SearchName"] = self.searchName!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.workflowStatusDesc != nil {
                map["WorkflowStatusDesc"] = self.workflowStatusDesc!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("Committer") {
                self.committer = dict["Committer"] as! String
            }
            if dict.keys.contains("CommitterId") {
                self.committerId = dict["CommitterId"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("KeyInfo") {
                var model = GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo()
                model.fromMap(dict["KeyInfo"] as! [String: Any])
                self.keyInfo = model
            }
            if dict.keys.contains("Log") {
                self.log = dict["Log"] as! String
            }
            if dict.keys.contains("SearchName") {
                self.searchName = dict["SearchName"] as! String
            }
            if dict.keys.contains("StatusDesc") {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("WorkflowStatusDesc") {
                self.workflowStatusDesc = dict["WorkflowStatusDesc"] as! String
            }
        }
    }
    public var databaseExportOrderDetail: GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.databaseExportOrderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseExportOrderDetail != nil {
            map["DatabaseExportOrderDetail"] = self.databaseExportOrderDetail?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseExportOrderDetail") {
            var model = GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail()
            model.fromMap(dict["DatabaseExportOrderDetail"] as! [String: Any])
            self.databaseExportOrderDetail = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDatabaseExportOrderDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDatabaseExportOrderDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDatabaseExportOrderDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDbExportDownloadURLRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDbExportDownloadURLResponseBody : Tea.TeaModel {
    public class DownloadURLResult : Tea.TeaModel {
        public var hasResult: Bool?

        public var tipMessage: String?

        public var URL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hasResult != nil {
                map["HasResult"] = self.hasResult!
            }
            if self.tipMessage != nil {
                map["TipMessage"] = self.tipMessage!
            }
            if self.URL != nil {
                map["URL"] = self.URL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HasResult") {
                self.hasResult = dict["HasResult"] as! Bool
            }
            if dict.keys.contains("TipMessage") {
                self.tipMessage = dict["TipMessage"] as! String
            }
            if dict.keys.contains("URL") {
                self.URL = dict["URL"] as! String
            }
        }
    }
    public var downloadURLResult: GetDbExportDownloadURLResponseBody.DownloadURLResult?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.downloadURLResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadURLResult != nil {
            map["DownloadURLResult"] = self.downloadURLResult?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadURLResult") {
            var model = GetDbExportDownloadURLResponseBody.DownloadURLResult()
            model.fromMap(dict["DownloadURLResult"] as! [String: Any])
            self.downloadURLResult = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDbExportDownloadURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDbExportDownloadURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDbExportDownloadURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceRequest : Tea.TeaModel {
    public var host: String?

    public var port: Int32?

    public var sid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.sid != nil {
            map["Sid"] = self.sid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Host") {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("Sid") {
            self.sid = dict["Sid"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetInstanceResponseBody : Tea.TeaModel {
    public class Instance : Tea.TeaModel {
        public class OwnerIdList : Tea.TeaModel {
            public var ownerIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ownerIds != nil {
                    map["OwnerIds"] = self.ownerIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OwnerIds") {
                    self.ownerIds = dict["OwnerIds"] as! [String]
                }
            }
        }
        public class OwnerNameList : Tea.TeaModel {
            public var ownerNames: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ownerNames != nil {
                    map["OwnerNames"] = self.ownerNames!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OwnerNames") {
                    self.ownerNames = dict["OwnerNames"] as! [String]
                }
            }
        }
        public class StandardGroup : Tea.TeaModel {
            public var groupMode: String?

            public var groupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupMode != nil {
                    map["GroupMode"] = self.groupMode!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupMode") {
                    self.groupMode = dict["GroupMode"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
            }
        }
        public var dataLinkName: String?

        public var databasePassword: String?

        public var databaseUser: String?

        public var dbaId: String?

        public var dbaNickName: String?

        public var ddlOnline: Int32?

        public var ecsInstanceId: String?

        public var ecsRegion: String?

        public var envType: String?

        public var exportTimeout: Int32?

        public var host: String?

        public var instanceAlias: String?

        public var instanceId: String?

        public var instanceSource: String?

        public var instanceType: String?

        public var ownerIdList: GetInstanceResponseBody.Instance.OwnerIdList?

        public var ownerNameList: GetInstanceResponseBody.Instance.OwnerNameList?

        public var port: Int32?

        public var queryTimeout: Int32?

        public var safeRuleId: String?

        public var sellSitd: String?

        public var sid: String?

        public var standardGroup: GetInstanceResponseBody.Instance.StandardGroup?

        public var state: String?

        public var useDsql: Int32?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ownerIdList?.validate()
            try self.ownerNameList?.validate()
            try self.standardGroup?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataLinkName != nil {
                map["DataLinkName"] = self.dataLinkName!
            }
            if self.databasePassword != nil {
                map["DatabasePassword"] = self.databasePassword!
            }
            if self.databaseUser != nil {
                map["DatabaseUser"] = self.databaseUser!
            }
            if self.dbaId != nil {
                map["DbaId"] = self.dbaId!
            }
            if self.dbaNickName != nil {
                map["DbaNickName"] = self.dbaNickName!
            }
            if self.ddlOnline != nil {
                map["DdlOnline"] = self.ddlOnline!
            }
            if self.ecsInstanceId != nil {
                map["EcsInstanceId"] = self.ecsInstanceId!
            }
            if self.ecsRegion != nil {
                map["EcsRegion"] = self.ecsRegion!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.exportTimeout != nil {
                map["ExportTimeout"] = self.exportTimeout!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.instanceAlias != nil {
                map["InstanceAlias"] = self.instanceAlias!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceSource != nil {
                map["InstanceSource"] = self.instanceSource!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.ownerIdList != nil {
                map["OwnerIdList"] = self.ownerIdList?.toMap()
            }
            if self.ownerNameList != nil {
                map["OwnerNameList"] = self.ownerNameList?.toMap()
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.queryTimeout != nil {
                map["QueryTimeout"] = self.queryTimeout!
            }
            if self.safeRuleId != nil {
                map["SafeRuleId"] = self.safeRuleId!
            }
            if self.sellSitd != nil {
                map["SellSitd"] = self.sellSitd!
            }
            if self.sid != nil {
                map["Sid"] = self.sid!
            }
            if self.standardGroup != nil {
                map["StandardGroup"] = self.standardGroup?.toMap()
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.useDsql != nil {
                map["UseDsql"] = self.useDsql!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataLinkName") {
                self.dataLinkName = dict["DataLinkName"] as! String
            }
            if dict.keys.contains("DatabasePassword") {
                self.databasePassword = dict["DatabasePassword"] as! String
            }
            if dict.keys.contains("DatabaseUser") {
                self.databaseUser = dict["DatabaseUser"] as! String
            }
            if dict.keys.contains("DbaId") {
                self.dbaId = dict["DbaId"] as! String
            }
            if dict.keys.contains("DbaNickName") {
                self.dbaNickName = dict["DbaNickName"] as! String
            }
            if dict.keys.contains("DdlOnline") {
                self.ddlOnline = dict["DdlOnline"] as! Int32
            }
            if dict.keys.contains("EcsInstanceId") {
                self.ecsInstanceId = dict["EcsInstanceId"] as! String
            }
            if dict.keys.contains("EcsRegion") {
                self.ecsRegion = dict["EcsRegion"] as! String
            }
            if dict.keys.contains("EnvType") {
                self.envType = dict["EnvType"] as! String
            }
            if dict.keys.contains("ExportTimeout") {
                self.exportTimeout = dict["ExportTimeout"] as! Int32
            }
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("InstanceAlias") {
                self.instanceAlias = dict["InstanceAlias"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceSource") {
                self.instanceSource = dict["InstanceSource"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("OwnerIdList") {
                var model = GetInstanceResponseBody.Instance.OwnerIdList()
                model.fromMap(dict["OwnerIdList"] as! [String: Any])
                self.ownerIdList = model
            }
            if dict.keys.contains("OwnerNameList") {
                var model = GetInstanceResponseBody.Instance.OwnerNameList()
                model.fromMap(dict["OwnerNameList"] as! [String: Any])
                self.ownerNameList = model
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("QueryTimeout") {
                self.queryTimeout = dict["QueryTimeout"] as! Int32
            }
            if dict.keys.contains("SafeRuleId") {
                self.safeRuleId = dict["SafeRuleId"] as! String
            }
            if dict.keys.contains("SellSitd") {
                self.sellSitd = dict["SellSitd"] as! String
            }
            if dict.keys.contains("Sid") {
                self.sid = dict["Sid"] as! String
            }
            if dict.keys.contains("StandardGroup") {
                var model = GetInstanceResponseBody.Instance.StandardGroup()
                model.fromMap(dict["StandardGroup"] as! [String: Any])
                self.standardGroup = model
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("UseDsql") {
                self.useDsql = dict["UseDsql"] as! Int32
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var instance: GetInstanceResponseBody.Instance?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.instance != nil {
            map["Instance"] = self.instance?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("Instance") {
            var model = GetInstanceResponseBody.Instance()
            model.fromMap(dict["Instance"] as! [String: Any])
            self.instance = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetIntervalLimitOfSLARequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetIntervalLimitOfSLAResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var intervalLimit: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.intervalLimit != nil {
            map["IntervalLimit"] = self.intervalLimit!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("IntervalLimit") {
            self.intervalLimit = dict["IntervalLimit"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetIntervalLimitOfSLAResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetIntervalLimitOfSLAResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetIntervalLimitOfSLAResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLhSpaceByNameRequest : Tea.TeaModel {
    public var spaceName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.spaceName != nil {
            map["SpaceName"] = self.spaceName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SpaceName") {
            self.spaceName = dict["SpaceName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetLhSpaceByNameResponseBody : Tea.TeaModel {
    public class LakehouseSpace : Tea.TeaModel {
        public var creatorId: String?

        public var description_: String?

        public var devDbId: Int32?

        public var dwDbType: String?

        public var id: Int64?

        public var isDeleted: Bool?

        public var mode: Int32?

        public var prodDbId: Int32?

        public var spaceConfig: String?

        public var spaceName: String?

        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.devDbId != nil {
                map["DevDbId"] = self.devDbId!
            }
            if self.dwDbType != nil {
                map["DwDbType"] = self.dwDbType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isDeleted != nil {
                map["IsDeleted"] = self.isDeleted!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.prodDbId != nil {
                map["ProdDbId"] = self.prodDbId!
            }
            if self.spaceConfig != nil {
                map["SpaceConfig"] = self.spaceConfig!
            }
            if self.spaceName != nil {
                map["SpaceName"] = self.spaceName!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DevDbId") {
                self.devDbId = dict["DevDbId"] as! Int32
            }
            if dict.keys.contains("DwDbType") {
                self.dwDbType = dict["DwDbType"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IsDeleted") {
                self.isDeleted = dict["IsDeleted"] as! Bool
            }
            if dict.keys.contains("Mode") {
                self.mode = dict["Mode"] as! Int32
            }
            if dict.keys.contains("ProdDbId") {
                self.prodDbId = dict["ProdDbId"] as! Int32
            }
            if dict.keys.contains("SpaceConfig") {
                self.spaceConfig = dict["SpaceConfig"] as! String
            }
            if dict.keys.contains("SpaceName") {
                self.spaceName = dict["SpaceName"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var lakehouseSpace: GetLhSpaceByNameResponseBody.LakehouseSpace?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lakehouseSpace?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.lakehouseSpace != nil {
            map["LakehouseSpace"] = self.lakehouseSpace?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("LakehouseSpace") {
            var model = GetLhSpaceByNameResponseBody.LakehouseSpace()
            model.fromMap(dict["LakehouseSpace"] as! [String: Any])
            self.lakehouseSpace = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetLhSpaceByNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLhSpaceByNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLhSpaceByNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLogicDatabaseRequest : Tea.TeaModel {
    public var dbId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetLogicDatabaseResponseBody : Tea.TeaModel {
    public class LogicDatabase : Tea.TeaModel {
        public class DatabaseIds : Tea.TeaModel {
            public var databaseIds: [Int64]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseIds != nil {
                    map["DatabaseIds"] = self.databaseIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DatabaseIds") {
                    self.databaseIds = dict["DatabaseIds"] as! [Int64]
                }
            }
        }
        public class OwnerIdList : Tea.TeaModel {
            public var ownerIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ownerIds != nil {
                    map["OwnerIds"] = self.ownerIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OwnerIds") {
                    self.ownerIds = dict["OwnerIds"] as! [String]
                }
            }
        }
        public class OwnerNameList : Tea.TeaModel {
            public var ownerNames: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ownerNames != nil {
                    map["OwnerNames"] = self.ownerNames!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OwnerNames") {
                    self.ownerNames = dict["OwnerNames"] as! [String]
                }
            }
        }
        public var alias: String?

        public var databaseId: String?

        public var databaseIds: GetLogicDatabaseResponseBody.LogicDatabase.DatabaseIds?

        public var dbType: String?

        public var envType: String?

        public var logic: Bool?

        public var ownerIdList: GetLogicDatabaseResponseBody.LogicDatabase.OwnerIdList?

        public var ownerNameList: GetLogicDatabaseResponseBody.LogicDatabase.OwnerNameList?

        public var schemaName: String?

        public var searchName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.databaseIds?.validate()
            try self.ownerIdList?.validate()
            try self.ownerNameList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alias != nil {
                map["Alias"] = self.alias!
            }
            if self.databaseId != nil {
                map["DatabaseId"] = self.databaseId!
            }
            if self.databaseIds != nil {
                map["DatabaseIds"] = self.databaseIds?.toMap()
            }
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.logic != nil {
                map["Logic"] = self.logic!
            }
            if self.ownerIdList != nil {
                map["OwnerIdList"] = self.ownerIdList?.toMap()
            }
            if self.ownerNameList != nil {
                map["OwnerNameList"] = self.ownerNameList?.toMap()
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.searchName != nil {
                map["SearchName"] = self.searchName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alias") {
                self.alias = dict["Alias"] as! String
            }
            if dict.keys.contains("DatabaseId") {
                self.databaseId = dict["DatabaseId"] as! String
            }
            if dict.keys.contains("DatabaseIds") {
                var model = GetLogicDatabaseResponseBody.LogicDatabase.DatabaseIds()
                model.fromMap(dict["DatabaseIds"] as! [String: Any])
                self.databaseIds = model
            }
            if dict.keys.contains("DbType") {
                self.dbType = dict["DbType"] as! String
            }
            if dict.keys.contains("EnvType") {
                self.envType = dict["EnvType"] as! String
            }
            if dict.keys.contains("Logic") {
                self.logic = dict["Logic"] as! Bool
            }
            if dict.keys.contains("OwnerIdList") {
                var model = GetLogicDatabaseResponseBody.LogicDatabase.OwnerIdList()
                model.fromMap(dict["OwnerIdList"] as! [String: Any])
                self.ownerIdList = model
            }
            if dict.keys.contains("OwnerNameList") {
                var model = GetLogicDatabaseResponseBody.LogicDatabase.OwnerNameList()
                model.fromMap(dict["OwnerNameList"] as! [String: Any])
                self.ownerNameList = model
            }
            if dict.keys.contains("SchemaName") {
                self.schemaName = dict["SchemaName"] as! String
            }
            if dict.keys.contains("SearchName") {
                self.searchName = dict["SearchName"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var logicDatabase: GetLogicDatabaseResponseBody.LogicDatabase?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logicDatabase?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.logicDatabase != nil {
            map["LogicDatabase"] = self.logicDatabase?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("LogicDatabase") {
            var model = GetLogicDatabaseResponseBody.LogicDatabase()
            model.fromMap(dict["LogicDatabase"] as! [String: Any])
            self.logicDatabase = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetLogicDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLogicDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLogicDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaTableColumnRequest : Tea.TeaModel {
    public var tableGuid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetMetaTableColumnResponseBody : Tea.TeaModel {
    public class ColumnList : Tea.TeaModel {
        public var autoIncrement: Bool?

        public var columnId: String?

        public var columnName: String?

        public var columnType: String?

        public var dataLength: Int64?

        public var dataPrecision: Int32?

        public var dataScale: Int32?

        public var description_: String?

        public var nullable: Bool?

        public var position: Int32?

        public var primaryKey: String?

        public var securityLevel: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoIncrement != nil {
                map["AutoIncrement"] = self.autoIncrement!
            }
            if self.columnId != nil {
                map["ColumnId"] = self.columnId!
            }
            if self.columnName != nil {
                map["ColumnName"] = self.columnName!
            }
            if self.columnType != nil {
                map["ColumnType"] = self.columnType!
            }
            if self.dataLength != nil {
                map["DataLength"] = self.dataLength!
            }
            if self.dataPrecision != nil {
                map["DataPrecision"] = self.dataPrecision!
            }
            if self.dataScale != nil {
                map["DataScale"] = self.dataScale!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.nullable != nil {
                map["Nullable"] = self.nullable!
            }
            if self.position != nil {
                map["Position"] = self.position!
            }
            if self.primaryKey != nil {
                map["PrimaryKey"] = self.primaryKey!
            }
            if self.securityLevel != nil {
                map["SecurityLevel"] = self.securityLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoIncrement") {
                self.autoIncrement = dict["AutoIncrement"] as! Bool
            }
            if dict.keys.contains("ColumnId") {
                self.columnId = dict["ColumnId"] as! String
            }
            if dict.keys.contains("ColumnName") {
                self.columnName = dict["ColumnName"] as! String
            }
            if dict.keys.contains("ColumnType") {
                self.columnType = dict["ColumnType"] as! String
            }
            if dict.keys.contains("DataLength") {
                self.dataLength = dict["DataLength"] as! Int64
            }
            if dict.keys.contains("DataPrecision") {
                self.dataPrecision = dict["DataPrecision"] as! Int32
            }
            if dict.keys.contains("DataScale") {
                self.dataScale = dict["DataScale"] as! Int32
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Nullable") {
                self.nullable = dict["Nullable"] as! Bool
            }
            if dict.keys.contains("Position") {
                self.position = dict["Position"] as! Int32
            }
            if dict.keys.contains("PrimaryKey") {
                self.primaryKey = dict["PrimaryKey"] as! String
            }
            if dict.keys.contains("SecurityLevel") {
                self.securityLevel = dict["SecurityLevel"] as! String
            }
        }
    }
    public var columnList: [GetMetaTableColumnResponseBody.ColumnList]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnList != nil {
            var tmp : [Any] = []
            for k in self.columnList! {
                tmp.append(k.toMap())
            }
            map["ColumnList"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnList") {
            var tmp : [GetMetaTableColumnResponseBody.ColumnList] = []
            for v in dict["ColumnList"] as! [Any] {
                var model = GetMetaTableColumnResponseBody.ColumnList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.columnList = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMetaTableColumnResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableColumnResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMetaTableColumnResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaTableDetailInfoRequest : Tea.TeaModel {
    public var tableGuid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetMetaTableDetailInfoResponseBody : Tea.TeaModel {
    public class DetailInfo : Tea.TeaModel {
        public class ColumnList : Tea.TeaModel {
            public var autoIncrement: Bool?

            public var columnId: String?

            public var columnName: String?

            public var columnType: String?

            public var dataLength: Int64?

            public var dataPrecision: Int32?

            public var dataScale: Int32?

            public var description_: String?

            public var nullable: Bool?

            public var position: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoIncrement != nil {
                    map["AutoIncrement"] = self.autoIncrement!
                }
                if self.columnId != nil {
                    map["ColumnId"] = self.columnId!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.columnType != nil {
                    map["ColumnType"] = self.columnType!
                }
                if self.dataLength != nil {
                    map["DataLength"] = self.dataLength!
                }
                if self.dataPrecision != nil {
                    map["DataPrecision"] = self.dataPrecision!
                }
                if self.dataScale != nil {
                    map["DataScale"] = self.dataScale!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.nullable != nil {
                    map["Nullable"] = self.nullable!
                }
                if self.position != nil {
                    map["Position"] = self.position!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoIncrement") {
                    self.autoIncrement = dict["AutoIncrement"] as! Bool
                }
                if dict.keys.contains("ColumnId") {
                    self.columnId = dict["ColumnId"] as! String
                }
                if dict.keys.contains("ColumnName") {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("ColumnType") {
                    self.columnType = dict["ColumnType"] as! String
                }
                if dict.keys.contains("DataLength") {
                    self.dataLength = dict["DataLength"] as! Int64
                }
                if dict.keys.contains("DataPrecision") {
                    self.dataPrecision = dict["DataPrecision"] as! Int32
                }
                if dict.keys.contains("DataScale") {
                    self.dataScale = dict["DataScale"] as! Int32
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Nullable") {
                    self.nullable = dict["Nullable"] as! Bool
                }
                if dict.keys.contains("Position") {
                    self.position = dict["Position"] as! String
                }
            }
        }
        public class IndexList : Tea.TeaModel {
            public var indexColumns: [String]?

            public var indexId: String?

            public var indexName: String?

            public var indexType: String?

            public var unique: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.indexColumns != nil {
                    map["IndexColumns"] = self.indexColumns!
                }
                if self.indexId != nil {
                    map["IndexId"] = self.indexId!
                }
                if self.indexName != nil {
                    map["IndexName"] = self.indexName!
                }
                if self.indexType != nil {
                    map["IndexType"] = self.indexType!
                }
                if self.unique != nil {
                    map["Unique"] = self.unique!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IndexColumns") {
                    self.indexColumns = dict["IndexColumns"] as! [String]
                }
                if dict.keys.contains("IndexId") {
                    self.indexId = dict["IndexId"] as! String
                }
                if dict.keys.contains("IndexName") {
                    self.indexName = dict["IndexName"] as! String
                }
                if dict.keys.contains("IndexType") {
                    self.indexType = dict["IndexType"] as! String
                }
                if dict.keys.contains("Unique") {
                    self.unique = dict["Unique"] as! Bool
                }
            }
        }
        public var columnList: [GetMetaTableDetailInfoResponseBody.DetailInfo.ColumnList]?

        public var indexList: [GetMetaTableDetailInfoResponseBody.DetailInfo.IndexList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columnList != nil {
                var tmp : [Any] = []
                for k in self.columnList! {
                    tmp.append(k.toMap())
                }
                map["ColumnList"] = tmp
            }
            if self.indexList != nil {
                var tmp : [Any] = []
                for k in self.indexList! {
                    tmp.append(k.toMap())
                }
                map["IndexList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ColumnList") {
                var tmp : [GetMetaTableDetailInfoResponseBody.DetailInfo.ColumnList] = []
                for v in dict["ColumnList"] as! [Any] {
                    var model = GetMetaTableDetailInfoResponseBody.DetailInfo.ColumnList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.columnList = tmp
            }
            if dict.keys.contains("IndexList") {
                var tmp : [GetMetaTableDetailInfoResponseBody.DetailInfo.IndexList] = []
                for v in dict["IndexList"] as! [Any] {
                    var model = GetMetaTableDetailInfoResponseBody.DetailInfo.IndexList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.indexList = tmp
            }
        }
    }
    public var detailInfo: GetMetaTableDetailInfoResponseBody.DetailInfo?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.detailInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.detailInfo != nil {
            map["DetailInfo"] = self.detailInfo?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DetailInfo") {
            var model = GetMetaTableDetailInfoResponseBody.DetailInfo()
            model.fromMap(dict["DetailInfo"] as! [String: Any])
            self.detailInfo = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMetaTableDetailInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableDetailInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMetaTableDetailInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOnlineDDLProgressRequest : Tea.TeaModel {
    public var jobDetailId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobDetailId != nil {
            map["JobDetailId"] = self.jobDetailId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobDetailId") {
            self.jobDetailId = dict["JobDetailId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetOnlineDDLProgressResponseBody : Tea.TeaModel {
    public class OnlineDDLTaskDetail : Tea.TeaModel {
        public var cleanStrategy: String?

        public var copyChunkMode: String?

        public var copyChunkSize: Int64?

        public var copyCount: Int64?

        public var copyTotal: Int64?

        public var cutoverFailRetryTimes: Int64?

        public var cutoverLockTimeSeconds: Int64?

        public var cutoverWindowEndTime: String?

        public var cutoverWindowStartTime: String?

        public var delaySeconds: Int64?

        public var jobStatus: String?

        public var progressRatio: String?

        public var statusDesc: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cleanStrategy != nil {
                map["CleanStrategy"] = self.cleanStrategy!
            }
            if self.copyChunkMode != nil {
                map["CopyChunkMode"] = self.copyChunkMode!
            }
            if self.copyChunkSize != nil {
                map["CopyChunkSize"] = self.copyChunkSize!
            }
            if self.copyCount != nil {
                map["CopyCount"] = self.copyCount!
            }
            if self.copyTotal != nil {
                map["CopyTotal"] = self.copyTotal!
            }
            if self.cutoverFailRetryTimes != nil {
                map["CutoverFailRetryTimes"] = self.cutoverFailRetryTimes!
            }
            if self.cutoverLockTimeSeconds != nil {
                map["CutoverLockTimeSeconds"] = self.cutoverLockTimeSeconds!
            }
            if self.cutoverWindowEndTime != nil {
                map["CutoverWindowEndTime"] = self.cutoverWindowEndTime!
            }
            if self.cutoverWindowStartTime != nil {
                map["CutoverWindowStartTime"] = self.cutoverWindowStartTime!
            }
            if self.delaySeconds != nil {
                map["DelaySeconds"] = self.delaySeconds!
            }
            if self.jobStatus != nil {
                map["JobStatus"] = self.jobStatus!
            }
            if self.progressRatio != nil {
                map["ProgressRatio"] = self.progressRatio!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CleanStrategy") {
                self.cleanStrategy = dict["CleanStrategy"] as! String
            }
            if dict.keys.contains("CopyChunkMode") {
                self.copyChunkMode = dict["CopyChunkMode"] as! String
            }
            if dict.keys.contains("CopyChunkSize") {
                self.copyChunkSize = dict["CopyChunkSize"] as! Int64
            }
            if dict.keys.contains("CopyCount") {
                self.copyCount = dict["CopyCount"] as! Int64
            }
            if dict.keys.contains("CopyTotal") {
                self.copyTotal = dict["CopyTotal"] as! Int64
            }
            if dict.keys.contains("CutoverFailRetryTimes") {
                self.cutoverFailRetryTimes = dict["CutoverFailRetryTimes"] as! Int64
            }
            if dict.keys.contains("CutoverLockTimeSeconds") {
                self.cutoverLockTimeSeconds = dict["CutoverLockTimeSeconds"] as! Int64
            }
            if dict.keys.contains("CutoverWindowEndTime") {
                self.cutoverWindowEndTime = dict["CutoverWindowEndTime"] as! String
            }
            if dict.keys.contains("CutoverWindowStartTime") {
                self.cutoverWindowStartTime = dict["CutoverWindowStartTime"] as! String
            }
            if dict.keys.contains("DelaySeconds") {
                self.delaySeconds = dict["DelaySeconds"] as! Int64
            }
            if dict.keys.contains("JobStatus") {
                self.jobStatus = dict["JobStatus"] as! String
            }
            if dict.keys.contains("ProgressRatio") {
                self.progressRatio = dict["ProgressRatio"] as! String
            }
            if dict.keys.contains("StatusDesc") {
                self.statusDesc = dict["StatusDesc"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var onlineDDLTaskDetail: GetOnlineDDLProgressResponseBody.OnlineDDLTaskDetail?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.onlineDDLTaskDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.onlineDDLTaskDetail != nil {
            map["OnlineDDLTaskDetail"] = self.onlineDDLTaskDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("OnlineDDLTaskDetail") {
            var model = GetOnlineDDLProgressResponseBody.OnlineDDLTaskDetail()
            model.fromMap(dict["OnlineDDLTaskDetail"] as! [String: Any])
            self.onlineDDLTaskDetail = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetOnlineDDLProgressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOnlineDDLProgressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOnlineDDLProgressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOpLogRequest : Tea.TeaModel {
    public var databaseName: String?

    public var endTime: String?

    public var module: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: String?

    public var tid: Int64?

    public var userNick: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.module != nil {
            map["Module"] = self.module!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userNick != nil {
            map["UserNick"] = self.userNick!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Module") {
            self.module = dict["Module"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserNick") {
            self.userNick = dict["UserNick"] as! String
        }
    }
}

public class GetOpLogResponseBody : Tea.TeaModel {
    public class OpLogDetails : Tea.TeaModel {
        public class OpLogDetail : Tea.TeaModel {
            public var database: String?

            public var module: String?

            public var opContent: String?

            public var opTime: String?

            public var opUserId: Int64?

            public var orderId: Int64?

            public var userId: String?

            public var userNick: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.database != nil {
                    map["Database"] = self.database!
                }
                if self.module != nil {
                    map["Module"] = self.module!
                }
                if self.opContent != nil {
                    map["OpContent"] = self.opContent!
                }
                if self.opTime != nil {
                    map["OpTime"] = self.opTime!
                }
                if self.opUserId != nil {
                    map["OpUserId"] = self.opUserId!
                }
                if self.orderId != nil {
                    map["OrderId"] = self.orderId!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userNick != nil {
                    map["UserNick"] = self.userNick!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Database") {
                    self.database = dict["Database"] as! String
                }
                if dict.keys.contains("Module") {
                    self.module = dict["Module"] as! String
                }
                if dict.keys.contains("OpContent") {
                    self.opContent = dict["OpContent"] as! String
                }
                if dict.keys.contains("OpTime") {
                    self.opTime = dict["OpTime"] as! String
                }
                if dict.keys.contains("OpUserId") {
                    self.opUserId = dict["OpUserId"] as! Int64
                }
                if dict.keys.contains("OrderId") {
                    self.orderId = dict["OrderId"] as! Int64
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserNick") {
                    self.userNick = dict["UserNick"] as! String
                }
            }
        }
        public var opLogDetail: [GetOpLogResponseBody.OpLogDetails.OpLogDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.opLogDetail != nil {
                var tmp : [Any] = []
                for k in self.opLogDetail! {
                    tmp.append(k.toMap())
                }
                map["OpLogDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OpLogDetail") {
                var tmp : [GetOpLogResponseBody.OpLogDetails.OpLogDetail] = []
                for v in dict["OpLogDetail"] as! [Any] {
                    var model = GetOpLogResponseBody.OpLogDetails.OpLogDetail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.opLogDetail = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var opLogDetails: GetOpLogResponseBody.OpLogDetails?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.opLogDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.opLogDetails != nil {
            map["OpLogDetails"] = self.opLogDetails?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("OpLogDetails") {
            var model = GetOpLogResponseBody.OpLogDetails()
            model.fromMap(dict["OpLogDetails"] as! [String: Any])
            self.opLogDetails = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class GetOpLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOpLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOpLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOrderAttachmentFileRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetOrderAttachmentFileResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var fileUrl: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("FileUrl") {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetOrderAttachmentFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOrderAttachmentFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOrderAttachmentFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOrderBaseInfoRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetOrderBaseInfoResponseBody : Tea.TeaModel {
    public class OrderBaseInfo : Tea.TeaModel {
        public class RelatedUserList : Tea.TeaModel {
            public var userIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.userIds != nil {
                    map["UserIds"] = self.userIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("UserIds") {
                    self.userIds = dict["UserIds"] as! [String]
                }
            }
        }
        public class RelatedUserNickList : Tea.TeaModel {
            public var userNicks: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.userNicks != nil {
                    map["UserNicks"] = self.userNicks!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("UserNicks") {
                    self.userNicks = dict["UserNicks"] as! [String]
                }
            }
        }
        public var attachmentKey: String?

        public var comment: String?

        public var committer: String?

        public var committerId: Int64?

        public var createTime: String?

        public var lastModifyTime: String?

        public var orderId: Int64?

        public var originAttachmentName: String?

        public var pluginType: String?

        public var relatedUserList: GetOrderBaseInfoResponseBody.OrderBaseInfo.RelatedUserList?

        public var relatedUserNickList: GetOrderBaseInfoResponseBody.OrderBaseInfo.RelatedUserNickList?

        public var statusCode: String?

        public var statusDesc: String?

        public var workflowInstanceId: Int64?

        public var workflowStatusDesc: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.relatedUserList?.validate()
            try self.relatedUserNickList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachmentKey != nil {
                map["AttachmentKey"] = self.attachmentKey!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.committer != nil {
                map["Committer"] = self.committer!
            }
            if self.committerId != nil {
                map["CommitterId"] = self.committerId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastModifyTime != nil {
                map["LastModifyTime"] = self.lastModifyTime!
            }
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            if self.originAttachmentName != nil {
                map["OriginAttachmentName"] = self.originAttachmentName!
            }
            if self.pluginType != nil {
                map["PluginType"] = self.pluginType!
            }
            if self.relatedUserList != nil {
                map["RelatedUserList"] = self.relatedUserList?.toMap()
            }
            if self.relatedUserNickList != nil {
                map["RelatedUserNickList"] = self.relatedUserNickList?.toMap()
            }
            if self.statusCode != nil {
                map["StatusCode"] = self.statusCode!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.workflowInstanceId != nil {
                map["WorkflowInstanceId"] = self.workflowInstanceId!
            }
            if self.workflowStatusDesc != nil {
                map["WorkflowStatusDesc"] = self.workflowStatusDesc!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachmentKey") {
                self.attachmentKey = dict["AttachmentKey"] as! String
            }
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("Committer") {
                self.committer = dict["Committer"] as! String
            }
            if dict.keys.contains("CommitterId") {
                self.committerId = dict["CommitterId"] as! Int64
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("LastModifyTime") {
                self.lastModifyTime = dict["LastModifyTime"] as! String
            }
            if dict.keys.contains("OrderId") {
                self.orderId = dict["OrderId"] as! Int64
            }
            if dict.keys.contains("OriginAttachmentName") {
                self.originAttachmentName = dict["OriginAttachmentName"] as! String
            }
            if dict.keys.contains("PluginType") {
                self.pluginType = dict["PluginType"] as! String
            }
            if dict.keys.contains("RelatedUserList") {
                var model = GetOrderBaseInfoResponseBody.OrderBaseInfo.RelatedUserList()
                model.fromMap(dict["RelatedUserList"] as! [String: Any])
                self.relatedUserList = model
            }
            if dict.keys.contains("RelatedUserNickList") {
                var model = GetOrderBaseInfoResponseBody.OrderBaseInfo.RelatedUserNickList()
                model.fromMap(dict["RelatedUserNickList"] as! [String: Any])
                self.relatedUserNickList = model
            }
            if dict.keys.contains("StatusCode") {
                self.statusCode = dict["StatusCode"] as! String
            }
            if dict.keys.contains("StatusDesc") {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("WorkflowInstanceId") {
                self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
            }
            if dict.keys.contains("WorkflowStatusDesc") {
                self.workflowStatusDesc = dict["WorkflowStatusDesc"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var orderBaseInfo: GetOrderBaseInfoResponseBody.OrderBaseInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.orderBaseInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.orderBaseInfo != nil {
            map["OrderBaseInfo"] = self.orderBaseInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("OrderBaseInfo") {
            var model = GetOrderBaseInfoResponseBody.OrderBaseInfo()
            model.fromMap(dict["OrderBaseInfo"] as! [String: Any])
            self.orderBaseInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetOrderBaseInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOrderBaseInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOrderBaseInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOwnerApplyOrderDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetOwnerApplyOrderDetailResponseBody : Tea.TeaModel {
    public class OwnerApplyOrderDetail : Tea.TeaModel {
        public class Resources : Tea.TeaModel {
            public class ResourceDetail : Tea.TeaModel {
                public var dbType: String?

                public var envType: String?

                public var ownerIds: [Int64]?

                public var ownerNickNames: [String]?

                public var searchName: String?

                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dbType != nil {
                        map["DbType"] = self.dbType!
                    }
                    if self.envType != nil {
                        map["EnvType"] = self.envType!
                    }
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    if self.ownerNickNames != nil {
                        map["OwnerNickNames"] = self.ownerNickNames!
                    }
                    if self.searchName != nil {
                        map["SearchName"] = self.searchName!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DbType") {
                        self.dbType = dict["DbType"] as! String
                    }
                    if dict.keys.contains("EnvType") {
                        self.envType = dict["EnvType"] as! String
                    }
                    if dict.keys.contains("OwnerIds") {
                        self.ownerIds = dict["OwnerIds"] as! [Int64]
                    }
                    if dict.keys.contains("OwnerNickNames") {
                        self.ownerNickNames = dict["OwnerNickNames"] as! [String]
                    }
                    if dict.keys.contains("SearchName") {
                        self.searchName = dict["SearchName"] as! String
                    }
                    if dict.keys.contains("TableName") {
                        self.tableName = dict["TableName"] as! String
                    }
                }
            }
            public var logic: Bool?

            public var resourceDetail: GetOwnerApplyOrderDetailResponseBody.OwnerApplyOrderDetail.Resources.ResourceDetail?

            public var targetId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.resourceDetail?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.resourceDetail != nil {
                    map["ResourceDetail"] = self.resourceDetail?.toMap()
                }
                if self.targetId != nil {
                    map["TargetId"] = self.targetId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("ResourceDetail") {
                    var model = GetOwnerApplyOrderDetailResponseBody.OwnerApplyOrderDetail.Resources.ResourceDetail()
                    model.fromMap(dict["ResourceDetail"] as! [String: Any])
                    self.resourceDetail = model
                }
                if dict.keys.contains("TargetId") {
                    self.targetId = dict["TargetId"] as! String
                }
            }
        }
        public var applyType: String?

        public var resources: [GetOwnerApplyOrderDetailResponseBody.OwnerApplyOrderDetail.Resources]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applyType != nil {
                map["ApplyType"] = self.applyType!
            }
            if self.resources != nil {
                var tmp : [Any] = []
                for k in self.resources! {
                    tmp.append(k.toMap())
                }
                map["Resources"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplyType") {
                self.applyType = dict["ApplyType"] as! String
            }
            if dict.keys.contains("Resources") {
                var tmp : [GetOwnerApplyOrderDetailResponseBody.OwnerApplyOrderDetail.Resources] = []
                for v in dict["Resources"] as! [Any] {
                    var model = GetOwnerApplyOrderDetailResponseBody.OwnerApplyOrderDetail.Resources()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resources = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var ownerApplyOrderDetail: GetOwnerApplyOrderDetailResponseBody.OwnerApplyOrderDetail?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ownerApplyOrderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.ownerApplyOrderDetail != nil {
            map["OwnerApplyOrderDetail"] = self.ownerApplyOrderDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("OwnerApplyOrderDetail") {
            var model = GetOwnerApplyOrderDetailResponseBody.OwnerApplyOrderDetail()
            model.fromMap(dict["OwnerApplyOrderDetail"] as! [String: Any])
            self.ownerApplyOrderDetail = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetOwnerApplyOrderDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOwnerApplyOrderDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOwnerApplyOrderDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPagedInstanceRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetPagedInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public var businessTime: String?

            public var checkStatus: Int64?

            public var dagId: Int64?

            public var delete: String?

            public var endTime: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var historyDagId: Int64?

            public var id: Int64?

            public var lastRunningContext: String?

            public var msg: String?

            public var status: Int64?

            public var taskType: Int64?

            public var tenantId: String?

            public var triggerType: Int64?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessTime != nil {
                    map["BusinessTime"] = self.businessTime!
                }
                if self.checkStatus != nil {
                    map["CheckStatus"] = self.checkStatus!
                }
                if self.dagId != nil {
                    map["DagId"] = self.dagId!
                }
                if self.delete != nil {
                    map["Delete"] = self.delete!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.historyDagId != nil {
                    map["HistoryDagId"] = self.historyDagId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.lastRunningContext != nil {
                    map["LastRunningContext"] = self.lastRunningContext!
                }
                if self.msg != nil {
                    map["Msg"] = self.msg!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.triggerType != nil {
                    map["TriggerType"] = self.triggerType!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessTime") {
                    self.businessTime = dict["BusinessTime"] as! String
                }
                if dict.keys.contains("CheckStatus") {
                    self.checkStatus = dict["CheckStatus"] as! Int64
                }
                if dict.keys.contains("DagId") {
                    self.dagId = dict["DagId"] as! Int64
                }
                if dict.keys.contains("Delete") {
                    self.delete = dict["Delete"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("HistoryDagId") {
                    self.historyDagId = dict["HistoryDagId"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("LastRunningContext") {
                    self.lastRunningContext = dict["LastRunningContext"] as! String
                }
                if dict.keys.contains("Msg") {
                    self.msg = dict["Msg"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int64
                }
                if dict.keys.contains("TaskType") {
                    self.taskType = dict["TaskType"] as! Int64
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! String
                }
                if dict.keys.contains("TriggerType") {
                    self.triggerType = dict["TriggerType"] as! Int64
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var instance: [GetPagedInstanceResponseBody.Data.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Instance") {
                var tmp : [GetPagedInstanceResponseBody.Data.Instance] = []
                for v in dict["Instance"] as! [Any] {
                    var model = GetPagedInstanceResponseBody.Data.Instance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instance = tmp
            }
        }
    }
    public var data: GetPagedInstanceResponseBody.Data?

    public var errorCode: String?

    public var errorMessage: String?

    public var pageIndex: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var success: Bool?

    public var total: Int64?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetPagedInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("PageIndex") {
            self.pageIndex = dict["PageIndex"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class GetPagedInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPagedInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPagedInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPermApplyOrderDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetPermApplyOrderDetailResponseBody : Tea.TeaModel {
    public class PermApplyOrderDetail : Tea.TeaModel {
        public class Resources : Tea.TeaModel {
            public class ColumnInfo : Tea.TeaModel {
                public var columnName: String?

                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.columnName != nil {
                        map["ColumnName"] = self.columnName!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ColumnName") {
                        self.columnName = dict["ColumnName"] as! String
                    }
                    if dict.keys.contains("TableName") {
                        self.tableName = dict["TableName"] as! String
                    }
                }
            }
            public class DatabaseInfo : Tea.TeaModel {
                public var dbId: Int64?

                public var dbType: String?

                public var envType: String?

                public var logic: Bool?

                public var ownerIds: [Int64]?

                public var ownerNickNames: [String]?

                public var searchName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dbId != nil {
                        map["DbId"] = self.dbId!
                    }
                    if self.dbType != nil {
                        map["DbType"] = self.dbType!
                    }
                    if self.envType != nil {
                        map["EnvType"] = self.envType!
                    }
                    if self.logic != nil {
                        map["Logic"] = self.logic!
                    }
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    if self.ownerNickNames != nil {
                        map["OwnerNickNames"] = self.ownerNickNames!
                    }
                    if self.searchName != nil {
                        map["SearchName"] = self.searchName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DbId") {
                        self.dbId = dict["DbId"] as! Int64
                    }
                    if dict.keys.contains("DbType") {
                        self.dbType = dict["DbType"] as! String
                    }
                    if dict.keys.contains("EnvType") {
                        self.envType = dict["EnvType"] as! String
                    }
                    if dict.keys.contains("Logic") {
                        self.logic = dict["Logic"] as! Bool
                    }
                    if dict.keys.contains("OwnerIds") {
                        self.ownerIds = dict["OwnerIds"] as! [Int64]
                    }
                    if dict.keys.contains("OwnerNickNames") {
                        self.ownerNickNames = dict["OwnerNickNames"] as! [String]
                    }
                    if dict.keys.contains("SearchName") {
                        self.searchName = dict["SearchName"] as! String
                    }
                }
            }
            public class InstanceInfo : Tea.TeaModel {
                public var dbType: String?

                public var dbaId: Int64?

                public var dbaNickName: String?

                public var envType: String?

                public var host: String?

                public var instanceId: String?

                public var ownerIds: [Int64]?

                public var ownerNickName: [String]?

                public var port: Int64?

                public var searchName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dbType != nil {
                        map["DbType"] = self.dbType!
                    }
                    if self.dbaId != nil {
                        map["DbaId"] = self.dbaId!
                    }
                    if self.dbaNickName != nil {
                        map["DbaNickName"] = self.dbaNickName!
                    }
                    if self.envType != nil {
                        map["EnvType"] = self.envType!
                    }
                    if self.host != nil {
                        map["Host"] = self.host!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    if self.ownerNickName != nil {
                        map["OwnerNickName"] = self.ownerNickName!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.searchName != nil {
                        map["SearchName"] = self.searchName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DbType") {
                        self.dbType = dict["DbType"] as! String
                    }
                    if dict.keys.contains("DbaId") {
                        self.dbaId = dict["DbaId"] as! Int64
                    }
                    if dict.keys.contains("DbaNickName") {
                        self.dbaNickName = dict["DbaNickName"] as! String
                    }
                    if dict.keys.contains("EnvType") {
                        self.envType = dict["EnvType"] as! String
                    }
                    if dict.keys.contains("Host") {
                        self.host = dict["Host"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("OwnerIds") {
                        self.ownerIds = dict["OwnerIds"] as! [Int64]
                    }
                    if dict.keys.contains("OwnerNickName") {
                        self.ownerNickName = dict["OwnerNickName"] as! [String]
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! Int64
                    }
                    if dict.keys.contains("SearchName") {
                        self.searchName = dict["SearchName"] as! String
                    }
                }
            }
            public class TableInfo : Tea.TeaModel {
                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TableName") {
                        self.tableName = dict["TableName"] as! String
                    }
                }
            }
            public var columnInfo: GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources.ColumnInfo?

            public var databaseInfo: GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources.DatabaseInfo?

            public var instanceInfo: GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources.InstanceInfo?

            public var tableInfo: GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources.TableInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.columnInfo?.validate()
                try self.databaseInfo?.validate()
                try self.instanceInfo?.validate()
                try self.tableInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columnInfo != nil {
                    map["ColumnInfo"] = self.columnInfo?.toMap()
                }
                if self.databaseInfo != nil {
                    map["DatabaseInfo"] = self.databaseInfo?.toMap()
                }
                if self.instanceInfo != nil {
                    map["InstanceInfo"] = self.instanceInfo?.toMap()
                }
                if self.tableInfo != nil {
                    map["TableInfo"] = self.tableInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColumnInfo") {
                    var model = GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources.ColumnInfo()
                    model.fromMap(dict["ColumnInfo"] as! [String: Any])
                    self.columnInfo = model
                }
                if dict.keys.contains("DatabaseInfo") {
                    var model = GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources.DatabaseInfo()
                    model.fromMap(dict["DatabaseInfo"] as! [String: Any])
                    self.databaseInfo = model
                }
                if dict.keys.contains("InstanceInfo") {
                    var model = GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources.InstanceInfo()
                    model.fromMap(dict["InstanceInfo"] as! [String: Any])
                    self.instanceInfo = model
                }
                if dict.keys.contains("TableInfo") {
                    var model = GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources.TableInfo()
                    model.fromMap(dict["TableInfo"] as! [String: Any])
                    self.tableInfo = model
                }
            }
        }
        public var applyType: String?

        public var permType: Int64?

        public var resources: [GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources]?

        public var seconds: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applyType != nil {
                map["ApplyType"] = self.applyType!
            }
            if self.permType != nil {
                map["PermType"] = self.permType!
            }
            if self.resources != nil {
                var tmp : [Any] = []
                for k in self.resources! {
                    tmp.append(k.toMap())
                }
                map["Resources"] = tmp
            }
            if self.seconds != nil {
                map["Seconds"] = self.seconds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplyType") {
                self.applyType = dict["ApplyType"] as! String
            }
            if dict.keys.contains("PermType") {
                self.permType = dict["PermType"] as! Int64
            }
            if dict.keys.contains("Resources") {
                var tmp : [GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources] = []
                for v in dict["Resources"] as! [Any] {
                    var model = GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resources = tmp
            }
            if dict.keys.contains("Seconds") {
                self.seconds = dict["Seconds"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var permApplyOrderDetail: GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.permApplyOrderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.permApplyOrderDetail != nil {
            map["PermApplyOrderDetail"] = self.permApplyOrderDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("PermApplyOrderDetail") {
            var model = GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail()
            model.fromMap(dict["PermApplyOrderDetail"] as! [String: Any])
            self.permApplyOrderDetail = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetPermApplyOrderDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPermApplyOrderDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPermApplyOrderDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPhysicalDatabaseRequest : Tea.TeaModel {
    public var dbId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetPhysicalDatabaseResponseBody : Tea.TeaModel {
    public class Database : Tea.TeaModel {
        public class OwnerIdList : Tea.TeaModel {
            public var ownerIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ownerIds != nil {
                    map["OwnerIds"] = self.ownerIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OwnerIds") {
                    self.ownerIds = dict["OwnerIds"] as! [String]
                }
            }
        }
        public class OwnerNameList : Tea.TeaModel {
            public var ownerNames: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ownerNames != nil {
                    map["OwnerNames"] = self.ownerNames!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OwnerNames") {
                    self.ownerNames = dict["OwnerNames"] as! [String]
                }
            }
        }
        public var catalogName: String?

        public var databaseId: String?

        public var dbType: String?

        public var dbaId: String?

        public var dbaName: String?

        public var encoding: String?

        public var envType: String?

        public var host: String?

        public var instanceAlias: String?

        public var instanceId: String?

        public var ownerIdList: GetPhysicalDatabaseResponseBody.Database.OwnerIdList?

        public var ownerNameList: GetPhysicalDatabaseResponseBody.Database.OwnerNameList?

        public var port: Int32?

        public var schemaName: String?

        public var searchName: String?

        public var sid: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ownerIdList?.validate()
            try self.ownerNameList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.catalogName != nil {
                map["CatalogName"] = self.catalogName!
            }
            if self.databaseId != nil {
                map["DatabaseId"] = self.databaseId!
            }
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.dbaId != nil {
                map["DbaId"] = self.dbaId!
            }
            if self.dbaName != nil {
                map["DbaName"] = self.dbaName!
            }
            if self.encoding != nil {
                map["Encoding"] = self.encoding!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.instanceAlias != nil {
                map["InstanceAlias"] = self.instanceAlias!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.ownerIdList != nil {
                map["OwnerIdList"] = self.ownerIdList?.toMap()
            }
            if self.ownerNameList != nil {
                map["OwnerNameList"] = self.ownerNameList?.toMap()
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.searchName != nil {
                map["SearchName"] = self.searchName!
            }
            if self.sid != nil {
                map["Sid"] = self.sid!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CatalogName") {
                self.catalogName = dict["CatalogName"] as! String
            }
            if dict.keys.contains("DatabaseId") {
                self.databaseId = dict["DatabaseId"] as! String
            }
            if dict.keys.contains("DbType") {
                self.dbType = dict["DbType"] as! String
            }
            if dict.keys.contains("DbaId") {
                self.dbaId = dict["DbaId"] as! String
            }
            if dict.keys.contains("DbaName") {
                self.dbaName = dict["DbaName"] as! String
            }
            if dict.keys.contains("Encoding") {
                self.encoding = dict["Encoding"] as! String
            }
            if dict.keys.contains("EnvType") {
                self.envType = dict["EnvType"] as! String
            }
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("InstanceAlias") {
                self.instanceAlias = dict["InstanceAlias"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("OwnerIdList") {
                var model = GetPhysicalDatabaseResponseBody.Database.OwnerIdList()
                model.fromMap(dict["OwnerIdList"] as! [String: Any])
                self.ownerIdList = model
            }
            if dict.keys.contains("OwnerNameList") {
                var model = GetPhysicalDatabaseResponseBody.Database.OwnerNameList()
                model.fromMap(dict["OwnerNameList"] as! [String: Any])
                self.ownerNameList = model
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("SchemaName") {
                self.schemaName = dict["SchemaName"] as! String
            }
            if dict.keys.contains("SearchName") {
                self.searchName = dict["SearchName"] as! String
            }
            if dict.keys.contains("Sid") {
                self.sid = dict["Sid"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var database: GetPhysicalDatabaseResponseBody.Database?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.database?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.database != nil {
            map["Database"] = self.database?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Database") {
            var model = GetPhysicalDatabaseResponseBody.Database()
            model.fromMap(dict["Database"] as! [String: Any])
            self.database = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetPhysicalDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPhysicalDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPhysicalDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProxyRequest : Tea.TeaModel {
    public var proxyId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.proxyId != nil {
            map["ProxyId"] = self.proxyId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProxyId") {
            self.proxyId = dict["ProxyId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetProxyResponseBody : Tea.TeaModel {
    public var creatorId: Int64?

    public var creatorName: String?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpsPort: Int32?

    public var instanceId: Int64?

    public var privateEnable: Bool?

    public var privateHost: String?

    public var protocolPort: Int32?

    public var protocolType: String?

    public var proxyId: Int64?

    public var publicEnable: Bool?

    public var publicHost: String?

    public var regionId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creatorId != nil {
            map["CreatorId"] = self.creatorId!
        }
        if self.creatorName != nil {
            map["CreatorName"] = self.creatorName!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpsPort != nil {
            map["HttpsPort"] = self.httpsPort!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.privateEnable != nil {
            map["PrivateEnable"] = self.privateEnable!
        }
        if self.privateHost != nil {
            map["PrivateHost"] = self.privateHost!
        }
        if self.protocolPort != nil {
            map["ProtocolPort"] = self.protocolPort!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.proxyId != nil {
            map["ProxyId"] = self.proxyId!
        }
        if self.publicEnable != nil {
            map["PublicEnable"] = self.publicEnable!
        }
        if self.publicHost != nil {
            map["PublicHost"] = self.publicHost!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreatorId") {
            self.creatorId = dict["CreatorId"] as! Int64
        }
        if dict.keys.contains("CreatorName") {
            self.creatorName = dict["CreatorName"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpsPort") {
            self.httpsPort = dict["HttpsPort"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("PrivateEnable") {
            self.privateEnable = dict["PrivateEnable"] as! Bool
        }
        if dict.keys.contains("PrivateHost") {
            self.privateHost = dict["PrivateHost"] as! String
        }
        if dict.keys.contains("ProtocolPort") {
            self.protocolPort = dict["ProtocolPort"] as! Int32
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("ProxyId") {
            self.proxyId = dict["ProxyId"] as! Int64
        }
        if dict.keys.contains("PublicEnable") {
            self.publicEnable = dict["PublicEnable"] as! Bool
        }
        if dict.keys.contains("PublicHost") {
            self.publicHost = dict["PublicHost"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetProxyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProxyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetProxyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProxyAccessRequest : Tea.TeaModel {
    public var proxyAccessId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.proxyAccessId != nil {
            map["ProxyAccessId"] = self.proxyAccessId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProxyAccessId") {
            self.proxyAccessId = dict["ProxyAccessId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetProxyAccessResponseBody : Tea.TeaModel {
    public class ProxyAccess : Tea.TeaModel {
        public var accessId: String?

        public var gmtCreate: String?

        public var indepAccount: String?

        public var instanceId: Int64?

        public var originInfo: String?

        public var proxyAccessId: Int64?

        public var proxyId: Int64?

        public var userId: Int64?

        public var userName: String?

        public var userUid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessId != nil {
                map["AccessId"] = self.accessId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.indepAccount != nil {
                map["IndepAccount"] = self.indepAccount!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.originInfo != nil {
                map["OriginInfo"] = self.originInfo!
            }
            if self.proxyAccessId != nil {
                map["ProxyAccessId"] = self.proxyAccessId!
            }
            if self.proxyId != nil {
                map["ProxyId"] = self.proxyId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.userUid != nil {
                map["UserUid"] = self.userUid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessId") {
                self.accessId = dict["AccessId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("IndepAccount") {
                self.indepAccount = dict["IndepAccount"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("OriginInfo") {
                self.originInfo = dict["OriginInfo"] as! String
            }
            if dict.keys.contains("ProxyAccessId") {
                self.proxyAccessId = dict["ProxyAccessId"] as! Int64
            }
            if dict.keys.contains("ProxyId") {
                self.proxyId = dict["ProxyId"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! Int64
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("UserUid") {
                self.userUid = dict["UserUid"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var proxyAccess: GetProxyAccessResponseBody.ProxyAccess?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.proxyAccess?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.proxyAccess != nil {
            map["ProxyAccess"] = self.proxyAccess?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("ProxyAccess") {
            var model = GetProxyAccessResponseBody.ProxyAccess()
            model.fromMap(dict["ProxyAccess"] as! [String: Any])
            self.proxyAccess = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetProxyAccessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProxyAccessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetProxyAccessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRuleNumLimitOfSLARequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetRuleNumLimitOfSLAResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var ruleNumLimit: Int32?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleNumLimit != nil {
            map["RuleNumLimit"] = self.ruleNumLimit!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleNumLimit") {
            self.ruleNumLimit = dict["RuleNumLimit"] as! Int32
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetRuleNumLimitOfSLAResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRuleNumLimitOfSLAResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRuleNumLimitOfSLAResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSQLReviewCheckResultStatusRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetSQLReviewCheckResultStatusResponseBody : Tea.TeaModel {
    public class CheckResultStatus : Tea.TeaModel {
        public class CheckStatusResult : Tea.TeaModel {
            public var checkNotPass: Int64?

            public var checkPass: Int64?

            public var forceNotPass: Int64?

            public var forcePass: Int64?

            public var new: Int64?

            public var unknown: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkNotPass != nil {
                    map["CheckNotPass"] = self.checkNotPass!
                }
                if self.checkPass != nil {
                    map["CheckPass"] = self.checkPass!
                }
                if self.forceNotPass != nil {
                    map["ForceNotPass"] = self.forceNotPass!
                }
                if self.forcePass != nil {
                    map["ForcePass"] = self.forcePass!
                }
                if self.new != nil {
                    map["New"] = self.new!
                }
                if self.unknown != nil {
                    map["Unknown"] = self.unknown!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CheckNotPass") {
                    self.checkNotPass = dict["CheckNotPass"] as! Int64
                }
                if dict.keys.contains("CheckPass") {
                    self.checkPass = dict["CheckPass"] as! Int64
                }
                if dict.keys.contains("ForceNotPass") {
                    self.forceNotPass = dict["ForceNotPass"] as! Int64
                }
                if dict.keys.contains("ForcePass") {
                    self.forcePass = dict["ForcePass"] as! Int64
                }
                if dict.keys.contains("New") {
                    self.new = dict["New"] as! Int64
                }
                if dict.keys.contains("Unknown") {
                    self.unknown = dict["Unknown"] as! Int64
                }
            }
        }
        public class SQLReviewResult : Tea.TeaModel {
            public var mustImprove: Int64?

            public var potentialIssue: Int64?

            public var suggestImprove: Int64?

            public var tableIndexSuggest: Int64?

            public var useDmsDmlUnlock: Int64?

            public var useDmsToolkit: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mustImprove != nil {
                    map["MustImprove"] = self.mustImprove!
                }
                if self.potentialIssue != nil {
                    map["PotentialIssue"] = self.potentialIssue!
                }
                if self.suggestImprove != nil {
                    map["SuggestImprove"] = self.suggestImprove!
                }
                if self.tableIndexSuggest != nil {
                    map["TableIndexSuggest"] = self.tableIndexSuggest!
                }
                if self.useDmsDmlUnlock != nil {
                    map["UseDmsDmlUnlock"] = self.useDmsDmlUnlock!
                }
                if self.useDmsToolkit != nil {
                    map["UseDmsToolkit"] = self.useDmsToolkit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MustImprove") {
                    self.mustImprove = dict["MustImprove"] as! Int64
                }
                if dict.keys.contains("PotentialIssue") {
                    self.potentialIssue = dict["PotentialIssue"] as! Int64
                }
                if dict.keys.contains("SuggestImprove") {
                    self.suggestImprove = dict["SuggestImprove"] as! Int64
                }
                if dict.keys.contains("TableIndexSuggest") {
                    self.tableIndexSuggest = dict["TableIndexSuggest"] as! Int64
                }
                if dict.keys.contains("UseDmsDmlUnlock") {
                    self.useDmsDmlUnlock = dict["UseDmsDmlUnlock"] as! Int64
                }
                if dict.keys.contains("UseDmsToolkit") {
                    self.useDmsToolkit = dict["UseDmsToolkit"] as! Int64
                }
            }
        }
        public var checkStatusResult: GetSQLReviewCheckResultStatusResponseBody.CheckResultStatus.CheckStatusResult?

        public var checkedCount: Int64?

        public var SQLReviewResult: GetSQLReviewCheckResultStatusResponseBody.CheckResultStatus.SQLReviewResult?

        public var totalSQLCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkStatusResult?.validate()
            try self.SQLReviewResult?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkStatusResult != nil {
                map["CheckStatusResult"] = self.checkStatusResult?.toMap()
            }
            if self.checkedCount != nil {
                map["CheckedCount"] = self.checkedCount!
            }
            if self.SQLReviewResult != nil {
                map["SQLReviewResult"] = self.SQLReviewResult?.toMap()
            }
            if self.totalSQLCount != nil {
                map["TotalSQLCount"] = self.totalSQLCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckStatusResult") {
                var model = GetSQLReviewCheckResultStatusResponseBody.CheckResultStatus.CheckStatusResult()
                model.fromMap(dict["CheckStatusResult"] as! [String: Any])
                self.checkStatusResult = model
            }
            if dict.keys.contains("CheckedCount") {
                self.checkedCount = dict["CheckedCount"] as! Int64
            }
            if dict.keys.contains("SQLReviewResult") {
                var model = GetSQLReviewCheckResultStatusResponseBody.CheckResultStatus.SQLReviewResult()
                model.fromMap(dict["SQLReviewResult"] as! [String: Any])
                self.SQLReviewResult = model
            }
            if dict.keys.contains("TotalSQLCount") {
                self.totalSQLCount = dict["TotalSQLCount"] as! Int64
            }
        }
    }
    public var checkResultStatus: GetSQLReviewCheckResultStatusResponseBody.CheckResultStatus?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.checkResultStatus?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkResultStatus != nil {
            map["CheckResultStatus"] = self.checkResultStatus?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckResultStatus") {
            var model = GetSQLReviewCheckResultStatusResponseBody.CheckResultStatus()
            model.fromMap(dict["CheckResultStatus"] as! [String: Any])
            self.checkResultStatus = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetSQLReviewCheckResultStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSQLReviewCheckResultStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSQLReviewCheckResultStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSQLReviewOptimizeDetailRequest : Tea.TeaModel {
    public var SQLReviewQueryKey: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.SQLReviewQueryKey != nil {
            map["SQLReviewQueryKey"] = self.SQLReviewQueryKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SQLReviewQueryKey") {
            self.SQLReviewQueryKey = dict["SQLReviewQueryKey"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetSQLReviewOptimizeDetailResponseBody : Tea.TeaModel {
    public class OptimizeDetail : Tea.TeaModel {
        public class QualityResult : Tea.TeaModel {
            public class Results : Tea.TeaModel {
                public class Scripts : Tea.TeaModel {
                    public var content: String?

                    public var opType: String?

                    public var tableName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.opType != nil {
                            map["OpType"] = self.opType!
                        }
                        if self.tableName != nil {
                            map["TableName"] = self.tableName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Content") {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("OpType") {
                            self.opType = dict["OpType"] as! String
                        }
                        if dict.keys.contains("TableName") {
                            self.tableName = dict["TableName"] as! String
                        }
                    }
                }
                public var comments: String?

                public var feedback: String?

                public var messages: [String]?

                public var ruleName: String?

                public var ruleType: String?

                public var scripts: [GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail.QualityResult.Results.Scripts]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.comments != nil {
                        map["Comments"] = self.comments!
                    }
                    if self.feedback != nil {
                        map["Feedback"] = self.feedback!
                    }
                    if self.messages != nil {
                        map["Messages"] = self.messages!
                    }
                    if self.ruleName != nil {
                        map["RuleName"] = self.ruleName!
                    }
                    if self.ruleType != nil {
                        map["RuleType"] = self.ruleType!
                    }
                    if self.scripts != nil {
                        var tmp : [Any] = []
                        for k in self.scripts! {
                            tmp.append(k.toMap())
                        }
                        map["Scripts"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Comments") {
                        self.comments = dict["Comments"] as! String
                    }
                    if dict.keys.contains("Feedback") {
                        self.feedback = dict["Feedback"] as! String
                    }
                    if dict.keys.contains("Messages") {
                        self.messages = dict["Messages"] as! [String]
                    }
                    if dict.keys.contains("RuleName") {
                        self.ruleName = dict["RuleName"] as! String
                    }
                    if dict.keys.contains("RuleType") {
                        self.ruleType = dict["RuleType"] as! String
                    }
                    if dict.keys.contains("Scripts") {
                        var tmp : [GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail.QualityResult.Results.Scripts] = []
                        for v in dict["Scripts"] as! [Any] {
                            var model = GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail.QualityResult.Results.Scripts()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.scripts = tmp
                    }
                }
            }
            public var errorMessage: String?

            public var occurError: Bool?

            public var results: [GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail.QualityResult.Results]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.occurError != nil {
                    map["OccurError"] = self.occurError!
                }
                if self.results != nil {
                    var tmp : [Any] = []
                    for k in self.results! {
                        tmp.append(k.toMap())
                    }
                    map["Results"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("OccurError") {
                    self.occurError = dict["OccurError"] as! Bool
                }
                if dict.keys.contains("Results") {
                    var tmp : [GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail.QualityResult.Results] = []
                    for v in dict["Results"] as! [Any] {
                        var model = GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail.QualityResult.Results()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.results = tmp
                }
            }
        }
        public var dbId: Int32?

        public var instanceId: Int32?

        public var qualityResult: GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail.QualityResult?

        public var queryKey: String?

        public var sqlType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.qualityResult?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.qualityResult != nil {
                map["QualityResult"] = self.qualityResult?.toMap()
            }
            if self.queryKey != nil {
                map["QueryKey"] = self.queryKey!
            }
            if self.sqlType != nil {
                map["SqlType"] = self.sqlType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbId") {
                self.dbId = dict["DbId"] as! Int32
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int32
            }
            if dict.keys.contains("QualityResult") {
                var model = GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail.QualityResult()
                model.fromMap(dict["QualityResult"] as! [String: Any])
                self.qualityResult = model
            }
            if dict.keys.contains("QueryKey") {
                self.queryKey = dict["QueryKey"] as! String
            }
            if dict.keys.contains("SqlType") {
                self.sqlType = dict["SqlType"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var optimizeDetail: GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.optimizeDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.optimizeDetail != nil {
            map["OptimizeDetail"] = self.optimizeDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("OptimizeDetail") {
            var model = GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail()
            model.fromMap(dict["OptimizeDetail"] as! [String: Any])
            self.optimizeDetail = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetSQLReviewOptimizeDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSQLReviewOptimizeDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSQLReviewOptimizeDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetStandardGroupRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetStandardGroupResponseBody : Tea.TeaModel {
    public class StandardGroup : Tea.TeaModel {
        public var dbType: String?

        public var description_: String?

        public var groupId: Int64?

        public var groupMode: String?

        public var groupName: String?

        public var lastMenderId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupMode != nil {
                map["GroupMode"] = self.groupMode!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.lastMenderId != nil {
                map["LastMenderId"] = self.lastMenderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbType") {
                self.dbType = dict["DbType"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! Int64
            }
            if dict.keys.contains("GroupMode") {
                self.groupMode = dict["GroupMode"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("LastMenderId") {
                self.lastMenderId = dict["LastMenderId"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var standardGroup: GetStandardGroupResponseBody.StandardGroup?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.standardGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.standardGroup != nil {
            map["StandardGroup"] = self.standardGroup?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StandardGroup") {
            var model = GetStandardGroupResponseBody.StandardGroup()
            model.fromMap(dict["StandardGroup"] as! [String: Any])
            self.standardGroup = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetStandardGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetStandardGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetStandardGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetStructSyncExecSqlDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetStructSyncExecSqlDetailResponseBody : Tea.TeaModel {
    public class StructSyncExecSqlDetail : Tea.TeaModel {
        public var execSql: String?

        public var totalSqlCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.execSql != nil {
                map["ExecSql"] = self.execSql!
            }
            if self.totalSqlCount != nil {
                map["TotalSqlCount"] = self.totalSqlCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExecSql") {
                self.execSql = dict["ExecSql"] as! String
            }
            if dict.keys.contains("TotalSqlCount") {
                self.totalSqlCount = dict["TotalSqlCount"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var structSyncExecSqlDetail: GetStructSyncExecSqlDetailResponseBody.StructSyncExecSqlDetail?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.structSyncExecSqlDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.structSyncExecSqlDetail != nil {
            map["StructSyncExecSqlDetail"] = self.structSyncExecSqlDetail?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StructSyncExecSqlDetail") {
            var model = GetStructSyncExecSqlDetailResponseBody.StructSyncExecSqlDetail()
            model.fromMap(dict["StructSyncExecSqlDetail"] as! [String: Any])
            self.structSyncExecSqlDetail = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetStructSyncExecSqlDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetStructSyncExecSqlDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetStructSyncExecSqlDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetStructSyncJobAnalyzeResultRequest : Tea.TeaModel {
    public var compareType: String?

    public var orderId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compareType != nil {
            map["CompareType"] = self.compareType!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CompareType") {
            self.compareType = dict["CompareType"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetStructSyncJobAnalyzeResultResponseBody : Tea.TeaModel {
    public class StructSyncJobAnalyzeResult : Tea.TeaModel {
        public class ResultList : Tea.TeaModel {
            public var script: String?

            public var sourceTableName: String?

            public var targetTableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.script != nil {
                    map["Script"] = self.script!
                }
                if self.sourceTableName != nil {
                    map["SourceTableName"] = self.sourceTableName!
                }
                if self.targetTableName != nil {
                    map["TargetTableName"] = self.targetTableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Script") {
                    self.script = dict["Script"] as! String
                }
                if dict.keys.contains("SourceTableName") {
                    self.sourceTableName = dict["SourceTableName"] as! String
                }
                if dict.keys.contains("TargetTableName") {
                    self.targetTableName = dict["TargetTableName"] as! String
                }
            }
        }
        public class SummaryList : Tea.TeaModel {
            public var compareType: String?

            public var count: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.compareType != nil {
                    map["CompareType"] = self.compareType!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CompareType") {
                    self.compareType = dict["CompareType"] as! String
                }
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
            }
        }
        public var resultList: [GetStructSyncJobAnalyzeResultResponseBody.StructSyncJobAnalyzeResult.ResultList]?

        public var summaryList: [GetStructSyncJobAnalyzeResultResponseBody.StructSyncJobAnalyzeResult.SummaryList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resultList != nil {
                var tmp : [Any] = []
                for k in self.resultList! {
                    tmp.append(k.toMap())
                }
                map["ResultList"] = tmp
            }
            if self.summaryList != nil {
                var tmp : [Any] = []
                for k in self.summaryList! {
                    tmp.append(k.toMap())
                }
                map["SummaryList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResultList") {
                var tmp : [GetStructSyncJobAnalyzeResultResponseBody.StructSyncJobAnalyzeResult.ResultList] = []
                for v in dict["ResultList"] as! [Any] {
                    var model = GetStructSyncJobAnalyzeResultResponseBody.StructSyncJobAnalyzeResult.ResultList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resultList = tmp
            }
            if dict.keys.contains("SummaryList") {
                var tmp : [GetStructSyncJobAnalyzeResultResponseBody.StructSyncJobAnalyzeResult.SummaryList] = []
                for v in dict["SummaryList"] as! [Any] {
                    var model = GetStructSyncJobAnalyzeResultResponseBody.StructSyncJobAnalyzeResult.SummaryList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.summaryList = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var structSyncJobAnalyzeResult: GetStructSyncJobAnalyzeResultResponseBody.StructSyncJobAnalyzeResult?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.structSyncJobAnalyzeResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.structSyncJobAnalyzeResult != nil {
            map["StructSyncJobAnalyzeResult"] = self.structSyncJobAnalyzeResult?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StructSyncJobAnalyzeResult") {
            var model = GetStructSyncJobAnalyzeResultResponseBody.StructSyncJobAnalyzeResult()
            model.fromMap(dict["StructSyncJobAnalyzeResult"] as! [String: Any])
            self.structSyncJobAnalyzeResult = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetStructSyncJobAnalyzeResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetStructSyncJobAnalyzeResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetStructSyncJobAnalyzeResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetStructSyncJobDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetStructSyncJobDetailResponseBody : Tea.TeaModel {
    public class StructSyncJobDetail : Tea.TeaModel {
        public var DBTaskGroupId: Int64?

        public var executeCount: Int64?

        public var jobStatus: String?

        public var message: String?

        public var securityRule: String?

        public var sqlCount: Int64?

        public var tableAnalyzed: Int64?

        public var tableCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBTaskGroupId != nil {
                map["DBTaskGroupId"] = self.DBTaskGroupId!
            }
            if self.executeCount != nil {
                map["ExecuteCount"] = self.executeCount!
            }
            if self.jobStatus != nil {
                map["JobStatus"] = self.jobStatus!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.securityRule != nil {
                map["SecurityRule"] = self.securityRule!
            }
            if self.sqlCount != nil {
                map["SqlCount"] = self.sqlCount!
            }
            if self.tableAnalyzed != nil {
                map["TableAnalyzed"] = self.tableAnalyzed!
            }
            if self.tableCount != nil {
                map["TableCount"] = self.tableCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DBTaskGroupId") {
                self.DBTaskGroupId = dict["DBTaskGroupId"] as! Int64
            }
            if dict.keys.contains("ExecuteCount") {
                self.executeCount = dict["ExecuteCount"] as! Int64
            }
            if dict.keys.contains("JobStatus") {
                self.jobStatus = dict["JobStatus"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("SecurityRule") {
                self.securityRule = dict["SecurityRule"] as! String
            }
            if dict.keys.contains("SqlCount") {
                self.sqlCount = dict["SqlCount"] as! Int64
            }
            if dict.keys.contains("TableAnalyzed") {
                self.tableAnalyzed = dict["TableAnalyzed"] as! Int64
            }
            if dict.keys.contains("TableCount") {
                self.tableCount = dict["TableCount"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var structSyncJobDetail: GetStructSyncJobDetailResponseBody.StructSyncJobDetail?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.structSyncJobDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.structSyncJobDetail != nil {
            map["StructSyncJobDetail"] = self.structSyncJobDetail?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StructSyncJobDetail") {
            var model = GetStructSyncJobDetailResponseBody.StructSyncJobDetail()
            model.fromMap(dict["StructSyncJobDetail"] as! [String: Any])
            self.structSyncJobDetail = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetStructSyncJobDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetStructSyncJobDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetStructSyncJobDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetStructSyncOrderDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetStructSyncOrderDetailResponseBody : Tea.TeaModel {
    public class StructSyncOrderDetail : Tea.TeaModel {
        public class SourceDatabaseInfo : Tea.TeaModel {
            public var dbId: Int64?

            public var dbType: String?

            public var envType: String?

            public var logic: Bool?

            public var searchName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("DbType") {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("EnvType") {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("SearchName") {
                    self.searchName = dict["SearchName"] as! String
                }
            }
        }
        public class SourceVersionInfo : Tea.TeaModel {
            public var versionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.versionId != nil {
                    map["VersionId"] = self.versionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("VersionId") {
                    self.versionId = dict["VersionId"] as! String
                }
            }
        }
        public class TableInfoList : Tea.TeaModel {
            public var sourceTableName: String?

            public var targetTableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sourceTableName != nil {
                    map["SourceTableName"] = self.sourceTableName!
                }
                if self.targetTableName != nil {
                    map["TargetTableName"] = self.targetTableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SourceTableName") {
                    self.sourceTableName = dict["SourceTableName"] as! String
                }
                if dict.keys.contains("TargetTableName") {
                    self.targetTableName = dict["TargetTableName"] as! String
                }
            }
        }
        public class TargetDatabaseInfo : Tea.TeaModel {
            public var dbId: Int64?

            public var dbType: String?

            public var envType: String?

            public var logic: Bool?

            public var searchName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("DbType") {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("EnvType") {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("SearchName") {
                    self.searchName = dict["SearchName"] as! String
                }
            }
        }
        public class TargetVersionInfo : Tea.TeaModel {
            public var versionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.versionId != nil {
                    map["VersionId"] = self.versionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("VersionId") {
                    self.versionId = dict["VersionId"] as! String
                }
            }
        }
        public var ignoreError: Bool?

        public var sourceDatabaseInfo: GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.SourceDatabaseInfo?

        public var sourceType: String?

        public var sourceVersionInfo: GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.SourceVersionInfo?

        public var tableInfoList: [GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.TableInfoList]?

        public var targetDatabaseInfo: GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.TargetDatabaseInfo?

        public var targetType: String?

        public var targetVersionInfo: GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.TargetVersionInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sourceDatabaseInfo?.validate()
            try self.sourceVersionInfo?.validate()
            try self.targetDatabaseInfo?.validate()
            try self.targetVersionInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ignoreError != nil {
                map["IgnoreError"] = self.ignoreError!
            }
            if self.sourceDatabaseInfo != nil {
                map["SourceDatabaseInfo"] = self.sourceDatabaseInfo?.toMap()
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.sourceVersionInfo != nil {
                map["SourceVersionInfo"] = self.sourceVersionInfo?.toMap()
            }
            if self.tableInfoList != nil {
                var tmp : [Any] = []
                for k in self.tableInfoList! {
                    tmp.append(k.toMap())
                }
                map["TableInfoList"] = tmp
            }
            if self.targetDatabaseInfo != nil {
                map["TargetDatabaseInfo"] = self.targetDatabaseInfo?.toMap()
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            if self.targetVersionInfo != nil {
                map["TargetVersionInfo"] = self.targetVersionInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IgnoreError") {
                self.ignoreError = dict["IgnoreError"] as! Bool
            }
            if dict.keys.contains("SourceDatabaseInfo") {
                var model = GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.SourceDatabaseInfo()
                model.fromMap(dict["SourceDatabaseInfo"] as! [String: Any])
                self.sourceDatabaseInfo = model
            }
            if dict.keys.contains("SourceType") {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("SourceVersionInfo") {
                var model = GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.SourceVersionInfo()
                model.fromMap(dict["SourceVersionInfo"] as! [String: Any])
                self.sourceVersionInfo = model
            }
            if dict.keys.contains("TableInfoList") {
                var tmp : [GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.TableInfoList] = []
                for v in dict["TableInfoList"] as! [Any] {
                    var model = GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.TableInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tableInfoList = tmp
            }
            if dict.keys.contains("TargetDatabaseInfo") {
                var model = GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.TargetDatabaseInfo()
                model.fromMap(dict["TargetDatabaseInfo"] as! [String: Any])
                self.targetDatabaseInfo = model
            }
            if dict.keys.contains("TargetType") {
                self.targetType = dict["TargetType"] as! String
            }
            if dict.keys.contains("TargetVersionInfo") {
                var model = GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.TargetVersionInfo()
                model.fromMap(dict["TargetVersionInfo"] as! [String: Any])
                self.targetVersionInfo = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var structSyncOrderDetail: GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.structSyncOrderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.structSyncOrderDetail != nil {
            map["StructSyncOrderDetail"] = self.structSyncOrderDetail?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StructSyncOrderDetail") {
            var model = GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail()
            model.fromMap(dict["StructSyncOrderDetail"] as! [String: Any])
            self.structSyncOrderDetail = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetStructSyncOrderDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetStructSyncOrderDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetStructSyncOrderDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTableDBTopologyRequest : Tea.TeaModel {
    public var tableGuid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetTableDBTopologyResponseBody : Tea.TeaModel {
    public class DBTopology : Tea.TeaModel {
        public class DataSourceList : Tea.TeaModel {
            public class DatabaseList : Tea.TeaModel {
                public class TableList : Tea.TeaModel {
                    public var tableId: String?

                    public var tableName: String?

                    public var tableType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tableId != nil {
                            map["TableId"] = self.tableId!
                        }
                        if self.tableName != nil {
                            map["TableName"] = self.tableName!
                        }
                        if self.tableType != nil {
                            map["TableType"] = self.tableType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TableId") {
                            self.tableId = dict["TableId"] as! String
                        }
                        if dict.keys.contains("TableName") {
                            self.tableName = dict["TableName"] as! String
                        }
                        if dict.keys.contains("TableType") {
                            self.tableType = dict["TableType"] as! String
                        }
                    }
                }
                public var dbId: String?

                public var dbName: String?

                public var dbType: String?

                public var envType: String?

                public var tableList: [GetTableDBTopologyResponseBody.DBTopology.DataSourceList.DatabaseList.TableList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dbId != nil {
                        map["DbId"] = self.dbId!
                    }
                    if self.dbName != nil {
                        map["DbName"] = self.dbName!
                    }
                    if self.dbType != nil {
                        map["DbType"] = self.dbType!
                    }
                    if self.envType != nil {
                        map["EnvType"] = self.envType!
                    }
                    if self.tableList != nil {
                        var tmp : [Any] = []
                        for k in self.tableList! {
                            tmp.append(k.toMap())
                        }
                        map["TableList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DbId") {
                        self.dbId = dict["DbId"] as! String
                    }
                    if dict.keys.contains("DbName") {
                        self.dbName = dict["DbName"] as! String
                    }
                    if dict.keys.contains("DbType") {
                        self.dbType = dict["DbType"] as! String
                    }
                    if dict.keys.contains("EnvType") {
                        self.envType = dict["EnvType"] as! String
                    }
                    if dict.keys.contains("TableList") {
                        var tmp : [GetTableDBTopologyResponseBody.DBTopology.DataSourceList.DatabaseList.TableList] = []
                        for v in dict["TableList"] as! [Any] {
                            var model = GetTableDBTopologyResponseBody.DBTopology.DataSourceList.DatabaseList.TableList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tableList = tmp
                    }
                }
            }
            public var databaseList: [GetTableDBTopologyResponseBody.DBTopology.DataSourceList.DatabaseList]?

            public var dbType: String?

            public var host: String?

            public var port: Int32?

            public var sid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseList != nil {
                    var tmp : [Any] = []
                    for k in self.databaseList! {
                        tmp.append(k.toMap())
                    }
                    map["DatabaseList"] = tmp
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.sid != nil {
                    map["Sid"] = self.sid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DatabaseList") {
                    var tmp : [GetTableDBTopologyResponseBody.DBTopology.DataSourceList.DatabaseList] = []
                    for v in dict["DatabaseList"] as! [Any] {
                        var model = GetTableDBTopologyResponseBody.DBTopology.DataSourceList.DatabaseList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.databaseList = tmp
                }
                if dict.keys.contains("DbType") {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Sid") {
                    self.sid = dict["Sid"] as! String
                }
            }
        }
        public var dataSourceList: [GetTableDBTopologyResponseBody.DBTopology.DataSourceList]?

        public var tableGuid: String?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSourceList != nil {
                var tmp : [Any] = []
                for k in self.dataSourceList! {
                    tmp.append(k.toMap())
                }
                map["DataSourceList"] = tmp
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataSourceList") {
                var tmp : [GetTableDBTopologyResponseBody.DBTopology.DataSourceList] = []
                for v in dict["DataSourceList"] as! [Any] {
                    var model = GetTableDBTopologyResponseBody.DBTopology.DataSourceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataSourceList = tmp
            }
            if dict.keys.contains("TableGuid") {
                self.tableGuid = dict["TableGuid"] as! String
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
        }
    }
    public var DBTopology: GetTableDBTopologyResponseBody.DBTopology?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DBTopology?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBTopology != nil {
            map["DBTopology"] = self.DBTopology?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBTopology") {
            var model = GetTableDBTopologyResponseBody.DBTopology()
            model.fromMap(dict["DBTopology"] as! [String: Any])
            self.DBTopology = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetTableDBTopologyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTableDBTopologyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTableDBTopologyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTableDesignProjectFlowRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetTableDesignProjectFlowResponseBody : Tea.TeaModel {
    public class ProjectFlow : Tea.TeaModel {
        public class FlowNodeArray : Tea.TeaModel {
            public var backToDesign: Bool?

            public var canSkip: Bool?

            public var nodeRole: String?

            public var nodeTitle: String?

            public var position: Int32?

            public var publishAnchor: Bool?

            public var publishStrategies: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.backToDesign != nil {
                    map["BackToDesign"] = self.backToDesign!
                }
                if self.canSkip != nil {
                    map["CanSkip"] = self.canSkip!
                }
                if self.nodeRole != nil {
                    map["NodeRole"] = self.nodeRole!
                }
                if self.nodeTitle != nil {
                    map["NodeTitle"] = self.nodeTitle!
                }
                if self.position != nil {
                    map["Position"] = self.position!
                }
                if self.publishAnchor != nil {
                    map["PublishAnchor"] = self.publishAnchor!
                }
                if self.publishStrategies != nil {
                    map["PublishStrategies"] = self.publishStrategies!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BackToDesign") {
                    self.backToDesign = dict["BackToDesign"] as! Bool
                }
                if dict.keys.contains("CanSkip") {
                    self.canSkip = dict["CanSkip"] as! Bool
                }
                if dict.keys.contains("NodeRole") {
                    self.nodeRole = dict["NodeRole"] as! String
                }
                if dict.keys.contains("NodeTitle") {
                    self.nodeTitle = dict["NodeTitle"] as! String
                }
                if dict.keys.contains("Position") {
                    self.position = dict["Position"] as! Int32
                }
                if dict.keys.contains("PublishAnchor") {
                    self.publishAnchor = dict["PublishAnchor"] as! Bool
                }
                if dict.keys.contains("PublishStrategies") {
                    self.publishStrategies = dict["PublishStrategies"] as! [String]
                }
            }
        }
        public var currentPosition: Int32?

        public var flowNodeArray: [GetTableDesignProjectFlowResponseBody.ProjectFlow.FlowNodeArray]?

        public var ruleComment: String?

        public var ruleName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPosition != nil {
                map["CurrentPosition"] = self.currentPosition!
            }
            if self.flowNodeArray != nil {
                var tmp : [Any] = []
                for k in self.flowNodeArray! {
                    tmp.append(k.toMap())
                }
                map["FlowNodeArray"] = tmp
            }
            if self.ruleComment != nil {
                map["RuleComment"] = self.ruleComment!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPosition") {
                self.currentPosition = dict["CurrentPosition"] as! Int32
            }
            if dict.keys.contains("FlowNodeArray") {
                var tmp : [GetTableDesignProjectFlowResponseBody.ProjectFlow.FlowNodeArray] = []
                for v in dict["FlowNodeArray"] as! [Any] {
                    var model = GetTableDesignProjectFlowResponseBody.ProjectFlow.FlowNodeArray()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.flowNodeArray = tmp
            }
            if dict.keys.contains("RuleComment") {
                self.ruleComment = dict["RuleComment"] as! String
            }
            if dict.keys.contains("RuleName") {
                self.ruleName = dict["RuleName"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var projectFlow: GetTableDesignProjectFlowResponseBody.ProjectFlow?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.projectFlow?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.projectFlow != nil {
            map["ProjectFlow"] = self.projectFlow?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("ProjectFlow") {
            var model = GetTableDesignProjectFlowResponseBody.ProjectFlow()
            model.fromMap(dict["ProjectFlow"] as! [String: Any])
            self.projectFlow = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetTableDesignProjectFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTableDesignProjectFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTableDesignProjectFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTableDesignProjectInfoRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetTableDesignProjectInfoResponseBody : Tea.TeaModel {
    public class ProjectInfo : Tea.TeaModel {
        public class BaseDatabase : Tea.TeaModel {
            public var alias: String?

            public var dbId: Int32?

            public var dbType: String?

            public var envType: String?

            public var logic: Bool?

            public var schemaName: String?

            public var searchName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! Int32
                }
                if dict.keys.contains("DbType") {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("EnvType") {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("SchemaName") {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SearchName") {
                    self.searchName = dict["SearchName"] as! String
                }
            }
        }
        public var baseDatabase: GetTableDesignProjectInfoResponseBody.ProjectInfo.BaseDatabase?

        public var creatorId: Int64?

        public var description_: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var orderId: Int64?

        public var projectId: Int64?

        public var status: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.baseDatabase?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baseDatabase != nil {
                map["BaseDatabase"] = self.baseDatabase?.toMap()
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BaseDatabase") {
                var model = GetTableDesignProjectInfoResponseBody.ProjectInfo.BaseDatabase()
                model.fromMap(dict["BaseDatabase"] as! [String: Any])
                self.baseDatabase = model
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! Int64
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("OrderId") {
                self.orderId = dict["OrderId"] as! Int64
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var projectInfo: GetTableDesignProjectInfoResponseBody.ProjectInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.projectInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.projectInfo != nil {
            map["ProjectInfo"] = self.projectInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("ProjectInfo") {
            var model = GetTableDesignProjectInfoResponseBody.ProjectInfo()
            model.fromMap(dict["ProjectInfo"] as! [String: Any])
            self.projectInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetTableDesignProjectInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTableDesignProjectInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTableDesignProjectInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTableTopologyRequest : Tea.TeaModel {
    public var tableGuid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetTableTopologyResponseBody : Tea.TeaModel {
    public class TableTopology : Tea.TeaModel {
        public class TableTopologyInfoList : Tea.TeaModel {
            public var dbId: Int64?

            public var dbName: String?

            public var dbSearchName: String?

            public var dbType: String?

            public var instanceId: Int64?

            public var instanceResourceId: String?

            public var instanceSource: String?

            public var regionId: String?

            public var tableCount: Int64?

            public var tableNameExpr: String?

            public var tableNameList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbName != nil {
                    map["DbName"] = self.dbName!
                }
                if self.dbSearchName != nil {
                    map["DbSearchName"] = self.dbSearchName!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceResourceId != nil {
                    map["InstanceResourceId"] = self.instanceResourceId!
                }
                if self.instanceSource != nil {
                    map["InstanceSource"] = self.instanceSource!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.tableCount != nil {
                    map["TableCount"] = self.tableCount!
                }
                if self.tableNameExpr != nil {
                    map["TableNameExpr"] = self.tableNameExpr!
                }
                if self.tableNameList != nil {
                    map["TableNameList"] = self.tableNameList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("DbName") {
                    self.dbName = dict["DbName"] as! String
                }
                if dict.keys.contains("DbSearchName") {
                    self.dbSearchName = dict["DbSearchName"] as! String
                }
                if dict.keys.contains("DbType") {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("InstanceResourceId") {
                    self.instanceResourceId = dict["InstanceResourceId"] as! String
                }
                if dict.keys.contains("InstanceSource") {
                    self.instanceSource = dict["InstanceSource"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("TableCount") {
                    self.tableCount = dict["TableCount"] as! Int64
                }
                if dict.keys.contains("TableNameExpr") {
                    self.tableNameExpr = dict["TableNameExpr"] as! String
                }
                if dict.keys.contains("TableNameList") {
                    self.tableNameList = dict["TableNameList"] as! String
                }
            }
        }
        public var logic: Bool?

        public var tableGuid: String?

        public var tableName: String?

        public var tableTopologyInfoList: [GetTableTopologyResponseBody.TableTopology.TableTopologyInfoList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logic != nil {
                map["Logic"] = self.logic!
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            if self.tableTopologyInfoList != nil {
                var tmp : [Any] = []
                for k in self.tableTopologyInfoList! {
                    tmp.append(k.toMap())
                }
                map["TableTopologyInfoList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Logic") {
                self.logic = dict["Logic"] as! Bool
            }
            if dict.keys.contains("TableGuid") {
                self.tableGuid = dict["TableGuid"] as! String
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
            if dict.keys.contains("TableTopologyInfoList") {
                var tmp : [GetTableTopologyResponseBody.TableTopology.TableTopologyInfoList] = []
                for v in dict["TableTopologyInfoList"] as! [Any] {
                    var model = GetTableTopologyResponseBody.TableTopology.TableTopologyInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tableTopologyInfoList = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tableTopology: GetTableTopologyResponseBody.TableTopology?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tableTopology?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tableTopology != nil {
            map["TableTopology"] = self.tableTopology?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TableTopology") {
            var model = GetTableTopologyResponseBody.TableTopology()
            model.fromMap(dict["TableTopology"] as! [String: Any])
            self.tableTopology = model
        }
    }
}

public class GetTableTopologyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTableTopologyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTableTopologyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTaskRequest : Tea.TeaModel {
    public var nodeId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetTaskResponseBody : Tea.TeaModel {
    public class Task : Tea.TeaModel {
        public var dagId: Int64?

        public var graphParam: String?

        public var nodeConfig: String?

        public var nodeContent: String?

        public var nodeName: String?

        public var nodeOutput: String?

        public var nodeType: String?

        public var timeVariables: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dagId != nil {
                map["DagId"] = self.dagId!
            }
            if self.graphParam != nil {
                map["GraphParam"] = self.graphParam!
            }
            if self.nodeConfig != nil {
                map["NodeConfig"] = self.nodeConfig!
            }
            if self.nodeContent != nil {
                map["NodeContent"] = self.nodeContent!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.nodeOutput != nil {
                map["NodeOutput"] = self.nodeOutput!
            }
            if self.nodeType != nil {
                map["NodeType"] = self.nodeType!
            }
            if self.timeVariables != nil {
                map["TimeVariables"] = self.timeVariables!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DagId") {
                self.dagId = dict["DagId"] as! Int64
            }
            if dict.keys.contains("GraphParam") {
                self.graphParam = dict["GraphParam"] as! String
            }
            if dict.keys.contains("NodeConfig") {
                self.nodeConfig = dict["NodeConfig"] as! String
            }
            if dict.keys.contains("NodeContent") {
                self.nodeContent = dict["NodeContent"] as! String
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("NodeOutput") {
                self.nodeOutput = dict["NodeOutput"] as! String
            }
            if dict.keys.contains("NodeType") {
                self.nodeType = dict["NodeType"] as! String
            }
            if dict.keys.contains("TimeVariables") {
                self.timeVariables = dict["TimeVariables"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var task: GetTaskResponseBody.Task?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.task?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.task != nil {
            map["Task"] = self.task?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Task") {
            var model = GetTaskResponseBody.Task()
            model.fromMap(dict["Task"] as! [String: Any])
            self.task = model
        }
    }
}

public class GetTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTaskFlowGraphRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetTaskFlowGraphResponseBody : Tea.TeaModel {
    public class TaskFlowGraph : Tea.TeaModel {
        public class Edges : Tea.TeaModel {
            public class Edge : Tea.TeaModel {
                public var dagId: Int64?

                public var id: Int64?

                public var nodeEnd: Int64?

                public var nodeFrom: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dagId != nil {
                        map["DagId"] = self.dagId!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.nodeEnd != nil {
                        map["NodeEnd"] = self.nodeEnd!
                    }
                    if self.nodeFrom != nil {
                        map["NodeFrom"] = self.nodeFrom!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DagId") {
                        self.dagId = dict["DagId"] as! Int64
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("NodeEnd") {
                        self.nodeEnd = dict["NodeEnd"] as! Int64
                    }
                    if dict.keys.contains("NodeFrom") {
                        self.nodeFrom = dict["NodeFrom"] as! Int64
                    }
                }
            }
            public var edge: [GetTaskFlowGraphResponseBody.TaskFlowGraph.Edges.Edge]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.edge != nil {
                    var tmp : [Any] = []
                    for k in self.edge! {
                        tmp.append(k.toMap())
                    }
                    map["Edge"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Edge") {
                    var tmp : [GetTaskFlowGraphResponseBody.TaskFlowGraph.Edges.Edge] = []
                    for v in dict["Edge"] as! [Any] {
                        var model = GetTaskFlowGraphResponseBody.TaskFlowGraph.Edges.Edge()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.edge = tmp
                }
            }
        }
        public class Nodes : Tea.TeaModel {
            public class Node : Tea.TeaModel {
                public var dagId: Int64?

                public var graphParam: String?

                public var nodeConfig: String?

                public var nodeContent: String?

                public var nodeId: Int64?

                public var nodeName: String?

                public var nodeType: Int64?

                public var timeVariables: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dagId != nil {
                        map["DagId"] = self.dagId!
                    }
                    if self.graphParam != nil {
                        map["GraphParam"] = self.graphParam!
                    }
                    if self.nodeConfig != nil {
                        map["NodeConfig"] = self.nodeConfig!
                    }
                    if self.nodeContent != nil {
                        map["NodeContent"] = self.nodeContent!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.nodeName != nil {
                        map["NodeName"] = self.nodeName!
                    }
                    if self.nodeType != nil {
                        map["NodeType"] = self.nodeType!
                    }
                    if self.timeVariables != nil {
                        map["TimeVariables"] = self.timeVariables!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DagId") {
                        self.dagId = dict["DagId"] as! Int64
                    }
                    if dict.keys.contains("GraphParam") {
                        self.graphParam = dict["GraphParam"] as! String
                    }
                    if dict.keys.contains("NodeConfig") {
                        self.nodeConfig = dict["NodeConfig"] as! String
                    }
                    if dict.keys.contains("NodeContent") {
                        self.nodeContent = dict["NodeContent"] as! String
                    }
                    if dict.keys.contains("NodeId") {
                        self.nodeId = dict["NodeId"] as! Int64
                    }
                    if dict.keys.contains("NodeName") {
                        self.nodeName = dict["NodeName"] as! String
                    }
                    if dict.keys.contains("NodeType") {
                        self.nodeType = dict["NodeType"] as! Int64
                    }
                    if dict.keys.contains("TimeVariables") {
                        self.timeVariables = dict["TimeVariables"] as! String
                    }
                }
            }
            public var node: [GetTaskFlowGraphResponseBody.TaskFlowGraph.Nodes.Node]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.node != nil {
                    var tmp : [Any] = []
                    for k in self.node! {
                        tmp.append(k.toMap())
                    }
                    map["Node"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Node") {
                    var tmp : [GetTaskFlowGraphResponseBody.TaskFlowGraph.Nodes.Node] = []
                    for v in dict["Node"] as! [Any] {
                        var model = GetTaskFlowGraphResponseBody.TaskFlowGraph.Nodes.Node()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.node = tmp
                }
            }
        }
        public var canEdit: Bool?

        public var dagName: String?

        public var edges: GetTaskFlowGraphResponseBody.TaskFlowGraph.Edges?

        public var nodes: GetTaskFlowGraphResponseBody.TaskFlowGraph.Nodes?

        public var status: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.edges?.validate()
            try self.nodes?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.canEdit != nil {
                map["CanEdit"] = self.canEdit!
            }
            if self.dagName != nil {
                map["DagName"] = self.dagName!
            }
            if self.edges != nil {
                map["Edges"] = self.edges?.toMap()
            }
            if self.nodes != nil {
                map["Nodes"] = self.nodes?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CanEdit") {
                self.canEdit = dict["CanEdit"] as! Bool
            }
            if dict.keys.contains("DagName") {
                self.dagName = dict["DagName"] as! String
            }
            if dict.keys.contains("Edges") {
                var model = GetTaskFlowGraphResponseBody.TaskFlowGraph.Edges()
                model.fromMap(dict["Edges"] as! [String: Any])
                self.edges = model
            }
            if dict.keys.contains("Nodes") {
                var model = GetTaskFlowGraphResponseBody.TaskFlowGraph.Nodes()
                model.fromMap(dict["Nodes"] as! [String: Any])
                self.nodes = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var taskFlowGraph: GetTaskFlowGraphResponseBody.TaskFlowGraph?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskFlowGraph?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskFlowGraph != nil {
            map["TaskFlowGraph"] = self.taskFlowGraph?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TaskFlowGraph") {
            var model = GetTaskFlowGraphResponseBody.TaskFlowGraph()
            model.fromMap(dict["TaskFlowGraph"] as! [String: Any])
            self.taskFlowGraph = model
        }
    }
}

public class GetTaskFlowGraphResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTaskFlowGraphResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTaskFlowGraphResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTaskFlowNotificationRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetTaskFlowNotificationResponseBody : Tea.TeaModel {
    public class Notification : Tea.TeaModel {
        public var dagNotificationFail: Bool?

        public var dagNotificationSla: Bool?

        public var dagNotificationSuccess: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dagNotificationFail != nil {
                map["DagNotificationFail"] = self.dagNotificationFail!
            }
            if self.dagNotificationSla != nil {
                map["DagNotificationSla"] = self.dagNotificationSla!
            }
            if self.dagNotificationSuccess != nil {
                map["DagNotificationSuccess"] = self.dagNotificationSuccess!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DagNotificationFail") {
                self.dagNotificationFail = dict["DagNotificationFail"] as! Bool
            }
            if dict.keys.contains("DagNotificationSla") {
                self.dagNotificationSla = dict["DagNotificationSla"] as! Bool
            }
            if dict.keys.contains("DagNotificationSuccess") {
                self.dagNotificationSuccess = dict["DagNotificationSuccess"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var notification: GetTaskFlowNotificationResponseBody.Notification?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notification?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.notification != nil {
            map["Notification"] = self.notification?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("Notification") {
            var model = GetTaskFlowNotificationResponseBody.Notification()
            model.fromMap(dict["Notification"] as! [String: Any])
            self.notification = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetTaskFlowNotificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTaskFlowNotificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTaskFlowNotificationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTaskInstanceRelationRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var dagInstanceId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.dagInstanceId != nil {
            map["DagInstanceId"] = self.dagInstanceId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("DagInstanceId") {
            self.dagInstanceId = dict["DagInstanceId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetTaskInstanceRelationResponseBody : Tea.TeaModel {
    public class NodeList : Tea.TeaModel {
        public class Node : Tea.TeaModel {
            public var businessTime: String?

            public var endTime: String?

            public var executeTime: Int64?

            public var id: Int64?

            public var message: String?

            public var nodeId: Int64?

            public var nodeName: String?

            public var nodeType: Int32?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessTime != nil {
                    map["BusinessTime"] = self.businessTime!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.executeTime != nil {
                    map["ExecuteTime"] = self.executeTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.nodeType != nil {
                    map["NodeType"] = self.nodeType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessTime") {
                    self.businessTime = dict["BusinessTime"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("ExecuteTime") {
                    self.executeTime = dict["ExecuteTime"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("NodeType") {
                    self.nodeType = dict["NodeType"] as! Int32
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public var node: [GetTaskInstanceRelationResponseBody.NodeList.Node]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.node != nil {
                var tmp : [Any] = []
                for k in self.node! {
                    tmp.append(k.toMap())
                }
                map["Node"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Node") {
                var tmp : [GetTaskInstanceRelationResponseBody.NodeList.Node] = []
                for v in dict["Node"] as! [Any] {
                    var model = GetTaskInstanceRelationResponseBody.NodeList.Node()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.node = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var nodeList: GetTaskInstanceRelationResponseBody.NodeList?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.nodeList != nil {
            map["NodeList"] = self.nodeList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("NodeList") {
            var model = GetTaskInstanceRelationResponseBody.NodeList()
            model.fromMap(dict["NodeList"] as! [String: Any])
            self.nodeList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetTaskInstanceRelationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTaskInstanceRelationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTaskInstanceRelationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserRequest : Tea.TeaModel {
    public var tid: Int64?

    public var uid: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("Uid") {
            self.uid = dict["Uid"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GetUserResponseBody : Tea.TeaModel {
    public class User : Tea.TeaModel {
        public class RoleIdList : Tea.TeaModel {
            public var roleIds: [Int32]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.roleIds != nil {
                    map["RoleIds"] = self.roleIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RoleIds") {
                    self.roleIds = dict["RoleIds"] as! [Int32]
                }
            }
        }
        public class RoleNameList : Tea.TeaModel {
            public var roleNames: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.roleNames != nil {
                    map["RoleNames"] = self.roleNames!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RoleNames") {
                    self.roleNames = dict["RoleNames"] as! [String]
                }
            }
        }
        public var curExecuteCount: Int64?

        public var curResultCount: Int64?

        public var dingRobot: String?

        public var email: String?

        public var lastLoginTime: String?

        public var maxExecuteCount: Int64?

        public var maxResultCount: Int64?

        public var mobile: String?

        public var nickName: String?

        public var notificationMode: String?

        public var parentUid: Int64?

        public var roleIdList: GetUserResponseBody.User.RoleIdList?

        public var roleNameList: GetUserResponseBody.User.RoleNameList?

        public var signatureMethod: String?

        public var state: String?

        public var uid: String?

        public var userId: String?

        public var webhook: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.roleIdList?.validate()
            try self.roleNameList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.curExecuteCount != nil {
                map["CurExecuteCount"] = self.curExecuteCount!
            }
            if self.curResultCount != nil {
                map["CurResultCount"] = self.curResultCount!
            }
            if self.dingRobot != nil {
                map["DingRobot"] = self.dingRobot!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.lastLoginTime != nil {
                map["LastLoginTime"] = self.lastLoginTime!
            }
            if self.maxExecuteCount != nil {
                map["MaxExecuteCount"] = self.maxExecuteCount!
            }
            if self.maxResultCount != nil {
                map["MaxResultCount"] = self.maxResultCount!
            }
            if self.mobile != nil {
                map["Mobile"] = self.mobile!
            }
            if self.nickName != nil {
                map["NickName"] = self.nickName!
            }
            if self.notificationMode != nil {
                map["NotificationMode"] = self.notificationMode!
            }
            if self.parentUid != nil {
                map["ParentUid"] = self.parentUid!
            }
            if self.roleIdList != nil {
                map["RoleIdList"] = self.roleIdList?.toMap()
            }
            if self.roleNameList != nil {
                map["RoleNameList"] = self.roleNameList?.toMap()
            }
            if self.signatureMethod != nil {
                map["SignatureMethod"] = self.signatureMethod!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.uid != nil {
                map["Uid"] = self.uid!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.webhook != nil {
                map["Webhook"] = self.webhook!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurExecuteCount") {
                self.curExecuteCount = dict["CurExecuteCount"] as! Int64
            }
            if dict.keys.contains("CurResultCount") {
                self.curResultCount = dict["CurResultCount"] as! Int64
            }
            if dict.keys.contains("DingRobot") {
                self.dingRobot = dict["DingRobot"] as! String
            }
            if dict.keys.contains("Email") {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("LastLoginTime") {
                self.lastLoginTime = dict["LastLoginTime"] as! String
            }
            if dict.keys.contains("MaxExecuteCount") {
                self.maxExecuteCount = dict["MaxExecuteCount"] as! Int64
            }
            if dict.keys.contains("MaxResultCount") {
                self.maxResultCount = dict["MaxResultCount"] as! Int64
            }
            if dict.keys.contains("Mobile") {
                self.mobile = dict["Mobile"] as! String
            }
            if dict.keys.contains("NickName") {
                self.nickName = dict["NickName"] as! String
            }
            if dict.keys.contains("NotificationMode") {
                self.notificationMode = dict["NotificationMode"] as! String
            }
            if dict.keys.contains("ParentUid") {
                self.parentUid = dict["ParentUid"] as! Int64
            }
            if dict.keys.contains("RoleIdList") {
                var model = GetUserResponseBody.User.RoleIdList()
                model.fromMap(dict["RoleIdList"] as! [String: Any])
                self.roleIdList = model
            }
            if dict.keys.contains("RoleNameList") {
                var model = GetUserResponseBody.User.RoleNameList()
                model.fromMap(dict["RoleNameList"] as! [String: Any])
                self.roleNameList = model
            }
            if dict.keys.contains("SignatureMethod") {
                self.signatureMethod = dict["SignatureMethod"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Uid") {
                self.uid = dict["Uid"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("Webhook") {
                self.webhook = dict["Webhook"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var user: GetUserResponseBody.User?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.user?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.user != nil {
            map["User"] = self.user?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("User") {
            var model = GetUserResponseBody.User()
            model.fromMap(dict["User"] as! [String: Any])
            self.user = model
        }
    }
}

public class GetUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserActiveTenantRequest : Tea.TeaModel {
    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetUserActiveTenantResponseBody : Tea.TeaModel {
    public class Tenant : Tea.TeaModel {
        public var status: String?

        public var tenantName: String?

        public var tid: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tenantName != nil {
                map["TenantName"] = self.tenantName!
            }
            if self.tid != nil {
                map["Tid"] = self.tid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TenantName") {
                self.tenantName = dict["TenantName"] as! String
            }
            if dict.keys.contains("Tid") {
                self.tid = dict["Tid"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tenant: GetUserActiveTenantResponseBody.Tenant?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenant?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tenant != nil {
            map["Tenant"] = self.tenant?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Tenant") {
            var model = GetUserActiveTenantResponseBody.Tenant()
            model.fromMap(dict["Tenant"] as! [String: Any])
            self.tenant = model
        }
    }
}

public class GetUserActiveTenantResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserActiveTenantResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetUserActiveTenantResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserUploadFileJobRequest : Tea.TeaModel {
    public var jobKey: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobKey != nil {
            map["JobKey"] = self.jobKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobKey") {
            self.jobKey = dict["JobKey"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetUserUploadFileJobResponseBody : Tea.TeaModel {
    public class UploadFileJobDetail : Tea.TeaModel {
        public class UploadOSSParam : Tea.TeaModel {
            public var bucketName: String?

            public var endpoint: String?

            public var objectName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucketName != nil {
                    map["BucketName"] = self.bucketName!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.objectName != nil {
                    map["ObjectName"] = self.objectName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BucketName") {
                    self.bucketName = dict["BucketName"] as! String
                }
                if dict.keys.contains("Endpoint") {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("ObjectName") {
                    self.objectName = dict["ObjectName"] as! String
                }
            }
        }
        public var attachmentKey: String?

        public var fileName: String?

        public var fileSize: Int64?

        public var fileSource: String?

        public var jobKey: String?

        public var jobStatus: String?

        public var jobStatusDesc: String?

        public var uploadOSSParam: GetUserUploadFileJobResponseBody.UploadFileJobDetail.UploadOSSParam?

        public var uploadType: String?

        public var uploadURL: String?

        public var uploadedSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.uploadOSSParam?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachmentKey != nil {
                map["AttachmentKey"] = self.attachmentKey!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.fileSource != nil {
                map["FileSource"] = self.fileSource!
            }
            if self.jobKey != nil {
                map["JobKey"] = self.jobKey!
            }
            if self.jobStatus != nil {
                map["JobStatus"] = self.jobStatus!
            }
            if self.jobStatusDesc != nil {
                map["JobStatusDesc"] = self.jobStatusDesc!
            }
            if self.uploadOSSParam != nil {
                map["UploadOSSParam"] = self.uploadOSSParam?.toMap()
            }
            if self.uploadType != nil {
                map["UploadType"] = self.uploadType!
            }
            if self.uploadURL != nil {
                map["UploadURL"] = self.uploadURL!
            }
            if self.uploadedSize != nil {
                map["UploadedSize"] = self.uploadedSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachmentKey") {
                self.attachmentKey = dict["AttachmentKey"] as! String
            }
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileSize") {
                self.fileSize = dict["FileSize"] as! Int64
            }
            if dict.keys.contains("FileSource") {
                self.fileSource = dict["FileSource"] as! String
            }
            if dict.keys.contains("JobKey") {
                self.jobKey = dict["JobKey"] as! String
            }
            if dict.keys.contains("JobStatus") {
                self.jobStatus = dict["JobStatus"] as! String
            }
            if dict.keys.contains("JobStatusDesc") {
                self.jobStatusDesc = dict["JobStatusDesc"] as! String
            }
            if dict.keys.contains("UploadOSSParam") {
                var model = GetUserUploadFileJobResponseBody.UploadFileJobDetail.UploadOSSParam()
                model.fromMap(dict["UploadOSSParam"] as! [String: Any])
                self.uploadOSSParam = model
            }
            if dict.keys.contains("UploadType") {
                self.uploadType = dict["UploadType"] as! String
            }
            if dict.keys.contains("UploadURL") {
                self.uploadURL = dict["UploadURL"] as! String
            }
            if dict.keys.contains("UploadedSize") {
                self.uploadedSize = dict["UploadedSize"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var uploadFileJobDetail: GetUserUploadFileJobResponseBody.UploadFileJobDetail?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.uploadFileJobDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.uploadFileJobDetail != nil {
            map["UploadFileJobDetail"] = self.uploadFileJobDetail?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("UploadFileJobDetail") {
            var model = GetUserUploadFileJobResponseBody.UploadFileJobDetail()
            model.fromMap(dict["UploadFileJobDetail"] as! [String: Any])
            self.uploadFileJobDetail = model
        }
    }
}

public class GetUserUploadFileJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserUploadFileJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetUserUploadFileJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GrantTemplateAuthorityRequest : Tea.TeaModel {
    public var comment: String?

    public var expireDate: String?

    public var templateId: Int64?

    public var tid: Int64?

    public var userIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.expireDate != nil {
            map["ExpireDate"] = self.expireDate!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("ExpireDate") {
            self.expireDate = dict["ExpireDate"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserIds") {
            self.userIds = dict["UserIds"] as! String
        }
    }
}

public class GrantTemplateAuthorityResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GrantTemplateAuthorityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GrantTemplateAuthorityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GrantTemplateAuthorityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GrantUserPermissionRequest : Tea.TeaModel {
    public var dbId: String?

    public var dsType: String?

    public var expireDate: String?

    public var instanceId: Int64?

    public var logic: Bool?

    public var permTypes: String?

    public var tableId: String?

    public var tableName: String?

    public var tid: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.dsType != nil {
            map["DsType"] = self.dsType!
        }
        if self.expireDate != nil {
            map["ExpireDate"] = self.expireDate!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.permTypes != nil {
            map["PermTypes"] = self.permTypes!
        }
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! String
        }
        if dict.keys.contains("DsType") {
            self.dsType = dict["DsType"] as! String
        }
        if dict.keys.contains("ExpireDate") {
            self.expireDate = dict["ExpireDate"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("Logic") {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("PermTypes") {
            self.permTypes = dict["PermTypes"] as! String
        }
        if dict.keys.contains("TableId") {
            self.tableId = dict["TableId"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GrantUserPermissionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GrantUserPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GrantUserPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GrantUserPermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InspectProxyAccessSecretRequest : Tea.TeaModel {
    public var proxyAccessId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.proxyAccessId != nil {
            map["ProxyAccessId"] = self.proxyAccessId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProxyAccessId") {
            self.proxyAccessId = dict["ProxyAccessId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class InspectProxyAccessSecretResponseBody : Tea.TeaModel {
    public var accessSecret: String?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessSecret != nil {
            map["AccessSecret"] = self.accessSecret!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessSecret") {
            self.accessSecret = dict["AccessSecret"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class InspectProxyAccessSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InspectProxyAccessSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InspectProxyAccessSecretResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAbacAuthorizationsRequest : Tea.TeaModel {
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var policyId: String?

    public var policySource: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        if self.policySource != nil {
            map["PolicySource"] = self.policySource!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PolicyId") {
            self.policyId = dict["PolicyId"] as! String
        }
        if dict.keys.contains("PolicySource") {
            self.policySource = dict["PolicySource"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListAbacAuthorizationsResponseBody : Tea.TeaModel {
    public class AuthorizationList : Tea.TeaModel {
        public var authorizationId: Int64?

        public var identityId: Int64?

        public var identityName: String?

        public var identityType: String?

        public var policyId: Int64?

        public var policyName: String?

        public var policySource: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorizationId != nil {
                map["AuthorizationId"] = self.authorizationId!
            }
            if self.identityId != nil {
                map["IdentityId"] = self.identityId!
            }
            if self.identityName != nil {
                map["IdentityName"] = self.identityName!
            }
            if self.identityType != nil {
                map["IdentityType"] = self.identityType!
            }
            if self.policyId != nil {
                map["PolicyId"] = self.policyId!
            }
            if self.policyName != nil {
                map["PolicyName"] = self.policyName!
            }
            if self.policySource != nil {
                map["PolicySource"] = self.policySource!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorizationId") {
                self.authorizationId = dict["AuthorizationId"] as! Int64
            }
            if dict.keys.contains("IdentityId") {
                self.identityId = dict["IdentityId"] as! Int64
            }
            if dict.keys.contains("IdentityName") {
                self.identityName = dict["IdentityName"] as! String
            }
            if dict.keys.contains("IdentityType") {
                self.identityType = dict["IdentityType"] as! String
            }
            if dict.keys.contains("PolicyId") {
                self.policyId = dict["PolicyId"] as! Int64
            }
            if dict.keys.contains("PolicyName") {
                self.policyName = dict["PolicyName"] as! String
            }
            if dict.keys.contains("PolicySource") {
                self.policySource = dict["PolicySource"] as! String
            }
        }
    }
    public var authorizationList: [ListAbacAuthorizationsResponseBody.AuthorizationList]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorizationList != nil {
            var tmp : [Any] = []
            for k in self.authorizationList! {
                tmp.append(k.toMap())
            }
            map["AuthorizationList"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorizationList") {
            var tmp : [ListAbacAuthorizationsResponseBody.AuthorizationList] = []
            for v in dict["AuthorizationList"] as! [Any] {
                var model = ListAbacAuthorizationsResponseBody.AuthorizationList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.authorizationList = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListAbacAuthorizationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAbacAuthorizationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAbacAuthorizationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAbacPoliciesRequest : Tea.TeaModel {
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var searchKey: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListAbacPoliciesResponseBody : Tea.TeaModel {
    public class PolicyList : Tea.TeaModel {
        public var abacPolicyContent: String?

        public var abacPolicyDesc: String?

        public var abacPolicyId: Int64?

        public var abacPolicyName: String?

        public var abacPolicySource: String?

        public var creatorId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.abacPolicyContent != nil {
                map["AbacPolicyContent"] = self.abacPolicyContent!
            }
            if self.abacPolicyDesc != nil {
                map["AbacPolicyDesc"] = self.abacPolicyDesc!
            }
            if self.abacPolicyId != nil {
                map["AbacPolicyId"] = self.abacPolicyId!
            }
            if self.abacPolicyName != nil {
                map["AbacPolicyName"] = self.abacPolicyName!
            }
            if self.abacPolicySource != nil {
                map["AbacPolicySource"] = self.abacPolicySource!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AbacPolicyContent") {
                self.abacPolicyContent = dict["AbacPolicyContent"] as! String
            }
            if dict.keys.contains("AbacPolicyDesc") {
                self.abacPolicyDesc = dict["AbacPolicyDesc"] as! String
            }
            if dict.keys.contains("AbacPolicyId") {
                self.abacPolicyId = dict["AbacPolicyId"] as! Int64
            }
            if dict.keys.contains("AbacPolicyName") {
                self.abacPolicyName = dict["AbacPolicyName"] as! String
            }
            if dict.keys.contains("AbacPolicySource") {
                self.abacPolicySource = dict["AbacPolicySource"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var policyList: [ListAbacPoliciesResponseBody.PolicyList]?

    public var requestId: String?

    public var success: Bool?

    public var tid: Int64?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.policyList != nil {
            var tmp : [Any] = []
            for k in self.policyList! {
                tmp.append(k.toMap())
            }
            map["PolicyList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("PolicyList") {
            var tmp : [ListAbacPoliciesResponseBody.PolicyList] = []
            for v in dict["PolicyList"] as! [Any] {
                var model = ListAbacPoliciesResponseBody.PolicyList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.policyList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListAbacPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAbacPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAbacPoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAuthorityTemplateRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchKey: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListAuthorityTemplateResponseBody : Tea.TeaModel {
    public class AuthorityTemplateViewList : Tea.TeaModel {
        public class AuthorityTemplateView : Tea.TeaModel {
            public var createTime: String?

            public var creatorId: Int64?

            public var description_: String?

            public var name: String?

            public var templateId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreatorId") {
                    self.creatorId = dict["CreatorId"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("TemplateId") {
                    self.templateId = dict["TemplateId"] as! Int64
                }
            }
        }
        public var authorityTemplateView: [ListAuthorityTemplateResponseBody.AuthorityTemplateViewList.AuthorityTemplateView]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorityTemplateView != nil {
                var tmp : [Any] = []
                for k in self.authorityTemplateView! {
                    tmp.append(k.toMap())
                }
                map["AuthorityTemplateView"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorityTemplateView") {
                var tmp : [ListAuthorityTemplateResponseBody.AuthorityTemplateViewList.AuthorityTemplateView] = []
                for v in dict["AuthorityTemplateView"] as! [Any] {
                    var model = ListAuthorityTemplateResponseBody.AuthorityTemplateViewList.AuthorityTemplateView()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.authorityTemplateView = tmp
            }
        }
    }
    public var authorityTemplateViewList: ListAuthorityTemplateResponseBody.AuthorityTemplateViewList?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tid: Int64?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authorityTemplateViewList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorityTemplateViewList != nil {
            map["AuthorityTemplateViewList"] = self.authorityTemplateViewList?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorityTemplateViewList") {
            var model = ListAuthorityTemplateResponseBody.AuthorityTemplateViewList()
            model.fromMap(dict["AuthorityTemplateViewList"] as! [String: Any])
            self.authorityTemplateViewList = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListAuthorityTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAuthorityTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAuthorityTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAuthorizedDatabasesForUserRequest : Tea.TeaModel {
    public var dbType: String?

    public var envType: String?

    public var logic: Bool?

    public var pageNumber: String?

    public var pageSize: String?

    public var searchKey: String?

    public var tid: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbType != nil {
            map["DbType"] = self.dbType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbType") {
            self.dbType = dict["DbType"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("Logic") {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ListAuthorizedDatabasesForUserResponseBody : Tea.TeaModel {
    public class Databases : Tea.TeaModel {
        public class PermissionDetail : Tea.TeaModel {
            public var dsType: String?

            public var expireDate: String?

            public var message: String?

            public var permType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dsType != nil {
                    map["DsType"] = self.dsType!
                }
                if self.expireDate != nil {
                    map["ExpireDate"] = self.expireDate!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.permType != nil {
                    map["PermType"] = self.permType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DsType") {
                    self.dsType = dict["DsType"] as! String
                }
                if dict.keys.contains("ExpireDate") {
                    self.expireDate = dict["ExpireDate"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("PermType") {
                    self.permType = dict["PermType"] as! String
                }
            }
        }
        public var dbId: String?

        public var dbType: String?

        public var envType: String?

        public var instanceId: String?

        public var logic: Bool?

        public var permissionDetail: ListAuthorizedDatabasesForUserResponseBody.Databases.PermissionDetail?

        public var schemaName: String?

        public var searchName: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.permissionDetail?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.logic != nil {
                map["Logic"] = self.logic!
            }
            if self.permissionDetail != nil {
                map["PermissionDetail"] = self.permissionDetail?.toMap()
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.searchName != nil {
                map["SearchName"] = self.searchName!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbId") {
                self.dbId = dict["DbId"] as! String
            }
            if dict.keys.contains("DbType") {
                self.dbType = dict["DbType"] as! String
            }
            if dict.keys.contains("EnvType") {
                self.envType = dict["EnvType"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Logic") {
                self.logic = dict["Logic"] as! Bool
            }
            if dict.keys.contains("PermissionDetail") {
                var model = ListAuthorizedDatabasesForUserResponseBody.Databases.PermissionDetail()
                model.fromMap(dict["PermissionDetail"] as! [String: Any])
                self.permissionDetail = model
            }
            if dict.keys.contains("SchemaName") {
                self.schemaName = dict["SchemaName"] as! String
            }
            if dict.keys.contains("SearchName") {
                self.searchName = dict["SearchName"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var databases: [ListAuthorizedDatabasesForUserResponseBody.Databases]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databases != nil {
            var tmp : [Any] = []
            for k in self.databases! {
                tmp.append(k.toMap())
            }
            map["Databases"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Databases") {
            var tmp : [ListAuthorizedDatabasesForUserResponseBody.Databases] = []
            for v in dict["Databases"] as! [Any] {
                var model = ListAuthorizedDatabasesForUserResponseBody.Databases()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.databases = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAuthorizedDatabasesForUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAuthorizedDatabasesForUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAuthorizedDatabasesForUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAuthorizedInstancesForUserRequest : Tea.TeaModel {
    public var dbType: String?

    public var envType: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var searchKey: String?

    public var tid: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbType != nil {
            map["DbType"] = self.dbType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbType") {
            self.dbType = dict["DbType"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ListAuthorizedInstancesForUserResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class PermissionDetail : Tea.TeaModel {
            public var dsType: String?

            public var expireDate: String?

            public var message: String?

            public var permType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dsType != nil {
                    map["DsType"] = self.dsType!
                }
                if self.expireDate != nil {
                    map["ExpireDate"] = self.expireDate!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.permType != nil {
                    map["PermType"] = self.permType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DsType") {
                    self.dsType = dict["DsType"] as! String
                }
                if dict.keys.contains("ExpireDate") {
                    self.expireDate = dict["ExpireDate"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("PermType") {
                    self.permType = dict["PermType"] as! String
                }
            }
        }
        public var dbType: String?

        public var envType: String?

        public var host: String?

        public var instanceAlias: String?

        public var instanceId: String?

        public var permissionDetail: ListAuthorizedInstancesForUserResponseBody.Instances.PermissionDetail?

        public var port: String?

        public var userId: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.permissionDetail?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.instanceAlias != nil {
                map["InstanceAlias"] = self.instanceAlias!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.permissionDetail != nil {
                map["PermissionDetail"] = self.permissionDetail?.toMap()
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbType") {
                self.dbType = dict["DbType"] as! String
            }
            if dict.keys.contains("EnvType") {
                self.envType = dict["EnvType"] as! String
            }
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("InstanceAlias") {
                self.instanceAlias = dict["InstanceAlias"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("PermissionDetail") {
                var model = ListAuthorizedInstancesForUserResponseBody.Instances.PermissionDetail()
                model.fromMap(dict["PermissionDetail"] as! [String: Any])
                self.permissionDetail = model
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var instances: [ListAuthorizedInstancesForUserResponseBody.Instances]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") {
            var tmp : [ListAuthorizedInstancesForUserResponseBody.Instances] = []
            for v in dict["Instances"] as! [Any] {
                var model = ListAuthorizedInstancesForUserResponseBody.Instances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instances = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAuthorizedInstancesForUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAuthorizedInstancesForUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAuthorizedInstancesForUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAuthorizedUsersForDatabaseRequest : Tea.TeaModel {
    public var dbId: String?

    public var logic: Bool?

    public var pageNumber: String?

    public var pageSize: String?

    public var searchKey: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! String
        }
        if dict.keys.contains("Logic") {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListAuthorizedUsersForDatabaseResponseBody : Tea.TeaModel {
    public class Users : Tea.TeaModel {
        public var uid: String?

        public var userId: String?

        public var userNickName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.uid != nil {
                map["Uid"] = self.uid!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userNickName != nil {
                map["UserNickName"] = self.userNickName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Uid") {
                self.uid = dict["Uid"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserNickName") {
                self.userNickName = dict["UserNickName"] as! String
            }
        }
    }
    public var requestId: String?

    public var users: [ListAuthorizedUsersForDatabaseResponseBody.Users]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.users != nil {
            var tmp : [Any] = []
            for k in self.users! {
                tmp.append(k.toMap())
            }
            map["Users"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Users") {
            var tmp : [ListAuthorizedUsersForDatabaseResponseBody.Users] = []
            for v in dict["Users"] as! [Any] {
                var model = ListAuthorizedUsersForDatabaseResponseBody.Users()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.users = tmp
        }
    }
}

public class ListAuthorizedUsersForDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAuthorizedUsersForDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAuthorizedUsersForDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAuthorizedUsersForInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var searchKey: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListAuthorizedUsersForInstanceResponseBody : Tea.TeaModel {
    public class Users : Tea.TeaModel {
        public var uid: String?

        public var userId: String?

        public var userNickName: String?

        public var userRealName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.uid != nil {
                map["Uid"] = self.uid!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userNickName != nil {
                map["UserNickName"] = self.userNickName!
            }
            if self.userRealName != nil {
                map["UserRealName"] = self.userRealName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Uid") {
                self.uid = dict["Uid"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserNickName") {
                self.userNickName = dict["UserNickName"] as! String
            }
            if dict.keys.contains("UserRealName") {
                self.userRealName = dict["UserRealName"] as! String
            }
        }
    }
    public var requestId: String?

    public var users: [ListAuthorizedUsersForInstanceResponseBody.Users]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.users != nil {
            var tmp : [Any] = []
            for k in self.users! {
                tmp.append(k.toMap())
            }
            map["Users"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Users") {
            var tmp : [ListAuthorizedUsersForInstanceResponseBody.Users] = []
            for v in dict["Users"] as! [Any] {
                var model = ListAuthorizedUsersForInstanceResponseBody.Users()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.users = tmp
        }
    }
}

public class ListAuthorizedUsersForInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAuthorizedUsersForInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAuthorizedUsersForInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClassificationTemplatesRequest : Tea.TeaModel {
    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListClassificationTemplatesResponseBody : Tea.TeaModel {
    public class TemplateList : Tea.TeaModel {
        public var name: String?

        public var remark: String?

        public var templateId: Int64?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Remark") {
                self.remark = dict["Remark"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! Int64
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var templateList: [ListClassificationTemplatesResponseBody.TemplateList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.templateList != nil {
            var tmp : [Any] = []
            for k in self.templateList! {
                tmp.append(k.toMap())
            }
            map["TemplateList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TemplateList") {
            var tmp : [ListClassificationTemplatesResponseBody.TemplateList] = []
            for v in dict["TemplateList"] as! [Any] {
                var model = ListClassificationTemplatesResponseBody.TemplateList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templateList = tmp
        }
    }
}

public class ListClassificationTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClassificationTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListClassificationTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListColumnsRequest : Tea.TeaModel {
    public var logic: Bool?

    public var tableId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Logic") {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("TableId") {
            self.tableId = dict["TableId"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListColumnsResponseBody : Tea.TeaModel {
    public class ColumnList : Tea.TeaModel {
        public class Column : Tea.TeaModel {
            public var autoIncrement: Bool?

            public var columnId: String?

            public var columnName: String?

            public var columnType: String?

            public var dataLength: Int64?

            public var dataPrecision: Int32?

            public var dataScale: Int32?

            public var defaultValue: String?

            public var description_: String?

            public var functionType: String?

            public var nullable: Bool?

            public var securityLevel: String?

            public var sensitive: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoIncrement != nil {
                    map["AutoIncrement"] = self.autoIncrement!
                }
                if self.columnId != nil {
                    map["ColumnId"] = self.columnId!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.columnType != nil {
                    map["ColumnType"] = self.columnType!
                }
                if self.dataLength != nil {
                    map["DataLength"] = self.dataLength!
                }
                if self.dataPrecision != nil {
                    map["DataPrecision"] = self.dataPrecision!
                }
                if self.dataScale != nil {
                    map["DataScale"] = self.dataScale!
                }
                if self.defaultValue != nil {
                    map["DefaultValue"] = self.defaultValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.functionType != nil {
                    map["FunctionType"] = self.functionType!
                }
                if self.nullable != nil {
                    map["Nullable"] = self.nullable!
                }
                if self.securityLevel != nil {
                    map["SecurityLevel"] = self.securityLevel!
                }
                if self.sensitive != nil {
                    map["Sensitive"] = self.sensitive!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoIncrement") {
                    self.autoIncrement = dict["AutoIncrement"] as! Bool
                }
                if dict.keys.contains("ColumnId") {
                    self.columnId = dict["ColumnId"] as! String
                }
                if dict.keys.contains("ColumnName") {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("ColumnType") {
                    self.columnType = dict["ColumnType"] as! String
                }
                if dict.keys.contains("DataLength") {
                    self.dataLength = dict["DataLength"] as! Int64
                }
                if dict.keys.contains("DataPrecision") {
                    self.dataPrecision = dict["DataPrecision"] as! Int32
                }
                if dict.keys.contains("DataScale") {
                    self.dataScale = dict["DataScale"] as! Int32
                }
                if dict.keys.contains("DefaultValue") {
                    self.defaultValue = dict["DefaultValue"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("FunctionType") {
                    self.functionType = dict["FunctionType"] as! String
                }
                if dict.keys.contains("Nullable") {
                    self.nullable = dict["Nullable"] as! Bool
                }
                if dict.keys.contains("SecurityLevel") {
                    self.securityLevel = dict["SecurityLevel"] as! String
                }
                if dict.keys.contains("Sensitive") {
                    self.sensitive = dict["Sensitive"] as! Bool
                }
            }
        }
        public var column: [ListColumnsResponseBody.ColumnList.Column]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.column != nil {
                var tmp : [Any] = []
                for k in self.column! {
                    tmp.append(k.toMap())
                }
                map["Column"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Column") {
                var tmp : [ListColumnsResponseBody.ColumnList.Column] = []
                for v in dict["Column"] as! [Any] {
                    var model = ListColumnsResponseBody.ColumnList.Column()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.column = tmp
            }
        }
    }
    public var columnList: ListColumnsResponseBody.ColumnList?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.columnList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnList != nil {
            map["ColumnList"] = self.columnList?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnList") {
            var model = ListColumnsResponseBody.ColumnList()
            model.fromMap(dict["ColumnList"] as! [String: Any])
            self.columnList = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListColumnsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListColumnsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListColumnsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDAGVersionsRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var pageIndex: Int32?

    public var pageSize: Int32?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("PageIndex") {
            self.pageIndex = dict["PageIndex"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDAGVersionsResponseBody : Tea.TeaModel {
    public class DagVersionList : Tea.TeaModel {
        public class DagVersion : Tea.TeaModel {
            public var dagName: String?

            public var dagOwnerId: String?

            public var dagOwnerNickName: String?

            public var lastVersionId: Int64?

            public var versionComments: String?

            public var versionId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dagName != nil {
                    map["DagName"] = self.dagName!
                }
                if self.dagOwnerId != nil {
                    map["DagOwnerId"] = self.dagOwnerId!
                }
                if self.dagOwnerNickName != nil {
                    map["DagOwnerNickName"] = self.dagOwnerNickName!
                }
                if self.lastVersionId != nil {
                    map["LastVersionId"] = self.lastVersionId!
                }
                if self.versionComments != nil {
                    map["VersionComments"] = self.versionComments!
                }
                if self.versionId != nil {
                    map["VersionId"] = self.versionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DagName") {
                    self.dagName = dict["DagName"] as! String
                }
                if dict.keys.contains("DagOwnerId") {
                    self.dagOwnerId = dict["DagOwnerId"] as! String
                }
                if dict.keys.contains("DagOwnerNickName") {
                    self.dagOwnerNickName = dict["DagOwnerNickName"] as! String
                }
                if dict.keys.contains("LastVersionId") {
                    self.lastVersionId = dict["LastVersionId"] as! Int64
                }
                if dict.keys.contains("VersionComments") {
                    self.versionComments = dict["VersionComments"] as! String
                }
                if dict.keys.contains("VersionId") {
                    self.versionId = dict["VersionId"] as! Int64
                }
            }
        }
        public var dagVersion: [ListDAGVersionsResponseBody.DagVersionList.DagVersion]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dagVersion != nil {
                var tmp : [Any] = []
                for k in self.dagVersion! {
                    tmp.append(k.toMap())
                }
                map["DagVersion"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DagVersion") {
                var tmp : [ListDAGVersionsResponseBody.DagVersionList.DagVersion] = []
                for v in dict["DagVersion"] as! [Any] {
                    var model = ListDAGVersionsResponseBody.DagVersionList.DagVersion()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dagVersion = tmp
            }
        }
    }
    public var dagVersionList: ListDAGVersionsResponseBody.DagVersionList?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dagVersionList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagVersionList != nil {
            map["DagVersionList"] = self.dagVersionList?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagVersionList") {
            var model = ListDAGVersionsResponseBody.DagVersionList()
            model.fromMap(dict["DagVersionList"] as! [String: Any])
            self.dagVersionList = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListDAGVersionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDAGVersionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDAGVersionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDBTaskSQLJobRequest : Tea.TeaModel {
    public var DBTaskGroupId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBTaskGroupId != nil {
            map["DBTaskGroupId"] = self.DBTaskGroupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBTaskGroupId") {
            self.DBTaskGroupId = dict["DBTaskGroupId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDBTaskSQLJobResponseBody : Tea.TeaModel {
    public class DBTaskSQLJobList : Tea.TeaModel {
        public var comment: String?

        public var createTime: String?

        public var dbId: Int64?

        public var dbSearchName: String?

        public var dbTaskGroupId: Int64?

        public var jobId: Int64?

        public var jobType: String?

        public var lastExecTime: String?

        public var logic: Bool?

        public var status: String?

        public var transactional: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.dbSearchName != nil {
                map["DbSearchName"] = self.dbSearchName!
            }
            if self.dbTaskGroupId != nil {
                map["DbTaskGroupId"] = self.dbTaskGroupId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.lastExecTime != nil {
                map["LastExecTime"] = self.lastExecTime!
            }
            if self.logic != nil {
                map["Logic"] = self.logic!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.transactional != nil {
                map["Transactional"] = self.transactional!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DbId") {
                self.dbId = dict["DbId"] as! Int64
            }
            if dict.keys.contains("DbSearchName") {
                self.dbSearchName = dict["DbSearchName"] as! String
            }
            if dict.keys.contains("DbTaskGroupId") {
                self.dbTaskGroupId = dict["DbTaskGroupId"] as! Int64
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! Int64
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("LastExecTime") {
                self.lastExecTime = dict["LastExecTime"] as! String
            }
            if dict.keys.contains("Logic") {
                self.logic = dict["Logic"] as! Bool
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Transactional") {
                self.transactional = dict["Transactional"] as! Bool
            }
        }
    }
    public var DBTaskSQLJobList: [ListDBTaskSQLJobResponseBody.DBTaskSQLJobList]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBTaskSQLJobList != nil {
            var tmp : [Any] = []
            for k in self.DBTaskSQLJobList! {
                tmp.append(k.toMap())
            }
            map["DBTaskSQLJobList"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBTaskSQLJobList") {
            var tmp : [ListDBTaskSQLJobResponseBody.DBTaskSQLJobList] = []
            for v in dict["DBTaskSQLJobList"] as! [Any] {
                var model = ListDBTaskSQLJobResponseBody.DBTaskSQLJobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.DBTaskSQLJobList = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListDBTaskSQLJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDBTaskSQLJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDBTaskSQLJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDBTaskSQLJobDetailRequest : Tea.TeaModel {
    public var jobId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDBTaskSQLJobDetailResponseBody : Tea.TeaModel {
    public class DBTaskSQLJobDetailList : Tea.TeaModel {
        public var affectRows: Int64?

        public var currentSql: String?

        public var dbId: Int64?

        public var endTime: String?

        public var executeCount: Int64?

        public var jobDetailId: Int64?

        public var jobId: Int64?

        public var log: String?

        public var logic: Bool?

        public var skip: Bool?

        public var sqlType: String?

        public var startTime: String?

        public var status: String?

        public var timeDelay: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.affectRows != nil {
                map["AffectRows"] = self.affectRows!
            }
            if self.currentSql != nil {
                map["CurrentSql"] = self.currentSql!
            }
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.executeCount != nil {
                map["ExecuteCount"] = self.executeCount!
            }
            if self.jobDetailId != nil {
                map["JobDetailId"] = self.jobDetailId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.log != nil {
                map["Log"] = self.log!
            }
            if self.logic != nil {
                map["Logic"] = self.logic!
            }
            if self.skip != nil {
                map["Skip"] = self.skip!
            }
            if self.sqlType != nil {
                map["SqlType"] = self.sqlType!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.timeDelay != nil {
                map["TimeDelay"] = self.timeDelay!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AffectRows") {
                self.affectRows = dict["AffectRows"] as! Int64
            }
            if dict.keys.contains("CurrentSql") {
                self.currentSql = dict["CurrentSql"] as! String
            }
            if dict.keys.contains("DbId") {
                self.dbId = dict["DbId"] as! Int64
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("ExecuteCount") {
                self.executeCount = dict["ExecuteCount"] as! Int64
            }
            if dict.keys.contains("JobDetailId") {
                self.jobDetailId = dict["JobDetailId"] as! Int64
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! Int64
            }
            if dict.keys.contains("Log") {
                self.log = dict["Log"] as! String
            }
            if dict.keys.contains("Logic") {
                self.logic = dict["Logic"] as! Bool
            }
            if dict.keys.contains("Skip") {
                self.skip = dict["Skip"] as! Bool
            }
            if dict.keys.contains("SqlType") {
                self.sqlType = dict["SqlType"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TimeDelay") {
                self.timeDelay = dict["TimeDelay"] as! Int64
            }
        }
    }
    public var DBTaskSQLJobDetailList: [ListDBTaskSQLJobDetailResponseBody.DBTaskSQLJobDetailList]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBTaskSQLJobDetailList != nil {
            var tmp : [Any] = []
            for k in self.DBTaskSQLJobDetailList! {
                tmp.append(k.toMap())
            }
            map["DBTaskSQLJobDetailList"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBTaskSQLJobDetailList") {
            var tmp : [ListDBTaskSQLJobDetailResponseBody.DBTaskSQLJobDetailList] = []
            for v in dict["DBTaskSQLJobDetailList"] as! [Any] {
                var model = ListDBTaskSQLJobDetailResponseBody.DBTaskSQLJobDetailList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.DBTaskSQLJobDetailList = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListDBTaskSQLJobDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDBTaskSQLJobDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDBTaskSQLJobDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDDLPublishRecordsRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDDLPublishRecordsResponseBody : Tea.TeaModel {
    public class DDLPublishRecordList : Tea.TeaModel {
        public class PublishTaskInfoList : Tea.TeaModel {
            public class PublishJobList : Tea.TeaModel {
                public var DBTaskGroupId: Int64?

                public var executeCount: Int64?

                public var scripts: String?

                public var statusDesc: String?

                public var tableName: String?

                public var taskJobStatus: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.DBTaskGroupId != nil {
                        map["DBTaskGroupId"] = self.DBTaskGroupId!
                    }
                    if self.executeCount != nil {
                        map["ExecuteCount"] = self.executeCount!
                    }
                    if self.scripts != nil {
                        map["Scripts"] = self.scripts!
                    }
                    if self.statusDesc != nil {
                        map["StatusDesc"] = self.statusDesc!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    if self.taskJobStatus != nil {
                        map["TaskJobStatus"] = self.taskJobStatus!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DBTaskGroupId") {
                        self.DBTaskGroupId = dict["DBTaskGroupId"] as! Int64
                    }
                    if dict.keys.contains("ExecuteCount") {
                        self.executeCount = dict["ExecuteCount"] as! Int64
                    }
                    if dict.keys.contains("Scripts") {
                        self.scripts = dict["Scripts"] as! String
                    }
                    if dict.keys.contains("StatusDesc") {
                        self.statusDesc = dict["StatusDesc"] as! String
                    }
                    if dict.keys.contains("TableName") {
                        self.tableName = dict["TableName"] as! String
                    }
                    if dict.keys.contains("TaskJobStatus") {
                        self.taskJobStatus = dict["TaskJobStatus"] as! String
                    }
                }
            }
            public var dbId: Int64?

            public var logic: Bool?

            public var planTime: String?

            public var publishJobList: [ListDDLPublishRecordsResponseBody.DDLPublishRecordList.PublishTaskInfoList.PublishJobList]?

            public var publishStrategy: String?

            public var statusDesc: String?

            public var taskJobStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.planTime != nil {
                    map["PlanTime"] = self.planTime!
                }
                if self.publishJobList != nil {
                    var tmp : [Any] = []
                    for k in self.publishJobList! {
                        tmp.append(k.toMap())
                    }
                    map["PublishJobList"] = tmp
                }
                if self.publishStrategy != nil {
                    map["PublishStrategy"] = self.publishStrategy!
                }
                if self.statusDesc != nil {
                    map["StatusDesc"] = self.statusDesc!
                }
                if self.taskJobStatus != nil {
                    map["TaskJobStatus"] = self.taskJobStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("PlanTime") {
                    self.planTime = dict["PlanTime"] as! String
                }
                if dict.keys.contains("PublishJobList") {
                    var tmp : [ListDDLPublishRecordsResponseBody.DDLPublishRecordList.PublishTaskInfoList.PublishJobList] = []
                    for v in dict["PublishJobList"] as! [Any] {
                        var model = ListDDLPublishRecordsResponseBody.DDLPublishRecordList.PublishTaskInfoList.PublishJobList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.publishJobList = tmp
                }
                if dict.keys.contains("PublishStrategy") {
                    self.publishStrategy = dict["PublishStrategy"] as! String
                }
                if dict.keys.contains("StatusDesc") {
                    self.statusDesc = dict["StatusDesc"] as! String
                }
                if dict.keys.contains("TaskJobStatus") {
                    self.taskJobStatus = dict["TaskJobStatus"] as! String
                }
            }
        }
        public var auditExpireTime: String?

        public var auditStatus: String?

        public var comment: String?

        public var creatorId: Int64?

        public var finality: Bool?

        public var finalityReason: String?

        public var publishStatus: String?

        public var publishTaskInfoList: [ListDDLPublishRecordsResponseBody.DDLPublishRecordList.PublishTaskInfoList]?

        public var riskLevel: String?

        public var statusDesc: String?

        public var workflowInstanceId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.auditExpireTime != nil {
                map["AuditExpireTime"] = self.auditExpireTime!
            }
            if self.auditStatus != nil {
                map["AuditStatus"] = self.auditStatus!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.finality != nil {
                map["Finality"] = self.finality!
            }
            if self.finalityReason != nil {
                map["FinalityReason"] = self.finalityReason!
            }
            if self.publishStatus != nil {
                map["PublishStatus"] = self.publishStatus!
            }
            if self.publishTaskInfoList != nil {
                var tmp : [Any] = []
                for k in self.publishTaskInfoList! {
                    tmp.append(k.toMap())
                }
                map["PublishTaskInfoList"] = tmp
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.workflowInstanceId != nil {
                map["WorkflowInstanceId"] = self.workflowInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuditExpireTime") {
                self.auditExpireTime = dict["AuditExpireTime"] as! String
            }
            if dict.keys.contains("AuditStatus") {
                self.auditStatus = dict["AuditStatus"] as! String
            }
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! Int64
            }
            if dict.keys.contains("Finality") {
                self.finality = dict["Finality"] as! Bool
            }
            if dict.keys.contains("FinalityReason") {
                self.finalityReason = dict["FinalityReason"] as! String
            }
            if dict.keys.contains("PublishStatus") {
                self.publishStatus = dict["PublishStatus"] as! String
            }
            if dict.keys.contains("PublishTaskInfoList") {
                var tmp : [ListDDLPublishRecordsResponseBody.DDLPublishRecordList.PublishTaskInfoList] = []
                for v in dict["PublishTaskInfoList"] as! [Any] {
                    var model = ListDDLPublishRecordsResponseBody.DDLPublishRecordList.PublishTaskInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.publishTaskInfoList = tmp
            }
            if dict.keys.contains("RiskLevel") {
                self.riskLevel = dict["RiskLevel"] as! String
            }
            if dict.keys.contains("StatusDesc") {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("WorkflowInstanceId") {
                self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
            }
        }
    }
    public var DDLPublishRecordList: [ListDDLPublishRecordsResponseBody.DDLPublishRecordList]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DDLPublishRecordList != nil {
            var tmp : [Any] = []
            for k in self.DDLPublishRecordList! {
                tmp.append(k.toMap())
            }
            map["DDLPublishRecordList"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DDLPublishRecordList") {
            var tmp : [ListDDLPublishRecordsResponseBody.DDLPublishRecordList] = []
            for v in dict["DDLPublishRecordList"] as! [Any] {
                var model = ListDDLPublishRecordsResponseBody.DDLPublishRecordList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.DDLPublishRecordList = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDDLPublishRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDDLPublishRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDDLPublishRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataCorrectPreCheckDBRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDataCorrectPreCheckDBResponseBody : Tea.TeaModel {
    public class PreCheckDBList : Tea.TeaModel {
        public var dbId: Int64?

        public var searchName: String?

        public var sqlNum: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.searchName != nil {
                map["SearchName"] = self.searchName!
            }
            if self.sqlNum != nil {
                map["SqlNum"] = self.sqlNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbId") {
                self.dbId = dict["DbId"] as! Int64
            }
            if dict.keys.contains("SearchName") {
                self.searchName = dict["SearchName"] as! String
            }
            if dict.keys.contains("SqlNum") {
                self.sqlNum = dict["SqlNum"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var preCheckDBList: [ListDataCorrectPreCheckDBResponseBody.PreCheckDBList]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.preCheckDBList != nil {
            var tmp : [Any] = []
            for k in self.preCheckDBList! {
                tmp.append(k.toMap())
            }
            map["PreCheckDBList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("PreCheckDBList") {
            var tmp : [ListDataCorrectPreCheckDBResponseBody.PreCheckDBList] = []
            for v in dict["PreCheckDBList"] as! [Any] {
                var model = ListDataCorrectPreCheckDBResponseBody.PreCheckDBList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.preCheckDBList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDataCorrectPreCheckDBResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataCorrectPreCheckDBResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataCorrectPreCheckDBResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataCorrectPreCheckSQLRequest : Tea.TeaModel {
    public var dbId: Int64?

    public var orderId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! Int64
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDataCorrectPreCheckSQLResponseBody : Tea.TeaModel {
    public class PreCheckSQLList : Tea.TeaModel {
        public var affectRows: Int64?

        public var checkSQL: String?

        public var dbId: Int64?

        public var SQLReviewQueryKey: String?

        public var sqlReviewStatus: String?

        public var sqlType: String?

        public var tableNames: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.affectRows != nil {
                map["AffectRows"] = self.affectRows!
            }
            if self.checkSQL != nil {
                map["CheckSQL"] = self.checkSQL!
            }
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.SQLReviewQueryKey != nil {
                map["SQLReviewQueryKey"] = self.SQLReviewQueryKey!
            }
            if self.sqlReviewStatus != nil {
                map["SqlReviewStatus"] = self.sqlReviewStatus!
            }
            if self.sqlType != nil {
                map["SqlType"] = self.sqlType!
            }
            if self.tableNames != nil {
                map["TableNames"] = self.tableNames!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AffectRows") {
                self.affectRows = dict["AffectRows"] as! Int64
            }
            if dict.keys.contains("CheckSQL") {
                self.checkSQL = dict["CheckSQL"] as! String
            }
            if dict.keys.contains("DbId") {
                self.dbId = dict["DbId"] as! Int64
            }
            if dict.keys.contains("SQLReviewQueryKey") {
                self.SQLReviewQueryKey = dict["SQLReviewQueryKey"] as! String
            }
            if dict.keys.contains("SqlReviewStatus") {
                self.sqlReviewStatus = dict["SqlReviewStatus"] as! String
            }
            if dict.keys.contains("SqlType") {
                self.sqlType = dict["SqlType"] as! String
            }
            if dict.keys.contains("TableNames") {
                self.tableNames = dict["TableNames"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var preCheckSQLList: [ListDataCorrectPreCheckSQLResponseBody.PreCheckSQLList]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.preCheckSQLList != nil {
            var tmp : [Any] = []
            for k in self.preCheckSQLList! {
                tmp.append(k.toMap())
            }
            map["PreCheckSQLList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("PreCheckSQLList") {
            var tmp : [ListDataCorrectPreCheckSQLResponseBody.PreCheckSQLList] = []
            for v in dict["PreCheckSQLList"] as! [Any] {
                var model = ListDataCorrectPreCheckSQLResponseBody.PreCheckSQLList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.preCheckSQLList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDataCorrectPreCheckSQLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataCorrectPreCheckSQLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataCorrectPreCheckSQLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataImportSQLPreCheckDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var pageNumer: Int64?

    public var pageSize: Int64?

    public var sqlType: String?

    public var statusCode: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.pageNumer != nil {
            map["PageNumer"] = self.pageNumer!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sqlType != nil {
            map["SqlType"] = self.sqlType!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("PageNumer") {
            self.pageNumer = dict["PageNumer"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SqlType") {
            self.sqlType = dict["SqlType"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDataImportSQLPreCheckDetailResponseBody : Tea.TeaModel {
    public class PreCheckSQLDetailList : Tea.TeaModel {
        public var skip: Bool?

        public var sqlId: Int64?

        public var sqlType: String?

        public var statusCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.skip != nil {
                map["Skip"] = self.skip!
            }
            if self.sqlId != nil {
                map["SqlId"] = self.sqlId!
            }
            if self.sqlType != nil {
                map["SqlType"] = self.sqlType!
            }
            if self.statusCode != nil {
                map["StatusCode"] = self.statusCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Skip") {
                self.skip = dict["Skip"] as! Bool
            }
            if dict.keys.contains("SqlId") {
                self.sqlId = dict["SqlId"] as! Int64
            }
            if dict.keys.contains("SqlType") {
                self.sqlType = dict["SqlType"] as! String
            }
            if dict.keys.contains("StatusCode") {
                self.statusCode = dict["StatusCode"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var preCheckSQLDetailList: [ListDataImportSQLPreCheckDetailResponseBody.PreCheckSQLDetailList]?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.preCheckSQLDetailList != nil {
            var tmp : [Any] = []
            for k in self.preCheckSQLDetailList! {
                tmp.append(k.toMap())
            }
            map["PreCheckSQLDetailList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("PreCheckSQLDetailList") {
            var tmp : [ListDataImportSQLPreCheckDetailResponseBody.PreCheckSQLDetailList] = []
            for v in dict["PreCheckSQLDetailList"] as! [Any] {
                var model = ListDataImportSQLPreCheckDetailResponseBody.PreCheckSQLDetailList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.preCheckSQLDetailList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListDataImportSQLPreCheckDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataImportSQLPreCheckDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataImportSQLPreCheckDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataImportSQLTypeRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDataImportSQLTypeResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var sqlTypeResult: [String]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sqlTypeResult != nil {
            map["SqlTypeResult"] = self.sqlTypeResult!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SqlTypeResult") {
            self.sqlTypeResult = dict["SqlTypeResult"] as! [String]
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDataImportSQLTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataImportSQLTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataImportSQLTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataLakeCatalogRequest : Tea.TeaModel {
    public var dataRegion: String?

    public var searchKey: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDataLakeCatalogResponseBody : Tea.TeaModel {
    public var cataLogList: [DLCatalog]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cataLogList != nil {
            var tmp : [Any] = []
            for k in self.cataLogList! {
                tmp.append(k.toMap())
            }
            map["CataLogList"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CataLogList") {
            var tmp : [DLCatalog] = []
            for v in dict["CataLogList"] as! [Any] {
                var model = DLCatalog()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.cataLogList = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDataLakeCatalogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataLakeCatalogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataLakeCatalogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataLakeDatabaseRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var searchKey: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDataLakeDatabaseResponseBody : Tea.TeaModel {
    public var databaseList: [DLDatabase]?

    public var errorCode: String?

    public var errorMessage: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseList != nil {
            var tmp : [Any] = []
            for k in self.databaseList! {
                tmp.append(k.toMap())
            }
            map["DatabaseList"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseList") {
            var tmp : [DLDatabase] = []
            for v in dict["DatabaseList"] as! [Any] {
                var model = DLDatabase()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.databaseList = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDataLakeDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataLakeDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataLakeDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataLakePartitionRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var partNames: [String]?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.partNames != nil {
            map["PartNames"] = self.partNames!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PartNames") {
            self.partNames = dict["PartNames"] as! [String]
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDataLakePartitionShrinkRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var partNamesShrink: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.partNamesShrink != nil {
            map["PartNames"] = self.partNamesShrink!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PartNames") {
            self.partNamesShrink = dict["PartNames"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDataLakePartitionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var partitionList: [DLPartition]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.partitionList != nil {
            var tmp : [Any] = []
            for k in self.partitionList! {
                tmp.append(k.toMap())
            }
            map["PartitionList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PartitionList") {
            var tmp : [DLPartition] = []
            for v in dict["PartitionList"] as! [Any] {
                var model = DLPartition()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.partitionList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDataLakePartitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataLakePartitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataLakePartitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataLakePartitionByFilterRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var filter: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.filter != nil {
            map["Filter"] = self.filter!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("Filter") {
            self.filter = dict["Filter"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDataLakePartitionByFilterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var partitionList: [DLPartition]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.partitionList != nil {
            var tmp : [Any] = []
            for k in self.partitionList! {
                tmp.append(k.toMap())
            }
            map["PartitionList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PartitionList") {
            var tmp : [DLPartition] = []
            for v in dict["PartitionList"] as! [Any] {
                var model = DLPartition()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.partitionList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDataLakePartitionByFilterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataLakePartitionByFilterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataLakePartitionByFilterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataLakePartitionNameRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDataLakePartitionNameResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var partitionNameList: [String]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.partitionNameList != nil {
            map["PartitionNameList"] = self.partitionNameList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PartitionNameList") {
            self.partitionNameList = dict["PartitionNameList"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDataLakePartitionNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataLakePartitionNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataLakePartitionNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataLakeTableRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var tableNamePattern: String?

    public var tableType: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tableNamePattern != nil {
            map["TableNamePattern"] = self.tableNamePattern!
        }
        if self.tableType != nil {
            map["TableType"] = self.tableType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TableNamePattern") {
            self.tableNamePattern = dict["TableNamePattern"] as! String
        }
        if dict.keys.contains("TableType") {
            self.tableType = dict["TableType"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDataLakeTableResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var tableList: [DLTable]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tableList != nil {
            var tmp : [Any] = []
            for k in self.tableList! {
                tmp.append(k.toMap())
            }
            map["TableList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TableList") {
            var tmp : [DLTable] = []
            for v in dict["TableList"] as! [Any] {
                var model = DLTable()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tableList = tmp
        }
    }
}

public class ListDataLakeTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataLakeTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataLakeTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataLakeTableNameRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var tableNamePattern: String?

    public var tableType: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tableNamePattern != nil {
            map["TableNamePattern"] = self.tableNamePattern!
        }
        if self.tableType != nil {
            map["TableType"] = self.tableType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TableNamePattern") {
            self.tableNamePattern = dict["TableNamePattern"] as! String
        }
        if dict.keys.contains("TableType") {
            self.tableType = dict["TableType"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDataLakeTableNameResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var tableNameList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tableNameList != nil {
            map["TableNameList"] = self.tableNameList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TableNameList") {
            self.tableNameList = dict["TableNameList"] as! [String]
        }
    }
}

public class ListDataLakeTableNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataLakeTableNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataLakeTableNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataLakeTablebaseInfoRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var page: Int32?

    public var rows: Int32?

    public var searchKey: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.rows != nil {
            map["Rows"] = self.rows!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int32
        }
        if dict.keys.contains("Rows") {
            self.rows = dict["Rows"] as! Int32
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDataLakeTablebaseInfoResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tablebaseInfoList: [DLTablebaseInfo]?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tablebaseInfoList != nil {
            var tmp : [Any] = []
            for k in self.tablebaseInfoList! {
                tmp.append(k.toMap())
            }
            map["TablebaseInfoList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TablebaseInfoList") {
            var tmp : [DLTablebaseInfo] = []
            for v in dict["TablebaseInfoList"] as! [Any] {
                var model = DLTablebaseInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tablebaseInfoList = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class ListDataLakeTablebaseInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataLakeTablebaseInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataLakeTablebaseInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDatabaseUserPermssionsRequest : Tea.TeaModel {
    public var dbId: String?

    public var logic: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var permType: String?

    public var tid: Int64?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.permType != nil {
            map["PermType"] = self.permType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! String
        }
        if dict.keys.contains("Logic") {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PermType") {
            self.permType = dict["PermType"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class ListDatabaseUserPermssionsResponseBody : Tea.TeaModel {
    public class UserPermissions : Tea.TeaModel {
        public class UserPermission : Tea.TeaModel {
            public class PermDetails : Tea.TeaModel {
                public class PermDetail : Tea.TeaModel {
                    public var createDate: String?

                    public var expireDate: String?

                    public var extraData: String?

                    public var originFrom: String?

                    public var permType: String?

                    public var userAccessId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.createDate != nil {
                            map["CreateDate"] = self.createDate!
                        }
                        if self.expireDate != nil {
                            map["ExpireDate"] = self.expireDate!
                        }
                        if self.extraData != nil {
                            map["ExtraData"] = self.extraData!
                        }
                        if self.originFrom != nil {
                            map["OriginFrom"] = self.originFrom!
                        }
                        if self.permType != nil {
                            map["PermType"] = self.permType!
                        }
                        if self.userAccessId != nil {
                            map["UserAccessId"] = self.userAccessId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CreateDate") {
                            self.createDate = dict["CreateDate"] as! String
                        }
                        if dict.keys.contains("ExpireDate") {
                            self.expireDate = dict["ExpireDate"] as! String
                        }
                        if dict.keys.contains("ExtraData") {
                            self.extraData = dict["ExtraData"] as! String
                        }
                        if dict.keys.contains("OriginFrom") {
                            self.originFrom = dict["OriginFrom"] as! String
                        }
                        if dict.keys.contains("PermType") {
                            self.permType = dict["PermType"] as! String
                        }
                        if dict.keys.contains("UserAccessId") {
                            self.userAccessId = dict["UserAccessId"] as! String
                        }
                    }
                }
                public var permDetail: [ListDatabaseUserPermssionsResponseBody.UserPermissions.UserPermission.PermDetails.PermDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.permDetail != nil {
                        var tmp : [Any] = []
                        for k in self.permDetail! {
                            tmp.append(k.toMap())
                        }
                        map["PermDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PermDetail") {
                        var tmp : [ListDatabaseUserPermssionsResponseBody.UserPermissions.UserPermission.PermDetails.PermDetail] = []
                        for v in dict["PermDetail"] as! [Any] {
                            var model = ListDatabaseUserPermssionsResponseBody.UserPermissions.UserPermission.PermDetails.PermDetail()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.permDetail = tmp
                    }
                }
            }
            public var alias: String?

            public var columnName: String?

            public var dbId: String?

            public var dbType: String?

            public var dsType: String?

            public var envType: String?

            public var instanceId: String?

            public var logic: Bool?

            public var permDetails: ListDatabaseUserPermssionsResponseBody.UserPermissions.UserPermission.PermDetails?

            public var schemaName: String?

            public var searchName: String?

            public var tableId: String?

            public var tableName: String?

            public var userId: String?

            public var userNickName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.permDetails?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.dsType != nil {
                    map["DsType"] = self.dsType!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.permDetails != nil {
                    map["PermDetails"] = self.permDetails?.toMap()
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                if self.tableId != nil {
                    map["TableId"] = self.tableId!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userNickName != nil {
                    map["UserNickName"] = self.userNickName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("ColumnName") {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! String
                }
                if dict.keys.contains("DbType") {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("DsType") {
                    self.dsType = dict["DsType"] as! String
                }
                if dict.keys.contains("EnvType") {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("PermDetails") {
                    var model = ListDatabaseUserPermssionsResponseBody.UserPermissions.UserPermission.PermDetails()
                    model.fromMap(dict["PermDetails"] as! [String: Any])
                    self.permDetails = model
                }
                if dict.keys.contains("SchemaName") {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SearchName") {
                    self.searchName = dict["SearchName"] as! String
                }
                if dict.keys.contains("TableId") {
                    self.tableId = dict["TableId"] as! String
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserNickName") {
                    self.userNickName = dict["UserNickName"] as! String
                }
            }
        }
        public var userPermission: [ListDatabaseUserPermssionsResponseBody.UserPermissions.UserPermission]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userPermission != nil {
                var tmp : [Any] = []
                for k in self.userPermission! {
                    tmp.append(k.toMap())
                }
                map["UserPermission"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserPermission") {
                var tmp : [ListDatabaseUserPermssionsResponseBody.UserPermissions.UserPermission] = []
                for v in dict["UserPermission"] as! [Any] {
                    var model = ListDatabaseUserPermssionsResponseBody.UserPermissions.UserPermission()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.userPermission = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public var userPermissions: ListDatabaseUserPermssionsResponseBody.UserPermissions?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userPermissions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.userPermissions != nil {
            map["UserPermissions"] = self.userPermissions?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("UserPermissions") {
            var model = ListDatabaseUserPermssionsResponseBody.UserPermissions()
            model.fromMap(dict["UserPermissions"] as! [String: Any])
            self.userPermissions = model
        }
    }
}

public class ListDatabaseUserPermssionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDatabaseUserPermssionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDatabaseUserPermssionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDatabasesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDatabasesResponseBody : Tea.TeaModel {
    public class DatabaseList : Tea.TeaModel {
        public class Database : Tea.TeaModel {
            public class OwnerIdList : Tea.TeaModel {
                public var ownerIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerIds") {
                        self.ownerIds = dict["OwnerIds"] as! [String]
                    }
                }
            }
            public class OwnerNameList : Tea.TeaModel {
                public var ownerNames: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerNames != nil {
                        map["OwnerNames"] = self.ownerNames!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerNames") {
                        self.ownerNames = dict["OwnerNames"] as! [String]
                    }
                }
            }
            public var catalogName: String?

            public var databaseId: String?

            public var dbType: String?

            public var dbaId: String?

            public var dbaName: String?

            public var encoding: String?

            public var envType: String?

            public var host: String?

            public var instanceId: String?

            public var ownerIdList: ListDatabasesResponseBody.DatabaseList.Database.OwnerIdList?

            public var ownerNameList: ListDatabasesResponseBody.DatabaseList.Database.OwnerNameList?

            public var port: Int32?

            public var schemaName: String?

            public var searchName: String?

            public var sid: String?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ownerIdList?.validate()
                try self.ownerNameList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.catalogName != nil {
                    map["CatalogName"] = self.catalogName!
                }
                if self.databaseId != nil {
                    map["DatabaseId"] = self.databaseId!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.dbaId != nil {
                    map["DbaId"] = self.dbaId!
                }
                if self.dbaName != nil {
                    map["DbaName"] = self.dbaName!
                }
                if self.encoding != nil {
                    map["Encoding"] = self.encoding!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ownerIdList != nil {
                    map["OwnerIdList"] = self.ownerIdList?.toMap()
                }
                if self.ownerNameList != nil {
                    map["OwnerNameList"] = self.ownerNameList?.toMap()
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                if self.sid != nil {
                    map["Sid"] = self.sid!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CatalogName") {
                    self.catalogName = dict["CatalogName"] as! String
                }
                if dict.keys.contains("DatabaseId") {
                    self.databaseId = dict["DatabaseId"] as! String
                }
                if dict.keys.contains("DbType") {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("DbaId") {
                    self.dbaId = dict["DbaId"] as! String
                }
                if dict.keys.contains("DbaName") {
                    self.dbaName = dict["DbaName"] as! String
                }
                if dict.keys.contains("Encoding") {
                    self.encoding = dict["Encoding"] as! String
                }
                if dict.keys.contains("EnvType") {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("OwnerIdList") {
                    var model = ListDatabasesResponseBody.DatabaseList.Database.OwnerIdList()
                    model.fromMap(dict["OwnerIdList"] as! [String: Any])
                    self.ownerIdList = model
                }
                if dict.keys.contains("OwnerNameList") {
                    var model = ListDatabasesResponseBody.DatabaseList.Database.OwnerNameList()
                    model.fromMap(dict["OwnerNameList"] as! [String: Any])
                    self.ownerNameList = model
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("SchemaName") {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SearchName") {
                    self.searchName = dict["SearchName"] as! String
                }
                if dict.keys.contains("Sid") {
                    self.sid = dict["Sid"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var database: [ListDatabasesResponseBody.DatabaseList.Database]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.database != nil {
                var tmp : [Any] = []
                for k in self.database! {
                    tmp.append(k.toMap())
                }
                map["Database"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Database") {
                var tmp : [ListDatabasesResponseBody.DatabaseList.Database] = []
                for v in dict["Database"] as! [Any] {
                    var model = ListDatabasesResponseBody.DatabaseList.Database()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.database = tmp
            }
        }
    }
    public var databaseList: ListDatabasesResponseBody.DatabaseList?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.databaseList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseList != nil {
            map["DatabaseList"] = self.databaseList?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseList") {
            var model = ListDatabasesResponseBody.DatabaseList()
            model.fromMap(dict["DatabaseList"] as! [String: Any])
            self.databaseList = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListDatabasesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDatabasesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDatabasesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDefaultSLARulesRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDefaultSLARulesResponseBody : Tea.TeaModel {
    public class SLARuleList : Tea.TeaModel {
        public class SLARule : Tea.TeaModel {
            public var dagId: Int64?

            public var id: Int64?

            public var intervalMinutes: Int32?

            public var nodeId: Int64?

            public var ruleType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dagId != nil {
                    map["DagId"] = self.dagId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.intervalMinutes != nil {
                    map["IntervalMinutes"] = self.intervalMinutes!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.ruleType != nil {
                    map["RuleType"] = self.ruleType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DagId") {
                    self.dagId = dict["DagId"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IntervalMinutes") {
                    self.intervalMinutes = dict["IntervalMinutes"] as! Int32
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("RuleType") {
                    self.ruleType = dict["RuleType"] as! Int32
                }
            }
        }
        public var SLARule: [ListDefaultSLARulesResponseBody.SLARuleList.SLARule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.SLARule != nil {
                var tmp : [Any] = []
                for k in self.SLARule! {
                    tmp.append(k.toMap())
                }
                map["SLARule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SLARule") {
                var tmp : [ListDefaultSLARulesResponseBody.SLARuleList.SLARule] = []
                for v in dict["SLARule"] as! [Any] {
                    var model = ListDefaultSLARulesResponseBody.SLARuleList.SLARule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.SLARule = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var SLARuleList: ListDefaultSLARulesResponseBody.SLARuleList?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.SLARuleList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SLARuleList != nil {
            map["SLARuleList"] = self.SLARuleList?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SLARuleList") {
            var model = ListDefaultSLARulesResponseBody.SLARuleList()
            model.fromMap(dict["SLARuleList"] as! [String: Any])
            self.SLARuleList = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDefaultSLARulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDefaultSLARulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDefaultSLARulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDesensitizationRuleRequest : Tea.TeaModel {
    public var funcType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var ruleId: Int32?

    public var ruleName: String?

    public var ruleType: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.funcType != nil {
            map["FuncType"] = self.funcType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.ruleType != nil {
            map["RuleType"] = self.ruleType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FuncType") {
            self.funcType = dict["FuncType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! Int32
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("RuleType") {
            self.ruleType = dict["RuleType"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDesensitizationRuleResponseBody : Tea.TeaModel {
    public class DesensitizationRuleList : Tea.TeaModel {
        public var funcParams: String?

        public var funcSample: String?

        public var functionType: String?

        public var lastModifierId: String?

        public var lastModifierName: String?

        public var referenceCount: Int32?

        public var ruleDesc: String?

        public var ruleId: Int32?

        public var ruleName: String?

        public var ruleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.funcParams != nil {
                map["FuncParams"] = self.funcParams!
            }
            if self.funcSample != nil {
                map["FuncSample"] = self.funcSample!
            }
            if self.functionType != nil {
                map["FunctionType"] = self.functionType!
            }
            if self.lastModifierId != nil {
                map["LastModifierId"] = self.lastModifierId!
            }
            if self.lastModifierName != nil {
                map["LastModifierName"] = self.lastModifierName!
            }
            if self.referenceCount != nil {
                map["ReferenceCount"] = self.referenceCount!
            }
            if self.ruleDesc != nil {
                map["RuleDesc"] = self.ruleDesc!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.ruleType != nil {
                map["RuleType"] = self.ruleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FuncParams") {
                self.funcParams = dict["FuncParams"] as! String
            }
            if dict.keys.contains("FuncSample") {
                self.funcSample = dict["FuncSample"] as! String
            }
            if dict.keys.contains("FunctionType") {
                self.functionType = dict["FunctionType"] as! String
            }
            if dict.keys.contains("LastModifierId") {
                self.lastModifierId = dict["LastModifierId"] as! String
            }
            if dict.keys.contains("LastModifierName") {
                self.lastModifierName = dict["LastModifierName"] as! String
            }
            if dict.keys.contains("ReferenceCount") {
                self.referenceCount = dict["ReferenceCount"] as! Int32
            }
            if dict.keys.contains("RuleDesc") {
                self.ruleDesc = dict["RuleDesc"] as! String
            }
            if dict.keys.contains("RuleId") {
                self.ruleId = dict["RuleId"] as! Int32
            }
            if dict.keys.contains("RuleName") {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("RuleType") {
                self.ruleType = dict["RuleType"] as! String
            }
        }
    }
    public var desensitizationRuleList: [ListDesensitizationRuleResponseBody.DesensitizationRuleList]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desensitizationRuleList != nil {
            var tmp : [Any] = []
            for k in self.desensitizationRuleList! {
                tmp.append(k.toMap())
            }
            map["DesensitizationRuleList"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesensitizationRuleList") {
            var tmp : [ListDesensitizationRuleResponseBody.DesensitizationRuleList] = []
            for v in dict["DesensitizationRuleList"] as! [Any] {
                var model = ListDesensitizationRuleResponseBody.DesensitizationRuleList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.desensitizationRuleList = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListDesensitizationRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDesensitizationRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDesensitizationRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEffectiveOrdersRequest : Tea.TeaModel {
    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListEffectiveOrdersResponseBody : Tea.TeaModel {
    public class OrderSummary : Tea.TeaModel {
        public class OrderList : Tea.TeaModel {
            public var buyerId: String?

            public var endTime: String?

            public var insNum: String?

            public var instanceId: String?

            public var orderId: String?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.buyerId != nil {
                    map["BuyerId"] = self.buyerId!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.insNum != nil {
                    map["InsNum"] = self.insNum!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.orderId != nil {
                    map["OrderId"] = self.orderId!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BuyerId") {
                    self.buyerId = dict["BuyerId"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("InsNum") {
                    self.insNum = dict["InsNum"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("OrderId") {
                    self.orderId = dict["OrderId"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
            }
        }
        public var commodityCode: String?

        public var commodityType: String?

        public var orderList: [ListEffectiveOrdersResponseBody.OrderSummary.OrderList]?

        public var totalQuota: Int32?

        public var versionType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commodityCode != nil {
                map["CommodityCode"] = self.commodityCode!
            }
            if self.commodityType != nil {
                map["CommodityType"] = self.commodityType!
            }
            if self.orderList != nil {
                var tmp : [Any] = []
                for k in self.orderList! {
                    tmp.append(k.toMap())
                }
                map["OrderList"] = tmp
            }
            if self.totalQuota != nil {
                map["TotalQuota"] = self.totalQuota!
            }
            if self.versionType != nil {
                map["VersionType"] = self.versionType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CommodityCode") {
                self.commodityCode = dict["CommodityCode"] as! String
            }
            if dict.keys.contains("CommodityType") {
                self.commodityType = dict["CommodityType"] as! String
            }
            if dict.keys.contains("OrderList") {
                var tmp : [ListEffectiveOrdersResponseBody.OrderSummary.OrderList] = []
                for v in dict["OrderList"] as! [Any] {
                    var model = ListEffectiveOrdersResponseBody.OrderSummary.OrderList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.orderList = tmp
            }
            if dict.keys.contains("TotalQuota") {
                self.totalQuota = dict["TotalQuota"] as! Int32
            }
            if dict.keys.contains("VersionType") {
                self.versionType = dict["VersionType"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var orderSummary: [ListEffectiveOrdersResponseBody.OrderSummary]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.orderSummary != nil {
            var tmp : [Any] = []
            for k in self.orderSummary! {
                tmp.append(k.toMap())
            }
            map["OrderSummary"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("OrderSummary") {
            var tmp : [ListEffectiveOrdersResponseBody.OrderSummary] = []
            for v in dict["OrderSummary"] as! [Any] {
                var model = ListEffectiveOrdersResponseBody.OrderSummary()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.orderSummary = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListEffectiveOrdersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEffectiveOrdersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEffectiveOrdersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIndexesRequest : Tea.TeaModel {
    public var logic: Bool?

    public var tableId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Logic") {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("TableId") {
            self.tableId = dict["TableId"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListIndexesResponseBody : Tea.TeaModel {
    public class IndexList : Tea.TeaModel {
        public class Index : Tea.TeaModel {
            public var indexComment: String?

            public var indexId: String?

            public var indexName: String?

            public var indexType: String?

            public var tableId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.indexComment != nil {
                    map["IndexComment"] = self.indexComment!
                }
                if self.indexId != nil {
                    map["IndexId"] = self.indexId!
                }
                if self.indexName != nil {
                    map["IndexName"] = self.indexName!
                }
                if self.indexType != nil {
                    map["IndexType"] = self.indexType!
                }
                if self.tableId != nil {
                    map["TableId"] = self.tableId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IndexComment") {
                    self.indexComment = dict["IndexComment"] as! String
                }
                if dict.keys.contains("IndexId") {
                    self.indexId = dict["IndexId"] as! String
                }
                if dict.keys.contains("IndexName") {
                    self.indexName = dict["IndexName"] as! String
                }
                if dict.keys.contains("IndexType") {
                    self.indexType = dict["IndexType"] as! String
                }
                if dict.keys.contains("TableId") {
                    self.tableId = dict["TableId"] as! String
                }
            }
        }
        public var index: [ListIndexesResponseBody.IndexList.Index]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.index != nil {
                var tmp : [Any] = []
                for k in self.index! {
                    tmp.append(k.toMap())
                }
                map["Index"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Index") {
                var tmp : [ListIndexesResponseBody.IndexList.Index] = []
                for v in dict["Index"] as! [Any] {
                    var model = ListIndexesResponseBody.IndexList.Index()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.index = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var indexList: ListIndexesResponseBody.IndexList?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.indexList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.indexList != nil {
            map["IndexList"] = self.indexList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("IndexList") {
            var model = ListIndexesResponseBody.IndexList()
            model.fromMap(dict["IndexList"] as! [String: Any])
            self.indexList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListIndexesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIndexesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListIndexesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstanceLoginAuditLogRequest : Tea.TeaModel {
    public var endTime: String?

    public var opUserName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchName: String?

    public var startTime: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.opUserName != nil {
            map["OpUserName"] = self.opUserName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchName != nil {
            map["SearchName"] = self.searchName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OpUserName") {
            self.opUserName = dict["OpUserName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchName") {
            self.searchName = dict["SearchName"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListInstanceLoginAuditLogResponseBody : Tea.TeaModel {
    public class InstanceLoginAuditLogList : Tea.TeaModel {
        public class InstanceLoginAuditLog : Tea.TeaModel {
            public var dbUser: String?

            public var instanceId: Int64?

            public var instanceName: String?

            public var opTime: String?

            public var requestIp: String?

            public var userId: Int64?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbUser != nil {
                    map["DbUser"] = self.dbUser!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.opTime != nil {
                    map["OpTime"] = self.opTime!
                }
                if self.requestIp != nil {
                    map["RequestIp"] = self.requestIp!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbUser") {
                    self.dbUser = dict["DbUser"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("OpTime") {
                    self.opTime = dict["OpTime"] as! String
                }
                if dict.keys.contains("RequestIp") {
                    self.requestIp = dict["RequestIp"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! Int64
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public var instanceLoginAuditLog: [ListInstanceLoginAuditLogResponseBody.InstanceLoginAuditLogList.InstanceLoginAuditLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceLoginAuditLog != nil {
                var tmp : [Any] = []
                for k in self.instanceLoginAuditLog! {
                    tmp.append(k.toMap())
                }
                map["InstanceLoginAuditLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceLoginAuditLog") {
                var tmp : [ListInstanceLoginAuditLogResponseBody.InstanceLoginAuditLogList.InstanceLoginAuditLog] = []
                for v in dict["InstanceLoginAuditLog"] as! [Any] {
                    var model = ListInstanceLoginAuditLogResponseBody.InstanceLoginAuditLogList.InstanceLoginAuditLog()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceLoginAuditLog = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var instanceLoginAuditLogList: ListInstanceLoginAuditLogResponseBody.InstanceLoginAuditLogList?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceLoginAuditLogList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.instanceLoginAuditLogList != nil {
            map["InstanceLoginAuditLogList"] = self.instanceLoginAuditLogList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("InstanceLoginAuditLogList") {
            var model = ListInstanceLoginAuditLogResponseBody.InstanceLoginAuditLogList()
            model.fromMap(dict["InstanceLoginAuditLogList"] as! [String: Any])
            self.instanceLoginAuditLogList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListInstanceLoginAuditLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceLoginAuditLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInstanceLoginAuditLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstanceUserPermissionsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var tid: Int64?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class ListInstanceUserPermissionsResponseBody : Tea.TeaModel {
    public class UserPermissions : Tea.TeaModel {
        public class UserPermission : Tea.TeaModel {
            public class PermDetails : Tea.TeaModel {
                public class PermDetail : Tea.TeaModel {
                    public var createDate: String?

                    public var expireDate: String?

                    public var extraData: String?

                    public var originFrom: String?

                    public var permType: String?

                    public var userAccessId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.createDate != nil {
                            map["CreateDate"] = self.createDate!
                        }
                        if self.expireDate != nil {
                            map["ExpireDate"] = self.expireDate!
                        }
                        if self.extraData != nil {
                            map["ExtraData"] = self.extraData!
                        }
                        if self.originFrom != nil {
                            map["OriginFrom"] = self.originFrom!
                        }
                        if self.permType != nil {
                            map["PermType"] = self.permType!
                        }
                        if self.userAccessId != nil {
                            map["UserAccessId"] = self.userAccessId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CreateDate") {
                            self.createDate = dict["CreateDate"] as! String
                        }
                        if dict.keys.contains("ExpireDate") {
                            self.expireDate = dict["ExpireDate"] as! String
                        }
                        if dict.keys.contains("ExtraData") {
                            self.extraData = dict["ExtraData"] as! String
                        }
                        if dict.keys.contains("OriginFrom") {
                            self.originFrom = dict["OriginFrom"] as! String
                        }
                        if dict.keys.contains("PermType") {
                            self.permType = dict["PermType"] as! String
                        }
                        if dict.keys.contains("UserAccessId") {
                            self.userAccessId = dict["UserAccessId"] as! String
                        }
                    }
                }
                public var permDetail: [ListInstanceUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails.PermDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.permDetail != nil {
                        var tmp : [Any] = []
                        for k in self.permDetail! {
                            tmp.append(k.toMap())
                        }
                        map["PermDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PermDetail") {
                        var tmp : [ListInstanceUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails.PermDetail] = []
                        for v in dict["PermDetail"] as! [Any] {
                            var model = ListInstanceUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails.PermDetail()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.permDetail = tmp
                    }
                }
            }
            public var instanceId: String?

            public var permDetails: ListInstanceUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails?

            public var userId: String?

            public var userNickName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.permDetails?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.permDetails != nil {
                    map["PermDetails"] = self.permDetails?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userNickName != nil {
                    map["UserNickName"] = self.userNickName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("PermDetails") {
                    var model = ListInstanceUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails()
                    model.fromMap(dict["PermDetails"] as! [String: Any])
                    self.permDetails = model
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserNickName") {
                    self.userNickName = dict["UserNickName"] as! String
                }
            }
        }
        public var userPermission: [ListInstanceUserPermissionsResponseBody.UserPermissions.UserPermission]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userPermission != nil {
                var tmp : [Any] = []
                for k in self.userPermission! {
                    tmp.append(k.toMap())
                }
                map["UserPermission"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserPermission") {
                var tmp : [ListInstanceUserPermissionsResponseBody.UserPermissions.UserPermission] = []
                for v in dict["UserPermission"] as! [Any] {
                    var model = ListInstanceUserPermissionsResponseBody.UserPermissions.UserPermission()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.userPermission = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public var userPermissions: ListInstanceUserPermissionsResponseBody.UserPermissions?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userPermissions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.userPermissions != nil {
            map["UserPermissions"] = self.userPermissions?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("UserPermissions") {
            var model = ListInstanceUserPermissionsResponseBody.UserPermissions()
            model.fromMap(dict["UserPermissions"] as! [String: Any])
            self.userPermissions = model
        }
    }
}

public class ListInstanceUserPermissionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceUserPermissionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInstanceUserPermissionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstancesRequest : Tea.TeaModel {
    public var dbType: String?

    public var envType: String?

    public var instanceSource: String?

    public var instanceState: String?

    public var netType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchKey: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbType != nil {
            map["DbType"] = self.dbType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.instanceSource != nil {
            map["InstanceSource"] = self.instanceSource!
        }
        if self.instanceState != nil {
            map["InstanceState"] = self.instanceState!
        }
        if self.netType != nil {
            map["NetType"] = self.netType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbType") {
            self.dbType = dict["DbType"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("InstanceSource") {
            self.instanceSource = dict["InstanceSource"] as! String
        }
        if dict.keys.contains("InstanceState") {
            self.instanceState = dict["InstanceState"] as! String
        }
        if dict.keys.contains("NetType") {
            self.netType = dict["NetType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListInstancesResponseBody : Tea.TeaModel {
    public class InstanceList : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public class OwnerIdList : Tea.TeaModel {
                public var ownerIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerIds") {
                        self.ownerIds = dict["OwnerIds"] as! [String]
                    }
                }
            }
            public class OwnerNameList : Tea.TeaModel {
                public var ownerNames: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerNames != nil {
                        map["OwnerNames"] = self.ownerNames!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerNames") {
                        self.ownerNames = dict["OwnerNames"] as! [String]
                    }
                }
            }
            public class StandardGroup : Tea.TeaModel {
                public var groupMode: String?

                public var groupName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.groupMode != nil {
                        map["GroupMode"] = self.groupMode!
                    }
                    if self.groupName != nil {
                        map["GroupName"] = self.groupName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("GroupMode") {
                        self.groupMode = dict["GroupMode"] as! String
                    }
                    if dict.keys.contains("GroupName") {
                        self.groupName = dict["GroupName"] as! String
                    }
                }
            }
            public var dataLinkName: String?

            public var databasePassword: String?

            public var databaseUser: String?

            public var dbaId: String?

            public var dbaNickName: String?

            public var ddlOnline: Int32?

            public var ecsInstanceId: String?

            public var ecsRegion: String?

            public var envType: String?

            public var exportTimeout: Int32?

            public var host: String?

            public var instanceAlias: String?

            public var instanceId: String?

            public var instanceSource: String?

            public var instanceType: String?

            public var ownerIdList: ListInstancesResponseBody.InstanceList.Instance.OwnerIdList?

            public var ownerNameList: ListInstancesResponseBody.InstanceList.Instance.OwnerNameList?

            public var port: Int32?

            public var queryTimeout: Int32?

            public var safeRuleId: String?

            public var sellSitd: Bool?

            public var sid: String?

            public var standardGroup: ListInstancesResponseBody.InstanceList.Instance.StandardGroup?

            public var state: String?

            public var useDsql: Int32?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ownerIdList?.validate()
                try self.ownerNameList?.validate()
                try self.standardGroup?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataLinkName != nil {
                    map["DataLinkName"] = self.dataLinkName!
                }
                if self.databasePassword != nil {
                    map["DatabasePassword"] = self.databasePassword!
                }
                if self.databaseUser != nil {
                    map["DatabaseUser"] = self.databaseUser!
                }
                if self.dbaId != nil {
                    map["DbaId"] = self.dbaId!
                }
                if self.dbaNickName != nil {
                    map["DbaNickName"] = self.dbaNickName!
                }
                if self.ddlOnline != nil {
                    map["DdlOnline"] = self.ddlOnline!
                }
                if self.ecsInstanceId != nil {
                    map["EcsInstanceId"] = self.ecsInstanceId!
                }
                if self.ecsRegion != nil {
                    map["EcsRegion"] = self.ecsRegion!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.exportTimeout != nil {
                    map["ExportTimeout"] = self.exportTimeout!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.instanceAlias != nil {
                    map["InstanceAlias"] = self.instanceAlias!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceSource != nil {
                    map["InstanceSource"] = self.instanceSource!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ownerIdList != nil {
                    map["OwnerIdList"] = self.ownerIdList?.toMap()
                }
                if self.ownerNameList != nil {
                    map["OwnerNameList"] = self.ownerNameList?.toMap()
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.queryTimeout != nil {
                    map["QueryTimeout"] = self.queryTimeout!
                }
                if self.safeRuleId != nil {
                    map["SafeRuleId"] = self.safeRuleId!
                }
                if self.sellSitd != nil {
                    map["SellSitd"] = self.sellSitd!
                }
                if self.sid != nil {
                    map["Sid"] = self.sid!
                }
                if self.standardGroup != nil {
                    map["StandardGroup"] = self.standardGroup?.toMap()
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.useDsql != nil {
                    map["UseDsql"] = self.useDsql!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataLinkName") {
                    self.dataLinkName = dict["DataLinkName"] as! String
                }
                if dict.keys.contains("DatabasePassword") {
                    self.databasePassword = dict["DatabasePassword"] as! String
                }
                if dict.keys.contains("DatabaseUser") {
                    self.databaseUser = dict["DatabaseUser"] as! String
                }
                if dict.keys.contains("DbaId") {
                    self.dbaId = dict["DbaId"] as! String
                }
                if dict.keys.contains("DbaNickName") {
                    self.dbaNickName = dict["DbaNickName"] as! String
                }
                if dict.keys.contains("DdlOnline") {
                    self.ddlOnline = dict["DdlOnline"] as! Int32
                }
                if dict.keys.contains("EcsInstanceId") {
                    self.ecsInstanceId = dict["EcsInstanceId"] as! String
                }
                if dict.keys.contains("EcsRegion") {
                    self.ecsRegion = dict["EcsRegion"] as! String
                }
                if dict.keys.contains("EnvType") {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("ExportTimeout") {
                    self.exportTimeout = dict["ExportTimeout"] as! Int32
                }
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("InstanceAlias") {
                    self.instanceAlias = dict["InstanceAlias"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceSource") {
                    self.instanceSource = dict["InstanceSource"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("OwnerIdList") {
                    var model = ListInstancesResponseBody.InstanceList.Instance.OwnerIdList()
                    model.fromMap(dict["OwnerIdList"] as! [String: Any])
                    self.ownerIdList = model
                }
                if dict.keys.contains("OwnerNameList") {
                    var model = ListInstancesResponseBody.InstanceList.Instance.OwnerNameList()
                    model.fromMap(dict["OwnerNameList"] as! [String: Any])
                    self.ownerNameList = model
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("QueryTimeout") {
                    self.queryTimeout = dict["QueryTimeout"] as! Int32
                }
                if dict.keys.contains("SafeRuleId") {
                    self.safeRuleId = dict["SafeRuleId"] as! String
                }
                if dict.keys.contains("SellSitd") {
                    self.sellSitd = dict["SellSitd"] as! Bool
                }
                if dict.keys.contains("Sid") {
                    self.sid = dict["Sid"] as! String
                }
                if dict.keys.contains("StandardGroup") {
                    var model = ListInstancesResponseBody.InstanceList.Instance.StandardGroup()
                    model.fromMap(dict["StandardGroup"] as! [String: Any])
                    self.standardGroup = model
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("UseDsql") {
                    self.useDsql = dict["UseDsql"] as! Int32
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var instance: [ListInstancesResponseBody.InstanceList.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Instance") {
                var tmp : [ListInstancesResponseBody.InstanceList.Instance] = []
                for v in dict["Instance"] as! [Any] {
                    var model = ListInstancesResponseBody.InstanceList.Instance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instance = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var instanceList: ListInstancesResponseBody.InstanceList?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.instanceList != nil {
            map["InstanceList"] = self.instanceList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("InstanceList") {
            var model = ListInstancesResponseBody.InstanceList()
            model.fromMap(dict["InstanceList"] as! [String: Any])
            self.instanceList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLhTaskFlowAndScenarioRequest : Tea.TeaModel {
    public var spaceId: Int64?

    public var tid: Int64?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SpaceId") {
            self.spaceId = dict["SpaceId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class ListLhTaskFlowAndScenarioResponseBody : Tea.TeaModel {
    public class RawDAGList : Tea.TeaModel {
        public class Dag : Tea.TeaModel {
            public var canEdit: Bool?

            public var creatorId: String?

            public var creatorNickName: String?

            public var dagName: String?

            public var dagOwnerId: String?

            public var dagOwnerNickName: String?

            public var dataFlowId: Int64?

            public var demoId: String?

            public var deployId: Int64?

            public var id: Int64?

            public var isDeleted: Bool?

            public var latestInstanceStatus: Int32?

            public var latestInstanceTime: Int32?

            public var scenarioId: Int64?

            public var spaceId: Int64?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.canEdit != nil {
                    map["CanEdit"] = self.canEdit!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.creatorNickName != nil {
                    map["CreatorNickName"] = self.creatorNickName!
                }
                if self.dagName != nil {
                    map["DagName"] = self.dagName!
                }
                if self.dagOwnerId != nil {
                    map["DagOwnerId"] = self.dagOwnerId!
                }
                if self.dagOwnerNickName != nil {
                    map["DagOwnerNickName"] = self.dagOwnerNickName!
                }
                if self.dataFlowId != nil {
                    map["DataFlowId"] = self.dataFlowId!
                }
                if self.demoId != nil {
                    map["DemoId"] = self.demoId!
                }
                if self.deployId != nil {
                    map["DeployId"] = self.deployId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isDeleted != nil {
                    map["IsDeleted"] = self.isDeleted!
                }
                if self.latestInstanceStatus != nil {
                    map["LatestInstanceStatus"] = self.latestInstanceStatus!
                }
                if self.latestInstanceTime != nil {
                    map["LatestInstanceTime"] = self.latestInstanceTime!
                }
                if self.scenarioId != nil {
                    map["ScenarioId"] = self.scenarioId!
                }
                if self.spaceId != nil {
                    map["SpaceId"] = self.spaceId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CanEdit") {
                    self.canEdit = dict["CanEdit"] as! Bool
                }
                if dict.keys.contains("CreatorId") {
                    self.creatorId = dict["CreatorId"] as! String
                }
                if dict.keys.contains("CreatorNickName") {
                    self.creatorNickName = dict["CreatorNickName"] as! String
                }
                if dict.keys.contains("DagName") {
                    self.dagName = dict["DagName"] as! String
                }
                if dict.keys.contains("DagOwnerId") {
                    self.dagOwnerId = dict["DagOwnerId"] as! String
                }
                if dict.keys.contains("DagOwnerNickName") {
                    self.dagOwnerNickName = dict["DagOwnerNickName"] as! String
                }
                if dict.keys.contains("DataFlowId") {
                    self.dataFlowId = dict["DataFlowId"] as! Int64
                }
                if dict.keys.contains("DemoId") {
                    self.demoId = dict["DemoId"] as! String
                }
                if dict.keys.contains("DeployId") {
                    self.deployId = dict["DeployId"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IsDeleted") {
                    self.isDeleted = dict["IsDeleted"] as! Bool
                }
                if dict.keys.contains("LatestInstanceStatus") {
                    self.latestInstanceStatus = dict["LatestInstanceStatus"] as! Int32
                }
                if dict.keys.contains("LatestInstanceTime") {
                    self.latestInstanceTime = dict["LatestInstanceTime"] as! Int32
                }
                if dict.keys.contains("ScenarioId") {
                    self.scenarioId = dict["ScenarioId"] as! Int64
                }
                if dict.keys.contains("SpaceId") {
                    self.spaceId = dict["SpaceId"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public var dag: [ListLhTaskFlowAndScenarioResponseBody.RawDAGList.Dag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dag != nil {
                var tmp : [Any] = []
                for k in self.dag! {
                    tmp.append(k.toMap())
                }
                map["Dag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Dag") {
                var tmp : [ListLhTaskFlowAndScenarioResponseBody.RawDAGList.Dag] = []
                for v in dict["Dag"] as! [Any] {
                    var model = ListLhTaskFlowAndScenarioResponseBody.RawDAGList.Dag()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dag = tmp
            }
        }
    }
    public class ScenarioDAGList : Tea.TeaModel {
        public class ScenarioDAG : Tea.TeaModel {
            public class DagList : Tea.TeaModel {
                public class Dag : Tea.TeaModel {
                    public var canEdit: Bool?

                    public var creatorId: String?

                    public var creatorNickName: String?

                    public var dagName: String?

                    public var dagOwnerId: String?

                    public var dagOwnerNickName: String?

                    public var dataFlowId: Int64?

                    public var demoId: String?

                    public var deployId: Int64?

                    public var id: Int64?

                    public var isDeleted: Bool?

                    public var latestInstanceStatus: Int32?

                    public var latestInstanceTime: Int32?

                    public var scenarioId: Int64?

                    public var spaceId: Int64?

                    public var status: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.canEdit != nil {
                            map["CanEdit"] = self.canEdit!
                        }
                        if self.creatorId != nil {
                            map["CreatorId"] = self.creatorId!
                        }
                        if self.creatorNickName != nil {
                            map["CreatorNickName"] = self.creatorNickName!
                        }
                        if self.dagName != nil {
                            map["DagName"] = self.dagName!
                        }
                        if self.dagOwnerId != nil {
                            map["DagOwnerId"] = self.dagOwnerId!
                        }
                        if self.dagOwnerNickName != nil {
                            map["DagOwnerNickName"] = self.dagOwnerNickName!
                        }
                        if self.dataFlowId != nil {
                            map["DataFlowId"] = self.dataFlowId!
                        }
                        if self.demoId != nil {
                            map["DemoId"] = self.demoId!
                        }
                        if self.deployId != nil {
                            map["DeployId"] = self.deployId!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.isDeleted != nil {
                            map["IsDeleted"] = self.isDeleted!
                        }
                        if self.latestInstanceStatus != nil {
                            map["LatestInstanceStatus"] = self.latestInstanceStatus!
                        }
                        if self.latestInstanceTime != nil {
                            map["LatestInstanceTime"] = self.latestInstanceTime!
                        }
                        if self.scenarioId != nil {
                            map["ScenarioId"] = self.scenarioId!
                        }
                        if self.spaceId != nil {
                            map["SpaceId"] = self.spaceId!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CanEdit") {
                            self.canEdit = dict["CanEdit"] as! Bool
                        }
                        if dict.keys.contains("CreatorId") {
                            self.creatorId = dict["CreatorId"] as! String
                        }
                        if dict.keys.contains("CreatorNickName") {
                            self.creatorNickName = dict["CreatorNickName"] as! String
                        }
                        if dict.keys.contains("DagName") {
                            self.dagName = dict["DagName"] as! String
                        }
                        if dict.keys.contains("DagOwnerId") {
                            self.dagOwnerId = dict["DagOwnerId"] as! String
                        }
                        if dict.keys.contains("DagOwnerNickName") {
                            self.dagOwnerNickName = dict["DagOwnerNickName"] as! String
                        }
                        if dict.keys.contains("DataFlowId") {
                            self.dataFlowId = dict["DataFlowId"] as! Int64
                        }
                        if dict.keys.contains("DemoId") {
                            self.demoId = dict["DemoId"] as! String
                        }
                        if dict.keys.contains("DeployId") {
                            self.deployId = dict["DeployId"] as! Int64
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! Int64
                        }
                        if dict.keys.contains("IsDeleted") {
                            self.isDeleted = dict["IsDeleted"] as! Bool
                        }
                        if dict.keys.contains("LatestInstanceStatus") {
                            self.latestInstanceStatus = dict["LatestInstanceStatus"] as! Int32
                        }
                        if dict.keys.contains("LatestInstanceTime") {
                            self.latestInstanceTime = dict["LatestInstanceTime"] as! Int32
                        }
                        if dict.keys.contains("ScenarioId") {
                            self.scenarioId = dict["ScenarioId"] as! Int64
                        }
                        if dict.keys.contains("SpaceId") {
                            self.spaceId = dict["SpaceId"] as! Int64
                        }
                        if dict.keys.contains("Status") {
                            self.status = dict["Status"] as! Int32
                        }
                    }
                }
                public var dag: [ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG.DagList.Dag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dag != nil {
                        var tmp : [Any] = []
                        for k in self.dag! {
                            tmp.append(k.toMap())
                        }
                        map["Dag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Dag") {
                        var tmp : [ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG.DagList.Dag] = []
                        for v in dict["Dag"] as! [Any] {
                            var model = ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG.DagList.Dag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dag = tmp
                    }
                }
            }
            public class Scenario : Tea.TeaModel {
                public var creatorId: String?

                public var description_: String?

                public var scenarioName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.creatorId != nil {
                        map["CreatorId"] = self.creatorId!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.scenarioName != nil {
                        map["ScenarioName"] = self.scenarioName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CreatorId") {
                        self.creatorId = dict["CreatorId"] as! String
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("ScenarioName") {
                        self.scenarioName = dict["ScenarioName"] as! String
                    }
                }
            }
            public var dagList: ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG.DagList?

            public var scenario: ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG.Scenario?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dagList?.validate()
                try self.scenario?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dagList != nil {
                    map["DagList"] = self.dagList?.toMap()
                }
                if self.scenario != nil {
                    map["Scenario"] = self.scenario?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DagList") {
                    var model = ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG.DagList()
                    model.fromMap(dict["DagList"] as! [String: Any])
                    self.dagList = model
                }
                if dict.keys.contains("Scenario") {
                    var model = ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG.Scenario()
                    model.fromMap(dict["Scenario"] as! [String: Any])
                    self.scenario = model
                }
            }
        }
        public var scenarioDAG: [ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.scenarioDAG != nil {
                var tmp : [Any] = []
                for k in self.scenarioDAG! {
                    tmp.append(k.toMap())
                }
                map["ScenarioDAG"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ScenarioDAG") {
                var tmp : [ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG] = []
                for v in dict["ScenarioDAG"] as! [Any] {
                    var model = ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.scenarioDAG = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var rawDAGList: ListLhTaskFlowAndScenarioResponseBody.RawDAGList?

    public var requestId: String?

    public var scenarioDAGList: ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.rawDAGList?.validate()
        try self.scenarioDAGList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.rawDAGList != nil {
            map["RawDAGList"] = self.rawDAGList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scenarioDAGList != nil {
            map["ScenarioDAGList"] = self.scenarioDAGList?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RawDAGList") {
            var model = ListLhTaskFlowAndScenarioResponseBody.RawDAGList()
            model.fromMap(dict["RawDAGList"] as! [String: Any])
            self.rawDAGList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScenarioDAGList") {
            var model = ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList()
            model.fromMap(dict["ScenarioDAGList"] as! [String: Any])
            self.scenarioDAGList = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListLhTaskFlowAndScenarioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLhTaskFlowAndScenarioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLhTaskFlowAndScenarioResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLogicDatabasesRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListLogicDatabasesResponseBody : Tea.TeaModel {
    public class LogicDatabaseList : Tea.TeaModel {
        public class LogicDatabase : Tea.TeaModel {
            public class DatabaseIds : Tea.TeaModel {
                public var databaseIds: [Int64]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.databaseIds != nil {
                        map["DatabaseIds"] = self.databaseIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DatabaseIds") {
                        self.databaseIds = dict["DatabaseIds"] as! [Int64]
                    }
                }
            }
            public class OwnerIdList : Tea.TeaModel {
                public var ownerIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerIds") {
                        self.ownerIds = dict["OwnerIds"] as! [String]
                    }
                }
            }
            public class OwnerNameList : Tea.TeaModel {
                public var ownerNames: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerNames != nil {
                        map["OwnerNames"] = self.ownerNames!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerNames") {
                        self.ownerNames = dict["OwnerNames"] as! [String]
                    }
                }
            }
            public var alias: String?

            public var databaseId: String?

            public var databaseIds: ListLogicDatabasesResponseBody.LogicDatabaseList.LogicDatabase.DatabaseIds?

            public var dbType: String?

            public var envType: String?

            public var logic: Bool?

            public var ownerIdList: ListLogicDatabasesResponseBody.LogicDatabaseList.LogicDatabase.OwnerIdList?

            public var ownerNameList: ListLogicDatabasesResponseBody.LogicDatabaseList.LogicDatabase.OwnerNameList?

            public var schemaName: String?

            public var searchName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.databaseIds?.validate()
                try self.ownerIdList?.validate()
                try self.ownerNameList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.databaseId != nil {
                    map["DatabaseId"] = self.databaseId!
                }
                if self.databaseIds != nil {
                    map["DatabaseIds"] = self.databaseIds?.toMap()
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.ownerIdList != nil {
                    map["OwnerIdList"] = self.ownerIdList?.toMap()
                }
                if self.ownerNameList != nil {
                    map["OwnerNameList"] = self.ownerNameList?.toMap()
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("DatabaseId") {
                    self.databaseId = dict["DatabaseId"] as! String
                }
                if dict.keys.contains("DatabaseIds") {
                    var model = ListLogicDatabasesResponseBody.LogicDatabaseList.LogicDatabase.DatabaseIds()
                    model.fromMap(dict["DatabaseIds"] as! [String: Any])
                    self.databaseIds = model
                }
                if dict.keys.contains("DbType") {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("EnvType") {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("OwnerIdList") {
                    var model = ListLogicDatabasesResponseBody.LogicDatabaseList.LogicDatabase.OwnerIdList()
                    model.fromMap(dict["OwnerIdList"] as! [String: Any])
                    self.ownerIdList = model
                }
                if dict.keys.contains("OwnerNameList") {
                    var model = ListLogicDatabasesResponseBody.LogicDatabaseList.LogicDatabase.OwnerNameList()
                    model.fromMap(dict["OwnerNameList"] as! [String: Any])
                    self.ownerNameList = model
                }
                if dict.keys.contains("SchemaName") {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SearchName") {
                    self.searchName = dict["SearchName"] as! String
                }
            }
        }
        public var logicDatabase: [ListLogicDatabasesResponseBody.LogicDatabaseList.LogicDatabase]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logicDatabase != nil {
                var tmp : [Any] = []
                for k in self.logicDatabase! {
                    tmp.append(k.toMap())
                }
                map["LogicDatabase"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LogicDatabase") {
                var tmp : [ListLogicDatabasesResponseBody.LogicDatabaseList.LogicDatabase] = []
                for v in dict["LogicDatabase"] as! [Any] {
                    var model = ListLogicDatabasesResponseBody.LogicDatabaseList.LogicDatabase()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logicDatabase = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var logicDatabaseList: ListLogicDatabasesResponseBody.LogicDatabaseList?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logicDatabaseList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.logicDatabaseList != nil {
            map["LogicDatabaseList"] = self.logicDatabaseList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("LogicDatabaseList") {
            var model = ListLogicDatabasesResponseBody.LogicDatabaseList()
            model.fromMap(dict["LogicDatabaseList"] as! [String: Any])
            self.logicDatabaseList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLogicDatabasesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLogicDatabasesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLogicDatabasesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLogicTableRouteConfigRequest : Tea.TeaModel {
    public var tableId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TableId") {
            self.tableId = dict["TableId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListLogicTableRouteConfigResponseBody : Tea.TeaModel {
    public class LogicTableRouteConfigList : Tea.TeaModel {
        public class LogicTableRouteConfig : Tea.TeaModel {
            public var routeExpr: String?

            public var routeKey: String?

            public var tableId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.routeExpr != nil {
                    map["RouteExpr"] = self.routeExpr!
                }
                if self.routeKey != nil {
                    map["RouteKey"] = self.routeKey!
                }
                if self.tableId != nil {
                    map["TableId"] = self.tableId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RouteExpr") {
                    self.routeExpr = dict["RouteExpr"] as! String
                }
                if dict.keys.contains("RouteKey") {
                    self.routeKey = dict["RouteKey"] as! String
                }
                if dict.keys.contains("TableId") {
                    self.tableId = dict["TableId"] as! Int64
                }
            }
        }
        public var logicTableRouteConfig: [ListLogicTableRouteConfigResponseBody.LogicTableRouteConfigList.LogicTableRouteConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logicTableRouteConfig != nil {
                var tmp : [Any] = []
                for k in self.logicTableRouteConfig! {
                    tmp.append(k.toMap())
                }
                map["LogicTableRouteConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LogicTableRouteConfig") {
                var tmp : [ListLogicTableRouteConfigResponseBody.LogicTableRouteConfigList.LogicTableRouteConfig] = []
                for v in dict["LogicTableRouteConfig"] as! [Any] {
                    var model = ListLogicTableRouteConfigResponseBody.LogicTableRouteConfigList.LogicTableRouteConfig()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logicTableRouteConfig = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var logicTableRouteConfigList: ListLogicTableRouteConfigResponseBody.LogicTableRouteConfigList?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logicTableRouteConfigList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.logicTableRouteConfigList != nil {
            map["LogicTableRouteConfigList"] = self.logicTableRouteConfigList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("LogicTableRouteConfigList") {
            var model = ListLogicTableRouteConfigResponseBody.LogicTableRouteConfigList()
            model.fromMap(dict["LogicTableRouteConfigList"] as! [String: Any])
            self.logicTableRouteConfigList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListLogicTableRouteConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLogicTableRouteConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLogicTableRouteConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLogicTablesRequest : Tea.TeaModel {
    public var databaseId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var returnGuid: Bool?

    public var searchName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseId != nil {
            map["DatabaseId"] = self.databaseId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.returnGuid != nil {
            map["ReturnGuid"] = self.returnGuid!
        }
        if self.searchName != nil {
            map["SearchName"] = self.searchName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseId") {
            self.databaseId = dict["DatabaseId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ReturnGuid") {
            self.returnGuid = dict["ReturnGuid"] as! Bool
        }
        if dict.keys.contains("SearchName") {
            self.searchName = dict["SearchName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListLogicTablesResponseBody : Tea.TeaModel {
    public class LogicTableList : Tea.TeaModel {
        public class LogicTable : Tea.TeaModel {
            public class OwnerIdList : Tea.TeaModel {
                public var ownerIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerIds") {
                        self.ownerIds = dict["OwnerIds"] as! [String]
                    }
                }
            }
            public class OwnerNameList : Tea.TeaModel {
                public var ownerNames: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerNames != nil {
                        map["OwnerNames"] = self.ownerNames!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerNames") {
                        self.ownerNames = dict["OwnerNames"] as! [String]
                    }
                }
            }
            public var databaseId: String?

            public var logic: Bool?

            public var ownerIdList: ListLogicTablesResponseBody.LogicTableList.LogicTable.OwnerIdList?

            public var ownerNameList: ListLogicTablesResponseBody.LogicTableList.LogicTable.OwnerNameList?

            public var schemaName: String?

            public var tableCount: String?

            public var tableExpr: String?

            public var tableGuid: String?

            public var tableId: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ownerIdList?.validate()
                try self.ownerNameList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseId != nil {
                    map["DatabaseId"] = self.databaseId!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.ownerIdList != nil {
                    map["OwnerIdList"] = self.ownerIdList?.toMap()
                }
                if self.ownerNameList != nil {
                    map["OwnerNameList"] = self.ownerNameList?.toMap()
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.tableCount != nil {
                    map["TableCount"] = self.tableCount!
                }
                if self.tableExpr != nil {
                    map["TableExpr"] = self.tableExpr!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.tableId != nil {
                    map["TableId"] = self.tableId!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DatabaseId") {
                    self.databaseId = dict["DatabaseId"] as! String
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("OwnerIdList") {
                    var model = ListLogicTablesResponseBody.LogicTableList.LogicTable.OwnerIdList()
                    model.fromMap(dict["OwnerIdList"] as! [String: Any])
                    self.ownerIdList = model
                }
                if dict.keys.contains("OwnerNameList") {
                    var model = ListLogicTablesResponseBody.LogicTableList.LogicTable.OwnerNameList()
                    model.fromMap(dict["OwnerNameList"] as! [String: Any])
                    self.ownerNameList = model
                }
                if dict.keys.contains("SchemaName") {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("TableCount") {
                    self.tableCount = dict["TableCount"] as! String
                }
                if dict.keys.contains("TableExpr") {
                    self.tableExpr = dict["TableExpr"] as! String
                }
                if dict.keys.contains("TableGuid") {
                    self.tableGuid = dict["TableGuid"] as! String
                }
                if dict.keys.contains("TableId") {
                    self.tableId = dict["TableId"] as! String
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public var logicTable: [ListLogicTablesResponseBody.LogicTableList.LogicTable]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logicTable != nil {
                var tmp : [Any] = []
                for k in self.logicTable! {
                    tmp.append(k.toMap())
                }
                map["LogicTable"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LogicTable") {
                var tmp : [ListLogicTablesResponseBody.LogicTableList.LogicTable] = []
                for v in dict["LogicTable"] as! [Any] {
                    var model = ListLogicTablesResponseBody.LogicTableList.LogicTable()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logicTable = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var logicTableList: ListLogicTablesResponseBody.LogicTableList?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logicTableList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.logicTableList != nil {
            map["LogicTableList"] = self.logicTableList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("LogicTableList") {
            var model = ListLogicTablesResponseBody.LogicTableList()
            model.fromMap(dict["LogicTableList"] as! [String: Any])
            self.logicTableList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLogicTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLogicTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLogicTablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListOrdersRequest : Tea.TeaModel {
    public var endTime: String?

    public var orderResultType: String?

    public var orderStatus: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var pluginType: String?

    public var searchContent: String?

    public var searchDateType: String?

    public var startTime: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.orderResultType != nil {
            map["OrderResultType"] = self.orderResultType!
        }
        if self.orderStatus != nil {
            map["OrderStatus"] = self.orderStatus!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pluginType != nil {
            map["PluginType"] = self.pluginType!
        }
        if self.searchContent != nil {
            map["SearchContent"] = self.searchContent!
        }
        if self.searchDateType != nil {
            map["SearchDateType"] = self.searchDateType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OrderResultType") {
            self.orderResultType = dict["OrderResultType"] as! String
        }
        if dict.keys.contains("OrderStatus") {
            self.orderStatus = dict["OrderStatus"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PluginType") {
            self.pluginType = dict["PluginType"] as! String
        }
        if dict.keys.contains("SearchContent") {
            self.searchContent = dict["SearchContent"] as! String
        }
        if dict.keys.contains("SearchDateType") {
            self.searchDateType = dict["SearchDateType"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListOrdersResponseBody : Tea.TeaModel {
    public class Orders : Tea.TeaModel {
        public class Order : Tea.TeaModel {
            public var comment: String?

            public var committer: String?

            public var committerId: Int64?

            public var createTime: String?

            public var lastModifyTime: String?

            public var orderId: Int64?

            public var pluginType: String?

            public var statusCode: String?

            public var statusDesc: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.committer != nil {
                    map["Committer"] = self.committer!
                }
                if self.committerId != nil {
                    map["CommitterId"] = self.committerId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.lastModifyTime != nil {
                    map["LastModifyTime"] = self.lastModifyTime!
                }
                if self.orderId != nil {
                    map["OrderId"] = self.orderId!
                }
                if self.pluginType != nil {
                    map["PluginType"] = self.pluginType!
                }
                if self.statusCode != nil {
                    map["StatusCode"] = self.statusCode!
                }
                if self.statusDesc != nil {
                    map["StatusDesc"] = self.statusDesc!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Comment") {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("Committer") {
                    self.committer = dict["Committer"] as! String
                }
                if dict.keys.contains("CommitterId") {
                    self.committerId = dict["CommitterId"] as! Int64
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("LastModifyTime") {
                    self.lastModifyTime = dict["LastModifyTime"] as! String
                }
                if dict.keys.contains("OrderId") {
                    self.orderId = dict["OrderId"] as! Int64
                }
                if dict.keys.contains("PluginType") {
                    self.pluginType = dict["PluginType"] as! String
                }
                if dict.keys.contains("StatusCode") {
                    self.statusCode = dict["StatusCode"] as! String
                }
                if dict.keys.contains("StatusDesc") {
                    self.statusDesc = dict["StatusDesc"] as! String
                }
            }
        }
        public var order: [ListOrdersResponseBody.Orders.Order]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.order != nil {
                var tmp : [Any] = []
                for k in self.order! {
                    tmp.append(k.toMap())
                }
                map["Order"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Order") {
                var tmp : [ListOrdersResponseBody.Orders.Order] = []
                for v in dict["Order"] as! [Any] {
                    var model = ListOrdersResponseBody.Orders.Order()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.order = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var orders: ListOrdersResponseBody.Orders?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.orders?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.orders != nil {
            map["Orders"] = self.orders?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("Orders") {
            var model = ListOrdersResponseBody.Orders()
            model.fromMap(dict["Orders"] as! [String: Any])
            self.orders = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListOrdersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListOrdersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListOrdersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProxiesRequest : Tea.TeaModel {
    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListProxiesResponseBody : Tea.TeaModel {
    public class ProxyList : Tea.TeaModel {
        public var creatorId: Int64?

        public var creatorName: String?

        public var httpsPort: Int32?

        public var instanceId: Int64?

        public var privateEnable: Bool?

        public var privateHost: String?

        public var protocolPort: Int32?

        public var protocolType: String?

        public var proxyId: Int64?

        public var publicEnable: Bool?

        public var publicHost: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.creatorName != nil {
                map["CreatorName"] = self.creatorName!
            }
            if self.httpsPort != nil {
                map["HttpsPort"] = self.httpsPort!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.privateEnable != nil {
                map["PrivateEnable"] = self.privateEnable!
            }
            if self.privateHost != nil {
                map["PrivateHost"] = self.privateHost!
            }
            if self.protocolPort != nil {
                map["ProtocolPort"] = self.protocolPort!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.proxyId != nil {
                map["ProxyId"] = self.proxyId!
            }
            if self.publicEnable != nil {
                map["PublicEnable"] = self.publicEnable!
            }
            if self.publicHost != nil {
                map["PublicHost"] = self.publicHost!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! Int64
            }
            if dict.keys.contains("CreatorName") {
                self.creatorName = dict["CreatorName"] as! String
            }
            if dict.keys.contains("HttpsPort") {
                self.httpsPort = dict["HttpsPort"] as! Int32
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("PrivateEnable") {
                self.privateEnable = dict["PrivateEnable"] as! Bool
            }
            if dict.keys.contains("PrivateHost") {
                self.privateHost = dict["PrivateHost"] as! String
            }
            if dict.keys.contains("ProtocolPort") {
                self.protocolPort = dict["ProtocolPort"] as! Int32
            }
            if dict.keys.contains("ProtocolType") {
                self.protocolType = dict["ProtocolType"] as! String
            }
            if dict.keys.contains("ProxyId") {
                self.proxyId = dict["ProxyId"] as! Int64
            }
            if dict.keys.contains("PublicEnable") {
                self.publicEnable = dict["PublicEnable"] as! Bool
            }
            if dict.keys.contains("PublicHost") {
                self.publicHost = dict["PublicHost"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var proxyList: [ListProxiesResponseBody.ProxyList]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.proxyList != nil {
            var tmp : [Any] = []
            for k in self.proxyList! {
                tmp.append(k.toMap())
            }
            map["ProxyList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("ProxyList") {
            var tmp : [ListProxiesResponseBody.ProxyList] = []
            for v in dict["ProxyList"] as! [Any] {
                var model = ListProxiesResponseBody.ProxyList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.proxyList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListProxiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProxiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProxiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProxyAccessesRequest : Tea.TeaModel {
    public var proxyId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.proxyId != nil {
            map["ProxyId"] = self.proxyId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProxyId") {
            self.proxyId = dict["ProxyId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListProxyAccessesResponseBody : Tea.TeaModel {
    public class ProxyAccessList : Tea.TeaModel {
        public var accessId: String?

        public var gmtCreate: String?

        public var indepAccount: String?

        public var instanceId: Int64?

        public var originInfo: String?

        public var proxyAccessId: Int64?

        public var proxyId: Int64?

        public var userId: Int64?

        public var userName: String?

        public var userUid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessId != nil {
                map["AccessId"] = self.accessId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.indepAccount != nil {
                map["IndepAccount"] = self.indepAccount!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.originInfo != nil {
                map["OriginInfo"] = self.originInfo!
            }
            if self.proxyAccessId != nil {
                map["ProxyAccessId"] = self.proxyAccessId!
            }
            if self.proxyId != nil {
                map["ProxyId"] = self.proxyId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.userUid != nil {
                map["UserUid"] = self.userUid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessId") {
                self.accessId = dict["AccessId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("IndepAccount") {
                self.indepAccount = dict["IndepAccount"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("OriginInfo") {
                self.originInfo = dict["OriginInfo"] as! String
            }
            if dict.keys.contains("ProxyAccessId") {
                self.proxyAccessId = dict["ProxyAccessId"] as! Int64
            }
            if dict.keys.contains("ProxyId") {
                self.proxyId = dict["ProxyId"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! Int64
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("UserUid") {
                self.userUid = dict["UserUid"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var proxyAccessList: [ListProxyAccessesResponseBody.ProxyAccessList]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.proxyAccessList != nil {
            var tmp : [Any] = []
            for k in self.proxyAccessList! {
                tmp.append(k.toMap())
            }
            map["ProxyAccessList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("ProxyAccessList") {
            var tmp : [ListProxyAccessesResponseBody.ProxyAccessList] = []
            for v in dict["ProxyAccessList"] as! [Any] {
                var model = ListProxyAccessesResponseBody.ProxyAccessList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.proxyAccessList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListProxyAccessesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProxyAccessesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProxyAccessesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProxySQLExecAuditLogRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var execState: String?

    public var opUserName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var SQLType: String?

    public var searchName: String?

    public var startTime: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.execState != nil {
            map["ExecState"] = self.execState!
        }
        if self.opUserName != nil {
            map["OpUserName"] = self.opUserName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.SQLType != nil {
            map["SQLType"] = self.SQLType!
        }
        if self.searchName != nil {
            map["SearchName"] = self.searchName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ExecState") {
            self.execState = dict["ExecState"] as! String
        }
        if dict.keys.contains("OpUserName") {
            self.opUserName = dict["OpUserName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SQLType") {
            self.SQLType = dict["SQLType"] as! String
        }
        if dict.keys.contains("SearchName") {
            self.searchName = dict["SearchName"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListProxySQLExecAuditLogResponseBody : Tea.TeaModel {
    public class ProxySQLExecAuditLogList : Tea.TeaModel {
        public class ProxySQLExecAuditLog : Tea.TeaModel {
            public var affectRows: Int64?

            public var elapsedTime: Int64?

            public var execState: String?

            public var instanceId: Int64?

            public var instanceName: String?

            public var opTime: String?

            public var remark: String?

            public var SQL: String?

            public var SQLType: String?

            public var schemaName: String?

            public var userId: Int64?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.affectRows != nil {
                    map["AffectRows"] = self.affectRows!
                }
                if self.elapsedTime != nil {
                    map["ElapsedTime"] = self.elapsedTime!
                }
                if self.execState != nil {
                    map["ExecState"] = self.execState!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.opTime != nil {
                    map["OpTime"] = self.opTime!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.SQL != nil {
                    map["SQL"] = self.SQL!
                }
                if self.SQLType != nil {
                    map["SQLType"] = self.SQLType!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AffectRows") {
                    self.affectRows = dict["AffectRows"] as! Int64
                }
                if dict.keys.contains("ElapsedTime") {
                    self.elapsedTime = dict["ElapsedTime"] as! Int64
                }
                if dict.keys.contains("ExecState") {
                    self.execState = dict["ExecState"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("OpTime") {
                    self.opTime = dict["OpTime"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("SQL") {
                    self.SQL = dict["SQL"] as! String
                }
                if dict.keys.contains("SQLType") {
                    self.SQLType = dict["SQLType"] as! String
                }
                if dict.keys.contains("SchemaName") {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! Int64
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public var proxySQLExecAuditLog: [ListProxySQLExecAuditLogResponseBody.ProxySQLExecAuditLogList.ProxySQLExecAuditLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.proxySQLExecAuditLog != nil {
                var tmp : [Any] = []
                for k in self.proxySQLExecAuditLog! {
                    tmp.append(k.toMap())
                }
                map["ProxySQLExecAuditLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ProxySQLExecAuditLog") {
                var tmp : [ListProxySQLExecAuditLogResponseBody.ProxySQLExecAuditLogList.ProxySQLExecAuditLog] = []
                for v in dict["ProxySQLExecAuditLog"] as! [Any] {
                    var model = ListProxySQLExecAuditLogResponseBody.ProxySQLExecAuditLogList.ProxySQLExecAuditLog()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.proxySQLExecAuditLog = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var proxySQLExecAuditLogList: ListProxySQLExecAuditLogResponseBody.ProxySQLExecAuditLogList?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.proxySQLExecAuditLogList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.proxySQLExecAuditLogList != nil {
            map["ProxySQLExecAuditLogList"] = self.proxySQLExecAuditLogList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("ProxySQLExecAuditLogList") {
            var model = ListProxySQLExecAuditLogResponseBody.ProxySQLExecAuditLogList()
            model.fromMap(dict["ProxySQLExecAuditLogList"] as! [String: Any])
            self.proxySQLExecAuditLogList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListProxySQLExecAuditLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProxySQLExecAuditLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProxySQLExecAuditLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSLARulesRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListSLARulesResponseBody : Tea.TeaModel {
    public class SLARuleList : Tea.TeaModel {
        public class SLARule : Tea.TeaModel {
            public var dagId: Int64?

            public var id: Int64?

            public var intervalMinutes: Int32?

            public var nodeId: Int64?

            public var ruleType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dagId != nil {
                    map["DagId"] = self.dagId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.intervalMinutes != nil {
                    map["IntervalMinutes"] = self.intervalMinutes!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.ruleType != nil {
                    map["RuleType"] = self.ruleType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DagId") {
                    self.dagId = dict["DagId"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IntervalMinutes") {
                    self.intervalMinutes = dict["IntervalMinutes"] as! Int32
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("RuleType") {
                    self.ruleType = dict["RuleType"] as! Int32
                }
            }
        }
        public var SLARule: [ListSLARulesResponseBody.SLARuleList.SLARule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.SLARule != nil {
                var tmp : [Any] = []
                for k in self.SLARule! {
                    tmp.append(k.toMap())
                }
                map["SLARule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SLARule") {
                var tmp : [ListSLARulesResponseBody.SLARuleList.SLARule] = []
                for v in dict["SLARule"] as! [Any] {
                    var model = ListSLARulesResponseBody.SLARuleList.SLARule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.SLARule = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var SLARuleList: ListSLARulesResponseBody.SLARuleList?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.SLARuleList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SLARuleList != nil {
            map["SLARuleList"] = self.SLARuleList?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SLARuleList") {
            var model = ListSLARulesResponseBody.SLARuleList()
            model.fromMap(dict["SLARuleList"] as! [String: Any])
            self.SLARuleList = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSLARulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSLARulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSLARulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSQLExecAuditLogRequest : Tea.TeaModel {
    public var endTime: String?

    public var execState: String?

    public var opUserName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchName: String?

    public var sqlType: String?

    public var startTime: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.execState != nil {
            map["ExecState"] = self.execState!
        }
        if self.opUserName != nil {
            map["OpUserName"] = self.opUserName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchName != nil {
            map["SearchName"] = self.searchName!
        }
        if self.sqlType != nil {
            map["SqlType"] = self.sqlType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("ExecState") {
            self.execState = dict["ExecState"] as! String
        }
        if dict.keys.contains("OpUserName") {
            self.opUserName = dict["OpUserName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchName") {
            self.searchName = dict["SearchName"] as! String
        }
        if dict.keys.contains("SqlType") {
            self.sqlType = dict["SqlType"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListSQLExecAuditLogResponseBody : Tea.TeaModel {
    public class SQLExecAuditLogList : Tea.TeaModel {
        public class SQLExecAuditLog : Tea.TeaModel {
            public var affectRows: Int64?

            public var dbId: Int64?

            public var elapsedTime: Int64?

            public var execState: String?

            public var instanceId: Int64?

            public var instanceName: String?

            public var logic: Bool?

            public var opTime: String?

            public var remark: String?

            public var SQL: String?

            public var SQLType: String?

            public var schemaName: String?

            public var userId: Int64?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.affectRows != nil {
                    map["AffectRows"] = self.affectRows!
                }
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.elapsedTime != nil {
                    map["ElapsedTime"] = self.elapsedTime!
                }
                if self.execState != nil {
                    map["ExecState"] = self.execState!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.opTime != nil {
                    map["OpTime"] = self.opTime!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.SQL != nil {
                    map["SQL"] = self.SQL!
                }
                if self.SQLType != nil {
                    map["SQLType"] = self.SQLType!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AffectRows") {
                    self.affectRows = dict["AffectRows"] as! Int64
                }
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("ElapsedTime") {
                    self.elapsedTime = dict["ElapsedTime"] as! Int64
                }
                if dict.keys.contains("ExecState") {
                    self.execState = dict["ExecState"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("OpTime") {
                    self.opTime = dict["OpTime"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("SQL") {
                    self.SQL = dict["SQL"] as! String
                }
                if dict.keys.contains("SQLType") {
                    self.SQLType = dict["SQLType"] as! String
                }
                if dict.keys.contains("SchemaName") {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! Int64
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public var SQLExecAuditLog: [ListSQLExecAuditLogResponseBody.SQLExecAuditLogList.SQLExecAuditLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.SQLExecAuditLog != nil {
                var tmp : [Any] = []
                for k in self.SQLExecAuditLog! {
                    tmp.append(k.toMap())
                }
                map["SQLExecAuditLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SQLExecAuditLog") {
                var tmp : [ListSQLExecAuditLogResponseBody.SQLExecAuditLogList.SQLExecAuditLog] = []
                for v in dict["SQLExecAuditLog"] as! [Any] {
                    var model = ListSQLExecAuditLogResponseBody.SQLExecAuditLogList.SQLExecAuditLog()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.SQLExecAuditLog = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var SQLExecAuditLogList: ListSQLExecAuditLogResponseBody.SQLExecAuditLogList?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.SQLExecAuditLogList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SQLExecAuditLogList != nil {
            map["SQLExecAuditLogList"] = self.SQLExecAuditLogList?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SQLExecAuditLogList") {
            var model = ListSQLExecAuditLogResponseBody.SQLExecAuditLogList()
            model.fromMap(dict["SQLExecAuditLogList"] as! [String: Any])
            self.SQLExecAuditLogList = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListSQLExecAuditLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSQLExecAuditLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSQLExecAuditLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSQLReviewOriginSQLRequest : Tea.TeaModel {
    public class OrderActionDetail : Tea.TeaModel {
        public class Page : Tea.TeaModel {
            public var pageNumber: Int32?

            public var pageSize: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PageNumber") {
                    self.pageNumber = dict["PageNumber"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
            }
        }
        public var checkStatusResult: String?

        public var fileId: Int64?

        public var page: ListSQLReviewOriginSQLRequest.OrderActionDetail.Page?

        public var SQLReviewResult: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.page?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkStatusResult != nil {
                map["CheckStatusResult"] = self.checkStatusResult!
            }
            if self.fileId != nil {
                map["FileId"] = self.fileId!
            }
            if self.page != nil {
                map["Page"] = self.page?.toMap()
            }
            if self.SQLReviewResult != nil {
                map["SQLReviewResult"] = self.SQLReviewResult!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckStatusResult") {
                self.checkStatusResult = dict["CheckStatusResult"] as! String
            }
            if dict.keys.contains("FileId") {
                self.fileId = dict["FileId"] as! Int64
            }
            if dict.keys.contains("Page") {
                var model = ListSQLReviewOriginSQLRequest.OrderActionDetail.Page()
                model.fromMap(dict["Page"] as! [String: Any])
                self.page = model
            }
            if dict.keys.contains("SQLReviewResult") {
                self.SQLReviewResult = dict["SQLReviewResult"] as! String
            }
        }
    }
    public var orderActionDetail: ListSQLReviewOriginSQLRequest.OrderActionDetail?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.orderActionDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderActionDetail != nil {
            map["OrderActionDetail"] = self.orderActionDetail?.toMap()
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderActionDetail") {
            var model = ListSQLReviewOriginSQLRequest.OrderActionDetail()
            model.fromMap(dict["OrderActionDetail"] as! [String: Any])
            self.orderActionDetail = model
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListSQLReviewOriginSQLShrinkRequest : Tea.TeaModel {
    public var orderActionDetailShrink: String?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderActionDetailShrink != nil {
            map["OrderActionDetail"] = self.orderActionDetailShrink!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderActionDetail") {
            self.orderActionDetailShrink = dict["OrderActionDetail"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListSQLReviewOriginSQLResponseBody : Tea.TeaModel {
    public class OriginSQLList : Tea.TeaModel {
        public var checkStatus: String?

        public var checkedTime: String?

        public var fileId: Int64?

        public var fileName: String?

        public var reviewSummary: String?

        public var SQLContent: String?

        public var SQLId: Int64?

        public var SQLName: String?

        public var SQLReviewQueryKey: String?

        public var sqlHash: String?

        public var statusDesc: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkStatus != nil {
                map["CheckStatus"] = self.checkStatus!
            }
            if self.checkedTime != nil {
                map["CheckedTime"] = self.checkedTime!
            }
            if self.fileId != nil {
                map["FileId"] = self.fileId!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.reviewSummary != nil {
                map["ReviewSummary"] = self.reviewSummary!
            }
            if self.SQLContent != nil {
                map["SQLContent"] = self.SQLContent!
            }
            if self.SQLId != nil {
                map["SQLId"] = self.SQLId!
            }
            if self.SQLName != nil {
                map["SQLName"] = self.SQLName!
            }
            if self.SQLReviewQueryKey != nil {
                map["SQLReviewQueryKey"] = self.SQLReviewQueryKey!
            }
            if self.sqlHash != nil {
                map["SqlHash"] = self.sqlHash!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckStatus") {
                self.checkStatus = dict["CheckStatus"] as! String
            }
            if dict.keys.contains("CheckedTime") {
                self.checkedTime = dict["CheckedTime"] as! String
            }
            if dict.keys.contains("FileId") {
                self.fileId = dict["FileId"] as! Int64
            }
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("ReviewSummary") {
                self.reviewSummary = dict["ReviewSummary"] as! String
            }
            if dict.keys.contains("SQLContent") {
                self.SQLContent = dict["SQLContent"] as! String
            }
            if dict.keys.contains("SQLId") {
                self.SQLId = dict["SQLId"] as! Int64
            }
            if dict.keys.contains("SQLName") {
                self.SQLName = dict["SQLName"] as! String
            }
            if dict.keys.contains("SQLReviewQueryKey") {
                self.SQLReviewQueryKey = dict["SQLReviewQueryKey"] as! String
            }
            if dict.keys.contains("SqlHash") {
                self.sqlHash = dict["SqlHash"] as! String
            }
            if dict.keys.contains("StatusDesc") {
                self.statusDesc = dict["StatusDesc"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var originSQLList: [ListSQLReviewOriginSQLResponseBody.OriginSQLList]?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.originSQLList != nil {
            var tmp : [Any] = []
            for k in self.originSQLList! {
                tmp.append(k.toMap())
            }
            map["OriginSQLList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("OriginSQLList") {
            var tmp : [ListSQLReviewOriginSQLResponseBody.OriginSQLList] = []
            for v in dict["OriginSQLList"] as! [Any] {
                var model = ListSQLReviewOriginSQLResponseBody.OriginSQLList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.originSQLList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListSQLReviewOriginSQLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSQLReviewOriginSQLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSQLReviewOriginSQLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListScenariosRequest : Tea.TeaModel {
    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListScenariosResponseBody : Tea.TeaModel {
    public class ScenarioList : Tea.TeaModel {
        public var creatorId: String?

        public var description_: String?

        public var id: Int64?

        public var scenarioName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.scenarioName != nil {
                map["ScenarioName"] = self.scenarioName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("ScenarioName") {
                self.scenarioName = dict["ScenarioName"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var scenarioList: [ListScenariosResponseBody.ScenarioList]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scenarioList != nil {
            var tmp : [Any] = []
            for k in self.scenarioList! {
                tmp.append(k.toMap())
            }
            map["ScenarioList"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScenarioList") {
            var tmp : [ListScenariosResponseBody.ScenarioList] = []
            for v in dict["ScenarioList"] as! [Any] {
                var model = ListScenariosResponseBody.ScenarioList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scenarioList = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListScenariosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListScenariosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListScenariosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSensitiveColumnInfoRequest : Tea.TeaModel {
    public var columnName: String?

    public var instanceId: Int32?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var schemaName: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnName != nil {
            map["ColumnName"] = self.columnName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnName") {
            self.columnName = dict["ColumnName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int32
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SchemaName") {
            self.schemaName = dict["SchemaName"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListSensitiveColumnInfoResponseBody : Tea.TeaModel {
    public class SensitiveColumnList : Tea.TeaModel {
        public class SensitiveColumn : Tea.TeaModel {
            public class DefaultDesensitizationRule : Tea.TeaModel {
                public var ruleId: Int64?

                public var ruleName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ruleId != nil {
                        map["RuleId"] = self.ruleId!
                    }
                    if self.ruleName != nil {
                        map["RuleName"] = self.ruleName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RuleId") {
                        self.ruleId = dict["RuleId"] as! Int64
                    }
                    if dict.keys.contains("RuleName") {
                        self.ruleName = dict["RuleName"] as! String
                    }
                }
            }
            public class SemiDesensitizationRuleList : Tea.TeaModel {
                public class SemiDesensitizationRule : Tea.TeaModel {
                    public var ruleId: Int64?

                    public var ruleName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ruleId != nil {
                            map["RuleId"] = self.ruleId!
                        }
                        if self.ruleName != nil {
                            map["RuleName"] = self.ruleName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("RuleId") {
                            self.ruleId = dict["RuleId"] as! Int64
                        }
                        if dict.keys.contains("RuleName") {
                            self.ruleName = dict["RuleName"] as! String
                        }
                    }
                }
                public var semiDesensitizationRule: [ListSensitiveColumnInfoResponseBody.SensitiveColumnList.SensitiveColumn.SemiDesensitizationRuleList.SemiDesensitizationRule]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.semiDesensitizationRule != nil {
                        var tmp : [Any] = []
                        for k in self.semiDesensitizationRule! {
                            tmp.append(k.toMap())
                        }
                        map["SemiDesensitizationRule"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SemiDesensitizationRule") {
                        var tmp : [ListSensitiveColumnInfoResponseBody.SensitiveColumnList.SensitiveColumn.SemiDesensitizationRuleList.SemiDesensitizationRule] = []
                        for v in dict["SemiDesensitizationRule"] as! [Any] {
                            var model = ListSensitiveColumnInfoResponseBody.SensitiveColumnList.SensitiveColumn.SemiDesensitizationRuleList.SemiDesensitizationRule()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.semiDesensitizationRule = tmp
                    }
                }
            }
            public var categoryName: String?

            public var columnName: String?

            public var defaultDesensitizationRule: ListSensitiveColumnInfoResponseBody.SensitiveColumnList.SensitiveColumn.DefaultDesensitizationRule?

            public var instanceId: Int32?

            public var isPlain: Bool?

            public var sampleData: String?

            public var schemaName: String?

            public var securityLevel: String?

            public var semiDesensitizationRuleList: ListSensitiveColumnInfoResponseBody.SensitiveColumnList.SensitiveColumn.SemiDesensitizationRuleList?

            public var tableName: String?

            public var userSensitivityLevel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.defaultDesensitizationRule?.validate()
                try self.semiDesensitizationRuleList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.categoryName != nil {
                    map["CategoryName"] = self.categoryName!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.defaultDesensitizationRule != nil {
                    map["DefaultDesensitizationRule"] = self.defaultDesensitizationRule?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.isPlain != nil {
                    map["IsPlain"] = self.isPlain!
                }
                if self.sampleData != nil {
                    map["SampleData"] = self.sampleData!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.securityLevel != nil {
                    map["SecurityLevel"] = self.securityLevel!
                }
                if self.semiDesensitizationRuleList != nil {
                    map["SemiDesensitizationRuleList"] = self.semiDesensitizationRuleList?.toMap()
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.userSensitivityLevel != nil {
                    map["UserSensitivityLevel"] = self.userSensitivityLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CategoryName") {
                    self.categoryName = dict["CategoryName"] as! String
                }
                if dict.keys.contains("ColumnName") {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("DefaultDesensitizationRule") {
                    var model = ListSensitiveColumnInfoResponseBody.SensitiveColumnList.SensitiveColumn.DefaultDesensitizationRule()
                    model.fromMap(dict["DefaultDesensitizationRule"] as! [String: Any])
                    self.defaultDesensitizationRule = model
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! Int32
                }
                if dict.keys.contains("IsPlain") {
                    self.isPlain = dict["IsPlain"] as! Bool
                }
                if dict.keys.contains("SampleData") {
                    self.sampleData = dict["SampleData"] as! String
                }
                if dict.keys.contains("SchemaName") {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SecurityLevel") {
                    self.securityLevel = dict["SecurityLevel"] as! String
                }
                if dict.keys.contains("SemiDesensitizationRuleList") {
                    var model = ListSensitiveColumnInfoResponseBody.SensitiveColumnList.SensitiveColumn.SemiDesensitizationRuleList()
                    model.fromMap(dict["SemiDesensitizationRuleList"] as! [String: Any])
                    self.semiDesensitizationRuleList = model
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("UserSensitivityLevel") {
                    self.userSensitivityLevel = dict["UserSensitivityLevel"] as! String
                }
            }
        }
        public var sensitiveColumn: [ListSensitiveColumnInfoResponseBody.SensitiveColumnList.SensitiveColumn]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sensitiveColumn != nil {
                var tmp : [Any] = []
                for k in self.sensitiveColumn! {
                    tmp.append(k.toMap())
                }
                map["SensitiveColumn"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SensitiveColumn") {
                var tmp : [ListSensitiveColumnInfoResponseBody.SensitiveColumnList.SensitiveColumn] = []
                for v in dict["SensitiveColumn"] as! [Any] {
                    var model = ListSensitiveColumnInfoResponseBody.SensitiveColumnList.SensitiveColumn()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sensitiveColumn = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var sensitiveColumnList: ListSensitiveColumnInfoResponseBody.SensitiveColumnList?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sensitiveColumnList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sensitiveColumnList != nil {
            map["SensitiveColumnList"] = self.sensitiveColumnList?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SensitiveColumnList") {
            var model = ListSensitiveColumnInfoResponseBody.SensitiveColumnList()
            model.fromMap(dict["SensitiveColumnList"] as! [String: Any])
            self.sensitiveColumnList = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListSensitiveColumnInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSensitiveColumnInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSensitiveColumnInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSensitiveColumnsRequest : Tea.TeaModel {
    public var columnName: String?

    public var dbId: Int64?

    public var logic: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var schemaName: String?

    public var securityLevel: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnName != nil {
            map["ColumnName"] = self.columnName!
        }
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.securityLevel != nil {
            map["SecurityLevel"] = self.securityLevel!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnName") {
            self.columnName = dict["ColumnName"] as! String
        }
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! Int64
        }
        if dict.keys.contains("Logic") {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SchemaName") {
            self.schemaName = dict["SchemaName"] as! String
        }
        if dict.keys.contains("SecurityLevel") {
            self.securityLevel = dict["SecurityLevel"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListSensitiveColumnsResponseBody : Tea.TeaModel {
    public class SensitiveColumnList : Tea.TeaModel {
        public class SensitiveColumn : Tea.TeaModel {
            public var columnCount: Int64?

            public var columnName: String?

            public var functionType: String?

            public var schemaName: String?

            public var securityLevel: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columnCount != nil {
                    map["ColumnCount"] = self.columnCount!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.functionType != nil {
                    map["FunctionType"] = self.functionType!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.securityLevel != nil {
                    map["SecurityLevel"] = self.securityLevel!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColumnCount") {
                    self.columnCount = dict["ColumnCount"] as! Int64
                }
                if dict.keys.contains("ColumnName") {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("FunctionType") {
                    self.functionType = dict["FunctionType"] as! String
                }
                if dict.keys.contains("SchemaName") {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SecurityLevel") {
                    self.securityLevel = dict["SecurityLevel"] as! String
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public var sensitiveColumn: [ListSensitiveColumnsResponseBody.SensitiveColumnList.SensitiveColumn]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sensitiveColumn != nil {
                var tmp : [Any] = []
                for k in self.sensitiveColumn! {
                    tmp.append(k.toMap())
                }
                map["SensitiveColumn"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SensitiveColumn") {
                var tmp : [ListSensitiveColumnsResponseBody.SensitiveColumnList.SensitiveColumn] = []
                for v in dict["SensitiveColumn"] as! [Any] {
                    var model = ListSensitiveColumnsResponseBody.SensitiveColumnList.SensitiveColumn()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sensitiveColumn = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var sensitiveColumnList: ListSensitiveColumnsResponseBody.SensitiveColumnList?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sensitiveColumnList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sensitiveColumnList != nil {
            map["SensitiveColumnList"] = self.sensitiveColumnList?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SensitiveColumnList") {
            var model = ListSensitiveColumnsResponseBody.SensitiveColumnList()
            model.fromMap(dict["SensitiveColumnList"] as! [String: Any])
            self.sensitiveColumnList = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListSensitiveColumnsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSensitiveColumnsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSensitiveColumnsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSensitiveColumnsDetailRequest : Tea.TeaModel {
    public var columnName: String?

    public var dbId: Int64?

    public var logic: Bool?

    public var schemaName: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnName != nil {
            map["ColumnName"] = self.columnName!
        }
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnName") {
            self.columnName = dict["ColumnName"] as! String
        }
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! Int64
        }
        if dict.keys.contains("Logic") {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("SchemaName") {
            self.schemaName = dict["SchemaName"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListSensitiveColumnsDetailResponseBody : Tea.TeaModel {
    public class SensitiveColumnsDetailList : Tea.TeaModel {
        public class SensitiveColumnsDetail : Tea.TeaModel {
            public var columnDescription: String?

            public var columnName: String?

            public var columnType: String?

            public var dbId: Int64?

            public var dbType: String?

            public var envType: String?

            public var logic: Bool?

            public var schemaName: String?

            public var searchName: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columnDescription != nil {
                    map["ColumnDescription"] = self.columnDescription!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.columnType != nil {
                    map["ColumnType"] = self.columnType!
                }
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColumnDescription") {
                    self.columnDescription = dict["ColumnDescription"] as! String
                }
                if dict.keys.contains("ColumnName") {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("ColumnType") {
                    self.columnType = dict["ColumnType"] as! String
                }
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("DbType") {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("EnvType") {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("SchemaName") {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SearchName") {
                    self.searchName = dict["SearchName"] as! String
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public var sensitiveColumnsDetail: [ListSensitiveColumnsDetailResponseBody.SensitiveColumnsDetailList.SensitiveColumnsDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sensitiveColumnsDetail != nil {
                var tmp : [Any] = []
                for k in self.sensitiveColumnsDetail! {
                    tmp.append(k.toMap())
                }
                map["SensitiveColumnsDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SensitiveColumnsDetail") {
                var tmp : [ListSensitiveColumnsDetailResponseBody.SensitiveColumnsDetailList.SensitiveColumnsDetail] = []
                for v in dict["SensitiveColumnsDetail"] as! [Any] {
                    var model = ListSensitiveColumnsDetailResponseBody.SensitiveColumnsDetailList.SensitiveColumnsDetail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sensitiveColumnsDetail = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var sensitiveColumnsDetailList: ListSensitiveColumnsDetailResponseBody.SensitiveColumnsDetailList?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sensitiveColumnsDetailList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sensitiveColumnsDetailList != nil {
            map["SensitiveColumnsDetailList"] = self.sensitiveColumnsDetailList?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SensitiveColumnsDetailList") {
            var model = ListSensitiveColumnsDetailResponseBody.SensitiveColumnsDetailList()
            model.fromMap(dict["SensitiveColumnsDetailList"] as! [String: Any])
            self.sensitiveColumnsDetailList = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSensitiveColumnsDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSensitiveColumnsDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSensitiveColumnsDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSensitiveDataAuditLogRequest : Tea.TeaModel {
    public var columnName: String?

    public var dbName: String?

    public var endTime: String?

    public var moduleName: String?

    public var opUserName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnName != nil {
            map["ColumnName"] = self.columnName!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.moduleName != nil {
            map["ModuleName"] = self.moduleName!
        }
        if self.opUserName != nil {
            map["OpUserName"] = self.opUserName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnName") {
            self.columnName = dict["ColumnName"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("ModuleName") {
            self.moduleName = dict["ModuleName"] as! String
        }
        if dict.keys.contains("OpUserName") {
            self.opUserName = dict["OpUserName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListSensitiveDataAuditLogResponseBody : Tea.TeaModel {
    public class SensitiveDataAuditLogList : Tea.TeaModel {
        public class SensitiveDataLog : Tea.TeaModel {
            public var columnName: String?

            public var columnPermissionType: String?

            public var desensitizationRule: String?

            public var securityLevel: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.columnPermissionType != nil {
                    map["ColumnPermissionType"] = self.columnPermissionType!
                }
                if self.desensitizationRule != nil {
                    map["DesensitizationRule"] = self.desensitizationRule!
                }
                if self.securityLevel != nil {
                    map["SecurityLevel"] = self.securityLevel!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColumnName") {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("ColumnPermissionType") {
                    self.columnPermissionType = dict["ColumnPermissionType"] as! String
                }
                if dict.keys.contains("DesensitizationRule") {
                    self.desensitizationRule = dict["DesensitizationRule"] as! String
                }
                if dict.keys.contains("SecurityLevel") {
                    self.securityLevel = dict["SecurityLevel"] as! String
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public var dbDisplayName: String?

        public var instanceId: Int64?

        public var moduleName: String?

        public var opTime: String?

        public var sensitiveDataLog: [ListSensitiveDataAuditLogResponseBody.SensitiveDataAuditLogList.SensitiveDataLog]?

        public var targetName: String?

        public var userId: Int64?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbDisplayName != nil {
                map["DbDisplayName"] = self.dbDisplayName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.moduleName != nil {
                map["ModuleName"] = self.moduleName!
            }
            if self.opTime != nil {
                map["OpTime"] = self.opTime!
            }
            if self.sensitiveDataLog != nil {
                var tmp : [Any] = []
                for k in self.sensitiveDataLog! {
                    tmp.append(k.toMap())
                }
                map["SensitiveDataLog"] = tmp
            }
            if self.targetName != nil {
                map["TargetName"] = self.targetName!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbDisplayName") {
                self.dbDisplayName = dict["DbDisplayName"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("ModuleName") {
                self.moduleName = dict["ModuleName"] as! String
            }
            if dict.keys.contains("OpTime") {
                self.opTime = dict["OpTime"] as! String
            }
            if dict.keys.contains("SensitiveDataLog") {
                var tmp : [ListSensitiveDataAuditLogResponseBody.SensitiveDataAuditLogList.SensitiveDataLog] = []
                for v in dict["SensitiveDataLog"] as! [Any] {
                    var model = ListSensitiveDataAuditLogResponseBody.SensitiveDataAuditLogList.SensitiveDataLog()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sensitiveDataLog = tmp
            }
            if dict.keys.contains("TargetName") {
                self.targetName = dict["TargetName"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! Int64
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var sensitiveDataAuditLogList: [ListSensitiveDataAuditLogResponseBody.SensitiveDataAuditLogList]?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sensitiveDataAuditLogList != nil {
            var tmp : [Any] = []
            for k in self.sensitiveDataAuditLogList! {
                tmp.append(k.toMap())
            }
            map["SensitiveDataAuditLogList"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SensitiveDataAuditLogList") {
            var tmp : [ListSensitiveDataAuditLogResponseBody.SensitiveDataAuditLogList] = []
            for v in dict["SensitiveDataAuditLogList"] as! [Any] {
                var model = ListSensitiveDataAuditLogResponseBody.SensitiveDataAuditLogList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sensitiveDataAuditLogList = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListSensitiveDataAuditLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSensitiveDataAuditLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSensitiveDataAuditLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSensitivityLevelRequest : Tea.TeaModel {
    public var templateId: Int64?

    public var templateType: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListSensitivityLevelResponseBody : Tea.TeaModel {
    public class SensitivityLevelList : Tea.TeaModel {
        public var isPlain: Bool?

        public var name: String?

        public var templateId: String?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.isPlain != nil {
                map["IsPlain"] = self.isPlain!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IsPlain") {
                self.isPlain = dict["IsPlain"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var sensitivityLevelList: [ListSensitivityLevelResponseBody.SensitivityLevelList]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sensitivityLevelList != nil {
            var tmp : [Any] = []
            for k in self.sensitivityLevelList! {
                tmp.append(k.toMap())
            }
            map["SensitivityLevelList"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SensitivityLevelList") {
            var tmp : [ListSensitivityLevelResponseBody.SensitivityLevelList] = []
            for v in dict["SensitivityLevelList"] as! [Any] {
                var model = ListSensitivityLevelResponseBody.SensitivityLevelList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sensitivityLevelList = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSensitivityLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSensitivityLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSensitivityLevelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListStandardGroupsRequest : Tea.TeaModel {
    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListStandardGroupsResponseBody : Tea.TeaModel {
    public class StandardGroupList : Tea.TeaModel {
        public var dbType: String?

        public var description_: String?

        public var groupId: Int64?

        public var groupMode: String?

        public var groupName: String?

        public var lastMenderId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupMode != nil {
                map["GroupMode"] = self.groupMode!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.lastMenderId != nil {
                map["LastMenderId"] = self.lastMenderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbType") {
                self.dbType = dict["DbType"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! Int64
            }
            if dict.keys.contains("GroupMode") {
                self.groupMode = dict["GroupMode"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("LastMenderId") {
                self.lastMenderId = dict["LastMenderId"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var standardGroupList: [ListStandardGroupsResponseBody.StandardGroupList]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.standardGroupList != nil {
            var tmp : [Any] = []
            for k in self.standardGroupList! {
                tmp.append(k.toMap())
            }
            map["StandardGroupList"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StandardGroupList") {
            var tmp : [ListStandardGroupsResponseBody.StandardGroupList] = []
            for v in dict["StandardGroupList"] as! [Any] {
                var model = ListStandardGroupsResponseBody.StandardGroupList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.standardGroupList = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListStandardGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListStandardGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListStandardGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTablesRequest : Tea.TeaModel {
    public var databaseId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var returnGuid: Bool?

    public var searchName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseId != nil {
            map["DatabaseId"] = self.databaseId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.returnGuid != nil {
            map["ReturnGuid"] = self.returnGuid!
        }
        if self.searchName != nil {
            map["SearchName"] = self.searchName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseId") {
            self.databaseId = dict["DatabaseId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ReturnGuid") {
            self.returnGuid = dict["ReturnGuid"] as! Bool
        }
        if dict.keys.contains("SearchName") {
            self.searchName = dict["SearchName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListTablesResponseBody : Tea.TeaModel {
    public class TableList : Tea.TeaModel {
        public class Table : Tea.TeaModel {
            public class OwnerIdList : Tea.TeaModel {
                public var ownerIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerIds") {
                        self.ownerIds = dict["OwnerIds"] as! [String]
                    }
                }
            }
            public class OwnerNameList : Tea.TeaModel {
                public var ownerNames: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerNames != nil {
                        map["OwnerNames"] = self.ownerNames!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerNames") {
                        self.ownerNames = dict["OwnerNames"] as! [String]
                    }
                }
            }
            public var databaseId: String?

            public var description_: String?

            public var encoding: String?

            public var engine: String?

            public var numRows: Int64?

            public var ownerIdList: ListTablesResponseBody.TableList.Table.OwnerIdList?

            public var ownerNameList: ListTablesResponseBody.TableList.Table.OwnerNameList?

            public var storeCapacity: Int64?

            public var tableGuid: String?

            public var tableId: String?

            public var tableName: String?

            public var tableSchemaName: String?

            public var tableType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ownerIdList?.validate()
                try self.ownerNameList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseId != nil {
                    map["DatabaseId"] = self.databaseId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.encoding != nil {
                    map["Encoding"] = self.encoding!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.numRows != nil {
                    map["NumRows"] = self.numRows!
                }
                if self.ownerIdList != nil {
                    map["OwnerIdList"] = self.ownerIdList?.toMap()
                }
                if self.ownerNameList != nil {
                    map["OwnerNameList"] = self.ownerNameList?.toMap()
                }
                if self.storeCapacity != nil {
                    map["StoreCapacity"] = self.storeCapacity!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.tableId != nil {
                    map["TableId"] = self.tableId!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.tableSchemaName != nil {
                    map["TableSchemaName"] = self.tableSchemaName!
                }
                if self.tableType != nil {
                    map["TableType"] = self.tableType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DatabaseId") {
                    self.databaseId = dict["DatabaseId"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Encoding") {
                    self.encoding = dict["Encoding"] as! String
                }
                if dict.keys.contains("Engine") {
                    self.engine = dict["Engine"] as! String
                }
                if dict.keys.contains("NumRows") {
                    self.numRows = dict["NumRows"] as! Int64
                }
                if dict.keys.contains("OwnerIdList") {
                    var model = ListTablesResponseBody.TableList.Table.OwnerIdList()
                    model.fromMap(dict["OwnerIdList"] as! [String: Any])
                    self.ownerIdList = model
                }
                if dict.keys.contains("OwnerNameList") {
                    var model = ListTablesResponseBody.TableList.Table.OwnerNameList()
                    model.fromMap(dict["OwnerNameList"] as! [String: Any])
                    self.ownerNameList = model
                }
                if dict.keys.contains("StoreCapacity") {
                    self.storeCapacity = dict["StoreCapacity"] as! Int64
                }
                if dict.keys.contains("TableGuid") {
                    self.tableGuid = dict["TableGuid"] as! String
                }
                if dict.keys.contains("TableId") {
                    self.tableId = dict["TableId"] as! String
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("TableSchemaName") {
                    self.tableSchemaName = dict["TableSchemaName"] as! String
                }
                if dict.keys.contains("TableType") {
                    self.tableType = dict["TableType"] as! String
                }
            }
        }
        public var table: [ListTablesResponseBody.TableList.Table]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.table != nil {
                var tmp : [Any] = []
                for k in self.table! {
                    tmp.append(k.toMap())
                }
                map["Table"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Table") {
                var tmp : [ListTablesResponseBody.TableList.Table] = []
                for v in dict["Table"] as! [Any] {
                    var model = ListTablesResponseBody.TableList.Table()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.table = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tableList: ListTablesResponseBody.TableList?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tableList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tableList != nil {
            map["TableList"] = self.tableList?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TableList") {
            var model = ListTablesResponseBody.TableList()
            model.fromMap(dict["TableList"] as! [String: Any])
            self.tableList = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTaskFlowRequest : Tea.TeaModel {
    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListTaskFlowResponseBody : Tea.TeaModel {
    public class TaskFlowList : Tea.TeaModel {
        public class TaskFlow : Tea.TeaModel {
            public var creatorId: String?

            public var creatorNickName: String?

            public var dagOwnerNickName: String?

            public var deployId: Int64?

            public var id: Int64?

            public var latestInstanceStatus: Int32?

            public var latestInstanceTime: String?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.creatorNickName != nil {
                    map["CreatorNickName"] = self.creatorNickName!
                }
                if self.dagOwnerNickName != nil {
                    map["DagOwnerNickName"] = self.dagOwnerNickName!
                }
                if self.deployId != nil {
                    map["DeployId"] = self.deployId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.latestInstanceStatus != nil {
                    map["LatestInstanceStatus"] = self.latestInstanceStatus!
                }
                if self.latestInstanceTime != nil {
                    map["LatestInstanceTime"] = self.latestInstanceTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatorId") {
                    self.creatorId = dict["CreatorId"] as! String
                }
                if dict.keys.contains("CreatorNickName") {
                    self.creatorNickName = dict["CreatorNickName"] as! String
                }
                if dict.keys.contains("DagOwnerNickName") {
                    self.dagOwnerNickName = dict["DagOwnerNickName"] as! String
                }
                if dict.keys.contains("DeployId") {
                    self.deployId = dict["DeployId"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("LatestInstanceStatus") {
                    self.latestInstanceStatus = dict["LatestInstanceStatus"] as! Int32
                }
                if dict.keys.contains("LatestInstanceTime") {
                    self.latestInstanceTime = dict["LatestInstanceTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public var taskFlow: [ListTaskFlowResponseBody.TaskFlowList.TaskFlow]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskFlow != nil {
                var tmp : [Any] = []
                for k in self.taskFlow! {
                    tmp.append(k.toMap())
                }
                map["TaskFlow"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskFlow") {
                var tmp : [ListTaskFlowResponseBody.TaskFlowList.TaskFlow] = []
                for v in dict["TaskFlow"] as! [Any] {
                    var model = ListTaskFlowResponseBody.TaskFlowList.TaskFlow()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.taskFlow = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var taskFlowList: ListTaskFlowResponseBody.TaskFlowList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskFlowList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskFlowList != nil {
            map["TaskFlowList"] = self.taskFlowList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TaskFlowList") {
            var model = ListTaskFlowResponseBody.TaskFlowList()
            model.fromMap(dict["TaskFlowList"] as! [String: Any])
            self.taskFlowList = model
        }
    }
}

public class ListTaskFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTaskFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTaskFlowConstantsRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListTaskFlowConstantsResponseBody : Tea.TeaModel {
    public class DagConstants : Tea.TeaModel {
        public class DagConstant : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dagConstant: [ListTaskFlowConstantsResponseBody.DagConstants.DagConstant]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dagConstant != nil {
                var tmp : [Any] = []
                for k in self.dagConstant! {
                    tmp.append(k.toMap())
                }
                map["DagConstant"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DagConstant") {
                var tmp : [ListTaskFlowConstantsResponseBody.DagConstants.DagConstant] = []
                for v in dict["DagConstant"] as! [Any] {
                    var model = ListTaskFlowConstantsResponseBody.DagConstants.DagConstant()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dagConstant = tmp
            }
        }
    }
    public var dagConstants: ListTaskFlowConstantsResponseBody.DagConstants?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dagConstants?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagConstants != nil {
            map["DagConstants"] = self.dagConstants?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagConstants") {
            var model = ListTaskFlowConstantsResponseBody.DagConstants()
            model.fromMap(dict["DagConstants"] as! [String: Any])
            self.dagConstants = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListTaskFlowConstantsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskFlowConstantsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTaskFlowConstantsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTaskFlowCooperatorsRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListTaskFlowCooperatorsResponseBody : Tea.TeaModel {
    public class CooperatorList : Tea.TeaModel {
        public class Cooperator : Tea.TeaModel {
            public var email: String?

            public var loginName: String?

            public var nickName: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.loginName != nil {
                    map["LoginName"] = self.loginName!
                }
                if self.nickName != nil {
                    map["NickName"] = self.nickName!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Email") {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("LoginName") {
                    self.loginName = dict["LoginName"] as! String
                }
                if dict.keys.contains("NickName") {
                    self.nickName = dict["NickName"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var cooperator: [ListTaskFlowCooperatorsResponseBody.CooperatorList.Cooperator]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cooperator != nil {
                var tmp : [Any] = []
                for k in self.cooperator! {
                    tmp.append(k.toMap())
                }
                map["Cooperator"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cooperator") {
                var tmp : [ListTaskFlowCooperatorsResponseBody.CooperatorList.Cooperator] = []
                for v in dict["Cooperator"] as! [Any] {
                    var model = ListTaskFlowCooperatorsResponseBody.CooperatorList.Cooperator()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.cooperator = tmp
            }
        }
    }
    public var cooperatorList: ListTaskFlowCooperatorsResponseBody.CooperatorList?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cooperatorList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cooperatorList != nil {
            map["CooperatorList"] = self.cooperatorList?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CooperatorList") {
            var model = ListTaskFlowCooperatorsResponseBody.CooperatorList()
            model.fromMap(dict["CooperatorList"] as! [String: Any])
            self.cooperatorList = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListTaskFlowCooperatorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskFlowCooperatorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTaskFlowCooperatorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTaskFlowEdgesByConditionRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var id: Int64?

    public var nodeEnd: Int64?

    public var nodeFrom: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.nodeEnd != nil {
            map["NodeEnd"] = self.nodeEnd!
        }
        if self.nodeFrom != nil {
            map["NodeFrom"] = self.nodeFrom!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("NodeEnd") {
            self.nodeEnd = dict["NodeEnd"] as! Int64
        }
        if dict.keys.contains("NodeFrom") {
            self.nodeFrom = dict["NodeFrom"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListTaskFlowEdgesByConditionResponseBody : Tea.TeaModel {
    public class Edges : Tea.TeaModel {
        public class Edge : Tea.TeaModel {
            public var id: Int64?

            public var nodeEnd: Int64?

            public var nodeFrom: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.nodeEnd != nil {
                    map["NodeEnd"] = self.nodeEnd!
                }
                if self.nodeFrom != nil {
                    map["NodeFrom"] = self.nodeFrom!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("NodeEnd") {
                    self.nodeEnd = dict["NodeEnd"] as! Int64
                }
                if dict.keys.contains("NodeFrom") {
                    self.nodeFrom = dict["NodeFrom"] as! Int64
                }
            }
        }
        public var edge: [ListTaskFlowEdgesByConditionResponseBody.Edges.Edge]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.edge != nil {
                var tmp : [Any] = []
                for k in self.edge! {
                    tmp.append(k.toMap())
                }
                map["Edge"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Edge") {
                var tmp : [ListTaskFlowEdgesByConditionResponseBody.Edges.Edge] = []
                for v in dict["Edge"] as! [Any] {
                    var model = ListTaskFlowEdgesByConditionResponseBody.Edges.Edge()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.edge = tmp
            }
        }
    }
    public var edges: ListTaskFlowEdgesByConditionResponseBody.Edges?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.edges?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.edges != nil {
            map["Edges"] = self.edges?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Edges") {
            var model = ListTaskFlowEdgesByConditionResponseBody.Edges()
            model.fromMap(dict["Edges"] as! [String: Any])
            self.edges = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListTaskFlowEdgesByConditionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskFlowEdgesByConditionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTaskFlowEdgesByConditionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTaskFlowInstanceRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var pageIndex: Int32?

    public var pageSize: Int32?

    public var startTimeBegin: String?

    public var startTimeEnd: String?

    public var status: Int32?

    public var tid: Int64?

    public var triggerType: Int32?

    public var useBizDate: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTimeBegin != nil {
            map["StartTimeBegin"] = self.startTimeBegin!
        }
        if self.startTimeEnd != nil {
            map["StartTimeEnd"] = self.startTimeEnd!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.triggerType != nil {
            map["TriggerType"] = self.triggerType!
        }
        if self.useBizDate != nil {
            map["UseBizDate"] = self.useBizDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("PageIndex") {
            self.pageIndex = dict["PageIndex"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTimeBegin") {
            self.startTimeBegin = dict["StartTimeBegin"] as! String
        }
        if dict.keys.contains("StartTimeEnd") {
            self.startTimeEnd = dict["StartTimeEnd"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("TriggerType") {
            self.triggerType = dict["TriggerType"] as! Int32
        }
        if dict.keys.contains("UseBizDate") {
            self.useBizDate = dict["UseBizDate"] as! Bool
        }
    }
}

public class ListTaskFlowInstanceResponseBody : Tea.TeaModel {
    public class DAGInstanceList : Tea.TeaModel {
        public class DAGInstance : Tea.TeaModel {
            public var businessTime: String?

            public var dagId: String?

            public var dagName: String?

            public var dagVersion: String?

            public var endTime: String?

            public var historyDagId: Int64?

            public var id: Int64?

            public var message: String?

            public var ownerName: String?

            public var status: Int32?

            public var triggerType: Int32?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessTime != nil {
                    map["BusinessTime"] = self.businessTime!
                }
                if self.dagId != nil {
                    map["DagId"] = self.dagId!
                }
                if self.dagName != nil {
                    map["DagName"] = self.dagName!
                }
                if self.dagVersion != nil {
                    map["DagVersion"] = self.dagVersion!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.historyDagId != nil {
                    map["HistoryDagId"] = self.historyDagId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.ownerName != nil {
                    map["OwnerName"] = self.ownerName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.triggerType != nil {
                    map["TriggerType"] = self.triggerType!
                }
                if self.startTime != nil {
                    map["startTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessTime") {
                    self.businessTime = dict["BusinessTime"] as! String
                }
                if dict.keys.contains("DagId") {
                    self.dagId = dict["DagId"] as! String
                }
                if dict.keys.contains("DagName") {
                    self.dagName = dict["DagName"] as! String
                }
                if dict.keys.contains("DagVersion") {
                    self.dagVersion = dict["DagVersion"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("HistoryDagId") {
                    self.historyDagId = dict["HistoryDagId"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("OwnerName") {
                    self.ownerName = dict["OwnerName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("TriggerType") {
                    self.triggerType = dict["TriggerType"] as! Int32
                }
                if dict.keys.contains("startTime") {
                    self.startTime = dict["startTime"] as! String
                }
            }
        }
        public var DAGInstance: [ListTaskFlowInstanceResponseBody.DAGInstanceList.DAGInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DAGInstance != nil {
                var tmp : [Any] = []
                for k in self.DAGInstance! {
                    tmp.append(k.toMap())
                }
                map["DAGInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DAGInstance") {
                var tmp : [ListTaskFlowInstanceResponseBody.DAGInstanceList.DAGInstance] = []
                for v in dict["DAGInstance"] as! [Any] {
                    var model = ListTaskFlowInstanceResponseBody.DAGInstanceList.DAGInstance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.DAGInstance = tmp
            }
        }
    }
    public var DAGInstanceList: ListTaskFlowInstanceResponseBody.DAGInstanceList?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DAGInstanceList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DAGInstanceList != nil {
            map["DAGInstanceList"] = self.DAGInstanceList?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DAGInstanceList") {
            var model = ListTaskFlowInstanceResponseBody.DAGInstanceList()
            model.fromMap(dict["DAGInstanceList"] as! [String: Any])
            self.DAGInstanceList = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListTaskFlowInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskFlowInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTaskFlowInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTaskFlowTimeVariablesRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListTaskFlowTimeVariablesResponseBody : Tea.TeaModel {
    public class TimeVariables : Tea.TeaModel {
        public class TimeVariable : Tea.TeaModel {
            public var name: String?

            public var pattern: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.pattern != nil {
                    map["Pattern"] = self.pattern!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Pattern") {
                    self.pattern = dict["Pattern"] as! String
                }
            }
        }
        public var timeVariable: [ListTaskFlowTimeVariablesResponseBody.TimeVariables.TimeVariable]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.timeVariable != nil {
                var tmp : [Any] = []
                for k in self.timeVariable! {
                    tmp.append(k.toMap())
                }
                map["TimeVariable"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TimeVariable") {
                var tmp : [ListTaskFlowTimeVariablesResponseBody.TimeVariables.TimeVariable] = []
                for v in dict["TimeVariable"] as! [Any] {
                    var model = ListTaskFlowTimeVariablesResponseBody.TimeVariables.TimeVariable()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.timeVariable = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var timeVariables: ListTaskFlowTimeVariablesResponseBody.TimeVariables?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.timeVariables?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.timeVariables != nil {
            map["TimeVariables"] = self.timeVariables?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TimeVariables") {
            var model = ListTaskFlowTimeVariablesResponseBody.TimeVariables()
            model.fromMap(dict["TimeVariables"] as! [String: Any])
            self.timeVariables = model
        }
    }
}

public class ListTaskFlowTimeVariablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskFlowTimeVariablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTaskFlowTimeVariablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTaskFlowsByPageRequest : Tea.TeaModel {
    public var dagIdList: [Int64]?

    public var pageIndex: Int32?

    public var pageSize: Int32?

    public var scenarioId: Int64?

    public var searchKey: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagIdList != nil {
            map["DagIdList"] = self.dagIdList!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagIdList") {
            self.dagIdList = dict["DagIdList"] as! [Int64]
        }
        if dict.keys.contains("PageIndex") {
            self.pageIndex = dict["PageIndex"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ScenarioId") {
            self.scenarioId = dict["ScenarioId"] as! Int64
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListTaskFlowsByPageShrinkRequest : Tea.TeaModel {
    public var dagIdListShrink: String?

    public var pageIndex: Int32?

    public var pageSize: Int32?

    public var scenarioId: Int64?

    public var searchKey: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagIdListShrink != nil {
            map["DagIdList"] = self.dagIdListShrink!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagIdList") {
            self.dagIdListShrink = dict["DagIdList"] as! String
        }
        if dict.keys.contains("PageIndex") {
            self.pageIndex = dict["PageIndex"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ScenarioId") {
            self.scenarioId = dict["ScenarioId"] as! Int64
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListTaskFlowsByPageResponseBody : Tea.TeaModel {
    public class TaskFlowList : Tea.TeaModel {
        public class TaskFlow : Tea.TeaModel {
            public var creatorId: String?

            public var creatorNickName: String?

            public var cronBeginDate: String?

            public var cronEndDate: String?

            public var cronStr: String?

            public var cronSwitch: Bool?

            public var cronType: Int32?

            public var dagName: String?

            public var dagOwnerId: String?

            public var dagOwnerNickName: String?

            public var deployId: Int64?

            public var description_: String?

            public var id: Int64?

            public var latestInstanceStatus: Int32?

            public var latestInstanceTime: String?

            public var scenarioId: String?

            public var scheduleParam: String?

            public var status: Int32?

            public var timeZoneId: String?

            public var triggerType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.creatorNickName != nil {
                    map["CreatorNickName"] = self.creatorNickName!
                }
                if self.cronBeginDate != nil {
                    map["CronBeginDate"] = self.cronBeginDate!
                }
                if self.cronEndDate != nil {
                    map["CronEndDate"] = self.cronEndDate!
                }
                if self.cronStr != nil {
                    map["CronStr"] = self.cronStr!
                }
                if self.cronSwitch != nil {
                    map["CronSwitch"] = self.cronSwitch!
                }
                if self.cronType != nil {
                    map["CronType"] = self.cronType!
                }
                if self.dagName != nil {
                    map["DagName"] = self.dagName!
                }
                if self.dagOwnerId != nil {
                    map["DagOwnerId"] = self.dagOwnerId!
                }
                if self.dagOwnerNickName != nil {
                    map["DagOwnerNickName"] = self.dagOwnerNickName!
                }
                if self.deployId != nil {
                    map["DeployId"] = self.deployId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.latestInstanceStatus != nil {
                    map["LatestInstanceStatus"] = self.latestInstanceStatus!
                }
                if self.latestInstanceTime != nil {
                    map["LatestInstanceTime"] = self.latestInstanceTime!
                }
                if self.scenarioId != nil {
                    map["ScenarioId"] = self.scenarioId!
                }
                if self.scheduleParam != nil {
                    map["ScheduleParam"] = self.scheduleParam!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.timeZoneId != nil {
                    map["TimeZoneId"] = self.timeZoneId!
                }
                if self.triggerType != nil {
                    map["TriggerType"] = self.triggerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatorId") {
                    self.creatorId = dict["CreatorId"] as! String
                }
                if dict.keys.contains("CreatorNickName") {
                    self.creatorNickName = dict["CreatorNickName"] as! String
                }
                if dict.keys.contains("CronBeginDate") {
                    self.cronBeginDate = dict["CronBeginDate"] as! String
                }
                if dict.keys.contains("CronEndDate") {
                    self.cronEndDate = dict["CronEndDate"] as! String
                }
                if dict.keys.contains("CronStr") {
                    self.cronStr = dict["CronStr"] as! String
                }
                if dict.keys.contains("CronSwitch") {
                    self.cronSwitch = dict["CronSwitch"] as! Bool
                }
                if dict.keys.contains("CronType") {
                    self.cronType = dict["CronType"] as! Int32
                }
                if dict.keys.contains("DagName") {
                    self.dagName = dict["DagName"] as! String
                }
                if dict.keys.contains("DagOwnerId") {
                    self.dagOwnerId = dict["DagOwnerId"] as! String
                }
                if dict.keys.contains("DagOwnerNickName") {
                    self.dagOwnerNickName = dict["DagOwnerNickName"] as! String
                }
                if dict.keys.contains("DeployId") {
                    self.deployId = dict["DeployId"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("LatestInstanceStatus") {
                    self.latestInstanceStatus = dict["LatestInstanceStatus"] as! Int32
                }
                if dict.keys.contains("LatestInstanceTime") {
                    self.latestInstanceTime = dict["LatestInstanceTime"] as! String
                }
                if dict.keys.contains("ScenarioId") {
                    self.scenarioId = dict["ScenarioId"] as! String
                }
                if dict.keys.contains("ScheduleParam") {
                    self.scheduleParam = dict["ScheduleParam"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("TimeZoneId") {
                    self.timeZoneId = dict["TimeZoneId"] as! String
                }
                if dict.keys.contains("TriggerType") {
                    self.triggerType = dict["TriggerType"] as! Int32
                }
            }
        }
        public var taskFlow: [ListTaskFlowsByPageResponseBody.TaskFlowList.TaskFlow]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskFlow != nil {
                var tmp : [Any] = []
                for k in self.taskFlow! {
                    tmp.append(k.toMap())
                }
                map["TaskFlow"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskFlow") {
                var tmp : [ListTaskFlowsByPageResponseBody.TaskFlowList.TaskFlow] = []
                for v in dict["TaskFlow"] as! [Any] {
                    var model = ListTaskFlowsByPageResponseBody.TaskFlowList.TaskFlow()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.taskFlow = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var taskFlowList: ListTaskFlowsByPageResponseBody.TaskFlowList?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskFlowList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskFlowList != nil {
            map["TaskFlowList"] = self.taskFlowList?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TaskFlowList") {
            var model = ListTaskFlowsByPageResponseBody.TaskFlowList()
            model.fromMap(dict["TaskFlowList"] as! [String: Any])
            self.taskFlowList = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListTaskFlowsByPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskFlowsByPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTaskFlowsByPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTasksInTaskFlowRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListTasksInTaskFlowResponseBody : Tea.TeaModel {
    public class Tasks : Tea.TeaModel {
        public class Task : Tea.TeaModel {
            public var graphParam: String?

            public var nodeConfig: String?

            public var nodeContent: String?

            public var nodeId: String?

            public var nodeName: String?

            public var nodeOutput: String?

            public var nodeType: String?

            public var timeVariables: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.graphParam != nil {
                    map["GraphParam"] = self.graphParam!
                }
                if self.nodeConfig != nil {
                    map["NodeConfig"] = self.nodeConfig!
                }
                if self.nodeContent != nil {
                    map["NodeContent"] = self.nodeContent!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.nodeOutput != nil {
                    map["NodeOutput"] = self.nodeOutput!
                }
                if self.nodeType != nil {
                    map["NodeType"] = self.nodeType!
                }
                if self.timeVariables != nil {
                    map["TimeVariables"] = self.timeVariables!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GraphParam") {
                    self.graphParam = dict["GraphParam"] as! String
                }
                if dict.keys.contains("NodeConfig") {
                    self.nodeConfig = dict["NodeConfig"] as! String
                }
                if dict.keys.contains("NodeContent") {
                    self.nodeContent = dict["NodeContent"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! String
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("NodeOutput") {
                    self.nodeOutput = dict["NodeOutput"] as! String
                }
                if dict.keys.contains("NodeType") {
                    self.nodeType = dict["NodeType"] as! String
                }
                if dict.keys.contains("TimeVariables") {
                    self.timeVariables = dict["TimeVariables"] as! String
                }
            }
        }
        public var task: [ListTasksInTaskFlowResponseBody.Tasks.Task]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.task != nil {
                var tmp : [Any] = []
                for k in self.task! {
                    tmp.append(k.toMap())
                }
                map["Task"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Task") {
                var tmp : [ListTasksInTaskFlowResponseBody.Tasks.Task] = []
                for v in dict["Task"] as! [Any] {
                    var model = ListTasksInTaskFlowResponseBody.Tasks.Task()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.task = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tasks: ListTasksInTaskFlowResponseBody.Tasks?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tasks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tasks != nil {
            map["Tasks"] = self.tasks?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Tasks") {
            var model = ListTasksInTaskFlowResponseBody.Tasks()
            model.fromMap(dict["Tasks"] as! [String: Any])
            self.tasks = model
        }
    }
}

public class ListTasksInTaskFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTasksInTaskFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTasksInTaskFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUserPermissionsRequest : Tea.TeaModel {
    public var databaseName: String?

    public var dbType: String?

    public var envType: String?

    public var logic: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var permType: String?

    public var searchKey: String?

    public var tid: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.dbType != nil {
            map["DbType"] = self.dbType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.permType != nil {
            map["PermType"] = self.permType!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("DbType") {
            self.dbType = dict["DbType"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("Logic") {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PermType") {
            self.permType = dict["PermType"] as! String
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ListUserPermissionsResponseBody : Tea.TeaModel {
    public class UserPermissions : Tea.TeaModel {
        public class UserPermission : Tea.TeaModel {
            public class PermDetails : Tea.TeaModel {
                public class PermDetail : Tea.TeaModel {
                    public var createDate: String?

                    public var expireDate: String?

                    public var extraData: String?

                    public var originFrom: String?

                    public var permType: String?

                    public var userAccessId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.createDate != nil {
                            map["CreateDate"] = self.createDate!
                        }
                        if self.expireDate != nil {
                            map["ExpireDate"] = self.expireDate!
                        }
                        if self.extraData != nil {
                            map["ExtraData"] = self.extraData!
                        }
                        if self.originFrom != nil {
                            map["OriginFrom"] = self.originFrom!
                        }
                        if self.permType != nil {
                            map["PermType"] = self.permType!
                        }
                        if self.userAccessId != nil {
                            map["UserAccessId"] = self.userAccessId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CreateDate") {
                            self.createDate = dict["CreateDate"] as! String
                        }
                        if dict.keys.contains("ExpireDate") {
                            self.expireDate = dict["ExpireDate"] as! String
                        }
                        if dict.keys.contains("ExtraData") {
                            self.extraData = dict["ExtraData"] as! String
                        }
                        if dict.keys.contains("OriginFrom") {
                            self.originFrom = dict["OriginFrom"] as! String
                        }
                        if dict.keys.contains("PermType") {
                            self.permType = dict["PermType"] as! String
                        }
                        if dict.keys.contains("UserAccessId") {
                            self.userAccessId = dict["UserAccessId"] as! String
                        }
                    }
                }
                public var permDetail: [ListUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails.PermDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.permDetail != nil {
                        var tmp : [Any] = []
                        for k in self.permDetail! {
                            tmp.append(k.toMap())
                        }
                        map["PermDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PermDetail") {
                        var tmp : [ListUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails.PermDetail] = []
                        for v in dict["PermDetail"] as! [Any] {
                            var model = ListUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails.PermDetail()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.permDetail = tmp
                    }
                }
            }
            public var alias: String?

            public var columnName: String?

            public var dbId: String?

            public var dbType: String?

            public var dsType: String?

            public var envType: String?

            public var host: String?

            public var instanceId: String?

            public var logic: Bool?

            public var permDetails: ListUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails?

            public var port: Int64?

            public var schemaName: String?

            public var searchName: String?

            public var tableId: String?

            public var tableName: String?

            public var userId: String?

            public var userNickName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.permDetails?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.dsType != nil {
                    map["DsType"] = self.dsType!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.permDetails != nil {
                    map["PermDetails"] = self.permDetails?.toMap()
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                if self.tableId != nil {
                    map["TableId"] = self.tableId!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userNickName != nil {
                    map["UserNickName"] = self.userNickName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("ColumnName") {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("DbId") {
                    self.dbId = dict["DbId"] as! String
                }
                if dict.keys.contains("DbType") {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("DsType") {
                    self.dsType = dict["DsType"] as! String
                }
                if dict.keys.contains("EnvType") {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("PermDetails") {
                    var model = ListUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails()
                    model.fromMap(dict["PermDetails"] as! [String: Any])
                    self.permDetails = model
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int64
                }
                if dict.keys.contains("SchemaName") {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SearchName") {
                    self.searchName = dict["SearchName"] as! String
                }
                if dict.keys.contains("TableId") {
                    self.tableId = dict["TableId"] as! String
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserNickName") {
                    self.userNickName = dict["UserNickName"] as! String
                }
            }
        }
        public var userPermission: [ListUserPermissionsResponseBody.UserPermissions.UserPermission]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userPermission != nil {
                var tmp : [Any] = []
                for k in self.userPermission! {
                    tmp.append(k.toMap())
                }
                map["UserPermission"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserPermission") {
                var tmp : [ListUserPermissionsResponseBody.UserPermissions.UserPermission] = []
                for v in dict["UserPermission"] as! [Any] {
                    var model = ListUserPermissionsResponseBody.UserPermissions.UserPermission()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.userPermission = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public var userPermissions: ListUserPermissionsResponseBody.UserPermissions?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userPermissions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.userPermissions != nil {
            map["UserPermissions"] = self.userPermissions?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("UserPermissions") {
            var model = ListUserPermissionsResponseBody.UserPermissions()
            model.fromMap(dict["UserPermissions"] as! [String: Any])
            self.userPermissions = model
        }
    }
}

public class ListUserPermissionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserPermissionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListUserPermissionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUserTenantsRequest : Tea.TeaModel {
    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListUserTenantsResponseBody : Tea.TeaModel {
    public class TenantList : Tea.TeaModel {
        public var status: String?

        public var tenantName: String?

        public var tid: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tenantName != nil {
                map["TenantName"] = self.tenantName!
            }
            if self.tid != nil {
                map["Tid"] = self.tid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TenantName") {
                self.tenantName = dict["TenantName"] as! String
            }
            if dict.keys.contains("Tid") {
                self.tid = dict["Tid"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tenantList: [ListUserTenantsResponseBody.TenantList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tenantList != nil {
            var tmp : [Any] = []
            for k in self.tenantList! {
                tmp.append(k.toMap())
            }
            map["TenantList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TenantList") {
            var tmp : [ListUserTenantsResponseBody.TenantList] = []
            for v in dict["TenantList"] as! [Any] {
                var model = ListUserTenantsResponseBody.TenantList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tenantList = tmp
        }
    }
}

public class ListUserTenantsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserTenantsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListUserTenantsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUsersRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var role: String?

    public var searchKey: String?

    public var tid: Int64?

    public var userState: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userState != nil {
            map["UserState"] = self.userState!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! String
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserState") {
            self.userState = dict["UserState"] as! String
        }
    }
}

public class ListUsersResponseBody : Tea.TeaModel {
    public class UserList : Tea.TeaModel {
        public class User : Tea.TeaModel {
            public class RoleIdList : Tea.TeaModel {
                public var roleIds: [Int32]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.roleIds != nil {
                        map["RoleIds"] = self.roleIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RoleIds") {
                        self.roleIds = dict["RoleIds"] as! [Int32]
                    }
                }
            }
            public class RoleNameList : Tea.TeaModel {
                public var roleNames: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.roleNames != nil {
                        map["RoleNames"] = self.roleNames!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RoleNames") {
                        self.roleNames = dict["RoleNames"] as! [String]
                    }
                }
            }
            public var curExecuteCount: Int64?

            public var curResultCount: Int64?

            public var dingRobot: String?

            public var email: String?

            public var lastLoginTime: String?

            public var maxExecuteCount: Int64?

            public var maxResultCount: Int64?

            public var mobile: String?

            public var nickName: String?

            public var notificationMode: String?

            public var parentUid: String?

            public var roleIdList: ListUsersResponseBody.UserList.User.RoleIdList?

            public var roleNameList: ListUsersResponseBody.UserList.User.RoleNameList?

            public var signatureMethod: String?

            public var state: String?

            public var uid: String?

            public var userId: String?

            public var webhook: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.roleIdList?.validate()
                try self.roleNameList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.curExecuteCount != nil {
                    map["CurExecuteCount"] = self.curExecuteCount!
                }
                if self.curResultCount != nil {
                    map["CurResultCount"] = self.curResultCount!
                }
                if self.dingRobot != nil {
                    map["DingRobot"] = self.dingRobot!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.lastLoginTime != nil {
                    map["LastLoginTime"] = self.lastLoginTime!
                }
                if self.maxExecuteCount != nil {
                    map["MaxExecuteCount"] = self.maxExecuteCount!
                }
                if self.maxResultCount != nil {
                    map["MaxResultCount"] = self.maxResultCount!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.nickName != nil {
                    map["NickName"] = self.nickName!
                }
                if self.notificationMode != nil {
                    map["NotificationMode"] = self.notificationMode!
                }
                if self.parentUid != nil {
                    map["ParentUid"] = self.parentUid!
                }
                if self.roleIdList != nil {
                    map["RoleIdList"] = self.roleIdList?.toMap()
                }
                if self.roleNameList != nil {
                    map["RoleNameList"] = self.roleNameList?.toMap()
                }
                if self.signatureMethod != nil {
                    map["SignatureMethod"] = self.signatureMethod!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.uid != nil {
                    map["Uid"] = self.uid!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.webhook != nil {
                    map["Webhook"] = self.webhook!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CurExecuteCount") {
                    self.curExecuteCount = dict["CurExecuteCount"] as! Int64
                }
                if dict.keys.contains("CurResultCount") {
                    self.curResultCount = dict["CurResultCount"] as! Int64
                }
                if dict.keys.contains("DingRobot") {
                    self.dingRobot = dict["DingRobot"] as! String
                }
                if dict.keys.contains("Email") {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("LastLoginTime") {
                    self.lastLoginTime = dict["LastLoginTime"] as! String
                }
                if dict.keys.contains("MaxExecuteCount") {
                    self.maxExecuteCount = dict["MaxExecuteCount"] as! Int64
                }
                if dict.keys.contains("MaxResultCount") {
                    self.maxResultCount = dict["MaxResultCount"] as! Int64
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("NickName") {
                    self.nickName = dict["NickName"] as! String
                }
                if dict.keys.contains("NotificationMode") {
                    self.notificationMode = dict["NotificationMode"] as! String
                }
                if dict.keys.contains("ParentUid") {
                    self.parentUid = dict["ParentUid"] as! String
                }
                if dict.keys.contains("RoleIdList") {
                    var model = ListUsersResponseBody.UserList.User.RoleIdList()
                    model.fromMap(dict["RoleIdList"] as! [String: Any])
                    self.roleIdList = model
                }
                if dict.keys.contains("RoleNameList") {
                    var model = ListUsersResponseBody.UserList.User.RoleNameList()
                    model.fromMap(dict["RoleNameList"] as! [String: Any])
                    self.roleNameList = model
                }
                if dict.keys.contains("SignatureMethod") {
                    self.signatureMethod = dict["SignatureMethod"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Uid") {
                    self.uid = dict["Uid"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("Webhook") {
                    self.webhook = dict["Webhook"] as! String
                }
            }
        }
        public var user: [ListUsersResponseBody.UserList.User]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.user != nil {
                var tmp : [Any] = []
                for k in self.user! {
                    tmp.append(k.toMap())
                }
                map["User"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("User") {
                var tmp : [ListUsersResponseBody.UserList.User] = []
                for v in dict["User"] as! [Any] {
                    var model = ListUsersResponseBody.UserList.User()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.user = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public var userList: ListUsersResponseBody.UserList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.userList != nil {
            map["UserList"] = self.userList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("UserList") {
            var model = ListUsersResponseBody.UserList()
            model.fromMap(dict["UserList"] as! [String: Any])
            self.userList = model
        }
    }
}

public class ListUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWorkFlowNodesRequest : Tea.TeaModel {
    public var searchName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.searchName != nil {
            map["SearchName"] = self.searchName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SearchName") {
            self.searchName = dict["SearchName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListWorkFlowNodesResponseBody : Tea.TeaModel {
    public class WorkflowNodes : Tea.TeaModel {
        public class WorkflowNode : Tea.TeaModel {
            public class AuditUsers : Tea.TeaModel {
                public class AuditUser : Tea.TeaModel {
                    public var nickName: String?

                    public var realName: String?

                    public var userId: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.nickName != nil {
                            map["NickName"] = self.nickName!
                        }
                        if self.realName != nil {
                            map["RealName"] = self.realName!
                        }
                        if self.userId != nil {
                            map["UserId"] = self.userId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("NickName") {
                            self.nickName = dict["NickName"] as! String
                        }
                        if dict.keys.contains("RealName") {
                            self.realName = dict["RealName"] as! String
                        }
                        if dict.keys.contains("UserId") {
                            self.userId = dict["UserId"] as! Int64
                        }
                    }
                }
                public var auditUser: [ListWorkFlowNodesResponseBody.WorkflowNodes.WorkflowNode.AuditUsers.AuditUser]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.auditUser != nil {
                        var tmp : [Any] = []
                        for k in self.auditUser! {
                            tmp.append(k.toMap())
                        }
                        map["AuditUser"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AuditUser") {
                        var tmp : [ListWorkFlowNodesResponseBody.WorkflowNodes.WorkflowNode.AuditUsers.AuditUser] = []
                        for v in dict["AuditUser"] as! [Any] {
                            var model = ListWorkFlowNodesResponseBody.WorkflowNodes.WorkflowNode.AuditUsers.AuditUser()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.auditUser = tmp
                    }
                }
            }
            public var auditUsers: ListWorkFlowNodesResponseBody.WorkflowNodes.WorkflowNode.AuditUsers?

            public var comment: String?

            public var createUserId: Int64?

            public var createUserNickName: String?

            public var nodeId: Int64?

            public var nodeName: String?

            public var nodeType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.auditUsers?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.auditUsers != nil {
                    map["AuditUsers"] = self.auditUsers?.toMap()
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.createUserId != nil {
                    map["CreateUserId"] = self.createUserId!
                }
                if self.createUserNickName != nil {
                    map["CreateUserNickName"] = self.createUserNickName!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.nodeType != nil {
                    map["NodeType"] = self.nodeType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuditUsers") {
                    var model = ListWorkFlowNodesResponseBody.WorkflowNodes.WorkflowNode.AuditUsers()
                    model.fromMap(dict["AuditUsers"] as! [String: Any])
                    self.auditUsers = model
                }
                if dict.keys.contains("Comment") {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("CreateUserId") {
                    self.createUserId = dict["CreateUserId"] as! Int64
                }
                if dict.keys.contains("CreateUserNickName") {
                    self.createUserNickName = dict["CreateUserNickName"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("NodeType") {
                    self.nodeType = dict["NodeType"] as! String
                }
            }
        }
        public var workflowNode: [ListWorkFlowNodesResponseBody.WorkflowNodes.WorkflowNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.workflowNode != nil {
                var tmp : [Any] = []
                for k in self.workflowNode! {
                    tmp.append(k.toMap())
                }
                map["WorkflowNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WorkflowNode") {
                var tmp : [ListWorkFlowNodesResponseBody.WorkflowNodes.WorkflowNode] = []
                for v in dict["WorkflowNode"] as! [Any] {
                    var model = ListWorkFlowNodesResponseBody.WorkflowNodes.WorkflowNode()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.workflowNode = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var workflowNodes: ListWorkFlowNodesResponseBody.WorkflowNodes?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workflowNodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.workflowNodes != nil {
            map["WorkflowNodes"] = self.workflowNodes?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("WorkflowNodes") {
            var model = ListWorkFlowNodesResponseBody.WorkflowNodes()
            model.fromMap(dict["WorkflowNodes"] as! [String: Any])
            self.workflowNodes = model
        }
    }
}

public class ListWorkFlowNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkFlowNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListWorkFlowNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWorkFlowTemplatesRequest : Tea.TeaModel {
    public var searchName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.searchName != nil {
            map["SearchName"] = self.searchName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SearchName") {
            self.searchName = dict["SearchName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListWorkFlowTemplatesResponseBody : Tea.TeaModel {
    public class WorkFlowTemplates : Tea.TeaModel {
        public class WorkFlowTemplate : Tea.TeaModel {
            public class WorkflowNodes : Tea.TeaModel {
                public class WorkflowNode : Tea.TeaModel {
                    public var comment: String?

                    public var createUserId: Int64?

                    public var nodeId: Int64?

                    public var nodeName: String?

                    public var nodeType: String?

                    public var position: Int32?

                    public var templateId: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.comment != nil {
                            map["Comment"] = self.comment!
                        }
                        if self.createUserId != nil {
                            map["CreateUserId"] = self.createUserId!
                        }
                        if self.nodeId != nil {
                            map["NodeId"] = self.nodeId!
                        }
                        if self.nodeName != nil {
                            map["NodeName"] = self.nodeName!
                        }
                        if self.nodeType != nil {
                            map["NodeType"] = self.nodeType!
                        }
                        if self.position != nil {
                            map["Position"] = self.position!
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Comment") {
                            self.comment = dict["Comment"] as! String
                        }
                        if dict.keys.contains("CreateUserId") {
                            self.createUserId = dict["CreateUserId"] as! Int64
                        }
                        if dict.keys.contains("NodeId") {
                            self.nodeId = dict["NodeId"] as! Int64
                        }
                        if dict.keys.contains("NodeName") {
                            self.nodeName = dict["NodeName"] as! String
                        }
                        if dict.keys.contains("NodeType") {
                            self.nodeType = dict["NodeType"] as! String
                        }
                        if dict.keys.contains("Position") {
                            self.position = dict["Position"] as! Int32
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! Int64
                        }
                    }
                }
                public var workflowNode: [ListWorkFlowTemplatesResponseBody.WorkFlowTemplates.WorkFlowTemplate.WorkflowNodes.WorkflowNode]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.workflowNode != nil {
                        var tmp : [Any] = []
                        for k in self.workflowNode! {
                            tmp.append(k.toMap())
                        }
                        map["WorkflowNode"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("WorkflowNode") {
                        var tmp : [ListWorkFlowTemplatesResponseBody.WorkFlowTemplates.WorkFlowTemplate.WorkflowNodes.WorkflowNode] = []
                        for v in dict["WorkflowNode"] as! [Any] {
                            var model = ListWorkFlowTemplatesResponseBody.WorkFlowTemplates.WorkFlowTemplate.WorkflowNodes.WorkflowNode()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.workflowNode = tmp
                    }
                }
            }
            public var comment: String?

            public var createUserId: Int64?

            public var enabled: String?

            public var isSystem: Int32?

            public var templateId: Int64?

            public var templateName: String?

            public var workflowNodes: ListWorkFlowTemplatesResponseBody.WorkFlowTemplates.WorkFlowTemplate.WorkflowNodes?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.workflowNodes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.createUserId != nil {
                    map["CreateUserId"] = self.createUserId!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.isSystem != nil {
                    map["IsSystem"] = self.isSystem!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                if self.workflowNodes != nil {
                    map["WorkflowNodes"] = self.workflowNodes?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Comment") {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("CreateUserId") {
                    self.createUserId = dict["CreateUserId"] as! Int64
                }
                if dict.keys.contains("Enabled") {
                    self.enabled = dict["Enabled"] as! String
                }
                if dict.keys.contains("IsSystem") {
                    self.isSystem = dict["IsSystem"] as! Int32
                }
                if dict.keys.contains("TemplateId") {
                    self.templateId = dict["TemplateId"] as! Int64
                }
                if dict.keys.contains("TemplateName") {
                    self.templateName = dict["TemplateName"] as! String
                }
                if dict.keys.contains("WorkflowNodes") {
                    var model = ListWorkFlowTemplatesResponseBody.WorkFlowTemplates.WorkFlowTemplate.WorkflowNodes()
                    model.fromMap(dict["WorkflowNodes"] as! [String: Any])
                    self.workflowNodes = model
                }
            }
        }
        public var workFlowTemplate: [ListWorkFlowTemplatesResponseBody.WorkFlowTemplates.WorkFlowTemplate]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.workFlowTemplate != nil {
                var tmp : [Any] = []
                for k in self.workFlowTemplate! {
                    tmp.append(k.toMap())
                }
                map["WorkFlowTemplate"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WorkFlowTemplate") {
                var tmp : [ListWorkFlowTemplatesResponseBody.WorkFlowTemplates.WorkFlowTemplate] = []
                for v in dict["WorkFlowTemplate"] as! [Any] {
                    var model = ListWorkFlowTemplatesResponseBody.WorkFlowTemplates.WorkFlowTemplate()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.workFlowTemplate = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var workFlowTemplates: ListWorkFlowTemplatesResponseBody.WorkFlowTemplates?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workFlowTemplates?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.workFlowTemplates != nil {
            map["WorkFlowTemplates"] = self.workFlowTemplates?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("WorkFlowTemplates") {
            var model = ListWorkFlowTemplatesResponseBody.WorkFlowTemplates()
            model.fromMap(dict["WorkFlowTemplates"] as! [String: Any])
            self.workFlowTemplates = model
        }
    }
}

public class ListWorkFlowTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkFlowTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListWorkFlowTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MakeTaskFlowInstanceSuccessRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var dagInstanceId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.dagInstanceId != nil {
            map["DagInstanceId"] = self.dagInstanceId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("DagInstanceId") {
            self.dagInstanceId = dict["DagInstanceId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class MakeTaskFlowInstanceSuccessResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class MakeTaskFlowInstanceSuccessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MakeTaskFlowInstanceSuccessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MakeTaskFlowInstanceSuccessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDataCorrectExecSQLRequest : Tea.TeaModel {
    public var execSQL: String?

    public var orderId: Int64?

    public var realLoginUserUid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.execSQL != nil {
            map["ExecSQL"] = self.execSQL!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.realLoginUserUid != nil {
            map["RealLoginUserUid"] = self.realLoginUserUid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExecSQL") {
            self.execSQL = dict["ExecSQL"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RealLoginUserUid") {
            self.realLoginUserUid = dict["RealLoginUserUid"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ModifyDataCorrectExecSQLResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyDataCorrectExecSQLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDataCorrectExecSQLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDataCorrectExecSQLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDesensitizationStrategyRequest : Tea.TeaModel {
    public var columnName: String?

    public var dbId: Int32?

    public var isDefault: Bool?

    public var isLogic: Bool?

    public var isReset: Bool?

    public var ruleId: Int32?

    public var schemaName: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnName != nil {
            map["ColumnName"] = self.columnName!
        }
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.isLogic != nil {
            map["IsLogic"] = self.isLogic!
        }
        if self.isReset != nil {
            map["IsReset"] = self.isReset!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnName") {
            self.columnName = dict["ColumnName"] as! String
        }
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! Int32
        }
        if dict.keys.contains("IsDefault") {
            self.isDefault = dict["IsDefault"] as! Bool
        }
        if dict.keys.contains("IsLogic") {
            self.isLogic = dict["IsLogic"] as! Bool
        }
        if dict.keys.contains("IsReset") {
            self.isReset = dict["IsReset"] as! Bool
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! Int32
        }
        if dict.keys.contains("SchemaName") {
            self.schemaName = dict["SchemaName"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ModifyDesensitizationStrategyResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyDesensitizationStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDesensitizationStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDesensitizationStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceRequest : Tea.TeaModel {
    public var dataLinkName: String?

    public var databasePassword: String?

    public var databaseUser: String?

    public var dbaId: Int64?

    public var ddlOnline: Int32?

    public var ecsInstanceId: String?

    public var ecsRegion: String?

    public var enableSellCommon: String?

    public var enableSellSitd: String?

    public var enableSellStable: String?

    public var enableSellTrust: String?

    public var envType: String?

    public var exportTimeout: Int32?

    public var host: String?

    public var instanceAlias: String?

    public var instanceId: String?

    public var instanceSource: String?

    public var instanceType: String?

    public var networkType: String?

    public var port: Int32?

    public var queryTimeout: Int32?

    public var safeRule: String?

    public var sid: String?

    public var skipTest: Bool?

    public var templateId: Int64?

    public var templateType: String?

    public var tid: Int64?

    public var useDsql: Int32?

    public var useSsl: Int32?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataLinkName != nil {
            map["DataLinkName"] = self.dataLinkName!
        }
        if self.databasePassword != nil {
            map["DatabasePassword"] = self.databasePassword!
        }
        if self.databaseUser != nil {
            map["DatabaseUser"] = self.databaseUser!
        }
        if self.dbaId != nil {
            map["DbaId"] = self.dbaId!
        }
        if self.ddlOnline != nil {
            map["DdlOnline"] = self.ddlOnline!
        }
        if self.ecsInstanceId != nil {
            map["EcsInstanceId"] = self.ecsInstanceId!
        }
        if self.ecsRegion != nil {
            map["EcsRegion"] = self.ecsRegion!
        }
        if self.enableSellCommon != nil {
            map["EnableSellCommon"] = self.enableSellCommon!
        }
        if self.enableSellSitd != nil {
            map["EnableSellSitd"] = self.enableSellSitd!
        }
        if self.enableSellStable != nil {
            map["EnableSellStable"] = self.enableSellStable!
        }
        if self.enableSellTrust != nil {
            map["EnableSellTrust"] = self.enableSellTrust!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.exportTimeout != nil {
            map["ExportTimeout"] = self.exportTimeout!
        }
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.instanceAlias != nil {
            map["InstanceAlias"] = self.instanceAlias!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceSource != nil {
            map["InstanceSource"] = self.instanceSource!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.queryTimeout != nil {
            map["QueryTimeout"] = self.queryTimeout!
        }
        if self.safeRule != nil {
            map["SafeRule"] = self.safeRule!
        }
        if self.sid != nil {
            map["Sid"] = self.sid!
        }
        if self.skipTest != nil {
            map["SkipTest"] = self.skipTest!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.useDsql != nil {
            map["UseDsql"] = self.useDsql!
        }
        if self.useSsl != nil {
            map["UseSsl"] = self.useSsl!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataLinkName") {
            self.dataLinkName = dict["DataLinkName"] as! String
        }
        if dict.keys.contains("DatabasePassword") {
            self.databasePassword = dict["DatabasePassword"] as! String
        }
        if dict.keys.contains("DatabaseUser") {
            self.databaseUser = dict["DatabaseUser"] as! String
        }
        if dict.keys.contains("DbaId") {
            self.dbaId = dict["DbaId"] as! Int64
        }
        if dict.keys.contains("DdlOnline") {
            self.ddlOnline = dict["DdlOnline"] as! Int32
        }
        if dict.keys.contains("EcsInstanceId") {
            self.ecsInstanceId = dict["EcsInstanceId"] as! String
        }
        if dict.keys.contains("EcsRegion") {
            self.ecsRegion = dict["EcsRegion"] as! String
        }
        if dict.keys.contains("EnableSellCommon") {
            self.enableSellCommon = dict["EnableSellCommon"] as! String
        }
        if dict.keys.contains("EnableSellSitd") {
            self.enableSellSitd = dict["EnableSellSitd"] as! String
        }
        if dict.keys.contains("EnableSellStable") {
            self.enableSellStable = dict["EnableSellStable"] as! String
        }
        if dict.keys.contains("EnableSellTrust") {
            self.enableSellTrust = dict["EnableSellTrust"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("ExportTimeout") {
            self.exportTimeout = dict["ExportTimeout"] as! Int32
        }
        if dict.keys.contains("Host") {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("InstanceAlias") {
            self.instanceAlias = dict["InstanceAlias"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceSource") {
            self.instanceSource = dict["InstanceSource"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("QueryTimeout") {
            self.queryTimeout = dict["QueryTimeout"] as! Int32
        }
        if dict.keys.contains("SafeRule") {
            self.safeRule = dict["SafeRule"] as! String
        }
        if dict.keys.contains("Sid") {
            self.sid = dict["Sid"] as! String
        }
        if dict.keys.contains("SkipTest") {
            self.skipTest = dict["SkipTest"] as! Bool
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UseDsql") {
            self.useDsql = dict["UseDsql"] as! Int32
        }
        if dict.keys.contains("UseSsl") {
            self.useSsl = dict["UseSsl"] as! Int32
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class ModifyInstanceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MoveTaskFlowToScenarioRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var scenarioId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("ScenarioId") {
            self.scenarioId = dict["ScenarioId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class MoveTaskFlowToScenarioResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class MoveTaskFlowToScenarioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveTaskFlowToScenarioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MoveTaskFlowToScenarioResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OfflineTaskFlowRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class OfflineTaskFlowResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class OfflineTaskFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OfflineTaskFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OfflineTaskFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PauseDataCorrectSQLJobRequest : Tea.TeaModel {
    public var jobId: Int64?

    public var orderId: Int64?

    public var tid: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! Int64
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class PauseDataCorrectSQLJobResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PauseDataCorrectSQLJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PauseDataCorrectSQLJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PauseDataCorrectSQLJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PauseDataExportJobRequest : Tea.TeaModel {
    public var jobId: Int64?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! Int64
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class PauseDataExportJobResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PauseDataExportJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PauseDataExportJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PauseDataExportJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PreviewWorkflowRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class PreviewWorkflowResponseBody : Tea.TeaModel {
    public class WorkflowDetail : Tea.TeaModel {
        public class WorkflowNodeList : Tea.TeaModel {
            public class WorkflowNode : Tea.TeaModel {
                public class AuditUserList : Tea.TeaModel {
                    public class AuditUser : Tea.TeaModel {
                        public var nickName: String?

                        public var realName: String?

                        public var userId: Int64?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.nickName != nil {
                                map["NickName"] = self.nickName!
                            }
                            if self.realName != nil {
                                map["RealName"] = self.realName!
                            }
                            if self.userId != nil {
                                map["UserId"] = self.userId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("NickName") {
                                self.nickName = dict["NickName"] as! String
                            }
                            if dict.keys.contains("RealName") {
                                self.realName = dict["RealName"] as! String
                            }
                            if dict.keys.contains("UserId") {
                                self.userId = dict["UserId"] as! Int64
                            }
                        }
                    }
                    public var auditUser: [PreviewWorkflowResponseBody.WorkflowDetail.WorkflowNodeList.WorkflowNode.AuditUserList.AuditUser]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.auditUser != nil {
                            var tmp : [Any] = []
                            for k in self.auditUser! {
                                tmp.append(k.toMap())
                            }
                            map["AuditUser"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AuditUser") {
                            var tmp : [PreviewWorkflowResponseBody.WorkflowDetail.WorkflowNodeList.WorkflowNode.AuditUserList.AuditUser] = []
                            for v in dict["AuditUser"] as! [Any] {
                                var model = PreviewWorkflowResponseBody.WorkflowDetail.WorkflowNodeList.WorkflowNode.AuditUserList.AuditUser()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.auditUser = tmp
                        }
                    }
                }
                public var auditUserList: PreviewWorkflowResponseBody.WorkflowDetail.WorkflowNodeList.WorkflowNode.AuditUserList?

                public var comment: String?

                public var nodeName: String?

                public var nodeType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.auditUserList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.auditUserList != nil {
                        map["AuditUserList"] = self.auditUserList?.toMap()
                    }
                    if self.comment != nil {
                        map["Comment"] = self.comment!
                    }
                    if self.nodeName != nil {
                        map["NodeName"] = self.nodeName!
                    }
                    if self.nodeType != nil {
                        map["NodeType"] = self.nodeType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AuditUserList") {
                        var model = PreviewWorkflowResponseBody.WorkflowDetail.WorkflowNodeList.WorkflowNode.AuditUserList()
                        model.fromMap(dict["AuditUserList"] as! [String: Any])
                        self.auditUserList = model
                    }
                    if dict.keys.contains("Comment") {
                        self.comment = dict["Comment"] as! String
                    }
                    if dict.keys.contains("NodeName") {
                        self.nodeName = dict["NodeName"] as! String
                    }
                    if dict.keys.contains("NodeType") {
                        self.nodeType = dict["NodeType"] as! String
                    }
                }
            }
            public var workflowNode: [PreviewWorkflowResponseBody.WorkflowDetail.WorkflowNodeList.WorkflowNode]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.workflowNode != nil {
                    var tmp : [Any] = []
                    for k in self.workflowNode! {
                        tmp.append(k.toMap())
                    }
                    map["WorkflowNode"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("WorkflowNode") {
                    var tmp : [PreviewWorkflowResponseBody.WorkflowDetail.WorkflowNodeList.WorkflowNode] = []
                    for v in dict["WorkflowNode"] as! [Any] {
                        var model = PreviewWorkflowResponseBody.WorkflowDetail.WorkflowNodeList.WorkflowNode()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.workflowNode = tmp
                }
            }
        }
        public var comment: String?

        public var wfCateName: String?

        public var workflowNodeList: PreviewWorkflowResponseBody.WorkflowDetail.WorkflowNodeList?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.workflowNodeList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.wfCateName != nil {
                map["WfCateName"] = self.wfCateName!
            }
            if self.workflowNodeList != nil {
                map["WorkflowNodeList"] = self.workflowNodeList?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("WfCateName") {
                self.wfCateName = dict["WfCateName"] as! String
            }
            if dict.keys.contains("WorkflowNodeList") {
                var model = PreviewWorkflowResponseBody.WorkflowDetail.WorkflowNodeList()
                model.fromMap(dict["WorkflowNodeList"] as! [String: Any])
                self.workflowNodeList = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var workflowDetail: PreviewWorkflowResponseBody.WorkflowDetail?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workflowDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.workflowDetail != nil {
            map["WorkflowDetail"] = self.workflowDetail?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("WorkflowDetail") {
            var model = PreviewWorkflowResponseBody.WorkflowDetail()
            model.fromMap(dict["WorkflowDetail"] as! [String: Any])
            self.workflowDetail = model
        }
    }
}

public class PreviewWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PreviewWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PreviewWorkflowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PublishAndDeployTaskFlowRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public var versionComments: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.versionComments != nil {
            map["VersionComments"] = self.versionComments!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("VersionComments") {
            self.versionComments = dict["VersionComments"] as! String
        }
    }
}

public class PublishAndDeployTaskFlowResponseBody : Tea.TeaModel {
    public var deployId: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deployId != nil {
            map["DeployId"] = self.deployId!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeployId") {
            self.deployId = dict["DeployId"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PublishAndDeployTaskFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PublishAndDeployTaskFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PublishAndDeployTaskFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryDataTrackResultDownloadStatusRequest : Tea.TeaModel {
    public var downloadKeyId: String?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadKeyId != nil {
            map["DownloadKeyId"] = self.downloadKeyId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadKeyId") {
            self.downloadKeyId = dict["DownloadKeyId"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class QueryDataTrackResultDownloadStatusResponseBody : Tea.TeaModel {
    public class StatusResult : Tea.TeaModel {
        public var downloadStatus: String?

        public var downloadUrl: String?

        public var statusDesc: String?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadStatus != nil {
                map["DownloadStatus"] = self.downloadStatus!
            }
            if self.downloadUrl != nil {
                map["DownloadUrl"] = self.downloadUrl!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DownloadStatus") {
                self.downloadStatus = dict["DownloadStatus"] as! String
            }
            if dict.keys.contains("DownloadUrl") {
                self.downloadUrl = dict["DownloadUrl"] as! String
            }
            if dict.keys.contains("StatusDesc") {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var statusResult: QueryDataTrackResultDownloadStatusResponseBody.StatusResult?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.statusResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusResult != nil {
            map["StatusResult"] = self.statusResult?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusResult") {
            var model = QueryDataTrackResultDownloadStatusResponseBody.StatusResult()
            model.fromMap(dict["StatusResult"] as! [String: Any])
            self.statusResult = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryDataTrackResultDownloadStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryDataTrackResultDownloadStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryDataTrackResultDownloadStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReDeployLhDagVersionRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var dagVersion: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.dagVersion != nil {
            map["DagVersion"] = self.dagVersion!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("DagVersion") {
            self.dagVersion = dict["DagVersion"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ReDeployLhDagVersionResponseBody : Tea.TeaModel {
    public var deployId: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deployId != nil {
            map["DeployId"] = self.deployId!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeployId") {
            self.deployId = dict["DeployId"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ReDeployLhDagVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReDeployLhDagVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReDeployLhDagVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReRunTaskFlowInstanceRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var dagInstanceId: Int64?

    public var dagVersion: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.dagInstanceId != nil {
            map["DagInstanceId"] = self.dagInstanceId!
        }
        if self.dagVersion != nil {
            map["DagVersion"] = self.dagVersion!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("DagInstanceId") {
            self.dagInstanceId = dict["DagInstanceId"] as! Int64
        }
        if dict.keys.contains("DagVersion") {
            self.dagVersion = dict["DagVersion"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ReRunTaskFlowInstanceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ReRunTaskFlowInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReRunTaskFlowInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReRunTaskFlowInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefundPayAsYouGoOrderRequest : Tea.TeaModel {
    public var instanceId: String?

    public var orderId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class RefundPayAsYouGoOrderResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RefundPayAsYouGoOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefundPayAsYouGoOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RefundPayAsYouGoOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterInstanceRequest : Tea.TeaModel {
    public var dataLinkName: String?

    public var databasePassword: String?

    public var databaseUser: String?

    public var dbaUid: Int64?

    public var dbaUidByString: String?

    public var ddlOnline: Int32?

    public var ecsInstanceId: String?

    public var ecsRegion: String?

    public var enableSellSitd: String?

    public var envType: String?

    public var exportTimeout: Int32?

    public var host: String?

    public var instanceAlias: String?

    public var instanceSource: String?

    public var instanceType: String?

    public var networkType: String?

    public var port: Int32?

    public var queryTimeout: Int32?

    public var safeRule: String?

    public var sid: String?

    public var skipTest: Bool?

    public var templateId: Int64?

    public var templateType: String?

    public var tid: Int64?

    public var useDsql: Int32?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataLinkName != nil {
            map["DataLinkName"] = self.dataLinkName!
        }
        if self.databasePassword != nil {
            map["DatabasePassword"] = self.databasePassword!
        }
        if self.databaseUser != nil {
            map["DatabaseUser"] = self.databaseUser!
        }
        if self.dbaUid != nil {
            map["DbaUid"] = self.dbaUid!
        }
        if self.dbaUidByString != nil {
            map["DbaUidByString"] = self.dbaUidByString!
        }
        if self.ddlOnline != nil {
            map["DdlOnline"] = self.ddlOnline!
        }
        if self.ecsInstanceId != nil {
            map["EcsInstanceId"] = self.ecsInstanceId!
        }
        if self.ecsRegion != nil {
            map["EcsRegion"] = self.ecsRegion!
        }
        if self.enableSellSitd != nil {
            map["EnableSellSitd"] = self.enableSellSitd!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.exportTimeout != nil {
            map["ExportTimeout"] = self.exportTimeout!
        }
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.instanceAlias != nil {
            map["InstanceAlias"] = self.instanceAlias!
        }
        if self.instanceSource != nil {
            map["InstanceSource"] = self.instanceSource!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.queryTimeout != nil {
            map["QueryTimeout"] = self.queryTimeout!
        }
        if self.safeRule != nil {
            map["SafeRule"] = self.safeRule!
        }
        if self.sid != nil {
            map["Sid"] = self.sid!
        }
        if self.skipTest != nil {
            map["SkipTest"] = self.skipTest!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.useDsql != nil {
            map["UseDsql"] = self.useDsql!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataLinkName") {
            self.dataLinkName = dict["DataLinkName"] as! String
        }
        if dict.keys.contains("DatabasePassword") {
            self.databasePassword = dict["DatabasePassword"] as! String
        }
        if dict.keys.contains("DatabaseUser") {
            self.databaseUser = dict["DatabaseUser"] as! String
        }
        if dict.keys.contains("DbaUid") {
            self.dbaUid = dict["DbaUid"] as! Int64
        }
        if dict.keys.contains("DbaUidByString") {
            self.dbaUidByString = dict["DbaUidByString"] as! String
        }
        if dict.keys.contains("DdlOnline") {
            self.ddlOnline = dict["DdlOnline"] as! Int32
        }
        if dict.keys.contains("EcsInstanceId") {
            self.ecsInstanceId = dict["EcsInstanceId"] as! String
        }
        if dict.keys.contains("EcsRegion") {
            self.ecsRegion = dict["EcsRegion"] as! String
        }
        if dict.keys.contains("EnableSellSitd") {
            self.enableSellSitd = dict["EnableSellSitd"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("ExportTimeout") {
            self.exportTimeout = dict["ExportTimeout"] as! Int32
        }
        if dict.keys.contains("Host") {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("InstanceAlias") {
            self.instanceAlias = dict["InstanceAlias"] as! String
        }
        if dict.keys.contains("InstanceSource") {
            self.instanceSource = dict["InstanceSource"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("QueryTimeout") {
            self.queryTimeout = dict["QueryTimeout"] as! Int32
        }
        if dict.keys.contains("SafeRule") {
            self.safeRule = dict["SafeRule"] as! String
        }
        if dict.keys.contains("Sid") {
            self.sid = dict["Sid"] as! String
        }
        if dict.keys.contains("SkipTest") {
            self.skipTest = dict["SkipTest"] as! Bool
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UseDsql") {
            self.useDsql = dict["UseDsql"] as! Int32
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class RegisterInstanceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RegisterInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RegisterInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterUserRequest : Tea.TeaModel {
    public var mobile: String?

    public var roleNames: String?

    public var tid: Int64?

    public var uid: String?

    public var userNick: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mobile != nil {
            map["Mobile"] = self.mobile!
        }
        if self.roleNames != nil {
            map["RoleNames"] = self.roleNames!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        if self.userNick != nil {
            map["UserNick"] = self.userNick!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Mobile") {
            self.mobile = dict["Mobile"] as! String
        }
        if dict.keys.contains("RoleNames") {
            self.roleNames = dict["RoleNames"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("Uid") {
            self.uid = dict["Uid"] as! String
        }
        if dict.keys.contains("UserNick") {
            self.userNick = dict["UserNick"] as! String
        }
    }
}

public class RegisterUserResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RegisterUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RegisterUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveDataExportJobRequest : Tea.TeaModel {
    public var jobId: Int64?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! Int64
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class RemoveDataExportJobResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RemoveDataExportJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveDataExportJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveDataExportJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestartDataCorrectSQLJobRequest : Tea.TeaModel {
    public var jobId: Int64?

    public var orderId: Int64?

    public var realLoginUserUid: String?

    public var tid: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.realLoginUserUid != nil {
            map["RealLoginUserUid"] = self.realLoginUserUid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! Int64
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RealLoginUserUid") {
            self.realLoginUserUid = dict["RealLoginUserUid"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class RestartDataCorrectSQLJobResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RestartDataCorrectSQLJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartDataCorrectSQLJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RestartDataCorrectSQLJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestartDataExportJobRequest : Tea.TeaModel {
    public var jobId: Int64?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! Int64
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class RestartDataExportJobResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RestartDataExportJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartDataExportJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RestartDataExportJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResumeTaskFlowInstanceRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var dagInstanceId: Int64?

    public var dagVersion: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.dagInstanceId != nil {
            map["DagInstanceId"] = self.dagInstanceId!
        }
        if self.dagVersion != nil {
            map["DagVersion"] = self.dagVersion!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("DagInstanceId") {
            self.dagInstanceId = dict["DagInstanceId"] as! Int64
        }
        if dict.keys.contains("DagVersion") {
            self.dagVersion = dict["DagVersion"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ResumeTaskFlowInstanceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ResumeTaskFlowInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeTaskFlowInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResumeTaskFlowInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RetryDataCorrectPreCheckRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var realLoginUserUid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.realLoginUserUid != nil {
            map["RealLoginUserUid"] = self.realLoginUserUid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RealLoginUserUid") {
            self.realLoginUserUid = dict["RealLoginUserUid"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class RetryDataCorrectPreCheckResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RetryDataCorrectPreCheckResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetryDataCorrectPreCheckResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RetryDataCorrectPreCheckResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RevokeTemplateAuthorityRequest : Tea.TeaModel {
    public var templateId: Int64?

    public var tid: Int64?

    public var userIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserIds") {
            self.userIds = dict["UserIds"] as! String
        }
    }
}

public class RevokeTemplateAuthorityResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RevokeTemplateAuthorityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeTemplateAuthorityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RevokeTemplateAuthorityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RevokeUserPermissionRequest : Tea.TeaModel {
    public var dbId: String?

    public var dsType: String?

    public var instanceId: Int64?

    public var logic: Bool?

    public var permTypes: String?

    public var tableId: String?

    public var tableName: String?

    public var tid: Int64?

    public var userAccessId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.dsType != nil {
            map["DsType"] = self.dsType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.permTypes != nil {
            map["PermTypes"] = self.permTypes!
        }
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userAccessId != nil {
            map["UserAccessId"] = self.userAccessId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! String
        }
        if dict.keys.contains("DsType") {
            self.dsType = dict["DsType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("Logic") {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("PermTypes") {
            self.permTypes = dict["PermTypes"] as! String
        }
        if dict.keys.contains("TableId") {
            self.tableId = dict["TableId"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserAccessId") {
            self.userAccessId = dict["UserAccessId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class RevokeUserPermissionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RevokeUserPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeUserPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RevokeUserPermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchDataTrackResultRequest : Tea.TeaModel {
    public class ColumnFilter : Tea.TeaModel {
        public var betweenEnd: String?

        public var betweenStart: String?

        public var columnName: String?

        public var inList: [String]?

        public var operator_: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.betweenEnd != nil {
                map["BetweenEnd"] = self.betweenEnd!
            }
            if self.betweenStart != nil {
                map["BetweenStart"] = self.betweenStart!
            }
            if self.columnName != nil {
                map["ColumnName"] = self.columnName!
            }
            if self.inList != nil {
                map["InList"] = self.inList!
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BetweenEnd") {
                self.betweenEnd = dict["BetweenEnd"] as! String
            }
            if dict.keys.contains("BetweenStart") {
                self.betweenStart = dict["BetweenStart"] as! String
            }
            if dict.keys.contains("ColumnName") {
                self.columnName = dict["ColumnName"] as! String
            }
            if dict.keys.contains("InList") {
                self.inList = dict["InList"] as! [String]
            }
            if dict.keys.contains("Operator") {
                self.operator_ = dict["Operator"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var columnFilter: SearchDataTrackResultRequest.ColumnFilter?

    public var filterEndTime: String?

    public var filterStartTime: String?

    public var filterTableList: [String]?

    public var filterTypeList: [String]?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.columnFilter?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnFilter != nil {
            map["ColumnFilter"] = self.columnFilter?.toMap()
        }
        if self.filterEndTime != nil {
            map["FilterEndTime"] = self.filterEndTime!
        }
        if self.filterStartTime != nil {
            map["FilterStartTime"] = self.filterStartTime!
        }
        if self.filterTableList != nil {
            map["FilterTableList"] = self.filterTableList!
        }
        if self.filterTypeList != nil {
            map["FilterTypeList"] = self.filterTypeList!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnFilter") {
            var model = SearchDataTrackResultRequest.ColumnFilter()
            model.fromMap(dict["ColumnFilter"] as! [String: Any])
            self.columnFilter = model
        }
        if dict.keys.contains("FilterEndTime") {
            self.filterEndTime = dict["FilterEndTime"] as! String
        }
        if dict.keys.contains("FilterStartTime") {
            self.filterStartTime = dict["FilterStartTime"] as! String
        }
        if dict.keys.contains("FilterTableList") {
            self.filterTableList = dict["FilterTableList"] as! [String]
        }
        if dict.keys.contains("FilterTypeList") {
            self.filterTypeList = dict["FilterTypeList"] as! [String]
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SearchDataTrackResultShrinkRequest : Tea.TeaModel {
    public var columnFilterShrink: String?

    public var filterEndTime: String?

    public var filterStartTime: String?

    public var filterTableListShrink: String?

    public var filterTypeListShrink: String?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnFilterShrink != nil {
            map["ColumnFilter"] = self.columnFilterShrink!
        }
        if self.filterEndTime != nil {
            map["FilterEndTime"] = self.filterEndTime!
        }
        if self.filterStartTime != nil {
            map["FilterStartTime"] = self.filterStartTime!
        }
        if self.filterTableListShrink != nil {
            map["FilterTableList"] = self.filterTableListShrink!
        }
        if self.filterTypeListShrink != nil {
            map["FilterTypeList"] = self.filterTypeListShrink!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnFilter") {
            self.columnFilterShrink = dict["ColumnFilter"] as! String
        }
        if dict.keys.contains("FilterEndTime") {
            self.filterEndTime = dict["FilterEndTime"] as! String
        }
        if dict.keys.contains("FilterStartTime") {
            self.filterStartTime = dict["FilterStartTime"] as! String
        }
        if dict.keys.contains("FilterTableList") {
            self.filterTableListShrink = dict["FilterTableList"] as! String
        }
        if dict.keys.contains("FilterTypeList") {
            self.filterTypeListShrink = dict["FilterTypeList"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SearchDataTrackResultResponseBody : Tea.TeaModel {
    public class TrackResult : Tea.TeaModel {
        public class EventList : Tea.TeaModel {
            public var dataAfter: [String]?

            public var dataBefore: [String]?

            public var eventId: Int64?

            public var eventLength: Int64?

            public var eventTimestamp: String?

            public var eventType: String?

            public var rollSQL: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataAfter != nil {
                    map["DataAfter"] = self.dataAfter!
                }
                if self.dataBefore != nil {
                    map["DataBefore"] = self.dataBefore!
                }
                if self.eventId != nil {
                    map["EventId"] = self.eventId!
                }
                if self.eventLength != nil {
                    map["EventLength"] = self.eventLength!
                }
                if self.eventTimestamp != nil {
                    map["EventTimestamp"] = self.eventTimestamp!
                }
                if self.eventType != nil {
                    map["EventType"] = self.eventType!
                }
                if self.rollSQL != nil {
                    map["RollSQL"] = self.rollSQL!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataAfter") {
                    self.dataAfter = dict["DataAfter"] as! [String]
                }
                if dict.keys.contains("DataBefore") {
                    self.dataBefore = dict["DataBefore"] as! [String]
                }
                if dict.keys.contains("EventId") {
                    self.eventId = dict["EventId"] as! Int64
                }
                if dict.keys.contains("EventLength") {
                    self.eventLength = dict["EventLength"] as! Int64
                }
                if dict.keys.contains("EventTimestamp") {
                    self.eventTimestamp = dict["EventTimestamp"] as! String
                }
                if dict.keys.contains("EventType") {
                    self.eventType = dict["EventType"] as! String
                }
                if dict.keys.contains("RollSQL") {
                    self.rollSQL = dict["RollSQL"] as! String
                }
            }
        }
        public class TableInfoList : Tea.TeaModel {
            public class Columns : Tea.TeaModel {
                public var columnName: String?

                public var columnPosition: Int32?

                public var columnType: String?

                public var fictive: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.columnName != nil {
                        map["ColumnName"] = self.columnName!
                    }
                    if self.columnPosition != nil {
                        map["ColumnPosition"] = self.columnPosition!
                    }
                    if self.columnType != nil {
                        map["ColumnType"] = self.columnType!
                    }
                    if self.fictive != nil {
                        map["Fictive"] = self.fictive!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ColumnName") {
                        self.columnName = dict["ColumnName"] as! String
                    }
                    if dict.keys.contains("ColumnPosition") {
                        self.columnPosition = dict["ColumnPosition"] as! Int32
                    }
                    if dict.keys.contains("ColumnType") {
                        self.columnType = dict["ColumnType"] as! String
                    }
                    if dict.keys.contains("Fictive") {
                        self.fictive = dict["Fictive"] as! Bool
                    }
                }
            }
            public var columns: [SearchDataTrackResultResponseBody.TrackResult.TableInfoList.Columns]?

            public var description_: String?

            public var schemaName: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columns != nil {
                    var tmp : [Any] = []
                    for k in self.columns! {
                        tmp.append(k.toMap())
                    }
                    map["Columns"] = tmp
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Columns") {
                    var tmp : [SearchDataTrackResultResponseBody.TrackResult.TableInfoList.Columns] = []
                    for v in dict["Columns"] as! [Any] {
                        var model = SearchDataTrackResultResponseBody.TrackResult.TableInfoList.Columns()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.columns = tmp
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("SchemaName") {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public var eventList: [SearchDataTrackResultResponseBody.TrackResult.EventList]?

        public var tableInfoList: [SearchDataTrackResultResponseBody.TrackResult.TableInfoList]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventList != nil {
                var tmp : [Any] = []
                for k in self.eventList! {
                    tmp.append(k.toMap())
                }
                map["EventList"] = tmp
            }
            if self.tableInfoList != nil {
                var tmp : [Any] = []
                for k in self.tableInfoList! {
                    tmp.append(k.toMap())
                }
                map["TableInfoList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventList") {
                var tmp : [SearchDataTrackResultResponseBody.TrackResult.EventList] = []
                for v in dict["EventList"] as! [Any] {
                    var model = SearchDataTrackResultResponseBody.TrackResult.EventList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eventList = tmp
            }
            if dict.keys.contains("TableInfoList") {
                var tmp : [SearchDataTrackResultResponseBody.TrackResult.TableInfoList] = []
                for v in dict["TableInfoList"] as! [Any] {
                    var model = SearchDataTrackResultResponseBody.TrackResult.TableInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tableInfoList = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var trackResult: SearchDataTrackResultResponseBody.TrackResult?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.trackResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.trackResult != nil {
            map["TrackResult"] = self.trackResult?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TrackResult") {
            var model = SearchDataTrackResultResponseBody.TrackResult()
            model.fromMap(dict["TrackResult"] as! [String: Any])
            self.trackResult = model
        }
    }
}

public class SearchDataTrackResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchDataTrackResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchDataTrackResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchDatabaseRequest : Tea.TeaModel {
    public var dbType: String?

    public var envType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchKey: String?

    public var searchRange: String?

    public var searchTarget: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbType != nil {
            map["DbType"] = self.dbType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.searchRange != nil {
            map["SearchRange"] = self.searchRange!
        }
        if self.searchTarget != nil {
            map["SearchTarget"] = self.searchTarget!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbType") {
            self.dbType = dict["DbType"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("SearchRange") {
            self.searchRange = dict["SearchRange"] as! String
        }
        if dict.keys.contains("SearchTarget") {
            self.searchTarget = dict["SearchTarget"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SearchDatabaseResponseBody : Tea.TeaModel {
    public class SearchDatabaseList : Tea.TeaModel {
        public class SearchDatabase : Tea.TeaModel {
            public class OwnerIdList : Tea.TeaModel {
                public var ownerIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerIds") {
                        self.ownerIds = dict["OwnerIds"] as! [String]
                    }
                }
            }
            public class OwnerNameList : Tea.TeaModel {
                public var ownerNames: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerNames != nil {
                        map["OwnerNames"] = self.ownerNames!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerNames") {
                        self.ownerNames = dict["OwnerNames"] as! [String]
                    }
                }
            }
            public var alias: String?

            public var catalogName: String?

            public var databaseId: String?

            public var datalinkName: String?

            public var dbType: String?

            public var dbaId: String?

            public var encoding: String?

            public var envType: String?

            public var host: String?

            public var logic: Bool?

            public var ownerIdList: SearchDatabaseResponseBody.SearchDatabaseList.SearchDatabase.OwnerIdList?

            public var ownerNameList: SearchDatabaseResponseBody.SearchDatabaseList.SearchDatabase.OwnerNameList?

            public var port: Int32?

            public var schemaName: String?

            public var searchName: String?

            public var sid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ownerIdList?.validate()
                try self.ownerNameList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.catalogName != nil {
                    map["CatalogName"] = self.catalogName!
                }
                if self.databaseId != nil {
                    map["DatabaseId"] = self.databaseId!
                }
                if self.datalinkName != nil {
                    map["DatalinkName"] = self.datalinkName!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.dbaId != nil {
                    map["DbaId"] = self.dbaId!
                }
                if self.encoding != nil {
                    map["Encoding"] = self.encoding!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.ownerIdList != nil {
                    map["OwnerIdList"] = self.ownerIdList?.toMap()
                }
                if self.ownerNameList != nil {
                    map["OwnerNameList"] = self.ownerNameList?.toMap()
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                if self.sid != nil {
                    map["Sid"] = self.sid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("CatalogName") {
                    self.catalogName = dict["CatalogName"] as! String
                }
                if dict.keys.contains("DatabaseId") {
                    self.databaseId = dict["DatabaseId"] as! String
                }
                if dict.keys.contains("DatalinkName") {
                    self.datalinkName = dict["DatalinkName"] as! String
                }
                if dict.keys.contains("DbType") {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("DbaId") {
                    self.dbaId = dict["DbaId"] as! String
                }
                if dict.keys.contains("Encoding") {
                    self.encoding = dict["Encoding"] as! String
                }
                if dict.keys.contains("EnvType") {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("OwnerIdList") {
                    var model = SearchDatabaseResponseBody.SearchDatabaseList.SearchDatabase.OwnerIdList()
                    model.fromMap(dict["OwnerIdList"] as! [String: Any])
                    self.ownerIdList = model
                }
                if dict.keys.contains("OwnerNameList") {
                    var model = SearchDatabaseResponseBody.SearchDatabaseList.SearchDatabase.OwnerNameList()
                    model.fromMap(dict["OwnerNameList"] as! [String: Any])
                    self.ownerNameList = model
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("SchemaName") {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SearchName") {
                    self.searchName = dict["SearchName"] as! String
                }
                if dict.keys.contains("Sid") {
                    self.sid = dict["Sid"] as! String
                }
            }
        }
        public var searchDatabase: [SearchDatabaseResponseBody.SearchDatabaseList.SearchDatabase]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.searchDatabase != nil {
                var tmp : [Any] = []
                for k in self.searchDatabase! {
                    tmp.append(k.toMap())
                }
                map["SearchDatabase"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SearchDatabase") {
                var tmp : [SearchDatabaseResponseBody.SearchDatabaseList.SearchDatabase] = []
                for v in dict["SearchDatabase"] as! [Any] {
                    var model = SearchDatabaseResponseBody.SearchDatabaseList.SearchDatabase()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.searchDatabase = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var searchDatabaseList: SearchDatabaseResponseBody.SearchDatabaseList?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.searchDatabaseList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.searchDatabaseList != nil {
            map["SearchDatabaseList"] = self.searchDatabaseList?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SearchDatabaseList") {
            var model = SearchDatabaseResponseBody.SearchDatabaseList()
            model.fromMap(dict["SearchDatabaseList"] as! [String: Any])
            self.searchDatabaseList = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SearchDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchTableRequest : Tea.TeaModel {
    public var dbType: String?

    public var envType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var returnGuid: Bool?

    public var searchKey: String?

    public var searchRange: String?

    public var searchTarget: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbType != nil {
            map["DbType"] = self.dbType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.returnGuid != nil {
            map["ReturnGuid"] = self.returnGuid!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.searchRange != nil {
            map["SearchRange"] = self.searchRange!
        }
        if self.searchTarget != nil {
            map["SearchTarget"] = self.searchTarget!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbType") {
            self.dbType = dict["DbType"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ReturnGuid") {
            self.returnGuid = dict["ReturnGuid"] as! Bool
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("SearchRange") {
            self.searchRange = dict["SearchRange"] as! String
        }
        if dict.keys.contains("SearchTarget") {
            self.searchTarget = dict["SearchTarget"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SearchTableResponseBody : Tea.TeaModel {
    public class SearchTableList : Tea.TeaModel {
        public class SearchTable : Tea.TeaModel {
            public class OwnerIdList : Tea.TeaModel {
                public var ownerIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerIds") {
                        self.ownerIds = dict["OwnerIds"] as! [String]
                    }
                }
            }
            public class OwnerNameList : Tea.TeaModel {
                public var ownerNames: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerNames != nil {
                        map["OwnerNames"] = self.ownerNames!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerNames") {
                        self.ownerNames = dict["OwnerNames"] as! [String]
                    }
                }
            }
            public var DBSearchName: String?

            public var databaseId: String?

            public var dbName: String?

            public var dbType: String?

            public var description_: String?

            public var encoding: String?

            public var engine: String?

            public var envType: String?

            public var logic: Bool?

            public var ownerIdList: SearchTableResponseBody.SearchTableList.SearchTable.OwnerIdList?

            public var ownerNameList: SearchTableResponseBody.SearchTableList.SearchTable.OwnerNameList?

            public var tableGuid: String?

            public var tableId: String?

            public var tableName: String?

            public var tableSchemaName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ownerIdList?.validate()
                try self.ownerNameList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBSearchName != nil {
                    map["DBSearchName"] = self.DBSearchName!
                }
                if self.databaseId != nil {
                    map["DatabaseId"] = self.databaseId!
                }
                if self.dbName != nil {
                    map["DbName"] = self.dbName!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.encoding != nil {
                    map["Encoding"] = self.encoding!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.ownerIdList != nil {
                    map["OwnerIdList"] = self.ownerIdList?.toMap()
                }
                if self.ownerNameList != nil {
                    map["OwnerNameList"] = self.ownerNameList?.toMap()
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.tableId != nil {
                    map["TableId"] = self.tableId!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.tableSchemaName != nil {
                    map["TableSchemaName"] = self.tableSchemaName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DBSearchName") {
                    self.DBSearchName = dict["DBSearchName"] as! String
                }
                if dict.keys.contains("DatabaseId") {
                    self.databaseId = dict["DatabaseId"] as! String
                }
                if dict.keys.contains("DbName") {
                    self.dbName = dict["DbName"] as! String
                }
                if dict.keys.contains("DbType") {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Encoding") {
                    self.encoding = dict["Encoding"] as! String
                }
                if dict.keys.contains("Engine") {
                    self.engine = dict["Engine"] as! String
                }
                if dict.keys.contains("EnvType") {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("Logic") {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("OwnerIdList") {
                    var model = SearchTableResponseBody.SearchTableList.SearchTable.OwnerIdList()
                    model.fromMap(dict["OwnerIdList"] as! [String: Any])
                    self.ownerIdList = model
                }
                if dict.keys.contains("OwnerNameList") {
                    var model = SearchTableResponseBody.SearchTableList.SearchTable.OwnerNameList()
                    model.fromMap(dict["OwnerNameList"] as! [String: Any])
                    self.ownerNameList = model
                }
                if dict.keys.contains("TableGuid") {
                    self.tableGuid = dict["TableGuid"] as! String
                }
                if dict.keys.contains("TableId") {
                    self.tableId = dict["TableId"] as! String
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("TableSchemaName") {
                    self.tableSchemaName = dict["TableSchemaName"] as! String
                }
            }
        }
        public var searchTable: [SearchTableResponseBody.SearchTableList.SearchTable]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.searchTable != nil {
                var tmp : [Any] = []
                for k in self.searchTable! {
                    tmp.append(k.toMap())
                }
                map["SearchTable"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SearchTable") {
                var tmp : [SearchTableResponseBody.SearchTableList.SearchTable] = []
                for v in dict["SearchTable"] as! [Any] {
                    var model = SearchTableResponseBody.SearchTableList.SearchTable()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.searchTable = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var searchTableList: SearchTableResponseBody.SearchTableList?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.searchTableList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.searchTableList != nil {
            map["SearchTableList"] = self.searchTableList?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SearchTableList") {
            var model = SearchTableResponseBody.SearchTableList()
            model.fromMap(dict["SearchTableList"] as! [String: Any])
            self.searchTableList = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SearchTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetOwnersRequest : Tea.TeaModel {
    public var ownerIds: String?

    public var ownerType: String?

    public var resourceId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerIds != nil {
            map["OwnerIds"] = self.ownerIds!
        }
        if self.ownerType != nil {
            map["OwnerType"] = self.ownerType!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerIds") {
            self.ownerIds = dict["OwnerIds"] as! String
        }
        if dict.keys.contains("OwnerType") {
            self.ownerType = dict["OwnerType"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SetOwnersResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetOwnersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetOwnersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetOwnersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetWorkflowExtraInfoRequest : Tea.TeaModel {
    public var renderAddApprovalNode: Bool?

    public var renderAgree: Bool?

    public var renderCancel: Bool?

    public var renderReject: Bool?

    public var renderTransfer: Bool?

    public var thirdpartyWorkflowComment: String?

    public var thirdpartyWorkflowUrl: String?

    public var tid: Int64?

    public var workflowInstanceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.renderAddApprovalNode != nil {
            map["RenderAddApprovalNode"] = self.renderAddApprovalNode!
        }
        if self.renderAgree != nil {
            map["RenderAgree"] = self.renderAgree!
        }
        if self.renderCancel != nil {
            map["RenderCancel"] = self.renderCancel!
        }
        if self.renderReject != nil {
            map["RenderReject"] = self.renderReject!
        }
        if self.renderTransfer != nil {
            map["RenderTransfer"] = self.renderTransfer!
        }
        if self.thirdpartyWorkflowComment != nil {
            map["ThirdpartyWorkflowComment"] = self.thirdpartyWorkflowComment!
        }
        if self.thirdpartyWorkflowUrl != nil {
            map["ThirdpartyWorkflowUrl"] = self.thirdpartyWorkflowUrl!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.workflowInstanceId != nil {
            map["WorkflowInstanceId"] = self.workflowInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RenderAddApprovalNode") {
            self.renderAddApprovalNode = dict["RenderAddApprovalNode"] as! Bool
        }
        if dict.keys.contains("RenderAgree") {
            self.renderAgree = dict["RenderAgree"] as! Bool
        }
        if dict.keys.contains("RenderCancel") {
            self.renderCancel = dict["RenderCancel"] as! Bool
        }
        if dict.keys.contains("RenderReject") {
            self.renderReject = dict["RenderReject"] as! Bool
        }
        if dict.keys.contains("RenderTransfer") {
            self.renderTransfer = dict["RenderTransfer"] as! Bool
        }
        if dict.keys.contains("ThirdpartyWorkflowComment") {
            self.thirdpartyWorkflowComment = dict["ThirdpartyWorkflowComment"] as! String
        }
        if dict.keys.contains("ThirdpartyWorkflowUrl") {
            self.thirdpartyWorkflowUrl = dict["ThirdpartyWorkflowUrl"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("WorkflowInstanceId") {
            self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
        }
    }
}

public class SetWorkflowExtraInfoResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetWorkflowExtraInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetWorkflowExtraInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetWorkflowExtraInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SkipDataCorrectRowCheckRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var realLoginUserUid: String?

    public var reason: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.realLoginUserUid != nil {
            map["RealLoginUserUid"] = self.realLoginUserUid!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RealLoginUserUid") {
            self.realLoginUserUid = dict["RealLoginUserUid"] as! String
        }
        if dict.keys.contains("Reason") {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SkipDataCorrectRowCheckResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SkipDataCorrectRowCheckResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SkipDataCorrectRowCheckResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SkipDataCorrectRowCheckResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopTaskFlowInstanceRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var dagInstanceId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.dagInstanceId != nil {
            map["DagInstanceId"] = self.dagInstanceId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("DagInstanceId") {
            self.dagInstanceId = dict["DagInstanceId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class StopTaskFlowInstanceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StopTaskFlowInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopTaskFlowInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopTaskFlowInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitOrderApprovalRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var realLoginUserUid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.realLoginUserUid != nil {
            map["RealLoginUserUid"] = self.realLoginUserUid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RealLoginUserUid") {
            self.realLoginUserUid = dict["RealLoginUserUid"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SubmitOrderApprovalResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SubmitOrderApprovalResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitOrderApprovalResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitOrderApprovalResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitStructSyncOrderApprovalRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SubmitStructSyncOrderApprovalResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var workflowInstanceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.workflowInstanceId != nil {
            map["WorkflowInstanceId"] = self.workflowInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("WorkflowInstanceId") {
            self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
        }
    }
}

public class SubmitStructSyncOrderApprovalResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitStructSyncOrderApprovalResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitStructSyncOrderApprovalResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SuspendDataExportJobRequest : Tea.TeaModel {
    public var jobId: Int64?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! Int64
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SuspendDataExportJobResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SuspendDataExportJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendDataExportJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SuspendDataExportJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SuspendTaskFlowInstanceRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var dagInstanceId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.dagInstanceId != nil {
            map["DagInstanceId"] = self.dagInstanceId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("DagInstanceId") {
            self.dagInstanceId = dict["DagInstanceId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SuspendTaskFlowInstanceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SuspendTaskFlowInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendTaskFlowInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SuspendTaskFlowInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SyncDatabaseMetaRequest : Tea.TeaModel {
    public var dbId: String?

    public var logic: Bool?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") {
            self.dbId = dict["DbId"] as! String
        }
        if dict.keys.contains("Logic") {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SyncDatabaseMetaResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SyncDatabaseMetaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SyncDatabaseMetaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SyncDatabaseMetaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SyncInstanceMetaRequest : Tea.TeaModel {
    public var ignoreTable: Bool?

    public var instanceId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ignoreTable != nil {
            map["IgnoreTable"] = self.ignoreTable!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IgnoreTable") {
            self.ignoreTable = dict["IgnoreTable"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SyncInstanceMetaResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SyncInstanceMetaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SyncInstanceMetaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SyncInstanceMetaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAbacPolicyRequest : Tea.TeaModel {
    public var abacPolicyContent: String?

    public var abacPolicyDesc: String?

    public var abacPolicyId: Int64?

    public var abacPolicyName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.abacPolicyContent != nil {
            map["AbacPolicyContent"] = self.abacPolicyContent!
        }
        if self.abacPolicyDesc != nil {
            map["AbacPolicyDesc"] = self.abacPolicyDesc!
        }
        if self.abacPolicyId != nil {
            map["AbacPolicyId"] = self.abacPolicyId!
        }
        if self.abacPolicyName != nil {
            map["AbacPolicyName"] = self.abacPolicyName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AbacPolicyContent") {
            self.abacPolicyContent = dict["AbacPolicyContent"] as! String
        }
        if dict.keys.contains("AbacPolicyDesc") {
            self.abacPolicyDesc = dict["AbacPolicyDesc"] as! String
        }
        if dict.keys.contains("AbacPolicyId") {
            self.abacPolicyId = dict["AbacPolicyId"] as! Int64
        }
        if dict.keys.contains("AbacPolicyName") {
            self.abacPolicyName = dict["AbacPolicyName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateAbacPolicyResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var updatePolicyResult: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.updatePolicyResult != nil {
            map["UpdatePolicyResult"] = self.updatePolicyResult!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("UpdatePolicyResult") {
            self.updatePolicyResult = dict["UpdatePolicyResult"] as! Int64
        }
    }
}

public class UpdateAbacPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAbacPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAbacPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAuthorityTemplateRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var templateId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateAuthorityTemplateResponseBody : Tea.TeaModel {
    public class AuthorityTemplateView : Tea.TeaModel {
        public var creatorId: Int64?

        public var description_: String?

        public var name: String?

        public var templateId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! Int64
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! Int64
            }
        }
    }
    public var authorityTemplateView: UpdateAuthorityTemplateResponseBody.AuthorityTemplateView?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authorityTemplateView?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorityTemplateView != nil {
            map["AuthorityTemplateView"] = self.authorityTemplateView?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorityTemplateView") {
            var model = UpdateAuthorityTemplateResponseBody.AuthorityTemplateView()
            model.fromMap(dict["AuthorityTemplateView"] as! [String: Any])
            self.authorityTemplateView = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateAuthorityTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAuthorityTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAuthorityTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDataLakeDatabaseRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var description_: String?

    public var location: String?

    public var parameters: [String: String]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("Parameters") {
            self.parameters = dict["Parameters"] as! [String: String]
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateDataLakeDatabaseShrinkRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var description_: String?

    public var location: String?

    public var parametersShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.parametersShrink != nil {
            map["Parameters"] = self.parametersShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("Parameters") {
            self.parametersShrink = dict["Parameters"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateDataLakeDatabaseResponseBody : Tea.TeaModel {
    public var database: DLDatabase?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.database?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.database != nil {
            map["Database"] = self.database?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Database") {
            var model = DLDatabase()
            model.fromMap(dict["Database"] as! [String: Any])
            self.database = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateDataLakeDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDataLakeDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDataLakeDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDataLakePartitionRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var partitionInput: DLPartitionInput?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.partitionInput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.partitionInput != nil {
            map["PartitionInput"] = self.partitionInput?.toMap()
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("PartitionInput") {
            var model = DLPartitionInput()
            model.fromMap(dict["PartitionInput"] as! [String: Any])
            self.partitionInput = model
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateDataLakePartitionShrinkRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var partitionInputShrink: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.partitionInputShrink != nil {
            map["PartitionInput"] = self.partitionInputShrink!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("PartitionInput") {
            self.partitionInputShrink = dict["PartitionInput"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateDataLakePartitionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateDataLakePartitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDataLakePartitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDataLakePartitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDataLakeTableRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var tableInput: OpenStructDLTableInput?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tableInput?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.tableInput != nil {
            map["TableInput"] = self.tableInput?.toMap()
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("TableInput") {
            var model = OpenStructDLTableInput()
            model.fromMap(dict["TableInput"] as! [String: Any])
            self.tableInput = model
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateDataLakeTableShrinkRequest : Tea.TeaModel {
    public var catalogName: String?

    public var dataRegion: String?

    public var dbName: String?

    public var tableInputShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.dataRegion != nil {
            map["DataRegion"] = self.dataRegion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.tableInputShrink != nil {
            map["TableInput"] = self.tableInputShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("DataRegion") {
            self.dataRegion = dict["DataRegion"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("TableInput") {
            self.tableInputShrink = dict["TableInput"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateDataLakeTableResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var table: DLTable?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.table?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.table != nil {
            map["Table"] = self.table?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Table") {
            var model = DLTable()
            model.fromMap(dict["Table"] as! [String: Any])
            self.table = model
        }
    }
}

public class UpdateDataLakeTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDataLakeTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDataLakeTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateInstanceRequest : Tea.TeaModel {
    public var dataLinkName: String?

    public var databasePassword: String?

    public var databaseUser: String?

    public var dbaId: String?

    public var ddlOnline: Int32?

    public var ecsInstanceId: String?

    public var ecsRegion: String?

    public var enableSellSitd: String?

    public var envType: String?

    public var exportTimeout: Int32?

    public var host: String?

    public var instanceAlias: String?

    public var instanceId: String?

    public var instanceSource: String?

    public var instanceType: String?

    public var port: Int32?

    public var queryTimeout: Int32?

    public var safeRuleId: String?

    public var sid: String?

    public var skipTest: Bool?

    public var templateId: Int64?

    public var templateType: String?

    public var tid: Int64?

    public var useDsql: Int32?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataLinkName != nil {
            map["DataLinkName"] = self.dataLinkName!
        }
        if self.databasePassword != nil {
            map["DatabasePassword"] = self.databasePassword!
        }
        if self.databaseUser != nil {
            map["DatabaseUser"] = self.databaseUser!
        }
        if self.dbaId != nil {
            map["DbaId"] = self.dbaId!
        }
        if self.ddlOnline != nil {
            map["DdlOnline"] = self.ddlOnline!
        }
        if self.ecsInstanceId != nil {
            map["EcsInstanceId"] = self.ecsInstanceId!
        }
        if self.ecsRegion != nil {
            map["EcsRegion"] = self.ecsRegion!
        }
        if self.enableSellSitd != nil {
            map["EnableSellSitd"] = self.enableSellSitd!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.exportTimeout != nil {
            map["ExportTimeout"] = self.exportTimeout!
        }
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.instanceAlias != nil {
            map["InstanceAlias"] = self.instanceAlias!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceSource != nil {
            map["InstanceSource"] = self.instanceSource!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.queryTimeout != nil {
            map["QueryTimeout"] = self.queryTimeout!
        }
        if self.safeRuleId != nil {
            map["SafeRuleId"] = self.safeRuleId!
        }
        if self.sid != nil {
            map["Sid"] = self.sid!
        }
        if self.skipTest != nil {
            map["SkipTest"] = self.skipTest!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.useDsql != nil {
            map["UseDsql"] = self.useDsql!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataLinkName") {
            self.dataLinkName = dict["DataLinkName"] as! String
        }
        if dict.keys.contains("DatabasePassword") {
            self.databasePassword = dict["DatabasePassword"] as! String
        }
        if dict.keys.contains("DatabaseUser") {
            self.databaseUser = dict["DatabaseUser"] as! String
        }
        if dict.keys.contains("DbaId") {
            self.dbaId = dict["DbaId"] as! String
        }
        if dict.keys.contains("DdlOnline") {
            self.ddlOnline = dict["DdlOnline"] as! Int32
        }
        if dict.keys.contains("EcsInstanceId") {
            self.ecsInstanceId = dict["EcsInstanceId"] as! String
        }
        if dict.keys.contains("EcsRegion") {
            self.ecsRegion = dict["EcsRegion"] as! String
        }
        if dict.keys.contains("EnableSellSitd") {
            self.enableSellSitd = dict["EnableSellSitd"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("ExportTimeout") {
            self.exportTimeout = dict["ExportTimeout"] as! Int32
        }
        if dict.keys.contains("Host") {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("InstanceAlias") {
            self.instanceAlias = dict["InstanceAlias"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceSource") {
            self.instanceSource = dict["InstanceSource"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("QueryTimeout") {
            self.queryTimeout = dict["QueryTimeout"] as! Int32
        }
        if dict.keys.contains("SafeRuleId") {
            self.safeRuleId = dict["SafeRuleId"] as! String
        }
        if dict.keys.contains("Sid") {
            self.sid = dict["Sid"] as! String
        }
        if dict.keys.contains("SkipTest") {
            self.skipTest = dict["SkipTest"] as! Bool
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UseDsql") {
            self.useDsql = dict["UseDsql"] as! Int32
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class UpdateInstanceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSLARulesRequest : Tea.TeaModel {
    public class SlaRuleList : Tea.TeaModel {
        public var dagId: Int64?

        public var intervalMinutes: Int32?

        public var nodeId: Int64?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dagId != nil {
                map["DagId"] = self.dagId!
            }
            if self.intervalMinutes != nil {
                map["IntervalMinutes"] = self.intervalMinutes!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DagId") {
                self.dagId = dict["DagId"] as! Int64
            }
            if dict.keys.contains("IntervalMinutes") {
                self.intervalMinutes = dict["IntervalMinutes"] as! Int32
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var dagId: Int64?

    public var slaRuleList: [UpdateSLARulesRequest.SlaRuleList]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.slaRuleList != nil {
            var tmp : [Any] = []
            for k in self.slaRuleList! {
                tmp.append(k.toMap())
            }
            map["SlaRuleList"] = tmp
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("SlaRuleList") {
            var tmp : [UpdateSLARulesRequest.SlaRuleList] = []
            for v in dict["SlaRuleList"] as! [Any] {
                var model = UpdateSLARulesRequest.SlaRuleList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.slaRuleList = tmp
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateSLARulesShrinkRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var slaRuleListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.slaRuleListShrink != nil {
            map["SlaRuleList"] = self.slaRuleListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("SlaRuleList") {
            self.slaRuleListShrink = dict["SlaRuleList"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateSLARulesResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateSLARulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSLARulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateSLARulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateScenarioRequest : Tea.TeaModel {
    public var description_: String?

    public var scenarioId: String?

    public var scenarioName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.scenarioName != nil {
            map["ScenarioName"] = self.scenarioName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ScenarioId") {
            self.scenarioId = dict["ScenarioId"] as! String
        }
        if dict.keys.contains("ScenarioName") {
            self.scenarioName = dict["ScenarioName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateScenarioResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateScenarioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateScenarioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateScenarioResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateStandardGroupRequest : Tea.TeaModel {
    public var description_: String?

    public var groupId: Int64?

    public var groupName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateStandardGroupResponseBody : Tea.TeaModel {
    public class StandardGroup : Tea.TeaModel {
        public var dbType: String?

        public var description_: String?

        public var groupId: Int64?

        public var groupMode: String?

        public var groupName: String?

        public var lastMenderId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupMode != nil {
                map["GroupMode"] = self.groupMode!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.lastMenderId != nil {
                map["LastMenderId"] = self.lastMenderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbType") {
                self.dbType = dict["DbType"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! Int64
            }
            if dict.keys.contains("GroupMode") {
                self.groupMode = dict["GroupMode"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("LastMenderId") {
                self.lastMenderId = dict["LastMenderId"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var standardGroup: UpdateStandardGroupResponseBody.StandardGroup?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.standardGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.standardGroup != nil {
            map["StandardGroup"] = self.standardGroup?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StandardGroup") {
            var model = UpdateStandardGroupResponseBody.StandardGroup()
            model.fromMap(dict["StandardGroup"] as! [String: Any])
            self.standardGroup = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateStandardGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateStandardGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateStandardGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskConfigRequest : Tea.TeaModel {
    public var nodeConfig: String?

    public var nodeId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeConfig != nil {
            map["NodeConfig"] = self.nodeConfig!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeConfig") {
            self.nodeConfig = dict["NodeConfig"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskConfigResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTaskConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskContentRequest : Tea.TeaModel {
    public var nodeContent: String?

    public var nodeId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeContent != nil {
            map["NodeContent"] = self.nodeContent!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeContent") {
            self.nodeContent = dict["NodeContent"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskContentResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTaskContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskFlowConstantsRequest : Tea.TeaModel {
    public class DagConstants : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var dagConstants: [UpdateTaskFlowConstantsRequest.DagConstants]?

    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagConstants != nil {
            var tmp : [Any] = []
            for k in self.dagConstants! {
                tmp.append(k.toMap())
            }
            map["DagConstants"] = tmp
        }
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagConstants") {
            var tmp : [UpdateTaskFlowConstantsRequest.DagConstants] = []
            for v in dict["DagConstants"] as! [Any] {
                var model = UpdateTaskFlowConstantsRequest.DagConstants()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dagConstants = tmp
        }
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowConstantsShrinkRequest : Tea.TeaModel {
    public var dagConstantsShrink: String?

    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagConstantsShrink != nil {
            map["DagConstants"] = self.dagConstantsShrink!
        }
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagConstants") {
            self.dagConstantsShrink = dict["DagConstants"] as! String
        }
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowConstantsResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskFlowConstantsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskFlowConstantsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTaskFlowConstantsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskFlowCooperatorsRequest : Tea.TeaModel {
    public var cooperatorIds: [String]?

    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cooperatorIds != nil {
            map["CooperatorIds"] = self.cooperatorIds!
        }
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CooperatorIds") {
            self.cooperatorIds = dict["CooperatorIds"] as! [String]
        }
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowCooperatorsShrinkRequest : Tea.TeaModel {
    public var cooperatorIdsShrink: String?

    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cooperatorIdsShrink != nil {
            map["CooperatorIds"] = self.cooperatorIdsShrink!
        }
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CooperatorIds") {
            self.cooperatorIdsShrink = dict["CooperatorIds"] as! String
        }
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowCooperatorsResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskFlowCooperatorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskFlowCooperatorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTaskFlowCooperatorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskFlowEdgesRequest : Tea.TeaModel {
    public class Edges : Tea.TeaModel {
        public var id: Int64?

        public var nodeEnd: Int64?

        public var nodeFrom: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.nodeEnd != nil {
                map["NodeEnd"] = self.nodeEnd!
            }
            if self.nodeFrom != nil {
                map["NodeFrom"] = self.nodeFrom!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("NodeEnd") {
                self.nodeEnd = dict["NodeEnd"] as! Int64
            }
            if dict.keys.contains("NodeFrom") {
                self.nodeFrom = dict["NodeFrom"] as! Int64
            }
        }
    }
    public var dagId: Int64?

    public var edges: [UpdateTaskFlowEdgesRequest.Edges]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.edges != nil {
            var tmp : [Any] = []
            for k in self.edges! {
                tmp.append(k.toMap())
            }
            map["Edges"] = tmp
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Edges") {
            var tmp : [UpdateTaskFlowEdgesRequest.Edges] = []
            for v in dict["Edges"] as! [Any] {
                var model = UpdateTaskFlowEdgesRequest.Edges()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.edges = tmp
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowEdgesShrinkRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var edgesShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.edgesShrink != nil {
            map["Edges"] = self.edgesShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Edges") {
            self.edgesShrink = dict["Edges"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowEdgesResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskFlowEdgesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskFlowEdgesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTaskFlowEdgesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskFlowNameAndDescRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var dagName: String?

    public var description_: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.dagName != nil {
            map["DagName"] = self.dagName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("DagName") {
            self.dagName = dict["DagName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowNameAndDescResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskFlowNameAndDescResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskFlowNameAndDescResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTaskFlowNameAndDescResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskFlowNotificationRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var dagNotificationFail: Bool?

    public var dagNotificationSla: Bool?

    public var dagNotificationSuccess: Bool?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.dagNotificationFail != nil {
            map["DagNotificationFail"] = self.dagNotificationFail!
        }
        if self.dagNotificationSla != nil {
            map["DagNotificationSla"] = self.dagNotificationSla!
        }
        if self.dagNotificationSuccess != nil {
            map["DagNotificationSuccess"] = self.dagNotificationSuccess!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("DagNotificationFail") {
            self.dagNotificationFail = dict["DagNotificationFail"] as! Bool
        }
        if dict.keys.contains("DagNotificationSla") {
            self.dagNotificationSla = dict["DagNotificationSla"] as! Bool
        }
        if dict.keys.contains("DagNotificationSuccess") {
            self.dagNotificationSuccess = dict["DagNotificationSuccess"] as! Bool
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowNotificationResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskFlowNotificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskFlowNotificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTaskFlowNotificationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskFlowOwnerRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var newOwnerId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.newOwnerId != nil {
            map["NewOwnerId"] = self.newOwnerId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("NewOwnerId") {
            self.newOwnerId = dict["NewOwnerId"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowOwnerResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskFlowOwnerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskFlowOwnerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTaskFlowOwnerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskFlowRelationsRequest : Tea.TeaModel {
    public class Edges : Tea.TeaModel {
        public var id: Int64?

        public var nodeEnd: Int64?

        public var nodeFrom: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.nodeEnd != nil {
                map["NodeEnd"] = self.nodeEnd!
            }
            if self.nodeFrom != nil {
                map["NodeFrom"] = self.nodeFrom!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("NodeEnd") {
                self.nodeEnd = dict["NodeEnd"] as! Int64
            }
            if dict.keys.contains("NodeFrom") {
                self.nodeFrom = dict["NodeFrom"] as! Int64
            }
        }
    }
    public var dagId: Int64?

    public var edges: [UpdateTaskFlowRelationsRequest.Edges]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.edges != nil {
            var tmp : [Any] = []
            for k in self.edges! {
                tmp.append(k.toMap())
            }
            map["Edges"] = tmp
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Edges") {
            var tmp : [UpdateTaskFlowRelationsRequest.Edges] = []
            for v in dict["Edges"] as! [Any] {
                var model = UpdateTaskFlowRelationsRequest.Edges()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.edges = tmp
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowRelationsShrinkRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var edgesShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.edgesShrink != nil {
            map["Edges"] = self.edgesShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Edges") {
            self.edgesShrink = dict["Edges"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowRelationsResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskFlowRelationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskFlowRelationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTaskFlowRelationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskFlowScheduleRequest : Tea.TeaModel {
    public var cronBeginDate: String?

    public var cronEndDate: String?

    public var cronStr: String?

    public var cronType: String?

    public var dagId: Int64?

    public var scheduleParam: String?

    public var scheduleSwitch: Bool?

    public var tid: Int64?

    public var timeZoneId: String?

    public var triggerType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cronBeginDate != nil {
            map["CronBeginDate"] = self.cronBeginDate!
        }
        if self.cronEndDate != nil {
            map["CronEndDate"] = self.cronEndDate!
        }
        if self.cronStr != nil {
            map["CronStr"] = self.cronStr!
        }
        if self.cronType != nil {
            map["CronType"] = self.cronType!
        }
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.scheduleParam != nil {
            map["ScheduleParam"] = self.scheduleParam!
        }
        if self.scheduleSwitch != nil {
            map["ScheduleSwitch"] = self.scheduleSwitch!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.timeZoneId != nil {
            map["TimeZoneId"] = self.timeZoneId!
        }
        if self.triggerType != nil {
            map["TriggerType"] = self.triggerType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CronBeginDate") {
            self.cronBeginDate = dict["CronBeginDate"] as! String
        }
        if dict.keys.contains("CronEndDate") {
            self.cronEndDate = dict["CronEndDate"] as! String
        }
        if dict.keys.contains("CronStr") {
            self.cronStr = dict["CronStr"] as! String
        }
        if dict.keys.contains("CronType") {
            self.cronType = dict["CronType"] as! String
        }
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("ScheduleParam") {
            self.scheduleParam = dict["ScheduleParam"] as! String
        }
        if dict.keys.contains("ScheduleSwitch") {
            self.scheduleSwitch = dict["ScheduleSwitch"] as! Bool
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("TimeZoneId") {
            self.timeZoneId = dict["TimeZoneId"] as! String
        }
        if dict.keys.contains("TriggerType") {
            self.triggerType = dict["TriggerType"] as! String
        }
    }
}

public class UpdateTaskFlowScheduleResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskFlowScheduleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskFlowScheduleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTaskFlowScheduleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskFlowTimeVariablesRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public var timeVariables: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.timeVariables != nil {
            map["TimeVariables"] = self.timeVariables!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("TimeVariables") {
            self.timeVariables = dict["TimeVariables"] as! String
        }
    }
}

public class UpdateTaskFlowTimeVariablesResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskFlowTimeVariablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskFlowTimeVariablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTaskFlowTimeVariablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskNameRequest : Tea.TeaModel {
    public var nodeId: String?

    public var nodeName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("NodeName") {
            self.nodeName = dict["NodeName"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskNameResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTaskNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskOutputRequest : Tea.TeaModel {
    public var nodeId: String?

    public var nodeOutput: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeOutput != nil {
            map["NodeOutput"] = self.nodeOutput!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("NodeOutput") {
            self.nodeOutput = dict["NodeOutput"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskOutputResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTaskOutputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskTimeVariablesRequest : Tea.TeaModel {
    public var nodeId: String?

    public var tid: Int64?

    public var timeVariables: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.timeVariables != nil {
            map["TimeVariables"] = self.timeVariables!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("TimeVariables") {
            self.timeVariables = dict["TimeVariables"] as! String
        }
    }
}

public class UpdateTaskTimeVariablesResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskTimeVariablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskTimeVariablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTaskTimeVariablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateUserRequest : Tea.TeaModel {
    public var maxExecuteCount: Int64?

    public var maxResultCount: Int64?

    public var mobile: String?

    public var roleNames: String?

    public var tid: Int64?

    public var uid: Int64?

    public var userNick: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxExecuteCount != nil {
            map["MaxExecuteCount"] = self.maxExecuteCount!
        }
        if self.maxResultCount != nil {
            map["MaxResultCount"] = self.maxResultCount!
        }
        if self.mobile != nil {
            map["Mobile"] = self.mobile!
        }
        if self.roleNames != nil {
            map["RoleNames"] = self.roleNames!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        if self.userNick != nil {
            map["UserNick"] = self.userNick!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxExecuteCount") {
            self.maxExecuteCount = dict["MaxExecuteCount"] as! Int64
        }
        if dict.keys.contains("MaxResultCount") {
            self.maxResultCount = dict["MaxResultCount"] as! Int64
        }
        if dict.keys.contains("Mobile") {
            self.mobile = dict["Mobile"] as! String
        }
        if dict.keys.contains("RoleNames") {
            self.roleNames = dict["RoleNames"] as! String
        }
        if dict.keys.contains("Tid") {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("Uid") {
            self.uid = dict["Uid"] as! Int64
        }
        if dict.keys.contains("UserNick") {
            self.userNick = dict["UserNick"] as! String
        }
    }
}

public class UpdateUserResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
