import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AsyncTaskVO : Tea.TeaModel {
    public var datasetId: String?

    public var id: Int64?

    public var remark: String?

    public var taskName: String?

    public var taskStatus: Int32?

    public var taskType: Int32?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") && dict["DatasetId"] != nil {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
            self.taskStatus = dict["TaskStatus"] as! Int32
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! Int32
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class DatasetItemVO : Tea.TeaModel {
    public var asyncTaskList: [AsyncTaskVO]?

    public var datasetStatus: Int32?

    public var datasetType: Int32?

    public var digest: String?

    public var fileSystem: String?

    public var id: String?

    public var keyName: String?

    public var moreInfo: String?

    public var path: String?

    public var projectsLinked: [ProjectDetailsLiteVO]?

    public var recentTaskStatus: Int32?

    public var remark: String?

    public var schema: String?

    public var tableName: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asyncTaskList != nil {
            var tmp : [Any] = []
            for k in self.asyncTaskList! {
                tmp.append(k.toMap())
            }
            map["AsyncTaskList"] = tmp
        }
        if self.datasetStatus != nil {
            map["DatasetStatus"] = self.datasetStatus!
        }
        if self.datasetType != nil {
            map["DatasetType"] = self.datasetType!
        }
        if self.digest != nil {
            map["Digest"] = self.digest!
        }
        if self.fileSystem != nil {
            map["FileSystem"] = self.fileSystem!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.keyName != nil {
            map["KeyName"] = self.keyName!
        }
        if self.moreInfo != nil {
            map["MoreInfo"] = self.moreInfo!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.projectsLinked != nil {
            var tmp : [Any] = []
            for k in self.projectsLinked! {
                tmp.append(k.toMap())
            }
            map["ProjectsLinked"] = tmp
        }
        if self.recentTaskStatus != nil {
            map["RecentTaskStatus"] = self.recentTaskStatus!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AsyncTaskList") && dict["AsyncTaskList"] != nil {
            var tmp : [AsyncTaskVO] = []
            for v in dict["AsyncTaskList"] as! [Any] {
                var model = AsyncTaskVO()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.asyncTaskList = tmp
        }
        if dict.keys.contains("DatasetStatus") && dict["DatasetStatus"] != nil {
            self.datasetStatus = dict["DatasetStatus"] as! Int32
        }
        if dict.keys.contains("DatasetType") && dict["DatasetType"] != nil {
            self.datasetType = dict["DatasetType"] as! Int32
        }
        if dict.keys.contains("Digest") && dict["Digest"] != nil {
            self.digest = dict["Digest"] as! String
        }
        if dict.keys.contains("FileSystem") && dict["FileSystem"] != nil {
            self.fileSystem = dict["FileSystem"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("KeyName") && dict["KeyName"] != nil {
            self.keyName = dict["KeyName"] as! String
        }
        if dict.keys.contains("MoreInfo") && dict["MoreInfo"] != nil {
            self.moreInfo = dict["MoreInfo"] as! String
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("ProjectsLinked") && dict["ProjectsLinked"] != nil {
            var tmp : [ProjectDetailsLiteVO] = []
            for v in dict["ProjectsLinked"] as! [Any] {
                var model = ProjectDetailsLiteVO()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.projectsLinked = tmp
        }
        if dict.keys.contains("RecentTaskStatus") && dict["RecentTaskStatus"] != nil {
            self.recentTaskStatus = dict["RecentTaskStatus"] as! Int32
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("Schema") && dict["Schema"] != nil {
            self.schema = dict["Schema"] as! String
        }
        if dict.keys.contains("TableName") && dict["TableName"] != nil {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Url") && dict["Url"] != nil {
            self.url = dict["Url"] as! String
        }
    }
}

public class GetTableDataKeyVO : Tea.TeaModel {
    public var colName: String?

    public var dbName: String?

    public var mekId: Int64?

    public var schemaName: String?

    public var tblName: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.colName != nil {
            map["ColName"] = self.colName!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.mekId != nil {
            map["MekId"] = self.mekId!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tblName != nil {
            map["TblName"] = self.tblName!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColName") && dict["ColName"] != nil {
            self.colName = dict["ColName"] as! String
        }
        if dict.keys.contains("DbName") && dict["DbName"] != nil {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("MekId") && dict["MekId"] != nil {
            self.mekId = dict["MekId"] as! Int64
        }
        if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
            self.schemaName = dict["SchemaName"] as! String
        }
        if dict.keys.contains("TblName") && dict["TblName"] != nil {
            self.tblName = dict["TblName"] as! String
        }
        if dict.keys.contains("UserName") && dict["UserName"] != nil {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class ImportMasterKeyVO : Tea.TeaModel {
    public var encryptMekDataBase64: String?

    public var mekId: Int64?

    public var projectId: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.encryptMekDataBase64 != nil {
            map["EncryptMekDataBase64"] = self.encryptMekDataBase64!
        }
        if self.mekId != nil {
            map["MekId"] = self.mekId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EncryptMekDataBase64") && dict["EncryptMekDataBase64"] != nil {
            self.encryptMekDataBase64 = dict["EncryptMekDataBase64"] as! String
        }
        if dict.keys.contains("MekId") && dict["MekId"] != nil {
            self.mekId = dict["MekId"] as! Int64
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! [Int64]
        }
    }
}

public class ProjectDetailsLiteVO : Tea.TeaModel {
    public var id: Int64?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("ProjectName") && dict["ProjectName"] != nil {
            self.projectName = dict["ProjectName"] as! String
        }
    }
}

public class StsApplyVO : Tea.TeaModel {
    public var aliyunId: String?

    public var duration: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunId != nil {
            map["AliyunId"] = self.aliyunId!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunId") && dict["AliyunId"] != nil {
            self.aliyunId = dict["AliyunId"] as! String
        }
        if dict.keys.contains("Duration") && dict["Duration"] != nil {
            self.duration = dict["Duration"] as! Int64
        }
    }
}

public class StsTokenVO : Tea.TeaModel {
    public var accessKeyId: String?

    public var accessKeySecret: String?

    public var expiration: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessKeyId != nil {
            map["AccessKeyId"] = self.accessKeyId!
        }
        if self.accessKeySecret != nil {
            map["AccessKeySecret"] = self.accessKeySecret!
        }
        if self.expiration != nil {
            map["Expiration"] = self.expiration!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessKeyId") && dict["AccessKeyId"] != nil {
            self.accessKeyId = dict["AccessKeyId"] as! String
        }
        if dict.keys.contains("AccessKeySecret") && dict["AccessKeySecret"] != nil {
            self.accessKeySecret = dict["AccessKeySecret"] as! String
        }
        if dict.keys.contains("Expiration") && dict["Expiration"] != nil {
            self.expiration = dict["Expiration"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class TeeEvidenceVO : Tea.TeaModel {
    public var cipherSuite: String?

    public var enclaveData: String?

    public var encryptPublicKeyPem: String?

    public var encryptPublicKeyType: String?

    public var modifiedDate: String?

    public var publicKey: String?

    public var publicKeyRaBase64: String?

    public var publicKeyRaType: String?

    public var quoteReport: String?

    public var signPublicKeyPem: String?

    public var signPublicKeyType: String?

    public var trustedMrEnclave: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cipherSuite != nil {
            map["CipherSuite"] = self.cipherSuite!
        }
        if self.enclaveData != nil {
            map["EnclaveData"] = self.enclaveData!
        }
        if self.encryptPublicKeyPem != nil {
            map["EncryptPublicKeyPem"] = self.encryptPublicKeyPem!
        }
        if self.encryptPublicKeyType != nil {
            map["EncryptPublicKeyType"] = self.encryptPublicKeyType!
        }
        if self.modifiedDate != nil {
            map["ModifiedDate"] = self.modifiedDate!
        }
        if self.publicKey != nil {
            map["PublicKey"] = self.publicKey!
        }
        if self.publicKeyRaBase64 != nil {
            map["PublicKeyRaBase64"] = self.publicKeyRaBase64!
        }
        if self.publicKeyRaType != nil {
            map["PublicKeyRaType"] = self.publicKeyRaType!
        }
        if self.quoteReport != nil {
            map["QuoteReport"] = self.quoteReport!
        }
        if self.signPublicKeyPem != nil {
            map["SignPublicKeyPem"] = self.signPublicKeyPem!
        }
        if self.signPublicKeyType != nil {
            map["SignPublicKeyType"] = self.signPublicKeyType!
        }
        if self.trustedMrEnclave != nil {
            map["TrustedMrEnclave"] = self.trustedMrEnclave!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CipherSuite") && dict["CipherSuite"] != nil {
            self.cipherSuite = dict["CipherSuite"] as! String
        }
        if dict.keys.contains("EnclaveData") && dict["EnclaveData"] != nil {
            self.enclaveData = dict["EnclaveData"] as! String
        }
        if dict.keys.contains("EncryptPublicKeyPem") && dict["EncryptPublicKeyPem"] != nil {
            self.encryptPublicKeyPem = dict["EncryptPublicKeyPem"] as! String
        }
        if dict.keys.contains("EncryptPublicKeyType") && dict["EncryptPublicKeyType"] != nil {
            self.encryptPublicKeyType = dict["EncryptPublicKeyType"] as! String
        }
        if dict.keys.contains("ModifiedDate") && dict["ModifiedDate"] != nil {
            self.modifiedDate = dict["ModifiedDate"] as! String
        }
        if dict.keys.contains("PublicKey") && dict["PublicKey"] != nil {
            self.publicKey = dict["PublicKey"] as! String
        }
        if dict.keys.contains("PublicKeyRaBase64") && dict["PublicKeyRaBase64"] != nil {
            self.publicKeyRaBase64 = dict["PublicKeyRaBase64"] as! String
        }
        if dict.keys.contains("PublicKeyRaType") && dict["PublicKeyRaType"] != nil {
            self.publicKeyRaType = dict["PublicKeyRaType"] as! String
        }
        if dict.keys.contains("QuoteReport") && dict["QuoteReport"] != nil {
            self.quoteReport = dict["QuoteReport"] as! String
        }
        if dict.keys.contains("SignPublicKeyPem") && dict["SignPublicKeyPem"] != nil {
            self.signPublicKeyPem = dict["SignPublicKeyPem"] as! String
        }
        if dict.keys.contains("SignPublicKeyType") && dict["SignPublicKeyType"] != nil {
            self.signPublicKeyType = dict["SignPublicKeyType"] as! String
        }
        if dict.keys.contains("TrustedMrEnclave") && dict["TrustedMrEnclave"] != nil {
            self.trustedMrEnclave = dict["TrustedMrEnclave"] as! [String]
        }
    }
}

public class UsersDetailsVO : Tea.TeaModel {
    public var approvalSignatureBase64: String?

    public var approvalSqlTemplate: String?

    public var approvalStatus: String?

    public var creator: Int32?

    public var dataReady: Int32?

    public var id: Int64?

    public var mekid: Int64?

    public var pathPrefix: String?

    public var resultParty: Int32?

    public var uid: String?

    public var userConfirmed: Int32?

    public var userName: String?

    public var userPublicKeyPem: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.approvalSignatureBase64 != nil {
            map["ApprovalSignatureBase64"] = self.approvalSignatureBase64!
        }
        if self.approvalSqlTemplate != nil {
            map["ApprovalSqlTemplate"] = self.approvalSqlTemplate!
        }
        if self.approvalStatus != nil {
            map["ApprovalStatus"] = self.approvalStatus!
        }
        if self.creator != nil {
            map["Creator"] = self.creator!
        }
        if self.dataReady != nil {
            map["DataReady"] = self.dataReady!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mekid != nil {
            map["Mekid"] = self.mekid!
        }
        if self.pathPrefix != nil {
            map["PathPrefix"] = self.pathPrefix!
        }
        if self.resultParty != nil {
            map["ResultParty"] = self.resultParty!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        if self.userConfirmed != nil {
            map["UserConfirmed"] = self.userConfirmed!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        if self.userPublicKeyPem != nil {
            map["UserPublicKeyPem"] = self.userPublicKeyPem!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApprovalSignatureBase64") && dict["ApprovalSignatureBase64"] != nil {
            self.approvalSignatureBase64 = dict["ApprovalSignatureBase64"] as! String
        }
        if dict.keys.contains("ApprovalSqlTemplate") && dict["ApprovalSqlTemplate"] != nil {
            self.approvalSqlTemplate = dict["ApprovalSqlTemplate"] as! String
        }
        if dict.keys.contains("ApprovalStatus") && dict["ApprovalStatus"] != nil {
            self.approvalStatus = dict["ApprovalStatus"] as! String
        }
        if dict.keys.contains("Creator") && dict["Creator"] != nil {
            self.creator = dict["Creator"] as! Int32
        }
        if dict.keys.contains("DataReady") && dict["DataReady"] != nil {
            self.dataReady = dict["DataReady"] as! Int32
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Mekid") && dict["Mekid"] != nil {
            self.mekid = dict["Mekid"] as! Int64
        }
        if dict.keys.contains("PathPrefix") && dict["PathPrefix"] != nil {
            self.pathPrefix = dict["PathPrefix"] as! String
        }
        if dict.keys.contains("ResultParty") && dict["ResultParty"] != nil {
            self.resultParty = dict["ResultParty"] as! Int32
        }
        if dict.keys.contains("Uid") && dict["Uid"] != nil {
            self.uid = dict["Uid"] as! String
        }
        if dict.keys.contains("UserConfirmed") && dict["UserConfirmed"] != nil {
            self.userConfirmed = dict["UserConfirmed"] as! Int32
        }
        if dict.keys.contains("UserName") && dict["UserName"] != nil {
            self.userName = dict["UserName"] as! String
        }
        if dict.keys.contains("UserPublicKeyPem") && dict["UserPublicKeyPem"] != nil {
            self.userPublicKeyPem = dict["UserPublicKeyPem"] as! String
        }
    }
}

public class AddDesensitizationRuleRequest : Tea.TeaModel {
    public var functionParams: [[String: String]]?

    public var functionType: String?

    public var ruleDescription: String?

    public var ruleName: String?

    public var ruleType: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.functionParams != nil {
            map["FunctionParams"] = self.functionParams!
        }
        if self.functionType != nil {
            map["FunctionType"] = self.functionType!
        }
        if self.ruleDescription != nil {
            map["RuleDescription"] = self.ruleDescription!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.ruleType != nil {
            map["RuleType"] = self.ruleType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FunctionParams") && dict["FunctionParams"] != nil {
            self.functionParams = dict["FunctionParams"] as! [[String: String]]
        }
        if dict.keys.contains("FunctionType") && dict["FunctionType"] != nil {
            self.functionType = dict["FunctionType"] as! String
        }
        if dict.keys.contains("RuleDescription") && dict["RuleDescription"] != nil {
            self.ruleDescription = dict["RuleDescription"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
            self.ruleType = dict["RuleType"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class AddDesensitizationRuleResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var ruleId: Int32?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! Int32
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddDesensitizationRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDesensitizationRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddDesensitizationRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLhMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var roles: [String]?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.roles != nil {
                map["Roles"] = self.roles!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Roles") && dict["Roles"] != nil {
                self.roles = dict["Roles"] as! [String]
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! Int64
            }
        }
    }
    public var members: [AddLhMembersRequest.Members]?

    public var objectId: Int64?

    public var objectType: Int32?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.objectId != nil {
            map["ObjectId"] = self.objectId!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            var tmp : [AddLhMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = AddLhMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("ObjectId") && dict["ObjectId"] != nil {
            self.objectId = dict["ObjectId"] as! Int64
        }
        if dict.keys.contains("ObjectType") && dict["ObjectType"] != nil {
            self.objectType = dict["ObjectType"] as! Int32
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class AddLhMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var objectId: Int64?

    public var objectType: Int32?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.objectId != nil {
            map["ObjectId"] = self.objectId!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("ObjectId") && dict["ObjectId"] != nil {
            self.objectId = dict["ObjectId"] as! Int64
        }
        if dict.keys.contains("ObjectType") && dict["ObjectType"] != nil {
            self.objectType = dict["ObjectType"] as! Int32
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class AddLhMembersResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddLhMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLhMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddLhMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLogicTableRouteConfigRequest : Tea.TeaModel {
    public var routeExpr: String?

    public var routeKey: String?

    public var tableId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.routeExpr != nil {
            map["RouteExpr"] = self.routeExpr!
        }
        if self.routeKey != nil {
            map["RouteKey"] = self.routeKey!
        }
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RouteExpr") && dict["RouteExpr"] != nil {
            self.routeExpr = dict["RouteExpr"] as! String
        }
        if dict.keys.contains("RouteKey") && dict["RouteKey"] != nil {
            self.routeKey = dict["RouteKey"] as! String
        }
        if dict.keys.contains("TableId") && dict["TableId"] != nil {
            self.tableId = dict["TableId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class AddLogicTableRouteConfigResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddLogicTableRouteConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLogicTableRouteConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddLogicTableRouteConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddTaskFlowEdgesRequest : Tea.TeaModel {
    public class Edges : Tea.TeaModel {
        public var nodeEnd: Int64?

        public var nodeFrom: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeEnd != nil {
                map["NodeEnd"] = self.nodeEnd!
            }
            if self.nodeFrom != nil {
                map["NodeFrom"] = self.nodeFrom!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NodeEnd") && dict["NodeEnd"] != nil {
                self.nodeEnd = dict["NodeEnd"] as! Int64
            }
            if dict.keys.contains("NodeFrom") && dict["NodeFrom"] != nil {
                self.nodeFrom = dict["NodeFrom"] as! Int64
            }
        }
    }
    public var dagId: Int64?

    public var edges: [AddTaskFlowEdgesRequest.Edges]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.edges != nil {
            var tmp : [Any] = []
            for k in self.edges! {
                tmp.append(k.toMap())
            }
            map["Edges"] = tmp
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Edges") && dict["Edges"] != nil {
            var tmp : [AddTaskFlowEdgesRequest.Edges] = []
            for v in dict["Edges"] as! [Any] {
                var model = AddTaskFlowEdgesRequest.Edges()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.edges = tmp
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class AddTaskFlowEdgesShrinkRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var edgesShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.edgesShrink != nil {
            map["Edges"] = self.edgesShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Edges") && dict["Edges"] != nil {
            self.edgesShrink = dict["Edges"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class AddTaskFlowEdgesResponseBody : Tea.TeaModel {
    public class EdgeIds : Tea.TeaModel {
        public var edgeId: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.edgeId != nil {
                map["EdgeId"] = self.edgeId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EdgeId") && dict["EdgeId"] != nil {
                self.edgeId = dict["EdgeId"] as! [Int64]
            }
        }
    }
    public var edgeIds: AddTaskFlowEdgesResponseBody.EdgeIds?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.edgeIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.edgeIds != nil {
            map["EdgeIds"] = self.edgeIds?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EdgeIds") && dict["EdgeIds"] != nil {
            var model = AddTaskFlowEdgesResponseBody.EdgeIds()
            model.fromMap(dict["EdgeIds"] as! [String: Any])
            self.edgeIds = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddTaskFlowEdgesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTaskFlowEdgesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddTaskFlowEdgesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AnalyzeSQLLineageRequest : Tea.TeaModel {
    public var dbId: Int64?

    public var sqlContent: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.sqlContent != nil {
            map["SqlContent"] = self.sqlContent!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") && dict["DbId"] != nil {
            self.dbId = dict["DbId"] as! Int64
        }
        if dict.keys.contains("SqlContent") && dict["SqlContent"] != nil {
            self.sqlContent = dict["SqlContent"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class AnalyzeSQLLineageResponseBody : Tea.TeaModel {
    public class LineageResult : Tea.TeaModel {
        public class Lineages : Tea.TeaModel {
            public class ProcessDetail : Tea.TeaModel {
                public var calWay: String?

                public var code: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.calWay != nil {
                        map["CalWay"] = self.calWay!
                    }
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CalWay") && dict["CalWay"] != nil {
                        self.calWay = dict["CalWay"] as! String
                    }
                    if dict.keys.contains("Code") && dict["Code"] != nil {
                        self.code = dict["Code"] as! String
                    }
                }
            }
            public var dst: String?

            public var lineageType: String?

            public var operType: String?

            public var processDetail: AnalyzeSQLLineageResponseBody.LineageResult.Lineages.ProcessDetail?

            public var src: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.processDetail?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dst != nil {
                    map["Dst"] = self.dst!
                }
                if self.lineageType != nil {
                    map["LineageType"] = self.lineageType!
                }
                if self.operType != nil {
                    map["OperType"] = self.operType!
                }
                if self.processDetail != nil {
                    map["ProcessDetail"] = self.processDetail?.toMap()
                }
                if self.src != nil {
                    map["Src"] = self.src!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Dst") && dict["Dst"] != nil {
                    self.dst = dict["Dst"] as! String
                }
                if dict.keys.contains("LineageType") && dict["LineageType"] != nil {
                    self.lineageType = dict["LineageType"] as! String
                }
                if dict.keys.contains("OperType") && dict["OperType"] != nil {
                    self.operType = dict["OperType"] as! String
                }
                if dict.keys.contains("ProcessDetail") && dict["ProcessDetail"] != nil {
                    var model = AnalyzeSQLLineageResponseBody.LineageResult.Lineages.ProcessDetail()
                    model.fromMap(dict["ProcessDetail"] as! [String: Any])
                    self.processDetail = model
                }
                if dict.keys.contains("Src") && dict["Src"] != nil {
                    self.src = dict["Src"] as! String
                }
            }
        }
        public class ObjectMetadata : Tea.TeaModel {
            public class Fields : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var fields: [AnalyzeSQLLineageResponseBody.LineageResult.ObjectMetadata.Fields]?

            public var name: String?

            public var source: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fields != nil {
                    var tmp : [Any] = []
                    for k in self.fields! {
                        tmp.append(k.toMap())
                    }
                    map["Fields"] = tmp
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Fields") && dict["Fields"] != nil {
                    var tmp : [AnalyzeSQLLineageResponseBody.LineageResult.ObjectMetadata.Fields] = []
                    for v in dict["Fields"] as! [Any] {
                        var model = AnalyzeSQLLineageResponseBody.LineageResult.ObjectMetadata.Fields()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.fields = tmp
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Source") && dict["Source"] != nil {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var lineages: [AnalyzeSQLLineageResponseBody.LineageResult.Lineages]?

        public var objectMetadata: [AnalyzeSQLLineageResponseBody.LineageResult.ObjectMetadata]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lineages != nil {
                var tmp : [Any] = []
                for k in self.lineages! {
                    tmp.append(k.toMap())
                }
                map["Lineages"] = tmp
            }
            if self.objectMetadata != nil {
                var tmp : [Any] = []
                for k in self.objectMetadata! {
                    tmp.append(k.toMap())
                }
                map["ObjectMetadata"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Lineages") && dict["Lineages"] != nil {
                var tmp : [AnalyzeSQLLineageResponseBody.LineageResult.Lineages] = []
                for v in dict["Lineages"] as! [Any] {
                    var model = AnalyzeSQLLineageResponseBody.LineageResult.Lineages()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.lineages = tmp
            }
            if dict.keys.contains("ObjectMetadata") && dict["ObjectMetadata"] != nil {
                var tmp : [AnalyzeSQLLineageResponseBody.LineageResult.ObjectMetadata] = []
                for v in dict["ObjectMetadata"] as! [Any] {
                    var model = AnalyzeSQLLineageResponseBody.LineageResult.ObjectMetadata()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.objectMetadata = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var lineageResult: AnalyzeSQLLineageResponseBody.LineageResult?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lineageResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.lineageResult != nil {
            map["LineageResult"] = self.lineageResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("LineageResult") && dict["LineageResult"] != nil {
            var model = AnalyzeSQLLineageResponseBody.LineageResult()
            model.fromMap(dict["LineageResult"] as! [String: Any])
            self.lineageResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AnalyzeSQLLineageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AnalyzeSQLLineageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AnalyzeSQLLineageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApproveOrderRequest : Tea.TeaModel {
    public var approvalNodeId: Int64?

    public var approvalNodePos: String?

    public var approvalType: String?

    public var comment: String?

    public var newApprover: Int64?

    public var oldApprover: Int64?

    public var tid: Int64?

    public var workflowInstanceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.approvalNodeId != nil {
            map["ApprovalNodeId"] = self.approvalNodeId!
        }
        if self.approvalNodePos != nil {
            map["ApprovalNodePos"] = self.approvalNodePos!
        }
        if self.approvalType != nil {
            map["ApprovalType"] = self.approvalType!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.newApprover != nil {
            map["NewApprover"] = self.newApprover!
        }
        if self.oldApprover != nil {
            map["OldApprover"] = self.oldApprover!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.workflowInstanceId != nil {
            map["WorkflowInstanceId"] = self.workflowInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApprovalNodeId") && dict["ApprovalNodeId"] != nil {
            self.approvalNodeId = dict["ApprovalNodeId"] as! Int64
        }
        if dict.keys.contains("ApprovalNodePos") && dict["ApprovalNodePos"] != nil {
            self.approvalNodePos = dict["ApprovalNodePos"] as! String
        }
        if dict.keys.contains("ApprovalType") && dict["ApprovalType"] != nil {
            self.approvalType = dict["ApprovalType"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("NewApprover") && dict["NewApprover"] != nil {
            self.newApprover = dict["NewApprover"] as! Int64
        }
        if dict.keys.contains("OldApprover") && dict["OldApprover"] != nil {
            self.oldApprover = dict["OldApprover"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("WorkflowInstanceId") && dict["WorkflowInstanceId"] != nil {
            self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
        }
    }
}

public class ApproveOrderResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ApproveOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApproveOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ApproveOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BackFillRequest : Tea.TeaModel {
    public var asc: Bool?

    public var backFillDate: String?

    public var backFillDateBegin: String?

    public var backFillDateEnd: String?

    public var dagId: Int64?

    public var filterNodeIds: [Int64]?

    public var historyDagId: Int64?

    public var interval: Int32?

    public var isTriggerSubTree: Bool?

    public var startNodeIds: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.backFillDate != nil {
            map["BackFillDate"] = self.backFillDate!
        }
        if self.backFillDateBegin != nil {
            map["BackFillDateBegin"] = self.backFillDateBegin!
        }
        if self.backFillDateEnd != nil {
            map["BackFillDateEnd"] = self.backFillDateEnd!
        }
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.filterNodeIds != nil {
            map["FilterNodeIds"] = self.filterNodeIds!
        }
        if self.historyDagId != nil {
            map["HistoryDagId"] = self.historyDagId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.isTriggerSubTree != nil {
            map["IsTriggerSubTree"] = self.isTriggerSubTree!
        }
        if self.startNodeIds != nil {
            map["StartNodeIds"] = self.startNodeIds!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Asc") && dict["Asc"] != nil {
            self.asc = dict["Asc"] as! Bool
        }
        if dict.keys.contains("BackFillDate") && dict["BackFillDate"] != nil {
            self.backFillDate = dict["BackFillDate"] as! String
        }
        if dict.keys.contains("BackFillDateBegin") && dict["BackFillDateBegin"] != nil {
            self.backFillDateBegin = dict["BackFillDateBegin"] as! String
        }
        if dict.keys.contains("BackFillDateEnd") && dict["BackFillDateEnd"] != nil {
            self.backFillDateEnd = dict["BackFillDateEnd"] as! String
        }
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("FilterNodeIds") && dict["FilterNodeIds"] != nil {
            self.filterNodeIds = dict["FilterNodeIds"] as! [Int64]
        }
        if dict.keys.contains("HistoryDagId") && dict["HistoryDagId"] != nil {
            self.historyDagId = dict["HistoryDagId"] as! Int64
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IsTriggerSubTree") && dict["IsTriggerSubTree"] != nil {
            self.isTriggerSubTree = dict["IsTriggerSubTree"] as! Bool
        }
        if dict.keys.contains("StartNodeIds") && dict["StartNodeIds"] != nil {
            self.startNodeIds = dict["StartNodeIds"] as! [Int64]
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class BackFillShrinkRequest : Tea.TeaModel {
    public var asc: Bool?

    public var backFillDate: String?

    public var backFillDateBegin: String?

    public var backFillDateEnd: String?

    public var dagId: Int64?

    public var filterNodeIdsShrink: String?

    public var historyDagId: Int64?

    public var interval: Int32?

    public var isTriggerSubTree: Bool?

    public var startNodeIdsShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.backFillDate != nil {
            map["BackFillDate"] = self.backFillDate!
        }
        if self.backFillDateBegin != nil {
            map["BackFillDateBegin"] = self.backFillDateBegin!
        }
        if self.backFillDateEnd != nil {
            map["BackFillDateEnd"] = self.backFillDateEnd!
        }
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.filterNodeIdsShrink != nil {
            map["FilterNodeIds"] = self.filterNodeIdsShrink!
        }
        if self.historyDagId != nil {
            map["HistoryDagId"] = self.historyDagId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.isTriggerSubTree != nil {
            map["IsTriggerSubTree"] = self.isTriggerSubTree!
        }
        if self.startNodeIdsShrink != nil {
            map["StartNodeIds"] = self.startNodeIdsShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Asc") && dict["Asc"] != nil {
            self.asc = dict["Asc"] as! Bool
        }
        if dict.keys.contains("BackFillDate") && dict["BackFillDate"] != nil {
            self.backFillDate = dict["BackFillDate"] as! String
        }
        if dict.keys.contains("BackFillDateBegin") && dict["BackFillDateBegin"] != nil {
            self.backFillDateBegin = dict["BackFillDateBegin"] as! String
        }
        if dict.keys.contains("BackFillDateEnd") && dict["BackFillDateEnd"] != nil {
            self.backFillDateEnd = dict["BackFillDateEnd"] as! String
        }
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("FilterNodeIds") && dict["FilterNodeIds"] != nil {
            self.filterNodeIdsShrink = dict["FilterNodeIds"] as! String
        }
        if dict.keys.contains("HistoryDagId") && dict["HistoryDagId"] != nil {
            self.historyDagId = dict["HistoryDagId"] as! Int64
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IsTriggerSubTree") && dict["IsTriggerSubTree"] != nil {
            self.isTriggerSubTree = dict["IsTriggerSubTree"] as! Bool
        }
        if dict.keys.contains("StartNodeIds") && dict["StartNodeIds"] != nil {
            self.startNodeIdsShrink = dict["StartNodeIds"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class BackFillResponseBody : Tea.TeaModel {
    public var dagInstanceId: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var nodeId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagInstanceId != nil {
            map["DagInstanceId"] = self.dagInstanceId!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagInstanceId") && dict["DagInstanceId"] != nil {
            self.dagInstanceId = dict["DagInstanceId"] as! Int64
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class BackFillResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BackFillResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BackFillResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BuyPayAsYouGoOrderRequest : Tea.TeaModel {
    public var commodityType: String?

    public var insNum: Int32?

    public var tid: Int64?

    public var versionType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commodityType != nil {
            map["CommodityType"] = self.commodityType!
        }
        if self.insNum != nil {
            map["InsNum"] = self.insNum!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.versionType != nil {
            map["VersionType"] = self.versionType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommodityType") && dict["CommodityType"] != nil {
            self.commodityType = dict["CommodityType"] as! String
        }
        if dict.keys.contains("InsNum") && dict["InsNum"] != nil {
            self.insNum = dict["InsNum"] as! Int32
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("VersionType") && dict["VersionType"] != nil {
            self.versionType = dict["VersionType"] as! String
        }
    }
}

public class BuyPayAsYouGoOrderResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var instanceId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class BuyPayAsYouGoOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BuyPayAsYouGoOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BuyPayAsYouGoOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeColumnSecLevelRequest : Tea.TeaModel {
    public var columnName: String?

    public var dbId: Int64?

    public var isLogic: Bool?

    public var newLevel: String?

    public var schemaName: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnName != nil {
            map["ColumnName"] = self.columnName!
        }
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.isLogic != nil {
            map["IsLogic"] = self.isLogic!
        }
        if self.newLevel != nil {
            map["NewLevel"] = self.newLevel!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
            self.columnName = dict["ColumnName"] as! String
        }
        if dict.keys.contains("DbId") && dict["DbId"] != nil {
            self.dbId = dict["DbId"] as! Int64
        }
        if dict.keys.contains("IsLogic") && dict["IsLogic"] != nil {
            self.isLogic = dict["IsLogic"] as! Bool
        }
        if dict.keys.contains("NewLevel") && dict["NewLevel"] != nil {
            self.newLevel = dict["NewLevel"] as! String
        }
        if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
            self.schemaName = dict["SchemaName"] as! String
        }
        if dict.keys.contains("TableName") && dict["TableName"] != nil {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ChangeColumnSecLevelResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ChangeColumnSecLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeColumnSecLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ChangeColumnSecLevelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeLhDagOwnerRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var ownerUserId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.ownerUserId != nil {
            map["OwnerUserId"] = self.ownerUserId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("OwnerUserId") && dict["OwnerUserId"] != nil {
            self.ownerUserId = dict["OwnerUserId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ChangeLhDagOwnerResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ChangeLhDagOwnerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeLhDagOwnerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ChangeLhDagOwnerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CloseOrderRequest : Tea.TeaModel {
    public var closeReason: String?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.closeReason != nil {
            map["CloseReason"] = self.closeReason!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CloseReason") && dict["CloseReason"] != nil {
            self.closeReason = dict["CloseReason"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CloseOrderResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CloseOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloseOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CloseOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAuthorityTemplateRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateAuthorityTemplateResponseBody : Tea.TeaModel {
    public class AuthorityTemplateView : Tea.TeaModel {
        public var createTime: String?

        public var creatorId: Int64?

        public var description_: String?

        public var name: String?

        public var templateId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! Int64
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! Int64
            }
        }
    }
    public var authorityTemplateView: CreateAuthorityTemplateResponseBody.AuthorityTemplateView?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authorityTemplateView?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorityTemplateView != nil {
            map["AuthorityTemplateView"] = self.authorityTemplateView?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorityTemplateView") && dict["AuthorityTemplateView"] != nil {
            var model = CreateAuthorityTemplateResponseBody.AuthorityTemplateView()
            model.fromMap(dict["AuthorityTemplateView"] as! [String: Any])
            self.authorityTemplateView = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateAuthorityTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAuthorityTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateAuthorityTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataArchiveOrderRequest : Tea.TeaModel {
    public class Param : Tea.TeaModel {
        public class TableIncludes : Tea.TeaModel {
            public var tableName: String?

            public var tableWhere: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.tableWhere != nil {
                    map["TableWhere"] = self.tableWhere!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TableName") && dict["TableName"] != nil {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("TableWhere") && dict["TableWhere"] != nil {
                    self.tableWhere = dict["TableWhere"] as! String
                }
            }
        }
        public var archiveMethod: String?

        public var dbSchema: String?

        public var logic: Bool?

        public var orderAfter: [String]?

        public var runMethod: String?

        public var sourceDatabaseId: Int64?

        public var tableIncludes: [CreateDataArchiveOrderRequest.Param.TableIncludes]?

        public var tableMapping: [String]?

        public var targetInstanceId: String?

        public var variables: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.archiveMethod != nil {
                map["ArchiveMethod"] = self.archiveMethod!
            }
            if self.dbSchema != nil {
                map["DbSchema"] = self.dbSchema!
            }
            if self.logic != nil {
                map["Logic"] = self.logic!
            }
            if self.orderAfter != nil {
                map["OrderAfter"] = self.orderAfter!
            }
            if self.runMethod != nil {
                map["RunMethod"] = self.runMethod!
            }
            if self.sourceDatabaseId != nil {
                map["SourceDatabaseId"] = self.sourceDatabaseId!
            }
            if self.tableIncludes != nil {
                var tmp : [Any] = []
                for k in self.tableIncludes! {
                    tmp.append(k.toMap())
                }
                map["TableIncludes"] = tmp
            }
            if self.tableMapping != nil {
                map["TableMapping"] = self.tableMapping!
            }
            if self.targetInstanceId != nil {
                map["TargetInstanceId"] = self.targetInstanceId!
            }
            if self.variables != nil {
                map["Variables"] = self.variables!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ArchiveMethod") && dict["ArchiveMethod"] != nil {
                self.archiveMethod = dict["ArchiveMethod"] as! String
            }
            if dict.keys.contains("DbSchema") && dict["DbSchema"] != nil {
                self.dbSchema = dict["DbSchema"] as! String
            }
            if dict.keys.contains("Logic") && dict["Logic"] != nil {
                self.logic = dict["Logic"] as! Bool
            }
            if dict.keys.contains("OrderAfter") && dict["OrderAfter"] != nil {
                self.orderAfter = dict["OrderAfter"] as! [String]
            }
            if dict.keys.contains("RunMethod") && dict["RunMethod"] != nil {
                self.runMethod = dict["RunMethod"] as! String
            }
            if dict.keys.contains("SourceDatabaseId") && dict["SourceDatabaseId"] != nil {
                self.sourceDatabaseId = dict["SourceDatabaseId"] as! Int64
            }
            if dict.keys.contains("TableIncludes") && dict["TableIncludes"] != nil {
                var tmp : [CreateDataArchiveOrderRequest.Param.TableIncludes] = []
                for v in dict["TableIncludes"] as! [Any] {
                    var model = CreateDataArchiveOrderRequest.Param.TableIncludes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tableIncludes = tmp
            }
            if dict.keys.contains("TableMapping") && dict["TableMapping"] != nil {
                self.tableMapping = dict["TableMapping"] as! [String]
            }
            if dict.keys.contains("TargetInstanceId") && dict["TargetInstanceId"] != nil {
                self.targetInstanceId = dict["TargetInstanceId"] as! String
            }
            if dict.keys.contains("Variables") && dict["Variables"] != nil {
                self.variables = dict["Variables"] as! [String]
            }
        }
    }
    public var comment: String?

    public var param: CreateDataArchiveOrderRequest.Param?

    public var parentId: Int64?

    public var pluginType: String?

    public var relatedUserList: [String]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.param?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.param != nil {
            map["Param"] = self.param?.toMap()
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.pluginType != nil {
            map["PluginType"] = self.pluginType!
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            var model = CreateDataArchiveOrderRequest.Param()
            model.fromMap(dict["Param"] as! [String: Any])
            self.param = model
        }
        if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("PluginType") && dict["PluginType"] != nil {
            self.pluginType = dict["PluginType"] as! String
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserList = dict["RelatedUserList"] as! [String]
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataArchiveOrderShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var paramShrink: String?

    public var parentId: Int64?

    public var pluginType: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.paramShrink != nil {
            map["Param"] = self.paramShrink!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.pluginType != nil {
            map["PluginType"] = self.pluginType!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            self.paramShrink = dict["Param"] as! String
        }
        if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("PluginType") && dict["PluginType"] != nil {
            self.pluginType = dict["PluginType"] as! String
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataArchiveOrderResponseBody : Tea.TeaModel {
    public var createOrderResult: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") && dict["CreateOrderResult"] != nil {
            self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDataArchiveOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataArchiveOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateDataArchiveOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataCorrectOrderRequest : Tea.TeaModel {
    public class Param : Tea.TeaModel {
        public class DbItemList : Tea.TeaModel {
            public var dbId: Int64?

            public var logic: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
            }
        }
        public var attachmentName: String?

        public var classify: String?

        public var dbItemList: [CreateDataCorrectOrderRequest.Param.DbItemList]?

        public var estimateAffectRows: Int64?

        public var execMode: String?

        public var execSQL: String?

        public var rollbackAttachmentName: String?

        public var rollbackSQL: String?

        public var rollbackSqlType: String?

        public var sqlType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachmentName != nil {
                map["AttachmentName"] = self.attachmentName!
            }
            if self.classify != nil {
                map["Classify"] = self.classify!
            }
            if self.dbItemList != nil {
                var tmp : [Any] = []
                for k in self.dbItemList! {
                    tmp.append(k.toMap())
                }
                map["DbItemList"] = tmp
            }
            if self.estimateAffectRows != nil {
                map["EstimateAffectRows"] = self.estimateAffectRows!
            }
            if self.execMode != nil {
                map["ExecMode"] = self.execMode!
            }
            if self.execSQL != nil {
                map["ExecSQL"] = self.execSQL!
            }
            if self.rollbackAttachmentName != nil {
                map["RollbackAttachmentName"] = self.rollbackAttachmentName!
            }
            if self.rollbackSQL != nil {
                map["RollbackSQL"] = self.rollbackSQL!
            }
            if self.rollbackSqlType != nil {
                map["RollbackSqlType"] = self.rollbackSqlType!
            }
            if self.sqlType != nil {
                map["SqlType"] = self.sqlType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachmentName") && dict["AttachmentName"] != nil {
                self.attachmentName = dict["AttachmentName"] as! String
            }
            if dict.keys.contains("Classify") && dict["Classify"] != nil {
                self.classify = dict["Classify"] as! String
            }
            if dict.keys.contains("DbItemList") && dict["DbItemList"] != nil {
                var tmp : [CreateDataCorrectOrderRequest.Param.DbItemList] = []
                for v in dict["DbItemList"] as! [Any] {
                    var model = CreateDataCorrectOrderRequest.Param.DbItemList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dbItemList = tmp
            }
            if dict.keys.contains("EstimateAffectRows") && dict["EstimateAffectRows"] != nil {
                self.estimateAffectRows = dict["EstimateAffectRows"] as! Int64
            }
            if dict.keys.contains("ExecMode") && dict["ExecMode"] != nil {
                self.execMode = dict["ExecMode"] as! String
            }
            if dict.keys.contains("ExecSQL") && dict["ExecSQL"] != nil {
                self.execSQL = dict["ExecSQL"] as! String
            }
            if dict.keys.contains("RollbackAttachmentName") && dict["RollbackAttachmentName"] != nil {
                self.rollbackAttachmentName = dict["RollbackAttachmentName"] as! String
            }
            if dict.keys.contains("RollbackSQL") && dict["RollbackSQL"] != nil {
                self.rollbackSQL = dict["RollbackSQL"] as! String
            }
            if dict.keys.contains("RollbackSqlType") && dict["RollbackSqlType"] != nil {
                self.rollbackSqlType = dict["RollbackSqlType"] as! String
            }
            if dict.keys.contains("SqlType") && dict["SqlType"] != nil {
                self.sqlType = dict["SqlType"] as! String
            }
        }
    }
    public var attachmentKey: String?

    public var comment: String?

    public var param: CreateDataCorrectOrderRequest.Param?

    public var relatedUserList: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.param?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.param != nil {
            map["Param"] = self.param?.toMap()
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") && dict["AttachmentKey"] != nil {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            var model = CreateDataCorrectOrderRequest.Param()
            model.fromMap(dict["Param"] as! [String: Any])
            self.param = model
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserList = dict["RelatedUserList"] as! [Int64]
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataCorrectOrderShrinkRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var paramShrink: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.paramShrink != nil {
            map["Param"] = self.paramShrink!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") && dict["AttachmentKey"] != nil {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            self.paramShrink = dict["Param"] as! String
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataCorrectOrderResponseBody : Tea.TeaModel {
    public var createOrderResult: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") && dict["CreateOrderResult"] != nil {
            self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDataCorrectOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataCorrectOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateDataCorrectOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataCronClearOrderRequest : Tea.TeaModel {
    public class Param : Tea.TeaModel {
        public class CronClearItemList : Tea.TeaModel {
            public var columnName: String?

            public var filterSQL: String?

            public var remainDays: Int64?

            public var tableName: String?

            public var timeUnit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.filterSQL != nil {
                    map["FilterSQL"] = self.filterSQL!
                }
                if self.remainDays != nil {
                    map["RemainDays"] = self.remainDays!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.timeUnit != nil {
                    map["TimeUnit"] = self.timeUnit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("FilterSQL") && dict["FilterSQL"] != nil {
                    self.filterSQL = dict["FilterSQL"] as! String
                }
                if dict.keys.contains("RemainDays") && dict["RemainDays"] != nil {
                    self.remainDays = dict["RemainDays"] as! Int64
                }
                if dict.keys.contains("TableName") && dict["TableName"] != nil {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("TimeUnit") && dict["TimeUnit"] != nil {
                    self.timeUnit = dict["TimeUnit"] as! String
                }
            }
        }
        public class DbItemList : Tea.TeaModel {
            public var dbId: Int64?

            public var logic: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
            }
        }
        public var classify: String?

        public var cronClearItemList: [CreateDataCronClearOrderRequest.Param.CronClearItemList]?

        public var cronFormat: String?

        public var dbItemList: [CreateDataCronClearOrderRequest.Param.DbItemList]?

        public var durationHour: Int64?

        public var specifyDuration: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classify != nil {
                map["Classify"] = self.classify!
            }
            if self.cronClearItemList != nil {
                var tmp : [Any] = []
                for k in self.cronClearItemList! {
                    tmp.append(k.toMap())
                }
                map["CronClearItemList"] = tmp
            }
            if self.cronFormat != nil {
                map["CronFormat"] = self.cronFormat!
            }
            if self.dbItemList != nil {
                var tmp : [Any] = []
                for k in self.dbItemList! {
                    tmp.append(k.toMap())
                }
                map["DbItemList"] = tmp
            }
            if self.durationHour != nil {
                map["DurationHour"] = self.durationHour!
            }
            if self.specifyDuration != nil {
                map["specifyDuration"] = self.specifyDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Classify") && dict["Classify"] != nil {
                self.classify = dict["Classify"] as! String
            }
            if dict.keys.contains("CronClearItemList") && dict["CronClearItemList"] != nil {
                var tmp : [CreateDataCronClearOrderRequest.Param.CronClearItemList] = []
                for v in dict["CronClearItemList"] as! [Any] {
                    var model = CreateDataCronClearOrderRequest.Param.CronClearItemList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.cronClearItemList = tmp
            }
            if dict.keys.contains("CronFormat") && dict["CronFormat"] != nil {
                self.cronFormat = dict["CronFormat"] as! String
            }
            if dict.keys.contains("DbItemList") && dict["DbItemList"] != nil {
                var tmp : [CreateDataCronClearOrderRequest.Param.DbItemList] = []
                for v in dict["DbItemList"] as! [Any] {
                    var model = CreateDataCronClearOrderRequest.Param.DbItemList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dbItemList = tmp
            }
            if dict.keys.contains("DurationHour") && dict["DurationHour"] != nil {
                self.durationHour = dict["DurationHour"] as! Int64
            }
            if dict.keys.contains("specifyDuration") && dict["specifyDuration"] != nil {
                self.specifyDuration = dict["specifyDuration"] as! Bool
            }
        }
    }
    public var attachmentKey: String?

    public var comment: String?

    public var param: CreateDataCronClearOrderRequest.Param?

    public var relatedUserList: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.param?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.param != nil {
            map["Param"] = self.param?.toMap()
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") && dict["AttachmentKey"] != nil {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            var model = CreateDataCronClearOrderRequest.Param()
            model.fromMap(dict["Param"] as! [String: Any])
            self.param = model
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserList = dict["RelatedUserList"] as! [Int64]
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataCronClearOrderShrinkRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var paramShrink: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.paramShrink != nil {
            map["Param"] = self.paramShrink!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") && dict["AttachmentKey"] != nil {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            self.paramShrink = dict["Param"] as! String
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataCronClearOrderResponseBody : Tea.TeaModel {
    public var createOrderResult: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") && dict["CreateOrderResult"] != nil {
            self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDataCronClearOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataCronClearOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateDataCronClearOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataExportOrderRequest : Tea.TeaModel {
    public class PluginParam : Tea.TeaModel {
        public class Watermark : Tea.TeaModel {
            public var columnName: String?

            public var dataWatermark: String?

            public var fileWatermark: String?

            public var keys: [String]?

            public var watermarkTypes: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.dataWatermark != nil {
                    map["DataWatermark"] = self.dataWatermark!
                }
                if self.fileWatermark != nil {
                    map["FileWatermark"] = self.fileWatermark!
                }
                if self.keys != nil {
                    map["Keys"] = self.keys!
                }
                if self.watermarkTypes != nil {
                    map["WatermarkTypes"] = self.watermarkTypes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("DataWatermark") && dict["DataWatermark"] != nil {
                    self.dataWatermark = dict["DataWatermark"] as! String
                }
                if dict.keys.contains("FileWatermark") && dict["FileWatermark"] != nil {
                    self.fileWatermark = dict["FileWatermark"] as! String
                }
                if dict.keys.contains("Keys") && dict["Keys"] != nil {
                    self.keys = dict["Keys"] as! [String]
                }
                if dict.keys.contains("WatermarkTypes") && dict["WatermarkTypes"] != nil {
                    self.watermarkTypes = dict["WatermarkTypes"] as! [String]
                }
            }
        }
        public var affectRows: Int64?

        public var classify: String?

        public var dbId: Int64?

        public var exeSQL: String?

        public var ignoreAffectRows: Bool?

        public var ignoreAffectRowsReason: String?

        public var instanceId: Int64?

        public var logic: Bool?

        public var watermark: CreateDataExportOrderRequest.PluginParam.Watermark?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.watermark?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.affectRows != nil {
                map["AffectRows"] = self.affectRows!
            }
            if self.classify != nil {
                map["Classify"] = self.classify!
            }
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.exeSQL != nil {
                map["ExeSQL"] = self.exeSQL!
            }
            if self.ignoreAffectRows != nil {
                map["IgnoreAffectRows"] = self.ignoreAffectRows!
            }
            if self.ignoreAffectRowsReason != nil {
                map["IgnoreAffectRowsReason"] = self.ignoreAffectRowsReason!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.logic != nil {
                map["Logic"] = self.logic!
            }
            if self.watermark != nil {
                map["Watermark"] = self.watermark?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AffectRows") && dict["AffectRows"] != nil {
                self.affectRows = dict["AffectRows"] as! Int64
            }
            if dict.keys.contains("Classify") && dict["Classify"] != nil {
                self.classify = dict["Classify"] as! String
            }
            if dict.keys.contains("DbId") && dict["DbId"] != nil {
                self.dbId = dict["DbId"] as! Int64
            }
            if dict.keys.contains("ExeSQL") && dict["ExeSQL"] != nil {
                self.exeSQL = dict["ExeSQL"] as! String
            }
            if dict.keys.contains("IgnoreAffectRows") && dict["IgnoreAffectRows"] != nil {
                self.ignoreAffectRows = dict["IgnoreAffectRows"] as! Bool
            }
            if dict.keys.contains("IgnoreAffectRowsReason") && dict["IgnoreAffectRowsReason"] != nil {
                self.ignoreAffectRowsReason = dict["IgnoreAffectRowsReason"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("Logic") && dict["Logic"] != nil {
                self.logic = dict["Logic"] as! Bool
            }
            if dict.keys.contains("Watermark") && dict["Watermark"] != nil {
                var model = CreateDataExportOrderRequest.PluginParam.Watermark()
                model.fromMap(dict["Watermark"] as! [String: Any])
                self.watermark = model
            }
        }
    }
    public var attachmentKey: String?

    public var comment: String?

    public var parentId: Int64?

    public var pluginParam: CreateDataExportOrderRequest.PluginParam?

    public var relatedUserList: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pluginParam?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.pluginParam != nil {
            map["PluginParam"] = self.pluginParam?.toMap()
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") && dict["AttachmentKey"] != nil {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("PluginParam") && dict["PluginParam"] != nil {
            var model = CreateDataExportOrderRequest.PluginParam()
            model.fromMap(dict["PluginParam"] as! [String: Any])
            self.pluginParam = model
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserList = dict["RelatedUserList"] as! [Int64]
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataExportOrderShrinkRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var parentId: Int64?

    public var pluginParamShrink: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.pluginParamShrink != nil {
            map["PluginParam"] = self.pluginParamShrink!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") && dict["AttachmentKey"] != nil {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("PluginParam") && dict["PluginParam"] != nil {
            self.pluginParamShrink = dict["PluginParam"] as! String
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataExportOrderResponseBody : Tea.TeaModel {
    public class CreateOrderResult : Tea.TeaModel {
        public var createOrderResult: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createOrderResult != nil {
                map["CreateOrderResult"] = self.createOrderResult!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateOrderResult") && dict["CreateOrderResult"] != nil {
                self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
            }
        }
    }
    public var createOrderResult: CreateDataExportOrderResponseBody.CreateOrderResult?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createOrderResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") && dict["CreateOrderResult"] != nil {
            var model = CreateDataExportOrderResponseBody.CreateOrderResult()
            model.fromMap(dict["CreateOrderResult"] as! [String: Any])
            self.createOrderResult = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDataExportOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataExportOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateDataExportOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataImportOrderRequest : Tea.TeaModel {
    public class Param : Tea.TeaModel {
        public class DbItemList : Tea.TeaModel {
            public var dbId: Int64?

            public var logic: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
            }
        }
        public var attachmentName: String?

        public var classify: String?

        public var csvFirstRowIsColumnDef: Bool?

        public var dbItemList: [CreateDataImportOrderRequest.Param.DbItemList]?

        public var fileEncoding: String?

        public var fileType: String?

        public var ignoreError: Bool?

        public var importMode: String?

        public var insertType: String?

        public var rollbackAttachmentName: String?

        public var rollbackSQL: String?

        public var rollbackSqlType: String?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachmentName != nil {
                map["AttachmentName"] = self.attachmentName!
            }
            if self.classify != nil {
                map["Classify"] = self.classify!
            }
            if self.csvFirstRowIsColumnDef != nil {
                map["CsvFirstRowIsColumnDef"] = self.csvFirstRowIsColumnDef!
            }
            if self.dbItemList != nil {
                var tmp : [Any] = []
                for k in self.dbItemList! {
                    tmp.append(k.toMap())
                }
                map["DbItemList"] = tmp
            }
            if self.fileEncoding != nil {
                map["FileEncoding"] = self.fileEncoding!
            }
            if self.fileType != nil {
                map["FileType"] = self.fileType!
            }
            if self.ignoreError != nil {
                map["IgnoreError"] = self.ignoreError!
            }
            if self.importMode != nil {
                map["ImportMode"] = self.importMode!
            }
            if self.insertType != nil {
                map["InsertType"] = self.insertType!
            }
            if self.rollbackAttachmentName != nil {
                map["RollbackAttachmentName"] = self.rollbackAttachmentName!
            }
            if self.rollbackSQL != nil {
                map["RollbackSQL"] = self.rollbackSQL!
            }
            if self.rollbackSqlType != nil {
                map["RollbackSqlType"] = self.rollbackSqlType!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachmentName") && dict["AttachmentName"] != nil {
                self.attachmentName = dict["AttachmentName"] as! String
            }
            if dict.keys.contains("Classify") && dict["Classify"] != nil {
                self.classify = dict["Classify"] as! String
            }
            if dict.keys.contains("CsvFirstRowIsColumnDef") && dict["CsvFirstRowIsColumnDef"] != nil {
                self.csvFirstRowIsColumnDef = dict["CsvFirstRowIsColumnDef"] as! Bool
            }
            if dict.keys.contains("DbItemList") && dict["DbItemList"] != nil {
                var tmp : [CreateDataImportOrderRequest.Param.DbItemList] = []
                for v in dict["DbItemList"] as! [Any] {
                    var model = CreateDataImportOrderRequest.Param.DbItemList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dbItemList = tmp
            }
            if dict.keys.contains("FileEncoding") && dict["FileEncoding"] != nil {
                self.fileEncoding = dict["FileEncoding"] as! String
            }
            if dict.keys.contains("FileType") && dict["FileType"] != nil {
                self.fileType = dict["FileType"] as! String
            }
            if dict.keys.contains("IgnoreError") && dict["IgnoreError"] != nil {
                self.ignoreError = dict["IgnoreError"] as! Bool
            }
            if dict.keys.contains("ImportMode") && dict["ImportMode"] != nil {
                self.importMode = dict["ImportMode"] as! String
            }
            if dict.keys.contains("InsertType") && dict["InsertType"] != nil {
                self.insertType = dict["InsertType"] as! String
            }
            if dict.keys.contains("RollbackAttachmentName") && dict["RollbackAttachmentName"] != nil {
                self.rollbackAttachmentName = dict["RollbackAttachmentName"] as! String
            }
            if dict.keys.contains("RollbackSQL") && dict["RollbackSQL"] != nil {
                self.rollbackSQL = dict["RollbackSQL"] as! String
            }
            if dict.keys.contains("RollbackSqlType") && dict["RollbackSqlType"] != nil {
                self.rollbackSqlType = dict["RollbackSqlType"] as! String
            }
            if dict.keys.contains("TableName") && dict["TableName"] != nil {
                self.tableName = dict["TableName"] as! String
            }
        }
    }
    public var attachmentKey: String?

    public var comment: String?

    public var param: CreateDataImportOrderRequest.Param?

    public var relatedUserList: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.param?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.param != nil {
            map["Param"] = self.param?.toMap()
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") && dict["AttachmentKey"] != nil {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            var model = CreateDataImportOrderRequest.Param()
            model.fromMap(dict["Param"] as! [String: Any])
            self.param = model
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserList = dict["RelatedUserList"] as! [Int64]
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataImportOrderShrinkRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var paramShrink: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.paramShrink != nil {
            map["Param"] = self.paramShrink!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") && dict["AttachmentKey"] != nil {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            self.paramShrink = dict["Param"] as! String
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataImportOrderResponseBody : Tea.TeaModel {
    public var createOrderResult: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") && dict["CreateOrderResult"] != nil {
            self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDataImportOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataImportOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateDataImportOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataTrackOrderRequest : Tea.TeaModel {
    public class Param : Tea.TeaModel {
        public var dbId: String?

        public var jobEndTime: String?

        public var jobStartTime: String?

        public var tableNames: [String]?

        public var trackTypes: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.jobEndTime != nil {
                map["JobEndTime"] = self.jobEndTime!
            }
            if self.jobStartTime != nil {
                map["JobStartTime"] = self.jobStartTime!
            }
            if self.tableNames != nil {
                map["TableNames"] = self.tableNames!
            }
            if self.trackTypes != nil {
                map["TrackTypes"] = self.trackTypes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbId") && dict["DbId"] != nil {
                self.dbId = dict["DbId"] as! String
            }
            if dict.keys.contains("JobEndTime") && dict["JobEndTime"] != nil {
                self.jobEndTime = dict["JobEndTime"] as! String
            }
            if dict.keys.contains("JobStartTime") && dict["JobStartTime"] != nil {
                self.jobStartTime = dict["JobStartTime"] as! String
            }
            if dict.keys.contains("TableNames") && dict["TableNames"] != nil {
                self.tableNames = dict["TableNames"] as! [String]
            }
            if dict.keys.contains("TrackTypes") && dict["TrackTypes"] != nil {
                self.trackTypes = dict["TrackTypes"] as! [String]
            }
        }
    }
    public var comment: String?

    public var param: CreateDataTrackOrderRequest.Param?

    public var relatedUserList: [String]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.param?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.param != nil {
            map["Param"] = self.param?.toMap()
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            var model = CreateDataTrackOrderRequest.Param()
            model.fromMap(dict["Param"] as! [String: Any])
            self.param = model
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserList = dict["RelatedUserList"] as! [String]
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataTrackOrderShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var paramShrink: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.paramShrink != nil {
            map["Param"] = self.paramShrink!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            self.paramShrink = dict["Param"] as! String
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDataTrackOrderResponseBody : Tea.TeaModel {
    public var createOrderResult: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") && dict["CreateOrderResult"] != nil {
            self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDataTrackOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataTrackOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateDataTrackOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDatabaseExportOrderRequest : Tea.TeaModel {
    public class PluginParam : Tea.TeaModel {
        public class Config : Tea.TeaModel {
            public var dataOption: [String]?

            public var exportContent: String?

            public var exportTypes: [String]?

            public var SQLExtOption: [String]?

            public var selectedTables: [String]?

            public var tables: [String: String]?

            public var targetOption: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataOption != nil {
                    map["DataOption"] = self.dataOption!
                }
                if self.exportContent != nil {
                    map["ExportContent"] = self.exportContent!
                }
                if self.exportTypes != nil {
                    map["ExportTypes"] = self.exportTypes!
                }
                if self.SQLExtOption != nil {
                    map["SQLExtOption"] = self.SQLExtOption!
                }
                if self.selectedTables != nil {
                    map["SelectedTables"] = self.selectedTables!
                }
                if self.tables != nil {
                    map["Tables"] = self.tables!
                }
                if self.targetOption != nil {
                    map["TargetOption"] = self.targetOption!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataOption") && dict["DataOption"] != nil {
                    self.dataOption = dict["DataOption"] as! [String]
                }
                if dict.keys.contains("ExportContent") && dict["ExportContent"] != nil {
                    self.exportContent = dict["ExportContent"] as! String
                }
                if dict.keys.contains("ExportTypes") && dict["ExportTypes"] != nil {
                    self.exportTypes = dict["ExportTypes"] as! [String]
                }
                if dict.keys.contains("SQLExtOption") && dict["SQLExtOption"] != nil {
                    self.SQLExtOption = dict["SQLExtOption"] as! [String]
                }
                if dict.keys.contains("SelectedTables") && dict["SelectedTables"] != nil {
                    self.selectedTables = dict["SelectedTables"] as! [String]
                }
                if dict.keys.contains("Tables") && dict["Tables"] != nil {
                    self.tables = dict["Tables"] as! [String: String]
                }
                if dict.keys.contains("TargetOption") && dict["TargetOption"] != nil {
                    self.targetOption = dict["TargetOption"] as! String
                }
            }
        }
        public var classify: String?

        public var config: CreateDatabaseExportOrderRequest.PluginParam.Config?

        public var dbId: Int64?

        public var instanceId: Int64?

        public var logic: Bool?

        public var searchName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.config?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classify != nil {
                map["Classify"] = self.classify!
            }
            if self.config != nil {
                map["Config"] = self.config?.toMap()
            }
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.logic != nil {
                map["Logic"] = self.logic!
            }
            if self.searchName != nil {
                map["SearchName"] = self.searchName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Classify") && dict["Classify"] != nil {
                self.classify = dict["Classify"] as! String
            }
            if dict.keys.contains("Config") && dict["Config"] != nil {
                var model = CreateDatabaseExportOrderRequest.PluginParam.Config()
                model.fromMap(dict["Config"] as! [String: Any])
                self.config = model
            }
            if dict.keys.contains("DbId") && dict["DbId"] != nil {
                self.dbId = dict["DbId"] as! Int64
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("Logic") && dict["Logic"] != nil {
                self.logic = dict["Logic"] as! Bool
            }
            if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                self.searchName = dict["SearchName"] as! String
            }
        }
    }
    public var attachmentKey: String?

    public var comment: String?

    public var parentId: Int64?

    public var pluginParam: CreateDatabaseExportOrderRequest.PluginParam?

    public var relatedUserList: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pluginParam?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.pluginParam != nil {
            map["PluginParam"] = self.pluginParam?.toMap()
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") && dict["AttachmentKey"] != nil {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("PluginParam") && dict["PluginParam"] != nil {
            var model = CreateDatabaseExportOrderRequest.PluginParam()
            model.fromMap(dict["PluginParam"] as! [String: Any])
            self.pluginParam = model
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserList = dict["RelatedUserList"] as! [Int64]
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDatabaseExportOrderShrinkRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var parentId: Int64?

    public var pluginParamShrink: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.pluginParamShrink != nil {
            map["PluginParam"] = self.pluginParamShrink!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") && dict["AttachmentKey"] != nil {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("PluginParam") && dict["PluginParam"] != nil {
            self.pluginParamShrink = dict["PluginParam"] as! String
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateDatabaseExportOrderResponseBody : Tea.TeaModel {
    public class CreateOrderResult : Tea.TeaModel {
        public var createOrderResult: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createOrderResult != nil {
                map["CreateOrderResult"] = self.createOrderResult!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateOrderResult") && dict["CreateOrderResult"] != nil {
                self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
            }
        }
    }
    public var createOrderResult: CreateDatabaseExportOrderResponseBody.CreateOrderResult?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createOrderResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") && dict["CreateOrderResult"] != nil {
            var model = CreateDatabaseExportOrderResponseBody.CreateOrderResult()
            model.fromMap(dict["CreateOrderResult"] as! [String: Any])
            self.createOrderResult = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDatabaseExportOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDatabaseExportOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateDatabaseExportOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFreeLockCorrectOrderRequest : Tea.TeaModel {
    public class Param : Tea.TeaModel {
        public class DbItemList : Tea.TeaModel {
            public var dbId: Int64?

            public var logic: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
            }
        }
        public var attachmentName: String?

        public var classify: String?

        public var dbItemList: [CreateFreeLockCorrectOrderRequest.Param.DbItemList]?

        public var execMode: String?

        public var execSQL: String?

        public var rollbackAttachmentName: String?

        public var rollbackSQL: String?

        public var rollbackSqlType: String?

        public var sqlType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachmentName != nil {
                map["AttachmentName"] = self.attachmentName!
            }
            if self.classify != nil {
                map["Classify"] = self.classify!
            }
            if self.dbItemList != nil {
                var tmp : [Any] = []
                for k in self.dbItemList! {
                    tmp.append(k.toMap())
                }
                map["DbItemList"] = tmp
            }
            if self.execMode != nil {
                map["ExecMode"] = self.execMode!
            }
            if self.execSQL != nil {
                map["ExecSQL"] = self.execSQL!
            }
            if self.rollbackAttachmentName != nil {
                map["RollbackAttachmentName"] = self.rollbackAttachmentName!
            }
            if self.rollbackSQL != nil {
                map["RollbackSQL"] = self.rollbackSQL!
            }
            if self.rollbackSqlType != nil {
                map["RollbackSqlType"] = self.rollbackSqlType!
            }
            if self.sqlType != nil {
                map["SqlType"] = self.sqlType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachmentName") && dict["AttachmentName"] != nil {
                self.attachmentName = dict["AttachmentName"] as! String
            }
            if dict.keys.contains("Classify") && dict["Classify"] != nil {
                self.classify = dict["Classify"] as! String
            }
            if dict.keys.contains("DbItemList") && dict["DbItemList"] != nil {
                var tmp : [CreateFreeLockCorrectOrderRequest.Param.DbItemList] = []
                for v in dict["DbItemList"] as! [Any] {
                    var model = CreateFreeLockCorrectOrderRequest.Param.DbItemList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dbItemList = tmp
            }
            if dict.keys.contains("ExecMode") && dict["ExecMode"] != nil {
                self.execMode = dict["ExecMode"] as! String
            }
            if dict.keys.contains("ExecSQL") && dict["ExecSQL"] != nil {
                self.execSQL = dict["ExecSQL"] as! String
            }
            if dict.keys.contains("RollbackAttachmentName") && dict["RollbackAttachmentName"] != nil {
                self.rollbackAttachmentName = dict["RollbackAttachmentName"] as! String
            }
            if dict.keys.contains("RollbackSQL") && dict["RollbackSQL"] != nil {
                self.rollbackSQL = dict["RollbackSQL"] as! String
            }
            if dict.keys.contains("RollbackSqlType") && dict["RollbackSqlType"] != nil {
                self.rollbackSqlType = dict["RollbackSqlType"] as! String
            }
            if dict.keys.contains("SqlType") && dict["SqlType"] != nil {
                self.sqlType = dict["SqlType"] as! String
            }
        }
    }
    public var attachmentKey: String?

    public var comment: String?

    public var param: CreateFreeLockCorrectOrderRequest.Param?

    public var relatedUserList: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.param?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.param != nil {
            map["Param"] = self.param?.toMap()
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") && dict["AttachmentKey"] != nil {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            var model = CreateFreeLockCorrectOrderRequest.Param()
            model.fromMap(dict["Param"] as! [String: Any])
            self.param = model
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserList = dict["RelatedUserList"] as! [Int64]
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateFreeLockCorrectOrderShrinkRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var paramShrink: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.paramShrink != nil {
            map["Param"] = self.paramShrink!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") && dict["AttachmentKey"] != nil {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            self.paramShrink = dict["Param"] as! String
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateFreeLockCorrectOrderResponseBody : Tea.TeaModel {
    public var createOrderResult: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") && dict["CreateOrderResult"] != nil {
            self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateFreeLockCorrectOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFreeLockCorrectOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateFreeLockCorrectOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLakeHouseSpaceRequest : Tea.TeaModel {
    public var description_: String?

    public var devDbId: String?

    public var dwDbType: String?

    public var mode: String?

    public var prodDbId: String?

    public var spaceConfig: String?

    public var spaceName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.devDbId != nil {
            map["DevDbId"] = self.devDbId!
        }
        if self.dwDbType != nil {
            map["DwDbType"] = self.dwDbType!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.prodDbId != nil {
            map["ProdDbId"] = self.prodDbId!
        }
        if self.spaceConfig != nil {
            map["SpaceConfig"] = self.spaceConfig!
        }
        if self.spaceName != nil {
            map["SpaceName"] = self.spaceName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DevDbId") && dict["DevDbId"] != nil {
            self.devDbId = dict["DevDbId"] as! String
        }
        if dict.keys.contains("DwDbType") && dict["DwDbType"] != nil {
            self.dwDbType = dict["DwDbType"] as! String
        }
        if dict.keys.contains("Mode") && dict["Mode"] != nil {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("ProdDbId") && dict["ProdDbId"] != nil {
            self.prodDbId = dict["ProdDbId"] as! String
        }
        if dict.keys.contains("SpaceConfig") && dict["SpaceConfig"] != nil {
            self.spaceConfig = dict["SpaceConfig"] as! String
        }
        if dict.keys.contains("SpaceName") && dict["SpaceName"] != nil {
            self.spaceName = dict["SpaceName"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateLakeHouseSpaceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var spaceId: Int64?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
            self.spaceId = dict["SpaceId"] as! Int64
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateLakeHouseSpaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLakeHouseSpaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateLakeHouseSpaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLogicDatabaseRequest : Tea.TeaModel {
    public var alias: String?

    public var databaseIds: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alias != nil {
            map["Alias"] = self.alias!
        }
        if self.databaseIds != nil {
            map["DatabaseIds"] = self.databaseIds!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Alias") && dict["Alias"] != nil {
            self.alias = dict["Alias"] as! String
        }
        if dict.keys.contains("DatabaseIds") && dict["DatabaseIds"] != nil {
            self.databaseIds = dict["DatabaseIds"] as! [Int64]
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateLogicDatabaseShrinkRequest : Tea.TeaModel {
    public var alias: String?

    public var databaseIdsShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alias != nil {
            map["Alias"] = self.alias!
        }
        if self.databaseIdsShrink != nil {
            map["DatabaseIds"] = self.databaseIdsShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Alias") && dict["Alias"] != nil {
            self.alias = dict["Alias"] as! String
        }
        if dict.keys.contains("DatabaseIds") && dict["DatabaseIds"] != nil {
            self.databaseIdsShrink = dict["DatabaseIds"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateLogicDatabaseResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var logicDbId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.logicDbId != nil {
            map["LogicDbId"] = self.logicDbId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("LogicDbId") && dict["LogicDbId"] != nil {
            self.logicDbId = dict["LogicDbId"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateLogicDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLogicDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateLogicDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrderRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var pluginParam: [String: Any]?

    public var pluginType: String?

    public var relatedUserList: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.pluginParam != nil {
            map["PluginParam"] = self.pluginParam!
        }
        if self.pluginType != nil {
            map["PluginType"] = self.pluginType!
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") && dict["AttachmentKey"] != nil {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("PluginParam") && dict["PluginParam"] != nil {
            self.pluginParam = dict["PluginParam"] as! [String: Any]
        }
        if dict.keys.contains("PluginType") && dict["PluginType"] != nil {
            self.pluginType = dict["PluginType"] as! String
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserList = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateOrderShrinkRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var pluginParamShrink: String?

    public var pluginType: String?

    public var relatedUserList: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.pluginParamShrink != nil {
            map["PluginParam"] = self.pluginParamShrink!
        }
        if self.pluginType != nil {
            map["PluginType"] = self.pluginType!
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") && dict["AttachmentKey"] != nil {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("PluginParam") && dict["PluginParam"] != nil {
            self.pluginParamShrink = dict["PluginParam"] as! String
        }
        if dict.keys.contains("PluginType") && dict["PluginType"] != nil {
            self.pluginType = dict["PluginType"] as! String
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserList = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateOrderResponseBody : Tea.TeaModel {
    public class CreateOrderResult : Tea.TeaModel {
        public var orderIds: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.orderIds != nil {
                map["OrderIds"] = self.orderIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OrderIds") && dict["OrderIds"] != nil {
                self.orderIds = dict["OrderIds"] as! [Int64]
            }
        }
    }
    public var createOrderResult: CreateOrderResponseBody.CreateOrderResult?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createOrderResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") && dict["CreateOrderResult"] != nil {
            var model = CreateOrderResponseBody.CreateOrderResult()
            model.fromMap(dict["CreateOrderResult"] as! [String: Any])
            self.createOrderResult = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProxyRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var password: String?

    public var tid: Int64?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("Password") && dict["Password"] != nil {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("Username") && dict["Username"] != nil {
            self.username = dict["Username"] as! String
        }
    }
}

public class CreateProxyResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var proxyId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.proxyId != nil {
            map["ProxyId"] = self.proxyId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("ProxyId") && dict["ProxyId"] != nil {
            self.proxyId = dict["ProxyId"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateProxyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProxyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateProxyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProxyAccessRequest : Tea.TeaModel {
    public var indepAccount: String?

    public var indepPassword: String?

    public var proxyId: Int64?

    public var tid: Int64?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.indepAccount != nil {
            map["IndepAccount"] = self.indepAccount!
        }
        if self.indepPassword != nil {
            map["IndepPassword"] = self.indepPassword!
        }
        if self.proxyId != nil {
            map["ProxyId"] = self.proxyId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IndepAccount") && dict["IndepAccount"] != nil {
            self.indepAccount = dict["IndepAccount"] as! String
        }
        if dict.keys.contains("IndepPassword") && dict["IndepPassword"] != nil {
            self.indepPassword = dict["IndepPassword"] as! String
        }
        if dict.keys.contains("ProxyId") && dict["ProxyId"] != nil {
            self.proxyId = dict["ProxyId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class CreateProxyAccessResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var proxyAccessId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.proxyAccessId != nil {
            map["ProxyAccessId"] = self.proxyAccessId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("ProxyAccessId") && dict["ProxyAccessId"] != nil {
            self.proxyAccessId = dict["ProxyAccessId"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateProxyAccessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProxyAccessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateProxyAccessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePublishGroupTaskRequest : Tea.TeaModel {
    public var dbId: Int32?

    public var logic: Bool?

    public var orderId: Int64?

    public var planTime: String?

    public var publishStrategy: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.planTime != nil {
            map["PlanTime"] = self.planTime!
        }
        if self.publishStrategy != nil {
            map["PublishStrategy"] = self.publishStrategy!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") && dict["DbId"] != nil {
            self.dbId = dict["DbId"] as! Int32
        }
        if dict.keys.contains("Logic") && dict["Logic"] != nil {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("PlanTime") && dict["PlanTime"] != nil {
            self.planTime = dict["PlanTime"] as! String
        }
        if dict.keys.contains("PublishStrategy") && dict["PublishStrategy"] != nil {
            self.publishStrategy = dict["PublishStrategy"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreatePublishGroupTaskResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class CreatePublishGroupTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePublishGroupTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreatePublishGroupTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSQLReviewOrderRequest : Tea.TeaModel {
    public class Param : Tea.TeaModel {
        public var attachmentKeyList: [String]?

        public var dbId: Int64?

        public var projectName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachmentKeyList != nil {
                map["AttachmentKeyList"] = self.attachmentKeyList!
            }
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachmentKeyList") && dict["AttachmentKeyList"] != nil {
                self.attachmentKeyList = dict["AttachmentKeyList"] as! [String]
            }
            if dict.keys.contains("DbId") && dict["DbId"] != nil {
                self.dbId = dict["DbId"] as! Int64
            }
            if dict.keys.contains("ProjectName") && dict["ProjectName"] != nil {
                self.projectName = dict["ProjectName"] as! String
            }
        }
    }
    public var comment: String?

    public var param: CreateSQLReviewOrderRequest.Param?

    public var relatedUserList: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.param?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.param != nil {
            map["Param"] = self.param?.toMap()
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            var model = CreateSQLReviewOrderRequest.Param()
            model.fromMap(dict["Param"] as! [String: Any])
            self.param = model
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserList = dict["RelatedUserList"] as! [Int64]
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateSQLReviewOrderShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var paramShrink: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.paramShrink != nil {
            map["Param"] = self.paramShrink!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            self.paramShrink = dict["Param"] as! String
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateSQLReviewOrderResponseBody : Tea.TeaModel {
    public var createOrderResult: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") && dict["CreateOrderResult"] != nil {
            self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateSQLReviewOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSQLReviewOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateSQLReviewOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScenarioRequest : Tea.TeaModel {
    public var description_: String?

    public var scenarioName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.scenarioName != nil {
            map["ScenarioName"] = self.scenarioName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ScenarioName") && dict["ScenarioName"] != nil {
            self.scenarioName = dict["ScenarioName"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateScenarioResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var scenarioId: Int64?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScenarioId") && dict["ScenarioId"] != nil {
            self.scenarioId = dict["ScenarioId"] as! Int64
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateScenarioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScenarioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateScenarioResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateStandardGroupRequest : Tea.TeaModel {
    public var dbType: String?

    public var description_: String?

    public var groupName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbType != nil {
            map["DbType"] = self.dbType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbType") && dict["DbType"] != nil {
            self.dbType = dict["DbType"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateStandardGroupResponseBody : Tea.TeaModel {
    public class StandardGroup : Tea.TeaModel {
        public var dbType: String?

        public var description_: String?

        public var groupMode: String?

        public var groupName: String?

        public var lastMenderId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupMode != nil {
                map["GroupMode"] = self.groupMode!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.lastMenderId != nil {
                map["LastMenderId"] = self.lastMenderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbType") && dict["DbType"] != nil {
                self.dbType = dict["DbType"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupMode") && dict["GroupMode"] != nil {
                self.groupMode = dict["GroupMode"] as! String
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("LastMenderId") && dict["LastMenderId"] != nil {
                self.lastMenderId = dict["LastMenderId"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var standardGroup: CreateStandardGroupResponseBody.StandardGroup?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.standardGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.standardGroup != nil {
            map["StandardGroup"] = self.standardGroup?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StandardGroup") && dict["StandardGroup"] != nil {
            var model = CreateStandardGroupResponseBody.StandardGroup()
            model.fromMap(dict["StandardGroup"] as! [String: Any])
            self.standardGroup = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateStandardGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateStandardGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateStandardGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateStructSyncOrderRequest : Tea.TeaModel {
    public class Param : Tea.TeaModel {
        public class Source : Tea.TeaModel {
            public var dbId: Int64?

            public var dbSearchName: String?

            public var logic: Bool?

            public var versionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbSearchName != nil {
                    map["DbSearchName"] = self.dbSearchName!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.versionId != nil {
                    map["VersionId"] = self.versionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("DbSearchName") && dict["DbSearchName"] != nil {
                    self.dbSearchName = dict["DbSearchName"] as! String
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("VersionId") && dict["VersionId"] != nil {
                    self.versionId = dict["VersionId"] as! String
                }
            }
        }
        public class TableInfoList : Tea.TeaModel {
            public var sourceTableName: String?

            public var targetTableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sourceTableName != nil {
                    map["SourceTableName"] = self.sourceTableName!
                }
                if self.targetTableName != nil {
                    map["TargetTableName"] = self.targetTableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SourceTableName") && dict["SourceTableName"] != nil {
                    self.sourceTableName = dict["SourceTableName"] as! String
                }
                if dict.keys.contains("TargetTableName") && dict["TargetTableName"] != nil {
                    self.targetTableName = dict["TargetTableName"] as! String
                }
            }
        }
        public class Target : Tea.TeaModel {
            public var dbId: Int64?

            public var dbSearchName: String?

            public var logic: Bool?

            public var versionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbSearchName != nil {
                    map["DbSearchName"] = self.dbSearchName!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.versionId != nil {
                    map["VersionId"] = self.versionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("DbSearchName") && dict["DbSearchName"] != nil {
                    self.dbSearchName = dict["DbSearchName"] as! String
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("VersionId") && dict["VersionId"] != nil {
                    self.versionId = dict["VersionId"] as! String
                }
            }
        }
        public var ignoreError: Bool?

        public var source: CreateStructSyncOrderRequest.Param.Source?

        public var tableInfoList: [CreateStructSyncOrderRequest.Param.TableInfoList]?

        public var target: CreateStructSyncOrderRequest.Param.Target?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.source?.validate()
            try self.target?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ignoreError != nil {
                map["IgnoreError"] = self.ignoreError!
            }
            if self.source != nil {
                map["Source"] = self.source?.toMap()
            }
            if self.tableInfoList != nil {
                var tmp : [Any] = []
                for k in self.tableInfoList! {
                    tmp.append(k.toMap())
                }
                map["TableInfoList"] = tmp
            }
            if self.target != nil {
                map["Target"] = self.target?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IgnoreError") && dict["IgnoreError"] != nil {
                self.ignoreError = dict["IgnoreError"] as! Bool
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                var model = CreateStructSyncOrderRequest.Param.Source()
                model.fromMap(dict["Source"] as! [String: Any])
                self.source = model
            }
            if dict.keys.contains("TableInfoList") && dict["TableInfoList"] != nil {
                var tmp : [CreateStructSyncOrderRequest.Param.TableInfoList] = []
                for v in dict["TableInfoList"] as! [Any] {
                    var model = CreateStructSyncOrderRequest.Param.TableInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tableInfoList = tmp
            }
            if dict.keys.contains("Target") && dict["Target"] != nil {
                var model = CreateStructSyncOrderRequest.Param.Target()
                model.fromMap(dict["Target"] as! [String: Any])
                self.target = model
            }
        }
    }
    public var attachmentKey: String?

    public var comment: String?

    public var param: CreateStructSyncOrderRequest.Param?

    public var relatedUserList: [Int64]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.param?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.param != nil {
            map["Param"] = self.param?.toMap()
        }
        if self.relatedUserList != nil {
            map["RelatedUserList"] = self.relatedUserList!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") && dict["AttachmentKey"] != nil {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            var model = CreateStructSyncOrderRequest.Param()
            model.fromMap(dict["Param"] as! [String: Any])
            self.param = model
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserList = dict["RelatedUserList"] as! [Int64]
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateStructSyncOrderShrinkRequest : Tea.TeaModel {
    public var attachmentKey: String?

    public var comment: String?

    public var paramShrink: String?

    public var relatedUserListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachmentKey != nil {
            map["AttachmentKey"] = self.attachmentKey!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.paramShrink != nil {
            map["Param"] = self.paramShrink!
        }
        if self.relatedUserListShrink != nil {
            map["RelatedUserList"] = self.relatedUserListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachmentKey") && dict["AttachmentKey"] != nil {
            self.attachmentKey = dict["AttachmentKey"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            self.paramShrink = dict["Param"] as! String
        }
        if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
            self.relatedUserListShrink = dict["RelatedUserList"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateStructSyncOrderResponseBody : Tea.TeaModel {
    public var createOrderResult: [Int64]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createOrderResult != nil {
            map["CreateOrderResult"] = self.createOrderResult!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateOrderResult") && dict["CreateOrderResult"] != nil {
            self.createOrderResult = dict["CreateOrderResult"] as! [Int64]
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateStructSyncOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateStructSyncOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateStructSyncOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTaskRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var graphParam: String?

    public var nodeContent: String?

    public var nodeName: String?

    public var nodeOutput: String?

    public var nodeType: String?

    public var tid: Int64?

    public var timeVariables: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.graphParam != nil {
            map["GraphParam"] = self.graphParam!
        }
        if self.nodeContent != nil {
            map["NodeContent"] = self.nodeContent!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.nodeOutput != nil {
            map["NodeOutput"] = self.nodeOutput!
        }
        if self.nodeType != nil {
            map["NodeType"] = self.nodeType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.timeVariables != nil {
            map["TimeVariables"] = self.timeVariables!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("GraphParam") && dict["GraphParam"] != nil {
            self.graphParam = dict["GraphParam"] as! String
        }
        if dict.keys.contains("NodeContent") && dict["NodeContent"] != nil {
            self.nodeContent = dict["NodeContent"] as! String
        }
        if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
            self.nodeName = dict["NodeName"] as! String
        }
        if dict.keys.contains("NodeOutput") && dict["NodeOutput"] != nil {
            self.nodeOutput = dict["NodeOutput"] as! String
        }
        if dict.keys.contains("NodeType") && dict["NodeType"] != nil {
            self.nodeType = dict["NodeType"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("TimeVariables") && dict["TimeVariables"] != nil {
            self.timeVariables = dict["TimeVariables"] as! String
        }
    }
}

public class CreateTaskResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var nodeId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTaskFlowRequest : Tea.TeaModel {
    public var dagName: String?

    public var description_: String?

    public var scenarioId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagName != nil {
            map["DagName"] = self.dagName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagName") && dict["DagName"] != nil {
            self.dagName = dict["DagName"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ScenarioId") && dict["ScenarioId"] != nil {
            self.scenarioId = dict["ScenarioId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class CreateTaskFlowResponseBody : Tea.TeaModel {
    public var dagId: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateTaskFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTaskFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateTaskFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUploadFileJobRequest : Tea.TeaModel {
    public var fileName: String?

    public var fileSource: String?

    public var tid: Int64?

    public var uploadURL: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileSource != nil {
            map["FileSource"] = self.fileSource!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.uploadURL != nil {
            map["UploadURL"] = self.uploadURL!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileSource") && dict["FileSource"] != nil {
            self.fileSource = dict["FileSource"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UploadURL") && dict["UploadURL"] != nil {
            self.uploadURL = dict["UploadURL"] as! String
        }
    }
}

public class CreateUploadFileJobResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var jobKey: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.jobKey != nil {
            map["JobKey"] = self.jobKey!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("JobKey") && dict["JobKey"] != nil {
            self.jobKey = dict["JobKey"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateUploadFileJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUploadFileJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateUploadFileJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUploadOSSFileJobRequest : Tea.TeaModel {
    public class UploadTarget : Tea.TeaModel {
        public var bucketName: String?

        public var endpoint: String?

        public var objectName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucketName != nil {
                map["BucketName"] = self.bucketName!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.objectName != nil {
                map["ObjectName"] = self.objectName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BucketName") && dict["BucketName"] != nil {
                self.bucketName = dict["BucketName"] as! String
            }
            if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("ObjectName") && dict["ObjectName"] != nil {
                self.objectName = dict["ObjectName"] as! String
            }
        }
    }
    public var fileName: String?

    public var fileSource: String?

    public var tid: Int64?

    public var uploadTarget: CreateUploadOSSFileJobRequest.UploadTarget?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.uploadTarget?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileSource != nil {
            map["FileSource"] = self.fileSource!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.uploadTarget != nil {
            map["UploadTarget"] = self.uploadTarget?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileSource") && dict["FileSource"] != nil {
            self.fileSource = dict["FileSource"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UploadTarget") && dict["UploadTarget"] != nil {
            var model = CreateUploadOSSFileJobRequest.UploadTarget()
            model.fromMap(dict["UploadTarget"] as! [String: Any])
            self.uploadTarget = model
        }
    }
}

public class CreateUploadOSSFileJobShrinkRequest : Tea.TeaModel {
    public var fileName: String?

    public var fileSource: String?

    public var tid: Int64?

    public var uploadTargetShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileSource != nil {
            map["FileSource"] = self.fileSource!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.uploadTargetShrink != nil {
            map["UploadTarget"] = self.uploadTargetShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileSource") && dict["FileSource"] != nil {
            self.fileSource = dict["FileSource"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UploadTarget") && dict["UploadTarget"] != nil {
            self.uploadTargetShrink = dict["UploadTarget"] as! String
        }
    }
}

public class CreateUploadOSSFileJobResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var jobKey: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.jobKey != nil {
            map["JobKey"] = self.jobKey!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("JobKey") && dict["JobKey"] != nil {
            self.jobKey = dict["JobKey"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateUploadOSSFileJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUploadOSSFileJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateUploadOSSFileJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteInstanceRequest : Tea.TeaModel {
    public var host: String?

    public var port: Int32?

    public var sid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.sid != nil {
            map["Sid"] = self.sid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Host") && dict["Host"] != nil {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("Sid") && dict["Sid"] != nil {
            self.sid = dict["Sid"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteInstanceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLakeHouseSpaceRequest : Tea.TeaModel {
    public var spaceId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
            self.spaceId = dict["SpaceId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteLakeHouseSpaceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteLakeHouseSpaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLakeHouseSpaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteLakeHouseSpaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLhMembersRequest : Tea.TeaModel {
    public var memberIds: [Int32]?

    public var objectId: Int64?

    public var objectType: Int32?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.memberIds != nil {
            map["MemberIds"] = self.memberIds!
        }
        if self.objectId != nil {
            map["ObjectId"] = self.objectId!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MemberIds") && dict["MemberIds"] != nil {
            self.memberIds = dict["MemberIds"] as! [Int32]
        }
        if dict.keys.contains("ObjectId") && dict["ObjectId"] != nil {
            self.objectId = dict["ObjectId"] as! Int64
        }
        if dict.keys.contains("ObjectType") && dict["ObjectType"] != nil {
            self.objectType = dict["ObjectType"] as! Int32
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteLhMembersShrinkRequest : Tea.TeaModel {
    public var memberIdsShrink: String?

    public var objectId: Int64?

    public var objectType: Int32?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.memberIdsShrink != nil {
            map["MemberIds"] = self.memberIdsShrink!
        }
        if self.objectId != nil {
            map["ObjectId"] = self.objectId!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MemberIds") && dict["MemberIds"] != nil {
            self.memberIdsShrink = dict["MemberIds"] as! String
        }
        if dict.keys.contains("ObjectId") && dict["ObjectId"] != nil {
            self.objectId = dict["ObjectId"] as! Int64
        }
        if dict.keys.contains("ObjectType") && dict["ObjectType"] != nil {
            self.objectType = dict["ObjectType"] as! Int32
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteLhMembersResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteLhMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLhMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteLhMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLogicDatabaseRequest : Tea.TeaModel {
    public var logicDbId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logicDbId != nil {
            map["LogicDbId"] = self.logicDbId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogicDbId") && dict["LogicDbId"] != nil {
            self.logicDbId = dict["LogicDbId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteLogicDatabaseResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteLogicDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLogicDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteLogicDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLogicTableRouteConfigRequest : Tea.TeaModel {
    public var routeKey: String?

    public var tableId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.routeKey != nil {
            map["RouteKey"] = self.routeKey!
        }
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RouteKey") && dict["RouteKey"] != nil {
            self.routeKey = dict["RouteKey"] as! String
        }
        if dict.keys.contains("TableId") && dict["TableId"] != nil {
            self.tableId = dict["TableId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteLogicTableRouteConfigResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteLogicTableRouteConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLogicTableRouteConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteLogicTableRouteConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProxyRequest : Tea.TeaModel {
    public var proxyId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.proxyId != nil {
            map["ProxyId"] = self.proxyId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProxyId") && dict["ProxyId"] != nil {
            self.proxyId = dict["ProxyId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteProxyResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteProxyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProxyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteProxyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProxyAccessRequest : Tea.TeaModel {
    public var proxyAccessId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.proxyAccessId != nil {
            map["ProxyAccessId"] = self.proxyAccessId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProxyAccessId") && dict["ProxyAccessId"] != nil {
            self.proxyAccessId = dict["ProxyAccessId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteProxyAccessResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteProxyAccessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProxyAccessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteProxyAccessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScenarioRequest : Tea.TeaModel {
    public var scenarioId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ScenarioId") && dict["ScenarioId"] != nil {
            self.scenarioId = dict["ScenarioId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteScenarioResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteScenarioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScenarioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteScenarioResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTaskRequest : Tea.TeaModel {
    public var nodeId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteTaskResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTaskFlowRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteTaskFlowResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteTaskFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTaskFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteTaskFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTaskFlowEdgesByConditionRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var id: Int64?

    public var nodeEnd: Int64?

    public var nodeFrom: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.nodeEnd != nil {
            map["NodeEnd"] = self.nodeEnd!
        }
        if self.nodeFrom != nil {
            map["NodeFrom"] = self.nodeFrom!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("NodeEnd") && dict["NodeEnd"] != nil {
            self.nodeEnd = dict["NodeEnd"] as! Int64
        }
        if dict.keys.contains("NodeFrom") && dict["NodeFrom"] != nil {
            self.nodeFrom = dict["NodeFrom"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DeleteTaskFlowEdgesByConditionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteTaskFlowEdgesByConditionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTaskFlowEdgesByConditionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteTaskFlowEdgesByConditionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteUserRequest : Tea.TeaModel {
    public var tid: Int64?

    public var uid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("Uid") && dict["Uid"] != nil {
            self.uid = dict["Uid"] as! String
        }
    }
}

public class DeleteUserResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableUserRequest : Tea.TeaModel {
    public var tid: Int64?

    public var uid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("Uid") && dict["Uid"] != nil {
            self.uid = dict["Uid"] as! String
        }
    }
}

public class DisableUserResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DisableUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DisableUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DownloadDataTrackResultRequest : Tea.TeaModel {
    public class ColumnFilter : Tea.TeaModel {
        public var betweenEnd: String?

        public var betweenStart: String?

        public var columnName: String?

        public var inList: [String]?

        public var operator_: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.betweenEnd != nil {
                map["BetweenEnd"] = self.betweenEnd!
            }
            if self.betweenStart != nil {
                map["BetweenStart"] = self.betweenStart!
            }
            if self.columnName != nil {
                map["ColumnName"] = self.columnName!
            }
            if self.inList != nil {
                map["InList"] = self.inList!
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BetweenEnd") && dict["BetweenEnd"] != nil {
                self.betweenEnd = dict["BetweenEnd"] as! String
            }
            if dict.keys.contains("BetweenStart") && dict["BetweenStart"] != nil {
                self.betweenStart = dict["BetweenStart"] as! String
            }
            if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
                self.columnName = dict["ColumnName"] as! String
            }
            if dict.keys.contains("InList") && dict["InList"] != nil {
                self.inList = dict["InList"] as! [String]
            }
            if dict.keys.contains("Operator") && dict["Operator"] != nil {
                self.operator_ = dict["Operator"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var columnFilter: DownloadDataTrackResultRequest.ColumnFilter?

    public var eventIdList: [Int64]?

    public var filterEndTime: String?

    public var filterStartTime: String?

    public var filterTableList: [String]?

    public var filterTypeList: [String]?

    public var orderId: Int64?

    public var rollbackSQLType: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.columnFilter?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnFilter != nil {
            map["ColumnFilter"] = self.columnFilter?.toMap()
        }
        if self.eventIdList != nil {
            map["EventIdList"] = self.eventIdList!
        }
        if self.filterEndTime != nil {
            map["FilterEndTime"] = self.filterEndTime!
        }
        if self.filterStartTime != nil {
            map["FilterStartTime"] = self.filterStartTime!
        }
        if self.filterTableList != nil {
            map["FilterTableList"] = self.filterTableList!
        }
        if self.filterTypeList != nil {
            map["FilterTypeList"] = self.filterTypeList!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.rollbackSQLType != nil {
            map["RollbackSQLType"] = self.rollbackSQLType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnFilter") && dict["ColumnFilter"] != nil {
            var model = DownloadDataTrackResultRequest.ColumnFilter()
            model.fromMap(dict["ColumnFilter"] as! [String: Any])
            self.columnFilter = model
        }
        if dict.keys.contains("EventIdList") && dict["EventIdList"] != nil {
            self.eventIdList = dict["EventIdList"] as! [Int64]
        }
        if dict.keys.contains("FilterEndTime") && dict["FilterEndTime"] != nil {
            self.filterEndTime = dict["FilterEndTime"] as! String
        }
        if dict.keys.contains("FilterStartTime") && dict["FilterStartTime"] != nil {
            self.filterStartTime = dict["FilterStartTime"] as! String
        }
        if dict.keys.contains("FilterTableList") && dict["FilterTableList"] != nil {
            self.filterTableList = dict["FilterTableList"] as! [String]
        }
        if dict.keys.contains("FilterTypeList") && dict["FilterTypeList"] != nil {
            self.filterTypeList = dict["FilterTypeList"] as! [String]
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RollbackSQLType") && dict["RollbackSQLType"] != nil {
            self.rollbackSQLType = dict["RollbackSQLType"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DownloadDataTrackResultShrinkRequest : Tea.TeaModel {
    public var columnFilterShrink: String?

    public var eventIdListShrink: String?

    public var filterEndTime: String?

    public var filterStartTime: String?

    public var filterTableListShrink: String?

    public var filterTypeListShrink: String?

    public var orderId: Int64?

    public var rollbackSQLType: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnFilterShrink != nil {
            map["ColumnFilter"] = self.columnFilterShrink!
        }
        if self.eventIdListShrink != nil {
            map["EventIdList"] = self.eventIdListShrink!
        }
        if self.filterEndTime != nil {
            map["FilterEndTime"] = self.filterEndTime!
        }
        if self.filterStartTime != nil {
            map["FilterStartTime"] = self.filterStartTime!
        }
        if self.filterTableListShrink != nil {
            map["FilterTableList"] = self.filterTableListShrink!
        }
        if self.filterTypeListShrink != nil {
            map["FilterTypeList"] = self.filterTypeListShrink!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.rollbackSQLType != nil {
            map["RollbackSQLType"] = self.rollbackSQLType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnFilter") && dict["ColumnFilter"] != nil {
            self.columnFilterShrink = dict["ColumnFilter"] as! String
        }
        if dict.keys.contains("EventIdList") && dict["EventIdList"] != nil {
            self.eventIdListShrink = dict["EventIdList"] as! String
        }
        if dict.keys.contains("FilterEndTime") && dict["FilterEndTime"] != nil {
            self.filterEndTime = dict["FilterEndTime"] as! String
        }
        if dict.keys.contains("FilterStartTime") && dict["FilterStartTime"] != nil {
            self.filterStartTime = dict["FilterStartTime"] as! String
        }
        if dict.keys.contains("FilterTableList") && dict["FilterTableList"] != nil {
            self.filterTableListShrink = dict["FilterTableList"] as! String
        }
        if dict.keys.contains("FilterTypeList") && dict["FilterTypeList"] != nil {
            self.filterTypeListShrink = dict["FilterTypeList"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RollbackSQLType") && dict["RollbackSQLType"] != nil {
            self.rollbackSQLType = dict["RollbackSQLType"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class DownloadDataTrackResultResponseBody : Tea.TeaModel {
    public var downloadKeyId: String?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadKeyId != nil {
            map["DownloadKeyId"] = self.downloadKeyId!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadKeyId") && dict["DownloadKeyId"] != nil {
            self.downloadKeyId = dict["DownloadKeyId"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DownloadDataTrackResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadDataTrackResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DownloadDataTrackResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EditLogicDatabaseRequest : Tea.TeaModel {
    public var alias: String?

    public var databaseIds: [Int64]?

    public var logicDbId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alias != nil {
            map["Alias"] = self.alias!
        }
        if self.databaseIds != nil {
            map["DatabaseIds"] = self.databaseIds!
        }
        if self.logicDbId != nil {
            map["LogicDbId"] = self.logicDbId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Alias") && dict["Alias"] != nil {
            self.alias = dict["Alias"] as! String
        }
        if dict.keys.contains("DatabaseIds") && dict["DatabaseIds"] != nil {
            self.databaseIds = dict["DatabaseIds"] as! [Int64]
        }
        if dict.keys.contains("LogicDbId") && dict["LogicDbId"] != nil {
            self.logicDbId = dict["LogicDbId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class EditLogicDatabaseShrinkRequest : Tea.TeaModel {
    public var alias: String?

    public var databaseIdsShrink: String?

    public var logicDbId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alias != nil {
            map["Alias"] = self.alias!
        }
        if self.databaseIdsShrink != nil {
            map["DatabaseIds"] = self.databaseIdsShrink!
        }
        if self.logicDbId != nil {
            map["LogicDbId"] = self.logicDbId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Alias") && dict["Alias"] != nil {
            self.alias = dict["Alias"] as! String
        }
        if dict.keys.contains("DatabaseIds") && dict["DatabaseIds"] != nil {
            self.databaseIdsShrink = dict["DatabaseIds"] as! String
        }
        if dict.keys.contains("LogicDbId") && dict["LogicDbId"] != nil {
            self.logicDbId = dict["LogicDbId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class EditLogicDatabaseResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EditLogicDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EditLogicDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EditLogicDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableUserRequest : Tea.TeaModel {
    public var tid: Int64?

    public var uid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("Uid") && dict["Uid"] != nil {
            self.uid = dict["Uid"] as! String
        }
    }
}

public class EnableUserResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EnableUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecuteDataCorrectRequest : Tea.TeaModel {
    public var actionDetail: [String: Any]?

    public var orderId: Int64?

    public var tid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionDetail != nil {
            map["ActionDetail"] = self.actionDetail!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionDetail") && dict["ActionDetail"] != nil {
            self.actionDetail = dict["ActionDetail"] as! [String: Any]
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! String
        }
    }
}

public class ExecuteDataCorrectShrinkRequest : Tea.TeaModel {
    public var actionDetailShrink: String?

    public var orderId: Int64?

    public var tid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionDetailShrink != nil {
            map["ActionDetail"] = self.actionDetailShrink!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionDetail") && dict["ActionDetail"] != nil {
            self.actionDetailShrink = dict["ActionDetail"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! String
        }
    }
}

public class ExecuteDataCorrectResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ExecuteDataCorrectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteDataCorrectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExecuteDataCorrectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecuteDataExportRequest : Tea.TeaModel {
    public var actionDetail: [String: Any]?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionDetail != nil {
            map["ActionDetail"] = self.actionDetail!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionDetail") && dict["ActionDetail"] != nil {
            self.actionDetail = dict["ActionDetail"] as! [String: Any]
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ExecuteDataExportShrinkRequest : Tea.TeaModel {
    public var actionDetailShrink: String?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionDetailShrink != nil {
            map["ActionDetail"] = self.actionDetailShrink!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionDetail") && dict["ActionDetail"] != nil {
            self.actionDetailShrink = dict["ActionDetail"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ExecuteDataExportResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ExecuteDataExportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteDataExportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExecuteDataExportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecuteScriptRequest : Tea.TeaModel {
    public var dbId: Int32?

    public var logic: Bool?

    public var script: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.script != nil {
            map["Script"] = self.script!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") && dict["DbId"] != nil {
            self.dbId = dict["DbId"] as! Int32
        }
        if dict.keys.contains("Logic") && dict["Logic"] != nil {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("Script") && dict["Script"] != nil {
            self.script = dict["Script"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ExecuteScriptResponseBody : Tea.TeaModel {
    public class Results : Tea.TeaModel {
        public var columnNames: [String]?

        public var message: String?

        public var rowCount: Int64?

        public var rows: [[String: Any]]?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columnNames != nil {
                map["ColumnNames"] = self.columnNames!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.rowCount != nil {
                map["RowCount"] = self.rowCount!
            }
            if self.rows != nil {
                map["Rows"] = self.rows!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ColumnNames") && dict["ColumnNames"] != nil {
                self.columnNames = dict["ColumnNames"] as! [String]
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("RowCount") && dict["RowCount"] != nil {
                self.rowCount = dict["RowCount"] as! Int64
            }
            if dict.keys.contains("Rows") && dict["Rows"] != nil {
                self.rows = dict["Rows"] as! [[String: Any]]
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var results: [ExecuteScriptResponseBody.Results]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.results != nil {
            var tmp : [Any] = []
            for k in self.results! {
                tmp.append(k.toMap())
            }
            map["Results"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Results") && dict["Results"] != nil {
            var tmp : [ExecuteScriptResponseBody.Results] = []
            for v in dict["Results"] as! [Any] {
                var model = ExecuteScriptResponseBody.Results()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.results = tmp
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ExecuteScriptResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteScriptResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExecuteScriptResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecuteStructSyncRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ExecuteStructSyncResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ExecuteStructSyncResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteStructSyncResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExecuteStructSyncResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetApprovalDetailRequest : Tea.TeaModel {
    public var tid: Int64?

    public var workflowInstanceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.workflowInstanceId != nil {
            map["WorkflowInstanceId"] = self.workflowInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("WorkflowInstanceId") && dict["WorkflowInstanceId"] != nil {
            self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
        }
    }
}

public class GetApprovalDetailResponseBody : Tea.TeaModel {
    public class ApprovalDetail : Tea.TeaModel {
        public class CurrentHandlers : Tea.TeaModel {
            public class CurrentHandler : Tea.TeaModel {
                public var id: Int64?

                public var nickName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.nickName != nil {
                        map["NickName"] = self.nickName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("NickName") && dict["NickName"] != nil {
                        self.nickName = dict["NickName"] as! String
                    }
                }
            }
            public var currentHandler: [GetApprovalDetailResponseBody.ApprovalDetail.CurrentHandlers.CurrentHandler]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currentHandler != nil {
                    var tmp : [Any] = []
                    for k in self.currentHandler! {
                        tmp.append(k.toMap())
                    }
                    map["CurrentHandler"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CurrentHandler") && dict["CurrentHandler"] != nil {
                    var tmp : [GetApprovalDetailResponseBody.ApprovalDetail.CurrentHandlers.CurrentHandler] = []
                    for v in dict["CurrentHandler"] as! [Any] {
                        var model = GetApprovalDetailResponseBody.ApprovalDetail.CurrentHandlers.CurrentHandler()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.currentHandler = tmp
                }
            }
        }
        public class ReasonList : Tea.TeaModel {
            public var reasons: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.reasons != nil {
                    map["Reasons"] = self.reasons!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Reasons") && dict["Reasons"] != nil {
                    self.reasons = dict["Reasons"] as! [String]
                }
            }
        }
        public class WorkflowNodes : Tea.TeaModel {
            public class WorkflowNode : Tea.TeaModel {
                public class AuditUserIdList : Tea.TeaModel {
                    public var auditUserIds: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.auditUserIds != nil {
                            map["AuditUserIds"] = self.auditUserIds!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AuditUserIds") && dict["AuditUserIds"] != nil {
                            self.auditUserIds = dict["AuditUserIds"] as! [String]
                        }
                    }
                }
                public var auditUserIdList: GetApprovalDetailResponseBody.ApprovalDetail.WorkflowNodes.WorkflowNode.AuditUserIdList?

                public var nodeName: String?

                public var operateComment: String?

                public var operateTime: String?

                public var operatorId: Int64?

                public var workflowInsCode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.auditUserIdList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.auditUserIdList != nil {
                        map["AuditUserIdList"] = self.auditUserIdList?.toMap()
                    }
                    if self.nodeName != nil {
                        map["NodeName"] = self.nodeName!
                    }
                    if self.operateComment != nil {
                        map["OperateComment"] = self.operateComment!
                    }
                    if self.operateTime != nil {
                        map["OperateTime"] = self.operateTime!
                    }
                    if self.operatorId != nil {
                        map["OperatorId"] = self.operatorId!
                    }
                    if self.workflowInsCode != nil {
                        map["WorkflowInsCode"] = self.workflowInsCode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AuditUserIdList") && dict["AuditUserIdList"] != nil {
                        var model = GetApprovalDetailResponseBody.ApprovalDetail.WorkflowNodes.WorkflowNode.AuditUserIdList()
                        model.fromMap(dict["AuditUserIdList"] as! [String: Any])
                        self.auditUserIdList = model
                    }
                    if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                        self.nodeName = dict["NodeName"] as! String
                    }
                    if dict.keys.contains("OperateComment") && dict["OperateComment"] != nil {
                        self.operateComment = dict["OperateComment"] as! String
                    }
                    if dict.keys.contains("OperateTime") && dict["OperateTime"] != nil {
                        self.operateTime = dict["OperateTime"] as! String
                    }
                    if dict.keys.contains("OperatorId") && dict["OperatorId"] != nil {
                        self.operatorId = dict["OperatorId"] as! Int64
                    }
                    if dict.keys.contains("WorkflowInsCode") && dict["WorkflowInsCode"] != nil {
                        self.workflowInsCode = dict["WorkflowInsCode"] as! String
                    }
                }
            }
            public var workflowNode: [GetApprovalDetailResponseBody.ApprovalDetail.WorkflowNodes.WorkflowNode]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.workflowNode != nil {
                    var tmp : [Any] = []
                    for k in self.workflowNode! {
                        tmp.append(k.toMap())
                    }
                    map["WorkflowNode"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("WorkflowNode") && dict["WorkflowNode"] != nil {
                    var tmp : [GetApprovalDetailResponseBody.ApprovalDetail.WorkflowNodes.WorkflowNode] = []
                    for v in dict["WorkflowNode"] as! [Any] {
                        var model = GetApprovalDetailResponseBody.ApprovalDetail.WorkflowNodes.WorkflowNode()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.workflowNode = tmp
                }
            }
        }
        public var auditId: Int64?

        public var createTime: String?

        public var currentHandlers: GetApprovalDetailResponseBody.ApprovalDetail.CurrentHandlers?

        public var description_: String?

        public var orderId: Int64?

        public var orderType: String?

        public var reasonList: GetApprovalDetailResponseBody.ApprovalDetail.ReasonList?

        public var templateId: Int64?

        public var title: String?

        public var workflowInsCode: String?

        public var workflowNodes: GetApprovalDetailResponseBody.ApprovalDetail.WorkflowNodes?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.currentHandlers?.validate()
            try self.reasonList?.validate()
            try self.workflowNodes?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.auditId != nil {
                map["AuditId"] = self.auditId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.currentHandlers != nil {
                map["CurrentHandlers"] = self.currentHandlers?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            if self.orderType != nil {
                map["OrderType"] = self.orderType!
            }
            if self.reasonList != nil {
                map["ReasonList"] = self.reasonList?.toMap()
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.workflowInsCode != nil {
                map["WorkflowInsCode"] = self.workflowInsCode!
            }
            if self.workflowNodes != nil {
                map["WorkflowNodes"] = self.workflowNodes?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuditId") && dict["AuditId"] != nil {
                self.auditId = dict["AuditId"] as! Int64
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CurrentHandlers") && dict["CurrentHandlers"] != nil {
                var model = GetApprovalDetailResponseBody.ApprovalDetail.CurrentHandlers()
                model.fromMap(dict["CurrentHandlers"] as! [String: Any])
                self.currentHandlers = model
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
                self.orderId = dict["OrderId"] as! Int64
            }
            if dict.keys.contains("OrderType") && dict["OrderType"] != nil {
                self.orderType = dict["OrderType"] as! String
            }
            if dict.keys.contains("ReasonList") && dict["ReasonList"] != nil {
                var model = GetApprovalDetailResponseBody.ApprovalDetail.ReasonList()
                model.fromMap(dict["ReasonList"] as! [String: Any])
                self.reasonList = model
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! Int64
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("WorkflowInsCode") && dict["WorkflowInsCode"] != nil {
                self.workflowInsCode = dict["WorkflowInsCode"] as! String
            }
            if dict.keys.contains("WorkflowNodes") && dict["WorkflowNodes"] != nil {
                var model = GetApprovalDetailResponseBody.ApprovalDetail.WorkflowNodes()
                model.fromMap(dict["WorkflowNodes"] as! [String: Any])
                self.workflowNodes = model
            }
        }
    }
    public var approvalDetail: GetApprovalDetailResponseBody.ApprovalDetail?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.approvalDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.approvalDetail != nil {
            map["ApprovalDetail"] = self.approvalDetail?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApprovalDetail") && dict["ApprovalDetail"] != nil {
            var model = GetApprovalDetailResponseBody.ApprovalDetail()
            model.fromMap(dict["ApprovalDetail"] as! [String: Any])
            self.approvalDetail = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetApprovalDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApprovalDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetApprovalDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAuthorityTemplateRequest : Tea.TeaModel {
    public var templateId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetAuthorityTemplateResponseBody : Tea.TeaModel {
    public class AuthorityTemplateView : Tea.TeaModel {
        public class AuthorityTemplateItemList : Tea.TeaModel {
            public class AuthorityTemplateItem : Tea.TeaModel {
                public var attribute: String?

                public var dbId: Int64?

                public var instanceId: Int64?

                public var itemId: Int64?

                public var modifierId: Int64?

                public var resourceType: String?

                public var tableName: String?

                public var templateId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.attribute != nil {
                        map["Attribute"] = self.attribute!
                    }
                    if self.dbId != nil {
                        map["DbId"] = self.dbId!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.itemId != nil {
                        map["ItemId"] = self.itemId!
                    }
                    if self.modifierId != nil {
                        map["ModifierId"] = self.modifierId!
                    }
                    if self.resourceType != nil {
                        map["ResourceType"] = self.resourceType!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Attribute") && dict["Attribute"] != nil {
                        self.attribute = dict["Attribute"] as! String
                    }
                    if dict.keys.contains("DbId") && dict["DbId"] != nil {
                        self.dbId = dict["DbId"] as! Int64
                    }
                    if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                        self.instanceId = dict["InstanceId"] as! Int64
                    }
                    if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                        self.itemId = dict["ItemId"] as! Int64
                    }
                    if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                        self.modifierId = dict["ModifierId"] as! Int64
                    }
                    if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                        self.resourceType = dict["ResourceType"] as! String
                    }
                    if dict.keys.contains("TableName") && dict["TableName"] != nil {
                        self.tableName = dict["TableName"] as! String
                    }
                    if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                        self.templateId = dict["TemplateId"] as! Int64
                    }
                }
            }
            public var authorityTemplateItem: [GetAuthorityTemplateResponseBody.AuthorityTemplateView.AuthorityTemplateItemList.AuthorityTemplateItem]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorityTemplateItem != nil {
                    var tmp : [Any] = []
                    for k in self.authorityTemplateItem! {
                        tmp.append(k.toMap())
                    }
                    map["AuthorityTemplateItem"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuthorityTemplateItem") && dict["AuthorityTemplateItem"] != nil {
                    var tmp : [GetAuthorityTemplateResponseBody.AuthorityTemplateView.AuthorityTemplateItemList.AuthorityTemplateItem] = []
                    for v in dict["AuthorityTemplateItem"] as! [Any] {
                        var model = GetAuthorityTemplateResponseBody.AuthorityTemplateView.AuthorityTemplateItemList.AuthorityTemplateItem()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.authorityTemplateItem = tmp
                }
            }
        }
        public var authorityTemplateItemList: GetAuthorityTemplateResponseBody.AuthorityTemplateView.AuthorityTemplateItemList?

        public var createTime: String?

        public var creatorId: Int64?

        public var description_: String?

        public var name: String?

        public var templateId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.authorityTemplateItemList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorityTemplateItemList != nil {
                map["AuthorityTemplateItemList"] = self.authorityTemplateItemList?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorityTemplateItemList") && dict["AuthorityTemplateItemList"] != nil {
                var model = GetAuthorityTemplateResponseBody.AuthorityTemplateView.AuthorityTemplateItemList()
                model.fromMap(dict["AuthorityTemplateItemList"] as! [String: Any])
                self.authorityTemplateItemList = model
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! Int64
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! Int64
            }
        }
    }
    public var authorityTemplateView: GetAuthorityTemplateResponseBody.AuthorityTemplateView?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authorityTemplateView?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorityTemplateView != nil {
            map["AuthorityTemplateView"] = self.authorityTemplateView?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorityTemplateView") && dict["AuthorityTemplateView"] != nil {
            var model = GetAuthorityTemplateResponseBody.AuthorityTemplateView()
            model.fromMap(dict["AuthorityTemplateView"] as! [String: Any])
            self.authorityTemplateView = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAuthorityTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAuthorityTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAuthorityTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAuthorityTemplateItemRequest : Tea.TeaModel {
    public var templateId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetAuthorityTemplateItemResponseBody : Tea.TeaModel {
    public class AuthorityTemplateItemList : Tea.TeaModel {
        public class AuthorityTemplateItem : Tea.TeaModel {
            public var attribute: String?

            public var dbId: Int64?

            public var instanceId: Int64?

            public var itemId: Int64?

            public var modifierId: Int64?

            public var resourceType: String?

            public var tableName: String?

            public var templateId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attribute != nil {
                    map["Attribute"] = self.attribute!
                }
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.modifierId != nil {
                    map["ModifierId"] = self.modifierId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Attribute") && dict["Attribute"] != nil {
                    self.attribute = dict["Attribute"] as! String
                }
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                    self.modifierId = dict["ModifierId"] as! Int64
                }
                if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("TableName") && dict["TableName"] != nil {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                    self.templateId = dict["TemplateId"] as! Int64
                }
            }
        }
        public var authorityTemplateItem: [GetAuthorityTemplateItemResponseBody.AuthorityTemplateItemList.AuthorityTemplateItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorityTemplateItem != nil {
                var tmp : [Any] = []
                for k in self.authorityTemplateItem! {
                    tmp.append(k.toMap())
                }
                map["AuthorityTemplateItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorityTemplateItem") && dict["AuthorityTemplateItem"] != nil {
                var tmp : [GetAuthorityTemplateItemResponseBody.AuthorityTemplateItemList.AuthorityTemplateItem] = []
                for v in dict["AuthorityTemplateItem"] as! [Any] {
                    var model = GetAuthorityTemplateItemResponseBody.AuthorityTemplateItemList.AuthorityTemplateItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.authorityTemplateItem = tmp
            }
        }
    }
    public var authorityTemplateItemList: GetAuthorityTemplateItemResponseBody.AuthorityTemplateItemList?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authorityTemplateItemList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorityTemplateItemList != nil {
            map["AuthorityTemplateItemList"] = self.authorityTemplateItemList?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorityTemplateItemList") && dict["AuthorityTemplateItemList"] != nil {
            var model = GetAuthorityTemplateItemResponseBody.AuthorityTemplateItemList()
            model.fromMap(dict["AuthorityTemplateItemList"] as! [String: Any])
            self.authorityTemplateItemList = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAuthorityTemplateItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAuthorityTemplateItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAuthorityTemplateItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDBTaskSQLJobLogRequest : Tea.TeaModel {
    public var jobId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDBTaskSQLJobLogResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var log: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.log != nil {
            map["Log"] = self.log!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("Log") && dict["Log"] != nil {
            self.log = dict["Log"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDBTaskSQLJobLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDBTaskSQLJobLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDBTaskSQLJobLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDBTopologyRequest : Tea.TeaModel {
    public var logicDbId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logicDbId != nil {
            map["LogicDbId"] = self.logicDbId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogicDbId") && dict["LogicDbId"] != nil {
            self.logicDbId = dict["LogicDbId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDBTopologyResponseBody : Tea.TeaModel {
    public class DBTopology : Tea.TeaModel {
        public class DBTopologyInfoList : Tea.TeaModel {
            public var catalogName: String?

            public var dbId: Int64?

            public var dbType: String?

            public var envType: String?

            public var instanceId: Int64?

            public var instanceResourceId: String?

            public var instanceSource: String?

            public var regionId: String?

            public var schemaName: String?

            public var searchName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.catalogName != nil {
                    map["CatalogName"] = self.catalogName!
                }
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceResourceId != nil {
                    map["InstanceResourceId"] = self.instanceResourceId!
                }
                if self.instanceSource != nil {
                    map["InstanceSource"] = self.instanceSource!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CatalogName") && dict["CatalogName"] != nil {
                    self.catalogName = dict["CatalogName"] as! String
                }
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("DbType") && dict["DbType"] != nil {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("InstanceResourceId") && dict["InstanceResourceId"] != nil {
                    self.instanceResourceId = dict["InstanceResourceId"] as! String
                }
                if dict.keys.contains("InstanceSource") && dict["InstanceSource"] != nil {
                    self.instanceSource = dict["InstanceSource"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                    self.searchName = dict["SearchName"] as! String
                }
            }
        }
        public var alias: String?

        public var DBTopologyInfoList: [GetDBTopologyResponseBody.DBTopology.DBTopologyInfoList]?

        public var dbType: String?

        public var envType: String?

        public var logicDbId: Int64?

        public var logicDbName: String?

        public var searchName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alias != nil {
                map["Alias"] = self.alias!
            }
            if self.DBTopologyInfoList != nil {
                var tmp : [Any] = []
                for k in self.DBTopologyInfoList! {
                    tmp.append(k.toMap())
                }
                map["DBTopologyInfoList"] = tmp
            }
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.logicDbId != nil {
                map["LogicDbId"] = self.logicDbId!
            }
            if self.logicDbName != nil {
                map["LogicDbName"] = self.logicDbName!
            }
            if self.searchName != nil {
                map["SearchName"] = self.searchName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alias") && dict["Alias"] != nil {
                self.alias = dict["Alias"] as! String
            }
            if dict.keys.contains("DBTopologyInfoList") && dict["DBTopologyInfoList"] != nil {
                var tmp : [GetDBTopologyResponseBody.DBTopology.DBTopologyInfoList] = []
                for v in dict["DBTopologyInfoList"] as! [Any] {
                    var model = GetDBTopologyResponseBody.DBTopology.DBTopologyInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.DBTopologyInfoList = tmp
            }
            if dict.keys.contains("DbType") && dict["DbType"] != nil {
                self.dbType = dict["DbType"] as! String
            }
            if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                self.envType = dict["EnvType"] as! String
            }
            if dict.keys.contains("LogicDbId") && dict["LogicDbId"] != nil {
                self.logicDbId = dict["LogicDbId"] as! Int64
            }
            if dict.keys.contains("LogicDbName") && dict["LogicDbName"] != nil {
                self.logicDbName = dict["LogicDbName"] as! String
            }
            if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                self.searchName = dict["SearchName"] as! String
            }
        }
    }
    public var DBTopology: GetDBTopologyResponseBody.DBTopology?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DBTopology?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBTopology != nil {
            map["DBTopology"] = self.DBTopology?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBTopology") && dict["DBTopology"] != nil {
            var model = GetDBTopologyResponseBody.DBTopology()
            model.fromMap(dict["DBTopology"] as! [String: Any])
            self.DBTopology = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDBTopologyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDBTopologyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDBTopologyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataArchiveCountRequest : Tea.TeaModel {
    public var orderResultType: String?

    public var pluginType: String?

    public var searchDateType: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderResultType != nil {
            map["OrderResultType"] = self.orderResultType!
        }
        if self.pluginType != nil {
            map["PluginType"] = self.pluginType!
        }
        if self.searchDateType != nil {
            map["SearchDateType"] = self.searchDateType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderResultType") && dict["OrderResultType"] != nil {
            self.orderResultType = dict["OrderResultType"] as! String
        }
        if dict.keys.contains("PluginType") && dict["PluginType"] != nil {
            self.pluginType = dict["PluginType"] as! String
        }
        if dict.keys.contains("SearchDateType") && dict["SearchDateType"] != nil {
            self.searchDateType = dict["SearchDateType"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataArchiveCountResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var failCount: Int64?

        public var processingCount: Int64?

        public var successCount: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failCount != nil {
                map["FailCount"] = self.failCount!
            }
            if self.processingCount != nil {
                map["ProcessingCount"] = self.processingCount!
            }
            if self.successCount != nil {
                map["SuccessCount"] = self.successCount!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailCount") && dict["FailCount"] != nil {
                self.failCount = dict["FailCount"] as! Int64
            }
            if dict.keys.contains("ProcessingCount") && dict["ProcessingCount"] != nil {
                self.processingCount = dict["ProcessingCount"] as! Int64
            }
            if dict.keys.contains("SuccessCount") && dict["SuccessCount"] != nil {
                self.successCount = dict["SuccessCount"] as! Int64
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var data: GetDataArchiveCountResponseBody.Data?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetDataArchiveCountResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataArchiveCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataArchiveCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDataArchiveCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataArchiveOrderDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataArchiveOrderDetailResponseBody : Tea.TeaModel {
    public class DataArchiveOrderDetail : Tea.TeaModel {
        public class PluginExtraData : Tea.TeaModel {
            public class DagInfo : Tea.TeaModel {
                public var creatorId: String?

                public var cronBeginDate: String?

                public var cronEndDate: String?

                public var cronTrigger: Bool?

                public var DWDevelop: Bool?

                public var dagName: String?

                public var dagOwnerId: String?

                public var deployId: Int64?

                public var description_: String?

                public var editDagId: Int64?

                public var gmtCreate: String?

                public var gmtModified: String?

                public var id: Int64?

                public var isPublic: Int64?

                public var legacy: Bool?

                public var system: Bool?

                public var tenantId: String?

                public var triggerOnce: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.creatorId != nil {
                        map["CreatorId"] = self.creatorId!
                    }
                    if self.cronBeginDate != nil {
                        map["CronBeginDate"] = self.cronBeginDate!
                    }
                    if self.cronEndDate != nil {
                        map["CronEndDate"] = self.cronEndDate!
                    }
                    if self.cronTrigger != nil {
                        map["CronTrigger"] = self.cronTrigger!
                    }
                    if self.DWDevelop != nil {
                        map["DWDevelop"] = self.DWDevelop!
                    }
                    if self.dagName != nil {
                        map["DagName"] = self.dagName!
                    }
                    if self.dagOwnerId != nil {
                        map["DagOwnerId"] = self.dagOwnerId!
                    }
                    if self.deployId != nil {
                        map["DeployId"] = self.deployId!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.editDagId != nil {
                        map["EditDagId"] = self.editDagId!
                    }
                    if self.gmtCreate != nil {
                        map["GmtCreate"] = self.gmtCreate!
                    }
                    if self.gmtModified != nil {
                        map["GmtModified"] = self.gmtModified!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.isPublic != nil {
                        map["IsPublic"] = self.isPublic!
                    }
                    if self.legacy != nil {
                        map["Legacy"] = self.legacy!
                    }
                    if self.system != nil {
                        map["System"] = self.system!
                    }
                    if self.tenantId != nil {
                        map["TenantId"] = self.tenantId!
                    }
                    if self.triggerOnce != nil {
                        map["TriggerOnce"] = self.triggerOnce!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                        self.creatorId = dict["CreatorId"] as! String
                    }
                    if dict.keys.contains("CronBeginDate") && dict["CronBeginDate"] != nil {
                        self.cronBeginDate = dict["CronBeginDate"] as! String
                    }
                    if dict.keys.contains("CronEndDate") && dict["CronEndDate"] != nil {
                        self.cronEndDate = dict["CronEndDate"] as! String
                    }
                    if dict.keys.contains("CronTrigger") && dict["CronTrigger"] != nil {
                        self.cronTrigger = dict["CronTrigger"] as! Bool
                    }
                    if dict.keys.contains("DWDevelop") && dict["DWDevelop"] != nil {
                        self.DWDevelop = dict["DWDevelop"] as! Bool
                    }
                    if dict.keys.contains("DagName") && dict["DagName"] != nil {
                        self.dagName = dict["DagName"] as! String
                    }
                    if dict.keys.contains("DagOwnerId") && dict["DagOwnerId"] != nil {
                        self.dagOwnerId = dict["DagOwnerId"] as! String
                    }
                    if dict.keys.contains("DeployId") && dict["DeployId"] != nil {
                        self.deployId = dict["DeployId"] as! Int64
                    }
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("EditDagId") && dict["EditDagId"] != nil {
                        self.editDagId = dict["EditDagId"] as! Int64
                    }
                    if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                        self.gmtCreate = dict["GmtCreate"] as! String
                    }
                    if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                        self.gmtModified = dict["GmtModified"] as! String
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("IsPublic") && dict["IsPublic"] != nil {
                        self.isPublic = dict["IsPublic"] as! Int64
                    }
                    if dict.keys.contains("Legacy") && dict["Legacy"] != nil {
                        self.legacy = dict["Legacy"] as! Bool
                    }
                    if dict.keys.contains("System") && dict["System"] != nil {
                        self.system = dict["System"] as! Bool
                    }
                    if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
                        self.tenantId = dict["TenantId"] as! String
                    }
                    if dict.keys.contains("TriggerOnce") && dict["TriggerOnce"] != nil {
                        self.triggerOnce = dict["TriggerOnce"] as! Bool
                    }
                }
            }
            public class DbBaseInfo : Tea.TeaModel {
                public class StandardGroup : Tea.TeaModel {
                    public var dbType: String?

                    public var description_: String?

                    public var freeOrStable: Bool?

                    public var gmtCreate: String?

                    public var gmtModified: String?

                    public var groupMode: String?

                    public var groupName: String?

                    public var id: Int64?

                    public var lastMenderId: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.dbType != nil {
                            map["DbType"] = self.dbType!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.freeOrStable != nil {
                            map["FreeOrStable"] = self.freeOrStable!
                        }
                        if self.gmtCreate != nil {
                            map["GmtCreate"] = self.gmtCreate!
                        }
                        if self.gmtModified != nil {
                            map["GmtModified"] = self.gmtModified!
                        }
                        if self.groupMode != nil {
                            map["GroupMode"] = self.groupMode!
                        }
                        if self.groupName != nil {
                            map["GroupName"] = self.groupName!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.lastMenderId != nil {
                            map["LastMenderId"] = self.lastMenderId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DbType") && dict["DbType"] != nil {
                            self.dbType = dict["DbType"] as! String
                        }
                        if dict.keys.contains("Description") && dict["Description"] != nil {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("FreeOrStable") && dict["FreeOrStable"] != nil {
                            self.freeOrStable = dict["FreeOrStable"] as! Bool
                        }
                        if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                            self.gmtCreate = dict["GmtCreate"] as! String
                        }
                        if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                            self.gmtModified = dict["GmtModified"] as! String
                        }
                        if dict.keys.contains("GroupMode") && dict["GroupMode"] != nil {
                            self.groupMode = dict["GroupMode"] as! String
                        }
                        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                            self.groupName = dict["GroupName"] as! String
                        }
                        if dict.keys.contains("Id") && dict["Id"] != nil {
                            self.id = dict["Id"] as! Int64
                        }
                        if dict.keys.contains("LastMenderId") && dict["LastMenderId"] != nil {
                            self.lastMenderId = dict["LastMenderId"] as! Int64
                        }
                    }
                }
                public var alias: String?

                public var alterTimeout: Int64?

                public var assetControl: Bool?

                public var catalogName: String?

                public var clusterNode: String?

                public var dbId: Int64?

                public var dbType: String?

                public var dbaId: Int64?

                public var dbaName: String?

                public var description_: String?

                public var encoding: String?

                public var envType: String?

                public var follow: Bool?

                public var host: String?

                public var idc: String?

                public var idcTitle: String?

                public var instanceId: Int64?

                public var instanceSource: String?

                public var lastSyncTime: String?

                public var level: String?

                public var logic: Bool?

                public var ownerIds: [Int64]?

                public var ownerNames: [String]?

                public var port: Int64?

                public var schemaName: String?

                public var searchName: String?

                public var standardGroup: GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.DbBaseInfo.StandardGroup?

                public var state: String?

                public var tableCount: Int64?

                public var tnsName: String?

                public var unitType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.standardGroup?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alias != nil {
                        map["Alias"] = self.alias!
                    }
                    if self.alterTimeout != nil {
                        map["AlterTimeout"] = self.alterTimeout!
                    }
                    if self.assetControl != nil {
                        map["AssetControl"] = self.assetControl!
                    }
                    if self.catalogName != nil {
                        map["CatalogName"] = self.catalogName!
                    }
                    if self.clusterNode != nil {
                        map["ClusterNode"] = self.clusterNode!
                    }
                    if self.dbId != nil {
                        map["DbId"] = self.dbId!
                    }
                    if self.dbType != nil {
                        map["DbType"] = self.dbType!
                    }
                    if self.dbaId != nil {
                        map["DbaId"] = self.dbaId!
                    }
                    if self.dbaName != nil {
                        map["DbaName"] = self.dbaName!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.encoding != nil {
                        map["Encoding"] = self.encoding!
                    }
                    if self.envType != nil {
                        map["EnvType"] = self.envType!
                    }
                    if self.follow != nil {
                        map["Follow"] = self.follow!
                    }
                    if self.host != nil {
                        map["Host"] = self.host!
                    }
                    if self.idc != nil {
                        map["Idc"] = self.idc!
                    }
                    if self.idcTitle != nil {
                        map["IdcTitle"] = self.idcTitle!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.instanceSource != nil {
                        map["InstanceSource"] = self.instanceSource!
                    }
                    if self.lastSyncTime != nil {
                        map["LastSyncTime"] = self.lastSyncTime!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.logic != nil {
                        map["Logic"] = self.logic!
                    }
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    if self.ownerNames != nil {
                        map["OwnerNames"] = self.ownerNames!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.schemaName != nil {
                        map["SchemaName"] = self.schemaName!
                    }
                    if self.searchName != nil {
                        map["SearchName"] = self.searchName!
                    }
                    if self.standardGroup != nil {
                        map["StandardGroup"] = self.standardGroup?.toMap()
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    if self.tableCount != nil {
                        map["TableCount"] = self.tableCount!
                    }
                    if self.tnsName != nil {
                        map["TnsName"] = self.tnsName!
                    }
                    if self.unitType != nil {
                        map["UnitType"] = self.unitType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Alias") && dict["Alias"] != nil {
                        self.alias = dict["Alias"] as! String
                    }
                    if dict.keys.contains("AlterTimeout") && dict["AlterTimeout"] != nil {
                        self.alterTimeout = dict["AlterTimeout"] as! Int64
                    }
                    if dict.keys.contains("AssetControl") && dict["AssetControl"] != nil {
                        self.assetControl = dict["AssetControl"] as! Bool
                    }
                    if dict.keys.contains("CatalogName") && dict["CatalogName"] != nil {
                        self.catalogName = dict["CatalogName"] as! String
                    }
                    if dict.keys.contains("ClusterNode") && dict["ClusterNode"] != nil {
                        self.clusterNode = dict["ClusterNode"] as! String
                    }
                    if dict.keys.contains("DbId") && dict["DbId"] != nil {
                        self.dbId = dict["DbId"] as! Int64
                    }
                    if dict.keys.contains("DbType") && dict["DbType"] != nil {
                        self.dbType = dict["DbType"] as! String
                    }
                    if dict.keys.contains("DbaId") && dict["DbaId"] != nil {
                        self.dbaId = dict["DbaId"] as! Int64
                    }
                    if dict.keys.contains("DbaName") && dict["DbaName"] != nil {
                        self.dbaName = dict["DbaName"] as! String
                    }
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Encoding") && dict["Encoding"] != nil {
                        self.encoding = dict["Encoding"] as! String
                    }
                    if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                        self.envType = dict["EnvType"] as! String
                    }
                    if dict.keys.contains("Follow") && dict["Follow"] != nil {
                        self.follow = dict["Follow"] as! Bool
                    }
                    if dict.keys.contains("Host") && dict["Host"] != nil {
                        self.host = dict["Host"] as! String
                    }
                    if dict.keys.contains("Idc") && dict["Idc"] != nil {
                        self.idc = dict["Idc"] as! String
                    }
                    if dict.keys.contains("IdcTitle") && dict["IdcTitle"] != nil {
                        self.idcTitle = dict["IdcTitle"] as! String
                    }
                    if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                        self.instanceId = dict["InstanceId"] as! Int64
                    }
                    if dict.keys.contains("InstanceSource") && dict["InstanceSource"] != nil {
                        self.instanceSource = dict["InstanceSource"] as! String
                    }
                    if dict.keys.contains("LastSyncTime") && dict["LastSyncTime"] != nil {
                        self.lastSyncTime = dict["LastSyncTime"] as! String
                    }
                    if dict.keys.contains("Level") && dict["Level"] != nil {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Logic") && dict["Logic"] != nil {
                        self.logic = dict["Logic"] as! Bool
                    }
                    if dict.keys.contains("OwnerIds") && dict["OwnerIds"] != nil {
                        self.ownerIds = dict["OwnerIds"] as! [Int64]
                    }
                    if dict.keys.contains("OwnerNames") && dict["OwnerNames"] != nil {
                        self.ownerNames = dict["OwnerNames"] as! [String]
                    }
                    if dict.keys.contains("Port") && dict["Port"] != nil {
                        self.port = dict["Port"] as! Int64
                    }
                    if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
                        self.schemaName = dict["SchemaName"] as! String
                    }
                    if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                        self.searchName = dict["SearchName"] as! String
                    }
                    if dict.keys.contains("StandardGroup") && dict["StandardGroup"] != nil {
                        var model = GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.DbBaseInfo.StandardGroup()
                        model.fromMap(dict["StandardGroup"] as! [String: Any])
                        self.standardGroup = model
                    }
                    if dict.keys.contains("State") && dict["State"] != nil {
                        self.state = dict["State"] as! String
                    }
                    if dict.keys.contains("TableCount") && dict["TableCount"] != nil {
                        self.tableCount = dict["TableCount"] as! Int64
                    }
                    if dict.keys.contains("TnsName") && dict["TnsName"] != nil {
                        self.tnsName = dict["TnsName"] as! String
                    }
                    if dict.keys.contains("UnitType") && dict["UnitType"] != nil {
                        self.unitType = dict["UnitType"] as! String
                    }
                }
            }
            public class Instances : Tea.TeaModel {
                public var businessTime: String?

                public var dagId: Int64?

                public var endTime: String?

                public var gmtCreate: String?

                public var gmtModified: String?

                public var historyDagId: Int64?

                public var id: Int64?

                public var lastRunningContext: String?

                public var msg: String?

                public var status: Int64?

                public var tenantId: String?

                public var triggerType: Int64?

                public var version: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.businessTime != nil {
                        map["BusinessTime"] = self.businessTime!
                    }
                    if self.dagId != nil {
                        map["DagId"] = self.dagId!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.gmtCreate != nil {
                        map["GmtCreate"] = self.gmtCreate!
                    }
                    if self.gmtModified != nil {
                        map["GmtModified"] = self.gmtModified!
                    }
                    if self.historyDagId != nil {
                        map["HistoryDagId"] = self.historyDagId!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.lastRunningContext != nil {
                        map["LastRunningContext"] = self.lastRunningContext!
                    }
                    if self.msg != nil {
                        map["Msg"] = self.msg!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.tenantId != nil {
                        map["TenantId"] = self.tenantId!
                    }
                    if self.triggerType != nil {
                        map["TriggerType"] = self.triggerType!
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BusinessTime") && dict["BusinessTime"] != nil {
                        self.businessTime = dict["BusinessTime"] as! String
                    }
                    if dict.keys.contains("DagId") && dict["DagId"] != nil {
                        self.dagId = dict["DagId"] as! Int64
                    }
                    if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                        self.endTime = dict["EndTime"] as! String
                    }
                    if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                        self.gmtCreate = dict["GmtCreate"] as! String
                    }
                    if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                        self.gmtModified = dict["GmtModified"] as! String
                    }
                    if dict.keys.contains("HistoryDagId") && dict["HistoryDagId"] != nil {
                        self.historyDagId = dict["HistoryDagId"] as! Int64
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("LastRunningContext") && dict["LastRunningContext"] != nil {
                        self.lastRunningContext = dict["LastRunningContext"] as! String
                    }
                    if dict.keys.contains("Msg") && dict["Msg"] != nil {
                        self.msg = dict["Msg"] as! String
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! Int64
                    }
                    if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
                        self.tenantId = dict["TenantId"] as! String
                    }
                    if dict.keys.contains("TriggerType") && dict["TriggerType"] != nil {
                        self.triggerType = dict["TriggerType"] as! Int64
                    }
                    if dict.keys.contains("Version") && dict["Version"] != nil {
                        self.version = dict["Version"] as! String
                    }
                }
            }
            public class NextFireTimeResult : Tea.TeaModel {
                public var cronFireType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cronFireType != nil {
                        map["CronFireType"] = self.cronFireType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CronFireType") && dict["CronFireType"] != nil {
                        self.cronFireType = dict["CronFireType"] as! String
                    }
                }
            }
            public var dagInfo: GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.DagInfo?

            public var dbBaseInfo: GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.DbBaseInfo?

            public var instanceTotal: Int64?

            public var instances: [GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.Instances]?

            public var nextFireTimeResult: GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.NextFireTimeResult?

            public var pageIndex: Int64?

            public var pageSize: Int64?

            public var tempTableNameMap: [String: Any]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dagInfo?.validate()
                try self.dbBaseInfo?.validate()
                try self.nextFireTimeResult?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dagInfo != nil {
                    map["DagInfo"] = self.dagInfo?.toMap()
                }
                if self.dbBaseInfo != nil {
                    map["DbBaseInfo"] = self.dbBaseInfo?.toMap()
                }
                if self.instanceTotal != nil {
                    map["InstanceTotal"] = self.instanceTotal!
                }
                if self.instances != nil {
                    var tmp : [Any] = []
                    for k in self.instances! {
                        tmp.append(k.toMap())
                    }
                    map["Instances"] = tmp
                }
                if self.nextFireTimeResult != nil {
                    map["NextFireTimeResult"] = self.nextFireTimeResult?.toMap()
                }
                if self.pageIndex != nil {
                    map["PageIndex"] = self.pageIndex!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.tempTableNameMap != nil {
                    map["TempTableNameMap"] = self.tempTableNameMap!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DagInfo") && dict["DagInfo"] != nil {
                    var model = GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.DagInfo()
                    model.fromMap(dict["DagInfo"] as! [String: Any])
                    self.dagInfo = model
                }
                if dict.keys.contains("DbBaseInfo") && dict["DbBaseInfo"] != nil {
                    var model = GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.DbBaseInfo()
                    model.fromMap(dict["DbBaseInfo"] as! [String: Any])
                    self.dbBaseInfo = model
                }
                if dict.keys.contains("InstanceTotal") && dict["InstanceTotal"] != nil {
                    self.instanceTotal = dict["InstanceTotal"] as! Int64
                }
                if dict.keys.contains("Instances") && dict["Instances"] != nil {
                    var tmp : [GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.Instances] = []
                    for v in dict["Instances"] as! [Any] {
                        var model = GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.Instances()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.instances = tmp
                }
                if dict.keys.contains("NextFireTimeResult") && dict["NextFireTimeResult"] != nil {
                    var model = GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData.NextFireTimeResult()
                    model.fromMap(dict["NextFireTimeResult"] as! [String: Any])
                    self.nextFireTimeResult = model
                }
                if dict.keys.contains("PageIndex") && dict["PageIndex"] != nil {
                    self.pageIndex = dict["PageIndex"] as! Int64
                }
                if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                    self.pageSize = dict["PageSize"] as! Int64
                }
                if dict.keys.contains("TempTableNameMap") && dict["TempTableNameMap"] != nil {
                    self.tempTableNameMap = dict["TempTableNameMap"] as! [String: Any]
                }
            }
        }
        public class PluginParam : Tea.TeaModel {
            public class TableIncludes : Tea.TeaModel {
                public var tableName: String?

                public var tableWhere: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    if self.tableWhere != nil {
                        map["TableWhere"] = self.tableWhere!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TableName") && dict["TableName"] != nil {
                        self.tableName = dict["TableName"] as! String
                    }
                    if dict.keys.contains("TableWhere") && dict["TableWhere"] != nil {
                        self.tableWhere = dict["TableWhere"] as! String
                    }
                }
            }
            public var archiveMethod: String?

            public var dbSchema: String?

            public var logic: Bool?

            public var orderAfter: [String]?

            public var runMethod: String?

            public var sourceDatabaseId: Int64?

            public var tableIncludes: [GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginParam.TableIncludes]?

            public var tableMapping: [String]?

            public var targetInstanceId: String?

            public var variables: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.archiveMethod != nil {
                    map["ArchiveMethod"] = self.archiveMethod!
                }
                if self.dbSchema != nil {
                    map["DbSchema"] = self.dbSchema!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.orderAfter != nil {
                    map["OrderAfter"] = self.orderAfter!
                }
                if self.runMethod != nil {
                    map["RunMethod"] = self.runMethod!
                }
                if self.sourceDatabaseId != nil {
                    map["SourceDatabaseId"] = self.sourceDatabaseId!
                }
                if self.tableIncludes != nil {
                    var tmp : [Any] = []
                    for k in self.tableIncludes! {
                        tmp.append(k.toMap())
                    }
                    map["TableIncludes"] = tmp
                }
                if self.tableMapping != nil {
                    map["TableMapping"] = self.tableMapping!
                }
                if self.targetInstanceId != nil {
                    map["TargetInstanceId"] = self.targetInstanceId!
                }
                if self.variables != nil {
                    map["Variables"] = self.variables!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ArchiveMethod") && dict["ArchiveMethod"] != nil {
                    self.archiveMethod = dict["ArchiveMethod"] as! String
                }
                if dict.keys.contains("DbSchema") && dict["DbSchema"] != nil {
                    self.dbSchema = dict["DbSchema"] as! String
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("OrderAfter") && dict["OrderAfter"] != nil {
                    self.orderAfter = dict["OrderAfter"] as! [String]
                }
                if dict.keys.contains("RunMethod") && dict["RunMethod"] != nil {
                    self.runMethod = dict["RunMethod"] as! String
                }
                if dict.keys.contains("SourceDatabaseId") && dict["SourceDatabaseId"] != nil {
                    self.sourceDatabaseId = dict["SourceDatabaseId"] as! Int64
                }
                if dict.keys.contains("TableIncludes") && dict["TableIncludes"] != nil {
                    var tmp : [GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginParam.TableIncludes] = []
                    for v in dict["TableIncludes"] as! [Any] {
                        var model = GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginParam.TableIncludes()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tableIncludes = tmp
                }
                if dict.keys.contains("TableMapping") && dict["TableMapping"] != nil {
                    self.tableMapping = dict["TableMapping"] as! [String]
                }
                if dict.keys.contains("TargetInstanceId") && dict["TargetInstanceId"] != nil {
                    self.targetInstanceId = dict["TargetInstanceId"] as! String
                }
                if dict.keys.contains("Variables") && dict["Variables"] != nil {
                    self.variables = dict["Variables"] as! [String]
                }
            }
        }
        public var comment: String?

        public var committer: String?

        public var committerId: Int64?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var pluginExtraData: GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData?

        public var pluginParam: GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginParam?

        public var pluginType: String?

        public var relatedUserList: [Int64]?

        public var relatedUserNickList: [String]?

        public var statusCode: String?

        public var statusDesc: String?

        public var workflowInstanceId: Int64?

        public var workflowStatusDesc: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pluginExtraData?.validate()
            try self.pluginParam?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.committer != nil {
                map["Committer"] = self.committer!
            }
            if self.committerId != nil {
                map["CommitterId"] = self.committerId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.pluginExtraData != nil {
                map["PluginExtraData"] = self.pluginExtraData?.toMap()
            }
            if self.pluginParam != nil {
                map["PluginParam"] = self.pluginParam?.toMap()
            }
            if self.pluginType != nil {
                map["PluginType"] = self.pluginType!
            }
            if self.relatedUserList != nil {
                map["RelatedUserList"] = self.relatedUserList!
            }
            if self.relatedUserNickList != nil {
                map["RelatedUserNickList"] = self.relatedUserNickList!
            }
            if self.statusCode != nil {
                map["StatusCode"] = self.statusCode!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.workflowInstanceId != nil {
                map["WorkflowInstanceId"] = self.workflowInstanceId!
            }
            if self.workflowStatusDesc != nil {
                map["WorkflowStatusDesc"] = self.workflowStatusDesc!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Comment") && dict["Comment"] != nil {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("Committer") && dict["Committer"] != nil {
                self.committer = dict["Committer"] as! String
            }
            if dict.keys.contains("CommitterId") && dict["CommitterId"] != nil {
                self.committerId = dict["CommitterId"] as! Int64
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("PluginExtraData") && dict["PluginExtraData"] != nil {
                var model = GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginExtraData()
                model.fromMap(dict["PluginExtraData"] as! [String: Any])
                self.pluginExtraData = model
            }
            if dict.keys.contains("PluginParam") && dict["PluginParam"] != nil {
                var model = GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail.PluginParam()
                model.fromMap(dict["PluginParam"] as! [String: Any])
                self.pluginParam = model
            }
            if dict.keys.contains("PluginType") && dict["PluginType"] != nil {
                self.pluginType = dict["PluginType"] as! String
            }
            if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
                self.relatedUserList = dict["RelatedUserList"] as! [Int64]
            }
            if dict.keys.contains("RelatedUserNickList") && dict["RelatedUserNickList"] != nil {
                self.relatedUserNickList = dict["RelatedUserNickList"] as! [String]
            }
            if dict.keys.contains("StatusCode") && dict["StatusCode"] != nil {
                self.statusCode = dict["StatusCode"] as! String
            }
            if dict.keys.contains("StatusDesc") && dict["StatusDesc"] != nil {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("WorkflowInstanceId") && dict["WorkflowInstanceId"] != nil {
                self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
            }
            if dict.keys.contains("WorkflowStatusDesc") && dict["WorkflowStatusDesc"] != nil {
                self.workflowStatusDesc = dict["WorkflowStatusDesc"] as! String
            }
        }
    }
    public var dataArchiveOrderDetail: GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataArchiveOrderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataArchiveOrderDetail != nil {
            map["DataArchiveOrderDetail"] = self.dataArchiveOrderDetail?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataArchiveOrderDetail") && dict["DataArchiveOrderDetail"] != nil {
            var model = GetDataArchiveOrderDetailResponseBody.DataArchiveOrderDetail()
            model.fromMap(dict["DataArchiveOrderDetail"] as! [String: Any])
            self.dataArchiveOrderDetail = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") && dict["TraceId"] != nil {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class GetDataArchiveOrderDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataArchiveOrderDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDataArchiveOrderDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataCorrectBackupFilesRequest : Tea.TeaModel {
    public var actionDetail: [String: Any]?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionDetail != nil {
            map["ActionDetail"] = self.actionDetail!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionDetail") && dict["ActionDetail"] != nil {
            self.actionDetail = dict["ActionDetail"] as! [String: Any]
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataCorrectBackupFilesShrinkRequest : Tea.TeaModel {
    public var actionDetailShrink: String?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionDetailShrink != nil {
            map["ActionDetail"] = self.actionDetailShrink!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionDetail") && dict["ActionDetail"] != nil {
            self.actionDetailShrink = dict["ActionDetail"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataCorrectBackupFilesResponseBody : Tea.TeaModel {
    public class DataCorrectBackupFiles : Tea.TeaModel {
        public var fileUrl: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                self.fileUrl = dict["FileUrl"] as! [String]
            }
        }
    }
    public var dataCorrectBackupFiles: GetDataCorrectBackupFilesResponseBody.DataCorrectBackupFiles?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataCorrectBackupFiles?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataCorrectBackupFiles != nil {
            map["DataCorrectBackupFiles"] = self.dataCorrectBackupFiles?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataCorrectBackupFiles") && dict["DataCorrectBackupFiles"] != nil {
            var model = GetDataCorrectBackupFilesResponseBody.DataCorrectBackupFiles()
            model.fromMap(dict["DataCorrectBackupFiles"] as! [String: Any])
            self.dataCorrectBackupFiles = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataCorrectBackupFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataCorrectBackupFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDataCorrectBackupFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataCorrectOrderDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataCorrectOrderDetailResponseBody : Tea.TeaModel {
    public class DataCorrectOrderDetail : Tea.TeaModel {
        public class DatabaseList : Tea.TeaModel {
            public class Database : Tea.TeaModel {
                public var dbId: Int32?

                public var dbType: String?

                public var envType: String?

                public var logic: Bool?

                public var searchName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dbId != nil {
                        map["DbId"] = self.dbId!
                    }
                    if self.dbType != nil {
                        map["DbType"] = self.dbType!
                    }
                    if self.envType != nil {
                        map["EnvType"] = self.envType!
                    }
                    if self.logic != nil {
                        map["Logic"] = self.logic!
                    }
                    if self.searchName != nil {
                        map["SearchName"] = self.searchName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DbId") && dict["DbId"] != nil {
                        self.dbId = dict["DbId"] as! Int32
                    }
                    if dict.keys.contains("DbType") && dict["DbType"] != nil {
                        self.dbType = dict["DbType"] as! String
                    }
                    if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                        self.envType = dict["EnvType"] as! String
                    }
                    if dict.keys.contains("Logic") && dict["Logic"] != nil {
                        self.logic = dict["Logic"] as! Bool
                    }
                    if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                        self.searchName = dict["SearchName"] as! String
                    }
                }
            }
            public var database: [GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.DatabaseList.Database]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.database != nil {
                    var tmp : [Any] = []
                    for k in self.database! {
                        tmp.append(k.toMap())
                    }
                    map["Database"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Database") && dict["Database"] != nil {
                    var tmp : [GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.DatabaseList.Database] = []
                    for v in dict["Database"] as! [Any] {
                        var model = GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.DatabaseList.Database()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.database = tmp
                }
            }
        }
        public class OrderDetail : Tea.TeaModel {
            public var actualAffectRows: Int64?

            public var attachmentName: String?

            public var classify: String?

            public var estimateAffectRows: Int64?

            public var exeSQL: String?

            public var ignoreAffectRows: Bool?

            public var ignoreAffectRowsReason: String?

            public var rbAttachmentName: String?

            public var rbSQL: String?

            public var rbSQLType: String?

            public var sqlType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actualAffectRows != nil {
                    map["ActualAffectRows"] = self.actualAffectRows!
                }
                if self.attachmentName != nil {
                    map["AttachmentName"] = self.attachmentName!
                }
                if self.classify != nil {
                    map["Classify"] = self.classify!
                }
                if self.estimateAffectRows != nil {
                    map["EstimateAffectRows"] = self.estimateAffectRows!
                }
                if self.exeSQL != nil {
                    map["ExeSQL"] = self.exeSQL!
                }
                if self.ignoreAffectRows != nil {
                    map["IgnoreAffectRows"] = self.ignoreAffectRows!
                }
                if self.ignoreAffectRowsReason != nil {
                    map["IgnoreAffectRowsReason"] = self.ignoreAffectRowsReason!
                }
                if self.rbAttachmentName != nil {
                    map["RbAttachmentName"] = self.rbAttachmentName!
                }
                if self.rbSQL != nil {
                    map["RbSQL"] = self.rbSQL!
                }
                if self.rbSQLType != nil {
                    map["RbSQLType"] = self.rbSQLType!
                }
                if self.sqlType != nil {
                    map["SqlType"] = self.sqlType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActualAffectRows") && dict["ActualAffectRows"] != nil {
                    self.actualAffectRows = dict["ActualAffectRows"] as! Int64
                }
                if dict.keys.contains("AttachmentName") && dict["AttachmentName"] != nil {
                    self.attachmentName = dict["AttachmentName"] as! String
                }
                if dict.keys.contains("Classify") && dict["Classify"] != nil {
                    self.classify = dict["Classify"] as! String
                }
                if dict.keys.contains("EstimateAffectRows") && dict["EstimateAffectRows"] != nil {
                    self.estimateAffectRows = dict["EstimateAffectRows"] as! Int64
                }
                if dict.keys.contains("ExeSQL") && dict["ExeSQL"] != nil {
                    self.exeSQL = dict["ExeSQL"] as! String
                }
                if dict.keys.contains("IgnoreAffectRows") && dict["IgnoreAffectRows"] != nil {
                    self.ignoreAffectRows = dict["IgnoreAffectRows"] as! Bool
                }
                if dict.keys.contains("IgnoreAffectRowsReason") && dict["IgnoreAffectRowsReason"] != nil {
                    self.ignoreAffectRowsReason = dict["IgnoreAffectRowsReason"] as! String
                }
                if dict.keys.contains("RbAttachmentName") && dict["RbAttachmentName"] != nil {
                    self.rbAttachmentName = dict["RbAttachmentName"] as! String
                }
                if dict.keys.contains("RbSQL") && dict["RbSQL"] != nil {
                    self.rbSQL = dict["RbSQL"] as! String
                }
                if dict.keys.contains("RbSQLType") && dict["RbSQLType"] != nil {
                    self.rbSQLType = dict["RbSQLType"] as! String
                }
                if dict.keys.contains("SqlType") && dict["SqlType"] != nil {
                    self.sqlType = dict["SqlType"] as! String
                }
            }
        }
        public class PreCheckDetail : Tea.TeaModel {
            public class TaskCheckDO : Tea.TeaModel {
                public var checkStatus: String?

                public var checkStep: String?

                public var userTip: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkStatus != nil {
                        map["CheckStatus"] = self.checkStatus!
                    }
                    if self.checkStep != nil {
                        map["CheckStep"] = self.checkStep!
                    }
                    if self.userTip != nil {
                        map["UserTip"] = self.userTip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CheckStatus") && dict["CheckStatus"] != nil {
                        self.checkStatus = dict["CheckStatus"] as! String
                    }
                    if dict.keys.contains("CheckStep") && dict["CheckStep"] != nil {
                        self.checkStep = dict["CheckStep"] as! String
                    }
                    if dict.keys.contains("UserTip") && dict["UserTip"] != nil {
                        self.userTip = dict["UserTip"] as! String
                    }
                }
            }
            public var taskCheckDO: [GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.PreCheckDetail.TaskCheckDO]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.taskCheckDO != nil {
                    var tmp : [Any] = []
                    for k in self.taskCheckDO! {
                        tmp.append(k.toMap())
                    }
                    map["TaskCheckDO"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TaskCheckDO") && dict["TaskCheckDO"] != nil {
                    var tmp : [GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.PreCheckDetail.TaskCheckDO] = []
                    for v in dict["TaskCheckDO"] as! [Any] {
                        var model = GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.PreCheckDetail.TaskCheckDO()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.taskCheckDO = tmp
                }
            }
        }
        public var databaseList: GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.DatabaseList?

        public var execMode: String?

        public var orderDetail: GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.OrderDetail?

        public var preCheckDetail: GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.PreCheckDetail?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.databaseList?.validate()
            try self.orderDetail?.validate()
            try self.preCheckDetail?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseList != nil {
                map["DatabaseList"] = self.databaseList?.toMap()
            }
            if self.execMode != nil {
                map["ExecMode"] = self.execMode!
            }
            if self.orderDetail != nil {
                map["OrderDetail"] = self.orderDetail?.toMap()
            }
            if self.preCheckDetail != nil {
                map["PreCheckDetail"] = self.preCheckDetail?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DatabaseList") && dict["DatabaseList"] != nil {
                var model = GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.DatabaseList()
                model.fromMap(dict["DatabaseList"] as! [String: Any])
                self.databaseList = model
            }
            if dict.keys.contains("ExecMode") && dict["ExecMode"] != nil {
                self.execMode = dict["ExecMode"] as! String
            }
            if dict.keys.contains("OrderDetail") && dict["OrderDetail"] != nil {
                var model = GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.OrderDetail()
                model.fromMap(dict["OrderDetail"] as! [String: Any])
                self.orderDetail = model
            }
            if dict.keys.contains("PreCheckDetail") && dict["PreCheckDetail"] != nil {
                var model = GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail.PreCheckDetail()
                model.fromMap(dict["PreCheckDetail"] as! [String: Any])
                self.preCheckDetail = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var dataCorrectOrderDetail: GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataCorrectOrderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataCorrectOrderDetail != nil {
            map["DataCorrectOrderDetail"] = self.dataCorrectOrderDetail?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataCorrectOrderDetail") && dict["DataCorrectOrderDetail"] != nil {
            var model = GetDataCorrectOrderDetailResponseBody.DataCorrectOrderDetail()
            model.fromMap(dict["DataCorrectOrderDetail"] as! [String: Any])
            self.dataCorrectOrderDetail = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataCorrectOrderDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataCorrectOrderDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDataCorrectOrderDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataCorrectRollbackFileRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataCorrectRollbackFileResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var fileUrl: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataCorrectRollbackFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataCorrectRollbackFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDataCorrectRollbackFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataCorrectSQLFileRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataCorrectSQLFileResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var fileUrl: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataCorrectSQLFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataCorrectSQLFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDataCorrectSQLFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataCorrectTaskDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataCorrectTaskDetailResponseBody : Tea.TeaModel {
    public class DataCorrectTaskDetail : Tea.TeaModel {
        public var actualAffectRows: Int64?

        public var createTime: String?

        public var DBTaskGroupId: Int64?

        public var jobStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualAffectRows != nil {
                map["ActualAffectRows"] = self.actualAffectRows!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.DBTaskGroupId != nil {
                map["DBTaskGroupId"] = self.DBTaskGroupId!
            }
            if self.jobStatus != nil {
                map["jobStatus"] = self.jobStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActualAffectRows") && dict["ActualAffectRows"] != nil {
                self.actualAffectRows = dict["ActualAffectRows"] as! Int64
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DBTaskGroupId") && dict["DBTaskGroupId"] != nil {
                self.DBTaskGroupId = dict["DBTaskGroupId"] as! Int64
            }
            if dict.keys.contains("jobStatus") && dict["jobStatus"] != nil {
                self.jobStatus = dict["jobStatus"] as! String
            }
        }
    }
    public var dataCorrectTaskDetail: GetDataCorrectTaskDetailResponseBody.DataCorrectTaskDetail?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataCorrectTaskDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataCorrectTaskDetail != nil {
            map["DataCorrectTaskDetail"] = self.dataCorrectTaskDetail?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataCorrectTaskDetail") && dict["DataCorrectTaskDetail"] != nil {
            var model = GetDataCorrectTaskDetailResponseBody.DataCorrectTaskDetail()
            model.fromMap(dict["DataCorrectTaskDetail"] as! [String: Any])
            self.dataCorrectTaskDetail = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataCorrectTaskDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataCorrectTaskDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDataCorrectTaskDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataCronClearConfigRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataCronClearConfigResponseBody : Tea.TeaModel {
    public class DataCronClearConfig : Tea.TeaModel {
        public var cronCallTimes: String?

        public var cronFormat: String?

        public var cronLastCallStartTime: String?

        public var cronNextCallTime: String?

        public var cronStatus: String?

        public var currentClearTaskCount: Int64?

        public var duration: String?

        public var optimizeTableAfterEveryClearTimes: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cronCallTimes != nil {
                map["CronCallTimes"] = self.cronCallTimes!
            }
            if self.cronFormat != nil {
                map["CronFormat"] = self.cronFormat!
            }
            if self.cronLastCallStartTime != nil {
                map["CronLastCallStartTime"] = self.cronLastCallStartTime!
            }
            if self.cronNextCallTime != nil {
                map["CronNextCallTime"] = self.cronNextCallTime!
            }
            if self.cronStatus != nil {
                map["CronStatus"] = self.cronStatus!
            }
            if self.currentClearTaskCount != nil {
                map["CurrentClearTaskCount"] = self.currentClearTaskCount!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.optimizeTableAfterEveryClearTimes != nil {
                map["OptimizeTableAfterEveryClearTimes"] = self.optimizeTableAfterEveryClearTimes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CronCallTimes") && dict["CronCallTimes"] != nil {
                self.cronCallTimes = dict["CronCallTimes"] as! String
            }
            if dict.keys.contains("CronFormat") && dict["CronFormat"] != nil {
                self.cronFormat = dict["CronFormat"] as! String
            }
            if dict.keys.contains("CronLastCallStartTime") && dict["CronLastCallStartTime"] != nil {
                self.cronLastCallStartTime = dict["CronLastCallStartTime"] as! String
            }
            if dict.keys.contains("CronNextCallTime") && dict["CronNextCallTime"] != nil {
                self.cronNextCallTime = dict["CronNextCallTime"] as! String
            }
            if dict.keys.contains("CronStatus") && dict["CronStatus"] != nil {
                self.cronStatus = dict["CronStatus"] as! String
            }
            if dict.keys.contains("CurrentClearTaskCount") && dict["CurrentClearTaskCount"] != nil {
                self.currentClearTaskCount = dict["CurrentClearTaskCount"] as! Int64
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("OptimizeTableAfterEveryClearTimes") && dict["OptimizeTableAfterEveryClearTimes"] != nil {
                self.optimizeTableAfterEveryClearTimes = dict["OptimizeTableAfterEveryClearTimes"] as! Int64
            }
        }
    }
    public var dataCronClearConfig: GetDataCronClearConfigResponseBody.DataCronClearConfig?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataCronClearConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataCronClearConfig != nil {
            map["DataCronClearConfig"] = self.dataCronClearConfig?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataCronClearConfig") && dict["DataCronClearConfig"] != nil {
            var model = GetDataCronClearConfigResponseBody.DataCronClearConfig()
            model.fromMap(dict["DataCronClearConfig"] as! [String: Any])
            self.dataCronClearConfig = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataCronClearConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataCronClearConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDataCronClearConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataCronClearTaskDetailListRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataCronClearTaskDetailListResponseBody : Tea.TeaModel {
    public class DataCronClearTaskDetailList : Tea.TeaModel {
        public var actualAffectRows: Int64?

        public var createTime: String?

        public var DBTaskGroupId: Int64?

        public var jobStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualAffectRows != nil {
                map["ActualAffectRows"] = self.actualAffectRows!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.DBTaskGroupId != nil {
                map["DBTaskGroupId"] = self.DBTaskGroupId!
            }
            if self.jobStatus != nil {
                map["jobStatus"] = self.jobStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActualAffectRows") && dict["ActualAffectRows"] != nil {
                self.actualAffectRows = dict["ActualAffectRows"] as! Int64
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DBTaskGroupId") && dict["DBTaskGroupId"] != nil {
                self.DBTaskGroupId = dict["DBTaskGroupId"] as! Int64
            }
            if dict.keys.contains("jobStatus") && dict["jobStatus"] != nil {
                self.jobStatus = dict["jobStatus"] as! String
            }
        }
    }
    public var dataCronClearTaskDetailList: [GetDataCronClearTaskDetailListResponseBody.DataCronClearTaskDetailList]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataCronClearTaskDetailList != nil {
            var tmp : [Any] = []
            for k in self.dataCronClearTaskDetailList! {
                tmp.append(k.toMap())
            }
            map["DataCronClearTaskDetailList"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataCronClearTaskDetailList") && dict["DataCronClearTaskDetailList"] != nil {
            var tmp : [GetDataCronClearTaskDetailListResponseBody.DataCronClearTaskDetailList] = []
            for v in dict["DataCronClearTaskDetailList"] as! [Any] {
                var model = GetDataCronClearTaskDetailListResponseBody.DataCronClearTaskDetailList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataCronClearTaskDetailList = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class GetDataCronClearTaskDetailListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataCronClearTaskDetailListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDataCronClearTaskDetailListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataExportDownloadURLRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataExportDownloadURLResponseBody : Tea.TeaModel {
    public class DownloadURLResult : Tea.TeaModel {
        public var hasResult: Bool?

        public var tipMessage: String?

        public var URL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hasResult != nil {
                map["HasResult"] = self.hasResult!
            }
            if self.tipMessage != nil {
                map["TipMessage"] = self.tipMessage!
            }
            if self.URL != nil {
                map["URL"] = self.URL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HasResult") && dict["HasResult"] != nil {
                self.hasResult = dict["HasResult"] as! Bool
            }
            if dict.keys.contains("TipMessage") && dict["TipMessage"] != nil {
                self.tipMessage = dict["TipMessage"] as! String
            }
            if dict.keys.contains("URL") && dict["URL"] != nil {
                self.URL = dict["URL"] as! String
            }
        }
    }
    public var downloadURLResult: GetDataExportDownloadURLResponseBody.DownloadURLResult?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.downloadURLResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadURLResult != nil {
            map["DownloadURLResult"] = self.downloadURLResult?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadURLResult") && dict["DownloadURLResult"] != nil {
            var model = GetDataExportDownloadURLResponseBody.DownloadURLResult()
            model.fromMap(dict["DownloadURLResult"] as! [String: Any])
            self.downloadURLResult = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataExportDownloadURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataExportDownloadURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDataExportDownloadURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataExportOrderDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataExportOrderDetailResponseBody : Tea.TeaModel {
    public class DataExportOrderDetail : Tea.TeaModel {
        public class KeyInfo : Tea.TeaModel {
            public var jobStatus: String?

            public var preCheckId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.jobStatus != nil {
                    map["JobStatus"] = self.jobStatus!
                }
                if self.preCheckId != nil {
                    map["PreCheckId"] = self.preCheckId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("JobStatus") && dict["JobStatus"] != nil {
                    self.jobStatus = dict["JobStatus"] as! String
                }
                if dict.keys.contains("PreCheckId") && dict["PreCheckId"] != nil {
                    self.preCheckId = dict["PreCheckId"] as! Int64
                }
            }
        }
        public class OrderDetail : Tea.TeaModel {
            public var actualAffectRows: Int64?

            public var classify: String?

            public var database: String?

            public var dbId: Int32?

            public var envType: String?

            public var exeSQL: String?

            public var ignoreAffectRows: Bool?

            public var ignoreAffectRowsReason: String?

            public var logic: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actualAffectRows != nil {
                    map["ActualAffectRows"] = self.actualAffectRows!
                }
                if self.classify != nil {
                    map["Classify"] = self.classify!
                }
                if self.database != nil {
                    map["Database"] = self.database!
                }
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.exeSQL != nil {
                    map["ExeSQL"] = self.exeSQL!
                }
                if self.ignoreAffectRows != nil {
                    map["IgnoreAffectRows"] = self.ignoreAffectRows!
                }
                if self.ignoreAffectRowsReason != nil {
                    map["IgnoreAffectRowsReason"] = self.ignoreAffectRowsReason!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActualAffectRows") && dict["ActualAffectRows"] != nil {
                    self.actualAffectRows = dict["ActualAffectRows"] as! Int64
                }
                if dict.keys.contains("Classify") && dict["Classify"] != nil {
                    self.classify = dict["Classify"] as! String
                }
                if dict.keys.contains("Database") && dict["Database"] != nil {
                    self.database = dict["Database"] as! String
                }
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! Int32
                }
                if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("ExeSQL") && dict["ExeSQL"] != nil {
                    self.exeSQL = dict["ExeSQL"] as! String
                }
                if dict.keys.contains("IgnoreAffectRows") && dict["IgnoreAffectRows"] != nil {
                    self.ignoreAffectRows = dict["IgnoreAffectRows"] as! Bool
                }
                if dict.keys.contains("IgnoreAffectRowsReason") && dict["IgnoreAffectRowsReason"] != nil {
                    self.ignoreAffectRowsReason = dict["IgnoreAffectRowsReason"] as! String
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
            }
        }
        public var keyInfo: GetDataExportOrderDetailResponseBody.DataExportOrderDetail.KeyInfo?

        public var orderDetail: GetDataExportOrderDetailResponseBody.DataExportOrderDetail.OrderDetail?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.keyInfo?.validate()
            try self.orderDetail?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.keyInfo != nil {
                map["KeyInfo"] = self.keyInfo?.toMap()
            }
            if self.orderDetail != nil {
                map["OrderDetail"] = self.orderDetail?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("KeyInfo") && dict["KeyInfo"] != nil {
                var model = GetDataExportOrderDetailResponseBody.DataExportOrderDetail.KeyInfo()
                model.fromMap(dict["KeyInfo"] as! [String: Any])
                self.keyInfo = model
            }
            if dict.keys.contains("OrderDetail") && dict["OrderDetail"] != nil {
                var model = GetDataExportOrderDetailResponseBody.DataExportOrderDetail.OrderDetail()
                model.fromMap(dict["OrderDetail"] as! [String: Any])
                self.orderDetail = model
            }
        }
    }
    public var dataExportOrderDetail: GetDataExportOrderDetailResponseBody.DataExportOrderDetail?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataExportOrderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataExportOrderDetail != nil {
            map["DataExportOrderDetail"] = self.dataExportOrderDetail?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataExportOrderDetail") && dict["DataExportOrderDetail"] != nil {
            var model = GetDataExportOrderDetailResponseBody.DataExportOrderDetail()
            model.fromMap(dict["DataExportOrderDetail"] as! [String: Any])
            self.dataExportOrderDetail = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataExportOrderDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataExportOrderDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDataExportOrderDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataExportPreCheckDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataExportPreCheckDetailResponseBody : Tea.TeaModel {
    public class PreCheckResult : Tea.TeaModel {
        public class PreCheckDetailList : Tea.TeaModel {
            public class PreCheckDetailList : Tea.TeaModel {
                public var affectRows: Int64?

                public var SQL: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.affectRows != nil {
                        map["AffectRows"] = self.affectRows!
                    }
                    if self.SQL != nil {
                        map["SQL"] = self.SQL!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AffectRows") && dict["AffectRows"] != nil {
                        self.affectRows = dict["AffectRows"] as! Int64
                    }
                    if dict.keys.contains("SQL") && dict["SQL"] != nil {
                        self.SQL = dict["SQL"] as! String
                    }
                }
            }
            public var preCheckDetailList: [GetDataExportPreCheckDetailResponseBody.PreCheckResult.PreCheckDetailList.PreCheckDetailList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.preCheckDetailList != nil {
                    var tmp : [Any] = []
                    for k in self.preCheckDetailList! {
                        tmp.append(k.toMap())
                    }
                    map["PreCheckDetailList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PreCheckDetailList") && dict["PreCheckDetailList"] != nil {
                    var tmp : [GetDataExportPreCheckDetailResponseBody.PreCheckResult.PreCheckDetailList.PreCheckDetailList] = []
                    for v in dict["PreCheckDetailList"] as! [Any] {
                        var model = GetDataExportPreCheckDetailResponseBody.PreCheckResult.PreCheckDetailList.PreCheckDetailList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.preCheckDetailList = tmp
                }
            }
        }
        public var ignoreAffectRows: Bool?

        public var preCheckDetailList: GetDataExportPreCheckDetailResponseBody.PreCheckResult.PreCheckDetailList?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.preCheckDetailList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ignoreAffectRows != nil {
                map["IgnoreAffectRows"] = self.ignoreAffectRows!
            }
            if self.preCheckDetailList != nil {
                map["PreCheckDetailList"] = self.preCheckDetailList?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IgnoreAffectRows") && dict["IgnoreAffectRows"] != nil {
                self.ignoreAffectRows = dict["IgnoreAffectRows"] as! Bool
            }
            if dict.keys.contains("PreCheckDetailList") && dict["PreCheckDetailList"] != nil {
                var model = GetDataExportPreCheckDetailResponseBody.PreCheckResult.PreCheckDetailList()
                model.fromMap(dict["PreCheckDetailList"] as! [String: Any])
                self.preCheckDetailList = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var preCheckResult: GetDataExportPreCheckDetailResponseBody.PreCheckResult?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.preCheckResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.preCheckResult != nil {
            map["PreCheckResult"] = self.preCheckResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("PreCheckResult") && dict["PreCheckResult"] != nil {
            var model = GetDataExportPreCheckDetailResponseBody.PreCheckResult()
            model.fromMap(dict["PreCheckResult"] as! [String: Any])
            self.preCheckResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataExportPreCheckDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataExportPreCheckDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDataExportPreCheckDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataImportSQLRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var sqlId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("SqlId") && dict["SqlId"] != nil {
            self.sqlId = dict["SqlId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataImportSQLResponseBody : Tea.TeaModel {
    public class SQLDetail : Tea.TeaModel {
        public var execSql: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.execSql != nil {
                map["ExecSql"] = self.execSql!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExecSql") && dict["ExecSql"] != nil {
                self.execSql = dict["ExecSql"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var SQLDetail: GetDataImportSQLResponseBody.SQLDetail?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.SQLDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SQLDetail != nil {
            map["SQLDetail"] = self.SQLDetail?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SQLDetail") && dict["SQLDetail"] != nil {
            var model = GetDataImportSQLResponseBody.SQLDetail()
            model.fromMap(dict["SQLDetail"] as! [String: Any])
            self.SQLDetail = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataImportSQLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataImportSQLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDataImportSQLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataTrackJobDegreeRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataTrackJobDegreeResponseBody : Tea.TeaModel {
    public class JobDegree : Tea.TeaModel {
        public var downloadCompletionDegree: Double?

        public var filterCompletionDegree: Double?

        public var jobStatus: String?

        public var listCompletionDegree: Double?

        public var statusDesc: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadCompletionDegree != nil {
                map["DownloadCompletionDegree"] = self.downloadCompletionDegree!
            }
            if self.filterCompletionDegree != nil {
                map["FilterCompletionDegree"] = self.filterCompletionDegree!
            }
            if self.jobStatus != nil {
                map["JobStatus"] = self.jobStatus!
            }
            if self.listCompletionDegree != nil {
                map["ListCompletionDegree"] = self.listCompletionDegree!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DownloadCompletionDegree") && dict["DownloadCompletionDegree"] != nil {
                self.downloadCompletionDegree = dict["DownloadCompletionDegree"] as! Double
            }
            if dict.keys.contains("FilterCompletionDegree") && dict["FilterCompletionDegree"] != nil {
                self.filterCompletionDegree = dict["FilterCompletionDegree"] as! Double
            }
            if dict.keys.contains("JobStatus") && dict["JobStatus"] != nil {
                self.jobStatus = dict["JobStatus"] as! String
            }
            if dict.keys.contains("ListCompletionDegree") && dict["ListCompletionDegree"] != nil {
                self.listCompletionDegree = dict["ListCompletionDegree"] as! Double
            }
            if dict.keys.contains("StatusDesc") && dict["StatusDesc"] != nil {
                self.statusDesc = dict["StatusDesc"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var jobDegree: GetDataTrackJobDegreeResponseBody.JobDegree?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobDegree?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.jobDegree != nil {
            map["JobDegree"] = self.jobDegree?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("JobDegree") && dict["JobDegree"] != nil {
            var model = GetDataTrackJobDegreeResponseBody.JobDegree()
            model.fromMap(dict["JobDegree"] as! [String: Any])
            self.jobDegree = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataTrackJobDegreeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataTrackJobDegreeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDataTrackJobDegreeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataTrackJobTableMetaRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataTrackJobTableMetaResponseBody : Tea.TeaModel {
    public class TableMetaList : Tea.TeaModel {
        public class Columns : Tea.TeaModel {
            public var charset: String?

            public var columnName: String?

            public var columnPosition: Int32?

            public var columnType: String?

            public var fictive: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.charset != nil {
                    map["Charset"] = self.charset!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.columnPosition != nil {
                    map["ColumnPosition"] = self.columnPosition!
                }
                if self.columnType != nil {
                    map["ColumnType"] = self.columnType!
                }
                if self.fictive != nil {
                    map["Fictive"] = self.fictive!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Charset") && dict["Charset"] != nil {
                    self.charset = dict["Charset"] as! String
                }
                if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("ColumnPosition") && dict["ColumnPosition"] != nil {
                    self.columnPosition = dict["ColumnPosition"] as! Int32
                }
                if dict.keys.contains("ColumnType") && dict["ColumnType"] != nil {
                    self.columnType = dict["ColumnType"] as! String
                }
                if dict.keys.contains("Fictive") && dict["Fictive"] != nil {
                    self.fictive = dict["Fictive"] as! Bool
                }
            }
        }
        public var columns: [GetDataTrackJobTableMetaResponseBody.TableMetaList.Columns]?

        public var schemaName: String?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columns != nil {
                var tmp : [Any] = []
                for k in self.columns! {
                    tmp.append(k.toMap())
                }
                map["Columns"] = tmp
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Columns") && dict["Columns"] != nil {
                var tmp : [GetDataTrackJobTableMetaResponseBody.TableMetaList.Columns] = []
                for v in dict["Columns"] as! [Any] {
                    var model = GetDataTrackJobTableMetaResponseBody.TableMetaList.Columns()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.columns = tmp
            }
            if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
                self.schemaName = dict["SchemaName"] as! String
            }
            if dict.keys.contains("TableName") && dict["TableName"] != nil {
                self.tableName = dict["TableName"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tableMetaList: [GetDataTrackJobTableMetaResponseBody.TableMetaList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tableMetaList != nil {
            var tmp : [Any] = []
            for k in self.tableMetaList! {
                tmp.append(k.toMap())
            }
            map["TableMetaList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TableMetaList") && dict["TableMetaList"] != nil {
            var tmp : [GetDataTrackJobTableMetaResponseBody.TableMetaList] = []
            for v in dict["TableMetaList"] as! [Any] {
                var model = GetDataTrackJobTableMetaResponseBody.TableMetaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tableMetaList = tmp
        }
    }
}

public class GetDataTrackJobTableMetaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataTrackJobTableMetaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDataTrackJobTableMetaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataTrackOrderDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDataTrackOrderDetailResponseBody : Tea.TeaModel {
    public class DataTrackOrderDetail : Tea.TeaModel {
        public var databaseSearchName: String?

        public var dbId: Int64?

        public var jobEndTime: String?

        public var jobStartTime: String?

        public var jobStatus: String?

        public var logic: Bool?

        public var schemaName: String?

        public var statusDesc: String?

        public var tableNames: [String]?

        public var trackTypes: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseSearchName != nil {
                map["DatabaseSearchName"] = self.databaseSearchName!
            }
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.jobEndTime != nil {
                map["JobEndTime"] = self.jobEndTime!
            }
            if self.jobStartTime != nil {
                map["JobStartTime"] = self.jobStartTime!
            }
            if self.jobStatus != nil {
                map["JobStatus"] = self.jobStatus!
            }
            if self.logic != nil {
                map["Logic"] = self.logic!
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.tableNames != nil {
                map["TableNames"] = self.tableNames!
            }
            if self.trackTypes != nil {
                map["TrackTypes"] = self.trackTypes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DatabaseSearchName") && dict["DatabaseSearchName"] != nil {
                self.databaseSearchName = dict["DatabaseSearchName"] as! String
            }
            if dict.keys.contains("DbId") && dict["DbId"] != nil {
                self.dbId = dict["DbId"] as! Int64
            }
            if dict.keys.contains("JobEndTime") && dict["JobEndTime"] != nil {
                self.jobEndTime = dict["JobEndTime"] as! String
            }
            if dict.keys.contains("JobStartTime") && dict["JobStartTime"] != nil {
                self.jobStartTime = dict["JobStartTime"] as! String
            }
            if dict.keys.contains("JobStatus") && dict["JobStatus"] != nil {
                self.jobStatus = dict["JobStatus"] as! String
            }
            if dict.keys.contains("Logic") && dict["Logic"] != nil {
                self.logic = dict["Logic"] as! Bool
            }
            if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
                self.schemaName = dict["SchemaName"] as! String
            }
            if dict.keys.contains("StatusDesc") && dict["StatusDesc"] != nil {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("TableNames") && dict["TableNames"] != nil {
                self.tableNames = dict["TableNames"] as! [String]
            }
            if dict.keys.contains("TrackTypes") && dict["TrackTypes"] != nil {
                self.trackTypes = dict["TrackTypes"] as! [String]
            }
        }
    }
    public var dataTrackOrderDetail: GetDataTrackOrderDetailResponseBody.DataTrackOrderDetail?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataTrackOrderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataTrackOrderDetail != nil {
            map["DataTrackOrderDetail"] = self.dataTrackOrderDetail?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataTrackOrderDetail") && dict["DataTrackOrderDetail"] != nil {
            var model = GetDataTrackOrderDetailResponseBody.DataTrackOrderDetail()
            model.fromMap(dict["DataTrackOrderDetail"] as! [String: Any])
            self.dataTrackOrderDetail = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDataTrackOrderDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataTrackOrderDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDataTrackOrderDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDatabaseRequest : Tea.TeaModel {
    public var host: String?

    public var port: Int32?

    public var schemaName: String?

    public var sid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.sid != nil {
            map["Sid"] = self.sid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Host") && dict["Host"] != nil {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
            self.schemaName = dict["SchemaName"] as! String
        }
        if dict.keys.contains("Sid") && dict["Sid"] != nil {
            self.sid = dict["Sid"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDatabaseResponseBody : Tea.TeaModel {
    public class Database : Tea.TeaModel {
        public class OwnerIdList : Tea.TeaModel {
            public var ownerIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ownerIds != nil {
                    map["OwnerIds"] = self.ownerIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OwnerIds") && dict["OwnerIds"] != nil {
                    self.ownerIds = dict["OwnerIds"] as! [String]
                }
            }
        }
        public class OwnerNameList : Tea.TeaModel {
            public var ownerNames: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ownerNames != nil {
                    map["OwnerNames"] = self.ownerNames!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OwnerNames") && dict["OwnerNames"] != nil {
                    self.ownerNames = dict["OwnerNames"] as! [String]
                }
            }
        }
        public var catalogName: String?

        public var databaseId: String?

        public var dbType: String?

        public var dbaId: String?

        public var dbaName: String?

        public var encoding: String?

        public var envType: String?

        public var host: String?

        public var instanceAlias: String?

        public var instanceId: String?

        public var ownerIdList: GetDatabaseResponseBody.Database.OwnerIdList?

        public var ownerNameList: GetDatabaseResponseBody.Database.OwnerNameList?

        public var port: Int32?

        public var schemaName: String?

        public var searchName: String?

        public var sid: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ownerIdList?.validate()
            try self.ownerNameList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.catalogName != nil {
                map["CatalogName"] = self.catalogName!
            }
            if self.databaseId != nil {
                map["DatabaseId"] = self.databaseId!
            }
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.dbaId != nil {
                map["DbaId"] = self.dbaId!
            }
            if self.dbaName != nil {
                map["DbaName"] = self.dbaName!
            }
            if self.encoding != nil {
                map["Encoding"] = self.encoding!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.instanceAlias != nil {
                map["InstanceAlias"] = self.instanceAlias!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.ownerIdList != nil {
                map["OwnerIdList"] = self.ownerIdList?.toMap()
            }
            if self.ownerNameList != nil {
                map["OwnerNameList"] = self.ownerNameList?.toMap()
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.searchName != nil {
                map["SearchName"] = self.searchName!
            }
            if self.sid != nil {
                map["Sid"] = self.sid!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CatalogName") && dict["CatalogName"] != nil {
                self.catalogName = dict["CatalogName"] as! String
            }
            if dict.keys.contains("DatabaseId") && dict["DatabaseId"] != nil {
                self.databaseId = dict["DatabaseId"] as! String
            }
            if dict.keys.contains("DbType") && dict["DbType"] != nil {
                self.dbType = dict["DbType"] as! String
            }
            if dict.keys.contains("DbaId") && dict["DbaId"] != nil {
                self.dbaId = dict["DbaId"] as! String
            }
            if dict.keys.contains("DbaName") && dict["DbaName"] != nil {
                self.dbaName = dict["DbaName"] as! String
            }
            if dict.keys.contains("Encoding") && dict["Encoding"] != nil {
                self.encoding = dict["Encoding"] as! String
            }
            if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                self.envType = dict["EnvType"] as! String
            }
            if dict.keys.contains("Host") && dict["Host"] != nil {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("InstanceAlias") && dict["InstanceAlias"] != nil {
                self.instanceAlias = dict["InstanceAlias"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("OwnerIdList") && dict["OwnerIdList"] != nil {
                var model = GetDatabaseResponseBody.Database.OwnerIdList()
                model.fromMap(dict["OwnerIdList"] as! [String: Any])
                self.ownerIdList = model
            }
            if dict.keys.contains("OwnerNameList") && dict["OwnerNameList"] != nil {
                var model = GetDatabaseResponseBody.Database.OwnerNameList()
                model.fromMap(dict["OwnerNameList"] as! [String: Any])
                self.ownerNameList = model
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
                self.schemaName = dict["SchemaName"] as! String
            }
            if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                self.searchName = dict["SearchName"] as! String
            }
            if dict.keys.contains("Sid") && dict["Sid"] != nil {
                self.sid = dict["Sid"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
        }
    }
    public var database: GetDatabaseResponseBody.Database?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.database?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.database != nil {
            map["Database"] = self.database?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Database") && dict["Database"] != nil {
            var model = GetDatabaseResponseBody.Database()
            model.fromMap(dict["Database"] as! [String: Any])
            self.database = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDatabaseExportOrderDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetDatabaseExportOrderDetailResponseBody : Tea.TeaModel {
    public class DatabaseExportOrderDetail : Tea.TeaModel {
        public class KeyInfo : Tea.TeaModel {
            public class Config : Tea.TeaModel {
                public class ExportTypes : Tea.TeaModel {
                    public var exportTypes: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.exportTypes != nil {
                            map["ExportTypes"] = self.exportTypes!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ExportTypes") && dict["ExportTypes"] != nil {
                            self.exportTypes = dict["ExportTypes"] as! [String]
                        }
                    }
                }
                public class SQLExtOption : Tea.TeaModel {
                    public var SQLExtOption: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.SQLExtOption != nil {
                            map["SQLExtOption"] = self.SQLExtOption!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("SQLExtOption") && dict["SQLExtOption"] != nil {
                            self.SQLExtOption = dict["SQLExtOption"] as! [String]
                        }
                    }
                }
                public class SelectedTables : Tea.TeaModel {
                    public var selectedTables: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.selectedTables != nil {
                            map["SelectedTables"] = self.selectedTables!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("SelectedTables") && dict["SelectedTables"] != nil {
                            self.selectedTables = dict["SelectedTables"] as! [String]
                        }
                    }
                }
                public var dbName: String?

                public var exportContent: String?

                public var exportTypes: GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo.Config.ExportTypes?

                public var SQLExtOption: GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo.Config.SQLExtOption?

                public var selectedTables: GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo.Config.SelectedTables?

                public var targetOption: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.exportTypes?.validate()
                    try self.SQLExtOption?.validate()
                    try self.selectedTables?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dbName != nil {
                        map["DbName"] = self.dbName!
                    }
                    if self.exportContent != nil {
                        map["ExportContent"] = self.exportContent!
                    }
                    if self.exportTypes != nil {
                        map["ExportTypes"] = self.exportTypes?.toMap()
                    }
                    if self.SQLExtOption != nil {
                        map["SQLExtOption"] = self.SQLExtOption?.toMap()
                    }
                    if self.selectedTables != nil {
                        map["SelectedTables"] = self.selectedTables?.toMap()
                    }
                    if self.targetOption != nil {
                        map["TargetOption"] = self.targetOption!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DbName") && dict["DbName"] != nil {
                        self.dbName = dict["DbName"] as! String
                    }
                    if dict.keys.contains("ExportContent") && dict["ExportContent"] != nil {
                        self.exportContent = dict["ExportContent"] as! String
                    }
                    if dict.keys.contains("ExportTypes") && dict["ExportTypes"] != nil {
                        var model = GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo.Config.ExportTypes()
                        model.fromMap(dict["ExportTypes"] as! [String: Any])
                        self.exportTypes = model
                    }
                    if dict.keys.contains("SQLExtOption") && dict["SQLExtOption"] != nil {
                        var model = GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo.Config.SQLExtOption()
                        model.fromMap(dict["SQLExtOption"] as! [String: Any])
                        self.SQLExtOption = model
                    }
                    if dict.keys.contains("SelectedTables") && dict["SelectedTables"] != nil {
                        var model = GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo.Config.SelectedTables()
                        model.fromMap(dict["SelectedTables"] as! [String: Any])
                        self.selectedTables = model
                    }
                    if dict.keys.contains("TargetOption") && dict["TargetOption"] != nil {
                        self.targetOption = dict["TargetOption"] as! String
                    }
                }
            }
            public var auditDate: String?

            public var config: GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo.Config?

            public var dbId: Int64?

            public var downloadURL: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.config?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.auditDate != nil {
                    map["AuditDate"] = self.auditDate!
                }
                if self.config != nil {
                    map["Config"] = self.config?.toMap()
                }
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.downloadURL != nil {
                    map["DownloadURL"] = self.downloadURL!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuditDate") && dict["AuditDate"] != nil {
                    self.auditDate = dict["AuditDate"] as! String
                }
                if dict.keys.contains("Config") && dict["Config"] != nil {
                    var model = GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo.Config()
                    model.fromMap(dict["Config"] as! [String: Any])
                    self.config = model
                }
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("DownloadURL") && dict["DownloadURL"] != nil {
                    self.downloadURL = dict["DownloadURL"] as! String
                }
            }
        }
        public var comment: String?

        public var committer: String?

        public var committerId: String?

        public var id: Int64?

        public var keyInfo: GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo?

        public var log: String?

        public var searchName: String?

        public var statusDesc: String?

        public var workflowStatusDesc: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.keyInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.committer != nil {
                map["Committer"] = self.committer!
            }
            if self.committerId != nil {
                map["CommitterId"] = self.committerId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.keyInfo != nil {
                map["KeyInfo"] = self.keyInfo?.toMap()
            }
            if self.log != nil {
                map["Log"] = self.log!
            }
            if self.searchName != nil {
                map["SearchName"] = self.searchName!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.workflowStatusDesc != nil {
                map["WorkflowStatusDesc"] = self.workflowStatusDesc!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Comment") && dict["Comment"] != nil {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("Committer") && dict["Committer"] != nil {
                self.committer = dict["Committer"] as! String
            }
            if dict.keys.contains("CommitterId") && dict["CommitterId"] != nil {
                self.committerId = dict["CommitterId"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("KeyInfo") && dict["KeyInfo"] != nil {
                var model = GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail.KeyInfo()
                model.fromMap(dict["KeyInfo"] as! [String: Any])
                self.keyInfo = model
            }
            if dict.keys.contains("Log") && dict["Log"] != nil {
                self.log = dict["Log"] as! String
            }
            if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                self.searchName = dict["SearchName"] as! String
            }
            if dict.keys.contains("StatusDesc") && dict["StatusDesc"] != nil {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("WorkflowStatusDesc") && dict["WorkflowStatusDesc"] != nil {
                self.workflowStatusDesc = dict["WorkflowStatusDesc"] as! String
            }
        }
    }
    public var databaseExportOrderDetail: GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.databaseExportOrderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseExportOrderDetail != nil {
            map["DatabaseExportOrderDetail"] = self.databaseExportOrderDetail?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseExportOrderDetail") && dict["DatabaseExportOrderDetail"] != nil {
            var model = GetDatabaseExportOrderDetailResponseBody.DatabaseExportOrderDetail()
            model.fromMap(dict["DatabaseExportOrderDetail"] as! [String: Any])
            self.databaseExportOrderDetail = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDatabaseExportOrderDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDatabaseExportOrderDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDatabaseExportOrderDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceRequest : Tea.TeaModel {
    public var host: String?

    public var port: Int32?

    public var sid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.sid != nil {
            map["Sid"] = self.sid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Host") && dict["Host"] != nil {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("Sid") && dict["Sid"] != nil {
            self.sid = dict["Sid"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetInstanceResponseBody : Tea.TeaModel {
    public class Instance : Tea.TeaModel {
        public class OwnerIdList : Tea.TeaModel {
            public var ownerIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ownerIds != nil {
                    map["OwnerIds"] = self.ownerIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OwnerIds") && dict["OwnerIds"] != nil {
                    self.ownerIds = dict["OwnerIds"] as! [String]
                }
            }
        }
        public class OwnerNameList : Tea.TeaModel {
            public var ownerNames: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ownerNames != nil {
                    map["OwnerNames"] = self.ownerNames!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OwnerNames") && dict["OwnerNames"] != nil {
                    self.ownerNames = dict["OwnerNames"] as! [String]
                }
            }
        }
        public class StandardGroup : Tea.TeaModel {
            public var groupMode: String?

            public var groupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupMode != nil {
                    map["GroupMode"] = self.groupMode!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupMode") && dict["GroupMode"] != nil {
                    self.groupMode = dict["GroupMode"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
            }
        }
        public var dataLinkName: String?

        public var databasePassword: String?

        public var databaseUser: String?

        public var dbaId: String?

        public var dbaNickName: String?

        public var ddlOnline: Int32?

        public var ecsInstanceId: String?

        public var ecsRegion: String?

        public var envType: String?

        public var exportTimeout: Int32?

        public var host: String?

        public var instanceAlias: String?

        public var instanceId: String?

        public var instanceSource: String?

        public var instanceType: String?

        public var ownerIdList: GetInstanceResponseBody.Instance.OwnerIdList?

        public var ownerNameList: GetInstanceResponseBody.Instance.OwnerNameList?

        public var port: Int32?

        public var queryTimeout: Int32?

        public var safeRuleId: String?

        public var sellSitd: String?

        public var sid: String?

        public var standardGroup: GetInstanceResponseBody.Instance.StandardGroup?

        public var state: String?

        public var useDsql: Int32?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ownerIdList?.validate()
            try self.ownerNameList?.validate()
            try self.standardGroup?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataLinkName != nil {
                map["DataLinkName"] = self.dataLinkName!
            }
            if self.databasePassword != nil {
                map["DatabasePassword"] = self.databasePassword!
            }
            if self.databaseUser != nil {
                map["DatabaseUser"] = self.databaseUser!
            }
            if self.dbaId != nil {
                map["DbaId"] = self.dbaId!
            }
            if self.dbaNickName != nil {
                map["DbaNickName"] = self.dbaNickName!
            }
            if self.ddlOnline != nil {
                map["DdlOnline"] = self.ddlOnline!
            }
            if self.ecsInstanceId != nil {
                map["EcsInstanceId"] = self.ecsInstanceId!
            }
            if self.ecsRegion != nil {
                map["EcsRegion"] = self.ecsRegion!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.exportTimeout != nil {
                map["ExportTimeout"] = self.exportTimeout!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.instanceAlias != nil {
                map["InstanceAlias"] = self.instanceAlias!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceSource != nil {
                map["InstanceSource"] = self.instanceSource!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.ownerIdList != nil {
                map["OwnerIdList"] = self.ownerIdList?.toMap()
            }
            if self.ownerNameList != nil {
                map["OwnerNameList"] = self.ownerNameList?.toMap()
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.queryTimeout != nil {
                map["QueryTimeout"] = self.queryTimeout!
            }
            if self.safeRuleId != nil {
                map["SafeRuleId"] = self.safeRuleId!
            }
            if self.sellSitd != nil {
                map["SellSitd"] = self.sellSitd!
            }
            if self.sid != nil {
                map["Sid"] = self.sid!
            }
            if self.standardGroup != nil {
                map["StandardGroup"] = self.standardGroup?.toMap()
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.useDsql != nil {
                map["UseDsql"] = self.useDsql!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataLinkName") && dict["DataLinkName"] != nil {
                self.dataLinkName = dict["DataLinkName"] as! String
            }
            if dict.keys.contains("DatabasePassword") && dict["DatabasePassword"] != nil {
                self.databasePassword = dict["DatabasePassword"] as! String
            }
            if dict.keys.contains("DatabaseUser") && dict["DatabaseUser"] != nil {
                self.databaseUser = dict["DatabaseUser"] as! String
            }
            if dict.keys.contains("DbaId") && dict["DbaId"] != nil {
                self.dbaId = dict["DbaId"] as! String
            }
            if dict.keys.contains("DbaNickName") && dict["DbaNickName"] != nil {
                self.dbaNickName = dict["DbaNickName"] as! String
            }
            if dict.keys.contains("DdlOnline") && dict["DdlOnline"] != nil {
                self.ddlOnline = dict["DdlOnline"] as! Int32
            }
            if dict.keys.contains("EcsInstanceId") && dict["EcsInstanceId"] != nil {
                self.ecsInstanceId = dict["EcsInstanceId"] as! String
            }
            if dict.keys.contains("EcsRegion") && dict["EcsRegion"] != nil {
                self.ecsRegion = dict["EcsRegion"] as! String
            }
            if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                self.envType = dict["EnvType"] as! String
            }
            if dict.keys.contains("ExportTimeout") && dict["ExportTimeout"] != nil {
                self.exportTimeout = dict["ExportTimeout"] as! Int32
            }
            if dict.keys.contains("Host") && dict["Host"] != nil {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("InstanceAlias") && dict["InstanceAlias"] != nil {
                self.instanceAlias = dict["InstanceAlias"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceSource") && dict["InstanceSource"] != nil {
                self.instanceSource = dict["InstanceSource"] as! String
            }
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("OwnerIdList") && dict["OwnerIdList"] != nil {
                var model = GetInstanceResponseBody.Instance.OwnerIdList()
                model.fromMap(dict["OwnerIdList"] as! [String: Any])
                self.ownerIdList = model
            }
            if dict.keys.contains("OwnerNameList") && dict["OwnerNameList"] != nil {
                var model = GetInstanceResponseBody.Instance.OwnerNameList()
                model.fromMap(dict["OwnerNameList"] as! [String: Any])
                self.ownerNameList = model
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("QueryTimeout") && dict["QueryTimeout"] != nil {
                self.queryTimeout = dict["QueryTimeout"] as! Int32
            }
            if dict.keys.contains("SafeRuleId") && dict["SafeRuleId"] != nil {
                self.safeRuleId = dict["SafeRuleId"] as! String
            }
            if dict.keys.contains("SellSitd") && dict["SellSitd"] != nil {
                self.sellSitd = dict["SellSitd"] as! String
            }
            if dict.keys.contains("Sid") && dict["Sid"] != nil {
                self.sid = dict["Sid"] as! String
            }
            if dict.keys.contains("StandardGroup") && dict["StandardGroup"] != nil {
                var model = GetInstanceResponseBody.Instance.StandardGroup()
                model.fromMap(dict["StandardGroup"] as! [String: Any])
                self.standardGroup = model
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("UseDsql") && dict["UseDsql"] != nil {
                self.useDsql = dict["UseDsql"] as! Int32
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var instance: GetInstanceResponseBody.Instance?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.instance != nil {
            map["Instance"] = self.instance?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("Instance") && dict["Instance"] != nil {
            var model = GetInstanceResponseBody.Instance()
            model.fromMap(dict["Instance"] as! [String: Any])
            self.instance = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetIntervalLimitOfSLARequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetIntervalLimitOfSLAResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var intervalLimit: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.intervalLimit != nil {
            map["IntervalLimit"] = self.intervalLimit!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("IntervalLimit") && dict["IntervalLimit"] != nil {
            self.intervalLimit = dict["IntervalLimit"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetIntervalLimitOfSLAResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetIntervalLimitOfSLAResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetIntervalLimitOfSLAResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLhSpaceByNameRequest : Tea.TeaModel {
    public var spaceName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.spaceName != nil {
            map["SpaceName"] = self.spaceName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SpaceName") && dict["SpaceName"] != nil {
            self.spaceName = dict["SpaceName"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetLhSpaceByNameResponseBody : Tea.TeaModel {
    public class LakehouseSpace : Tea.TeaModel {
        public var creatorId: String?

        public var description_: String?

        public var devDbId: Int32?

        public var dwDbType: String?

        public var id: Int64?

        public var isDeleted: Bool?

        public var mode: Int32?

        public var prodDbId: Int32?

        public var spaceConfig: String?

        public var spaceName: String?

        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.devDbId != nil {
                map["DevDbId"] = self.devDbId!
            }
            if self.dwDbType != nil {
                map["DwDbType"] = self.dwDbType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isDeleted != nil {
                map["IsDeleted"] = self.isDeleted!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.prodDbId != nil {
                map["ProdDbId"] = self.prodDbId!
            }
            if self.spaceConfig != nil {
                map["SpaceConfig"] = self.spaceConfig!
            }
            if self.spaceName != nil {
                map["SpaceName"] = self.spaceName!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DevDbId") && dict["DevDbId"] != nil {
                self.devDbId = dict["DevDbId"] as! Int32
            }
            if dict.keys.contains("DwDbType") && dict["DwDbType"] != nil {
                self.dwDbType = dict["DwDbType"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IsDeleted") && dict["IsDeleted"] != nil {
                self.isDeleted = dict["IsDeleted"] as! Bool
            }
            if dict.keys.contains("Mode") && dict["Mode"] != nil {
                self.mode = dict["Mode"] as! Int32
            }
            if dict.keys.contains("ProdDbId") && dict["ProdDbId"] != nil {
                self.prodDbId = dict["ProdDbId"] as! Int32
            }
            if dict.keys.contains("SpaceConfig") && dict["SpaceConfig"] != nil {
                self.spaceConfig = dict["SpaceConfig"] as! String
            }
            if dict.keys.contains("SpaceName") && dict["SpaceName"] != nil {
                self.spaceName = dict["SpaceName"] as! String
            }
            if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
                self.tenantId = dict["TenantId"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var lakehouseSpace: GetLhSpaceByNameResponseBody.LakehouseSpace?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lakehouseSpace?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.lakehouseSpace != nil {
            map["LakehouseSpace"] = self.lakehouseSpace?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("LakehouseSpace") && dict["LakehouseSpace"] != nil {
            var model = GetLhSpaceByNameResponseBody.LakehouseSpace()
            model.fromMap(dict["LakehouseSpace"] as! [String: Any])
            self.lakehouseSpace = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetLhSpaceByNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLhSpaceByNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetLhSpaceByNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLogicDatabaseRequest : Tea.TeaModel {
    public var dbId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") && dict["DbId"] != nil {
            self.dbId = dict["DbId"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetLogicDatabaseResponseBody : Tea.TeaModel {
    public class LogicDatabase : Tea.TeaModel {
        public class DatabaseIds : Tea.TeaModel {
            public var databaseIds: [Int64]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseIds != nil {
                    map["DatabaseIds"] = self.databaseIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DatabaseIds") && dict["DatabaseIds"] != nil {
                    self.databaseIds = dict["DatabaseIds"] as! [Int64]
                }
            }
        }
        public class OwnerIdList : Tea.TeaModel {
            public var ownerIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ownerIds != nil {
                    map["OwnerIds"] = self.ownerIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OwnerIds") && dict["OwnerIds"] != nil {
                    self.ownerIds = dict["OwnerIds"] as! [String]
                }
            }
        }
        public class OwnerNameList : Tea.TeaModel {
            public var ownerNames: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ownerNames != nil {
                    map["OwnerNames"] = self.ownerNames!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OwnerNames") && dict["OwnerNames"] != nil {
                    self.ownerNames = dict["OwnerNames"] as! [String]
                }
            }
        }
        public var alias: String?

        public var databaseId: String?

        public var databaseIds: GetLogicDatabaseResponseBody.LogicDatabase.DatabaseIds?

        public var dbType: String?

        public var envType: String?

        public var logic: Bool?

        public var ownerIdList: GetLogicDatabaseResponseBody.LogicDatabase.OwnerIdList?

        public var ownerNameList: GetLogicDatabaseResponseBody.LogicDatabase.OwnerNameList?

        public var schemaName: String?

        public var searchName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.databaseIds?.validate()
            try self.ownerIdList?.validate()
            try self.ownerNameList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alias != nil {
                map["Alias"] = self.alias!
            }
            if self.databaseId != nil {
                map["DatabaseId"] = self.databaseId!
            }
            if self.databaseIds != nil {
                map["DatabaseIds"] = self.databaseIds?.toMap()
            }
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.logic != nil {
                map["Logic"] = self.logic!
            }
            if self.ownerIdList != nil {
                map["OwnerIdList"] = self.ownerIdList?.toMap()
            }
            if self.ownerNameList != nil {
                map["OwnerNameList"] = self.ownerNameList?.toMap()
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.searchName != nil {
                map["SearchName"] = self.searchName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alias") && dict["Alias"] != nil {
                self.alias = dict["Alias"] as! String
            }
            if dict.keys.contains("DatabaseId") && dict["DatabaseId"] != nil {
                self.databaseId = dict["DatabaseId"] as! String
            }
            if dict.keys.contains("DatabaseIds") && dict["DatabaseIds"] != nil {
                var model = GetLogicDatabaseResponseBody.LogicDatabase.DatabaseIds()
                model.fromMap(dict["DatabaseIds"] as! [String: Any])
                self.databaseIds = model
            }
            if dict.keys.contains("DbType") && dict["DbType"] != nil {
                self.dbType = dict["DbType"] as! String
            }
            if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                self.envType = dict["EnvType"] as! String
            }
            if dict.keys.contains("Logic") && dict["Logic"] != nil {
                self.logic = dict["Logic"] as! Bool
            }
            if dict.keys.contains("OwnerIdList") && dict["OwnerIdList"] != nil {
                var model = GetLogicDatabaseResponseBody.LogicDatabase.OwnerIdList()
                model.fromMap(dict["OwnerIdList"] as! [String: Any])
                self.ownerIdList = model
            }
            if dict.keys.contains("OwnerNameList") && dict["OwnerNameList"] != nil {
                var model = GetLogicDatabaseResponseBody.LogicDatabase.OwnerNameList()
                model.fromMap(dict["OwnerNameList"] as! [String: Any])
                self.ownerNameList = model
            }
            if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
                self.schemaName = dict["SchemaName"] as! String
            }
            if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                self.searchName = dict["SearchName"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var logicDatabase: GetLogicDatabaseResponseBody.LogicDatabase?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logicDatabase?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.logicDatabase != nil {
            map["LogicDatabase"] = self.logicDatabase?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("LogicDatabase") && dict["LogicDatabase"] != nil {
            var model = GetLogicDatabaseResponseBody.LogicDatabase()
            model.fromMap(dict["LogicDatabase"] as! [String: Any])
            self.logicDatabase = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetLogicDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLogicDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetLogicDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaTableColumnRequest : Tea.TeaModel {
    public var tableGuid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TableGuid") && dict["TableGuid"] != nil {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetMetaTableColumnResponseBody : Tea.TeaModel {
    public class ColumnList : Tea.TeaModel {
        public var autoIncrement: Bool?

        public var columnId: String?

        public var columnName: String?

        public var columnType: String?

        public var dataLength: Int64?

        public var dataPrecision: Int32?

        public var dataScale: Int32?

        public var description_: String?

        public var nullable: Bool?

        public var position: Int32?

        public var primaryKey: String?

        public var securityLevel: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoIncrement != nil {
                map["AutoIncrement"] = self.autoIncrement!
            }
            if self.columnId != nil {
                map["ColumnId"] = self.columnId!
            }
            if self.columnName != nil {
                map["ColumnName"] = self.columnName!
            }
            if self.columnType != nil {
                map["ColumnType"] = self.columnType!
            }
            if self.dataLength != nil {
                map["DataLength"] = self.dataLength!
            }
            if self.dataPrecision != nil {
                map["DataPrecision"] = self.dataPrecision!
            }
            if self.dataScale != nil {
                map["DataScale"] = self.dataScale!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.nullable != nil {
                map["Nullable"] = self.nullable!
            }
            if self.position != nil {
                map["Position"] = self.position!
            }
            if self.primaryKey != nil {
                map["PrimaryKey"] = self.primaryKey!
            }
            if self.securityLevel != nil {
                map["SecurityLevel"] = self.securityLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoIncrement") && dict["AutoIncrement"] != nil {
                self.autoIncrement = dict["AutoIncrement"] as! Bool
            }
            if dict.keys.contains("ColumnId") && dict["ColumnId"] != nil {
                self.columnId = dict["ColumnId"] as! String
            }
            if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
                self.columnName = dict["ColumnName"] as! String
            }
            if dict.keys.contains("ColumnType") && dict["ColumnType"] != nil {
                self.columnType = dict["ColumnType"] as! String
            }
            if dict.keys.contains("DataLength") && dict["DataLength"] != nil {
                self.dataLength = dict["DataLength"] as! Int64
            }
            if dict.keys.contains("DataPrecision") && dict["DataPrecision"] != nil {
                self.dataPrecision = dict["DataPrecision"] as! Int32
            }
            if dict.keys.contains("DataScale") && dict["DataScale"] != nil {
                self.dataScale = dict["DataScale"] as! Int32
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Nullable") && dict["Nullable"] != nil {
                self.nullable = dict["Nullable"] as! Bool
            }
            if dict.keys.contains("Position") && dict["Position"] != nil {
                self.position = dict["Position"] as! Int32
            }
            if dict.keys.contains("PrimaryKey") && dict["PrimaryKey"] != nil {
                self.primaryKey = dict["PrimaryKey"] as! String
            }
            if dict.keys.contains("SecurityLevel") && dict["SecurityLevel"] != nil {
                self.securityLevel = dict["SecurityLevel"] as! String
            }
        }
    }
    public var columnList: [GetMetaTableColumnResponseBody.ColumnList]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnList != nil {
            var tmp : [Any] = []
            for k in self.columnList! {
                tmp.append(k.toMap())
            }
            map["ColumnList"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnList") && dict["ColumnList"] != nil {
            var tmp : [GetMetaTableColumnResponseBody.ColumnList] = []
            for v in dict["ColumnList"] as! [Any] {
                var model = GetMetaTableColumnResponseBody.ColumnList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.columnList = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMetaTableColumnResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableColumnResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMetaTableColumnResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMetaTableDetailInfoRequest : Tea.TeaModel {
    public var tableGuid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TableGuid") && dict["TableGuid"] != nil {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetMetaTableDetailInfoResponseBody : Tea.TeaModel {
    public class DetailInfo : Tea.TeaModel {
        public class ColumnList : Tea.TeaModel {
            public var autoIncrement: Bool?

            public var columnId: String?

            public var columnName: String?

            public var columnType: String?

            public var dataLength: Int64?

            public var dataPrecision: Int32?

            public var dataScale: Int32?

            public var description_: String?

            public var nullable: Bool?

            public var position: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoIncrement != nil {
                    map["AutoIncrement"] = self.autoIncrement!
                }
                if self.columnId != nil {
                    map["ColumnId"] = self.columnId!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.columnType != nil {
                    map["ColumnType"] = self.columnType!
                }
                if self.dataLength != nil {
                    map["DataLength"] = self.dataLength!
                }
                if self.dataPrecision != nil {
                    map["DataPrecision"] = self.dataPrecision!
                }
                if self.dataScale != nil {
                    map["DataScale"] = self.dataScale!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.nullable != nil {
                    map["Nullable"] = self.nullable!
                }
                if self.position != nil {
                    map["Position"] = self.position!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoIncrement") && dict["AutoIncrement"] != nil {
                    self.autoIncrement = dict["AutoIncrement"] as! Bool
                }
                if dict.keys.contains("ColumnId") && dict["ColumnId"] != nil {
                    self.columnId = dict["ColumnId"] as! String
                }
                if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("ColumnType") && dict["ColumnType"] != nil {
                    self.columnType = dict["ColumnType"] as! String
                }
                if dict.keys.contains("DataLength") && dict["DataLength"] != nil {
                    self.dataLength = dict["DataLength"] as! Int64
                }
                if dict.keys.contains("DataPrecision") && dict["DataPrecision"] != nil {
                    self.dataPrecision = dict["DataPrecision"] as! Int32
                }
                if dict.keys.contains("DataScale") && dict["DataScale"] != nil {
                    self.dataScale = dict["DataScale"] as! Int32
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Nullable") && dict["Nullable"] != nil {
                    self.nullable = dict["Nullable"] as! Bool
                }
                if dict.keys.contains("Position") && dict["Position"] != nil {
                    self.position = dict["Position"] as! String
                }
            }
        }
        public class IndexList : Tea.TeaModel {
            public var indexColumns: [String]?

            public var indexId: String?

            public var indexName: String?

            public var indexType: String?

            public var unique: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.indexColumns != nil {
                    map["IndexColumns"] = self.indexColumns!
                }
                if self.indexId != nil {
                    map["IndexId"] = self.indexId!
                }
                if self.indexName != nil {
                    map["IndexName"] = self.indexName!
                }
                if self.indexType != nil {
                    map["IndexType"] = self.indexType!
                }
                if self.unique != nil {
                    map["Unique"] = self.unique!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IndexColumns") && dict["IndexColumns"] != nil {
                    self.indexColumns = dict["IndexColumns"] as! [String]
                }
                if dict.keys.contains("IndexId") && dict["IndexId"] != nil {
                    self.indexId = dict["IndexId"] as! String
                }
                if dict.keys.contains("IndexName") && dict["IndexName"] != nil {
                    self.indexName = dict["IndexName"] as! String
                }
                if dict.keys.contains("IndexType") && dict["IndexType"] != nil {
                    self.indexType = dict["IndexType"] as! String
                }
                if dict.keys.contains("Unique") && dict["Unique"] != nil {
                    self.unique = dict["Unique"] as! Bool
                }
            }
        }
        public var columnList: [GetMetaTableDetailInfoResponseBody.DetailInfo.ColumnList]?

        public var indexList: [GetMetaTableDetailInfoResponseBody.DetailInfo.IndexList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columnList != nil {
                var tmp : [Any] = []
                for k in self.columnList! {
                    tmp.append(k.toMap())
                }
                map["ColumnList"] = tmp
            }
            if self.indexList != nil {
                var tmp : [Any] = []
                for k in self.indexList! {
                    tmp.append(k.toMap())
                }
                map["IndexList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ColumnList") && dict["ColumnList"] != nil {
                var tmp : [GetMetaTableDetailInfoResponseBody.DetailInfo.ColumnList] = []
                for v in dict["ColumnList"] as! [Any] {
                    var model = GetMetaTableDetailInfoResponseBody.DetailInfo.ColumnList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.columnList = tmp
            }
            if dict.keys.contains("IndexList") && dict["IndexList"] != nil {
                var tmp : [GetMetaTableDetailInfoResponseBody.DetailInfo.IndexList] = []
                for v in dict["IndexList"] as! [Any] {
                    var model = GetMetaTableDetailInfoResponseBody.DetailInfo.IndexList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.indexList = tmp
            }
        }
    }
    public var detailInfo: GetMetaTableDetailInfoResponseBody.DetailInfo?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.detailInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.detailInfo != nil {
            map["DetailInfo"] = self.detailInfo?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DetailInfo") && dict["DetailInfo"] != nil {
            var model = GetMetaTableDetailInfoResponseBody.DetailInfo()
            model.fromMap(dict["DetailInfo"] as! [String: Any])
            self.detailInfo = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMetaTableDetailInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaTableDetailInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMetaTableDetailInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOnlineDDLProgressRequest : Tea.TeaModel {
    public var jobDetailId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobDetailId != nil {
            map["JobDetailId"] = self.jobDetailId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobDetailId") && dict["JobDetailId"] != nil {
            self.jobDetailId = dict["JobDetailId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetOnlineDDLProgressResponseBody : Tea.TeaModel {
    public class OnlineDDLTaskDetail : Tea.TeaModel {
        public var cleanStrategy: String?

        public var copyChunkMode: String?

        public var copyChunkSize: Int64?

        public var copyCount: Int64?

        public var copyTotal: Int64?

        public var cutoverFailRetryTimes: Int64?

        public var cutoverLockTimeSeconds: Int64?

        public var cutoverWindowEndTime: String?

        public var cutoverWindowStartTime: String?

        public var delaySeconds: Int64?

        public var jobStatus: String?

        public var progressRatio: String?

        public var statusDesc: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cleanStrategy != nil {
                map["CleanStrategy"] = self.cleanStrategy!
            }
            if self.copyChunkMode != nil {
                map["CopyChunkMode"] = self.copyChunkMode!
            }
            if self.copyChunkSize != nil {
                map["CopyChunkSize"] = self.copyChunkSize!
            }
            if self.copyCount != nil {
                map["CopyCount"] = self.copyCount!
            }
            if self.copyTotal != nil {
                map["CopyTotal"] = self.copyTotal!
            }
            if self.cutoverFailRetryTimes != nil {
                map["CutoverFailRetryTimes"] = self.cutoverFailRetryTimes!
            }
            if self.cutoverLockTimeSeconds != nil {
                map["CutoverLockTimeSeconds"] = self.cutoverLockTimeSeconds!
            }
            if self.cutoverWindowEndTime != nil {
                map["CutoverWindowEndTime"] = self.cutoverWindowEndTime!
            }
            if self.cutoverWindowStartTime != nil {
                map["CutoverWindowStartTime"] = self.cutoverWindowStartTime!
            }
            if self.delaySeconds != nil {
                map["DelaySeconds"] = self.delaySeconds!
            }
            if self.jobStatus != nil {
                map["JobStatus"] = self.jobStatus!
            }
            if self.progressRatio != nil {
                map["ProgressRatio"] = self.progressRatio!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CleanStrategy") && dict["CleanStrategy"] != nil {
                self.cleanStrategy = dict["CleanStrategy"] as! String
            }
            if dict.keys.contains("CopyChunkMode") && dict["CopyChunkMode"] != nil {
                self.copyChunkMode = dict["CopyChunkMode"] as! String
            }
            if dict.keys.contains("CopyChunkSize") && dict["CopyChunkSize"] != nil {
                self.copyChunkSize = dict["CopyChunkSize"] as! Int64
            }
            if dict.keys.contains("CopyCount") && dict["CopyCount"] != nil {
                self.copyCount = dict["CopyCount"] as! Int64
            }
            if dict.keys.contains("CopyTotal") && dict["CopyTotal"] != nil {
                self.copyTotal = dict["CopyTotal"] as! Int64
            }
            if dict.keys.contains("CutoverFailRetryTimes") && dict["CutoverFailRetryTimes"] != nil {
                self.cutoverFailRetryTimes = dict["CutoverFailRetryTimes"] as! Int64
            }
            if dict.keys.contains("CutoverLockTimeSeconds") && dict["CutoverLockTimeSeconds"] != nil {
                self.cutoverLockTimeSeconds = dict["CutoverLockTimeSeconds"] as! Int64
            }
            if dict.keys.contains("CutoverWindowEndTime") && dict["CutoverWindowEndTime"] != nil {
                self.cutoverWindowEndTime = dict["CutoverWindowEndTime"] as! String
            }
            if dict.keys.contains("CutoverWindowStartTime") && dict["CutoverWindowStartTime"] != nil {
                self.cutoverWindowStartTime = dict["CutoverWindowStartTime"] as! String
            }
            if dict.keys.contains("DelaySeconds") && dict["DelaySeconds"] != nil {
                self.delaySeconds = dict["DelaySeconds"] as! Int64
            }
            if dict.keys.contains("JobStatus") && dict["JobStatus"] != nil {
                self.jobStatus = dict["JobStatus"] as! String
            }
            if dict.keys.contains("ProgressRatio") && dict["ProgressRatio"] != nil {
                self.progressRatio = dict["ProgressRatio"] as! String
            }
            if dict.keys.contains("StatusDesc") && dict["StatusDesc"] != nil {
                self.statusDesc = dict["StatusDesc"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var onlineDDLTaskDetail: GetOnlineDDLProgressResponseBody.OnlineDDLTaskDetail?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.onlineDDLTaskDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.onlineDDLTaskDetail != nil {
            map["OnlineDDLTaskDetail"] = self.onlineDDLTaskDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("OnlineDDLTaskDetail") && dict["OnlineDDLTaskDetail"] != nil {
            var model = GetOnlineDDLProgressResponseBody.OnlineDDLTaskDetail()
            model.fromMap(dict["OnlineDDLTaskDetail"] as! [String: Any])
            self.onlineDDLTaskDetail = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetOnlineDDLProgressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOnlineDDLProgressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOnlineDDLProgressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOpLogRequest : Tea.TeaModel {
    public var databaseName: String?

    public var endTime: String?

    public var module: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: String?

    public var tid: Int64?

    public var userNick: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.module != nil {
            map["Module"] = self.module!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userNick != nil {
            map["UserNick"] = self.userNick!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseName") && dict["DatabaseName"] != nil {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Module") && dict["Module"] != nil {
            self.module = dict["Module"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserNick") && dict["UserNick"] != nil {
            self.userNick = dict["UserNick"] as! String
        }
    }
}

public class GetOpLogResponseBody : Tea.TeaModel {
    public class OpLogDetails : Tea.TeaModel {
        public class OpLogDetail : Tea.TeaModel {
            public var database: String?

            public var module: String?

            public var opContent: String?

            public var opTime: String?

            public var opUserId: Int64?

            public var orderId: Int64?

            public var userId: String?

            public var userNick: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.database != nil {
                    map["Database"] = self.database!
                }
                if self.module != nil {
                    map["Module"] = self.module!
                }
                if self.opContent != nil {
                    map["OpContent"] = self.opContent!
                }
                if self.opTime != nil {
                    map["OpTime"] = self.opTime!
                }
                if self.opUserId != nil {
                    map["OpUserId"] = self.opUserId!
                }
                if self.orderId != nil {
                    map["OrderId"] = self.orderId!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userNick != nil {
                    map["UserNick"] = self.userNick!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Database") && dict["Database"] != nil {
                    self.database = dict["Database"] as! String
                }
                if dict.keys.contains("Module") && dict["Module"] != nil {
                    self.module = dict["Module"] as! String
                }
                if dict.keys.contains("OpContent") && dict["OpContent"] != nil {
                    self.opContent = dict["OpContent"] as! String
                }
                if dict.keys.contains("OpTime") && dict["OpTime"] != nil {
                    self.opTime = dict["OpTime"] as! String
                }
                if dict.keys.contains("OpUserId") && dict["OpUserId"] != nil {
                    self.opUserId = dict["OpUserId"] as! Int64
                }
                if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
                    self.orderId = dict["OrderId"] as! Int64
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserNick") && dict["UserNick"] != nil {
                    self.userNick = dict["UserNick"] as! String
                }
            }
        }
        public var opLogDetail: [GetOpLogResponseBody.OpLogDetails.OpLogDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.opLogDetail != nil {
                var tmp : [Any] = []
                for k in self.opLogDetail! {
                    tmp.append(k.toMap())
                }
                map["OpLogDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OpLogDetail") && dict["OpLogDetail"] != nil {
                var tmp : [GetOpLogResponseBody.OpLogDetails.OpLogDetail] = []
                for v in dict["OpLogDetail"] as! [Any] {
                    var model = GetOpLogResponseBody.OpLogDetails.OpLogDetail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.opLogDetail = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var opLogDetails: GetOpLogResponseBody.OpLogDetails?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.opLogDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.opLogDetails != nil {
            map["OpLogDetails"] = self.opLogDetails?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("OpLogDetails") && dict["OpLogDetails"] != nil {
            var model = GetOpLogResponseBody.OpLogDetails()
            model.fromMap(dict["OpLogDetails"] as! [String: Any])
            self.opLogDetails = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class GetOpLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOpLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOpLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOrderAttachmentFileRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetOrderAttachmentFileResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var fileUrl: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetOrderAttachmentFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOrderAttachmentFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOrderAttachmentFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOrderBaseInfoRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetOrderBaseInfoResponseBody : Tea.TeaModel {
    public class OrderBaseInfo : Tea.TeaModel {
        public class RelatedUserList : Tea.TeaModel {
            public var userIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.userIds != nil {
                    map["UserIds"] = self.userIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("UserIds") && dict["UserIds"] != nil {
                    self.userIds = dict["UserIds"] as! [String]
                }
            }
        }
        public class RelatedUserNickList : Tea.TeaModel {
            public var userNicks: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.userNicks != nil {
                    map["UserNicks"] = self.userNicks!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("UserNicks") && dict["UserNicks"] != nil {
                    self.userNicks = dict["UserNicks"] as! [String]
                }
            }
        }
        public var comment: String?

        public var committer: String?

        public var committerId: Int64?

        public var createTime: String?

        public var lastModifyTime: String?

        public var orderId: Int64?

        public var pluginType: String?

        public var relatedUserList: GetOrderBaseInfoResponseBody.OrderBaseInfo.RelatedUserList?

        public var relatedUserNickList: GetOrderBaseInfoResponseBody.OrderBaseInfo.RelatedUserNickList?

        public var statusCode: String?

        public var statusDesc: String?

        public var workflowInstanceId: Int64?

        public var workflowStatusDesc: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.relatedUserList?.validate()
            try self.relatedUserNickList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.committer != nil {
                map["Committer"] = self.committer!
            }
            if self.committerId != nil {
                map["CommitterId"] = self.committerId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastModifyTime != nil {
                map["LastModifyTime"] = self.lastModifyTime!
            }
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            if self.pluginType != nil {
                map["PluginType"] = self.pluginType!
            }
            if self.relatedUserList != nil {
                map["RelatedUserList"] = self.relatedUserList?.toMap()
            }
            if self.relatedUserNickList != nil {
                map["RelatedUserNickList"] = self.relatedUserNickList?.toMap()
            }
            if self.statusCode != nil {
                map["StatusCode"] = self.statusCode!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.workflowInstanceId != nil {
                map["WorkflowInstanceId"] = self.workflowInstanceId!
            }
            if self.workflowStatusDesc != nil {
                map["WorkflowStatusDesc"] = self.workflowStatusDesc!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Comment") && dict["Comment"] != nil {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("Committer") && dict["Committer"] != nil {
                self.committer = dict["Committer"] as! String
            }
            if dict.keys.contains("CommitterId") && dict["CommitterId"] != nil {
                self.committerId = dict["CommitterId"] as! Int64
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("LastModifyTime") && dict["LastModifyTime"] != nil {
                self.lastModifyTime = dict["LastModifyTime"] as! String
            }
            if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
                self.orderId = dict["OrderId"] as! Int64
            }
            if dict.keys.contains("PluginType") && dict["PluginType"] != nil {
                self.pluginType = dict["PluginType"] as! String
            }
            if dict.keys.contains("RelatedUserList") && dict["RelatedUserList"] != nil {
                var model = GetOrderBaseInfoResponseBody.OrderBaseInfo.RelatedUserList()
                model.fromMap(dict["RelatedUserList"] as! [String: Any])
                self.relatedUserList = model
            }
            if dict.keys.contains("RelatedUserNickList") && dict["RelatedUserNickList"] != nil {
                var model = GetOrderBaseInfoResponseBody.OrderBaseInfo.RelatedUserNickList()
                model.fromMap(dict["RelatedUserNickList"] as! [String: Any])
                self.relatedUserNickList = model
            }
            if dict.keys.contains("StatusCode") && dict["StatusCode"] != nil {
                self.statusCode = dict["StatusCode"] as! String
            }
            if dict.keys.contains("StatusDesc") && dict["StatusDesc"] != nil {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("WorkflowInstanceId") && dict["WorkflowInstanceId"] != nil {
                self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
            }
            if dict.keys.contains("WorkflowStatusDesc") && dict["WorkflowStatusDesc"] != nil {
                self.workflowStatusDesc = dict["WorkflowStatusDesc"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var orderBaseInfo: GetOrderBaseInfoResponseBody.OrderBaseInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.orderBaseInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.orderBaseInfo != nil {
            map["OrderBaseInfo"] = self.orderBaseInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("OrderBaseInfo") && dict["OrderBaseInfo"] != nil {
            var model = GetOrderBaseInfoResponseBody.OrderBaseInfo()
            model.fromMap(dict["OrderBaseInfo"] as! [String: Any])
            self.orderBaseInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetOrderBaseInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOrderBaseInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOrderBaseInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOwnerApplyOrderDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetOwnerApplyOrderDetailResponseBody : Tea.TeaModel {
    public class OwnerApplyOrderDetail : Tea.TeaModel {
        public class Resources : Tea.TeaModel {
            public class ResourceDetail : Tea.TeaModel {
                public var dbType: String?

                public var envType: String?

                public var ownerIds: [Int64]?

                public var ownerNickNames: [String]?

                public var searchName: String?

                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dbType != nil {
                        map["DbType"] = self.dbType!
                    }
                    if self.envType != nil {
                        map["EnvType"] = self.envType!
                    }
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    if self.ownerNickNames != nil {
                        map["OwnerNickNames"] = self.ownerNickNames!
                    }
                    if self.searchName != nil {
                        map["SearchName"] = self.searchName!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DbType") && dict["DbType"] != nil {
                        self.dbType = dict["DbType"] as! String
                    }
                    if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                        self.envType = dict["EnvType"] as! String
                    }
                    if dict.keys.contains("OwnerIds") && dict["OwnerIds"] != nil {
                        self.ownerIds = dict["OwnerIds"] as! [Int64]
                    }
                    if dict.keys.contains("OwnerNickNames") && dict["OwnerNickNames"] != nil {
                        self.ownerNickNames = dict["OwnerNickNames"] as! [String]
                    }
                    if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                        self.searchName = dict["SearchName"] as! String
                    }
                    if dict.keys.contains("TableName") && dict["TableName"] != nil {
                        self.tableName = dict["TableName"] as! String
                    }
                }
            }
            public var logic: Bool?

            public var resourceDetail: GetOwnerApplyOrderDetailResponseBody.OwnerApplyOrderDetail.Resources.ResourceDetail?

            public var targetId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.resourceDetail?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.resourceDetail != nil {
                    map["ResourceDetail"] = self.resourceDetail?.toMap()
                }
                if self.targetId != nil {
                    map["TargetId"] = self.targetId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("ResourceDetail") && dict["ResourceDetail"] != nil {
                    var model = GetOwnerApplyOrderDetailResponseBody.OwnerApplyOrderDetail.Resources.ResourceDetail()
                    model.fromMap(dict["ResourceDetail"] as! [String: Any])
                    self.resourceDetail = model
                }
                if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                    self.targetId = dict["TargetId"] as! String
                }
            }
        }
        public var applyType: String?

        public var resources: [GetOwnerApplyOrderDetailResponseBody.OwnerApplyOrderDetail.Resources]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applyType != nil {
                map["ApplyType"] = self.applyType!
            }
            if self.resources != nil {
                var tmp : [Any] = []
                for k in self.resources! {
                    tmp.append(k.toMap())
                }
                map["Resources"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplyType") && dict["ApplyType"] != nil {
                self.applyType = dict["ApplyType"] as! String
            }
            if dict.keys.contains("Resources") && dict["Resources"] != nil {
                var tmp : [GetOwnerApplyOrderDetailResponseBody.OwnerApplyOrderDetail.Resources] = []
                for v in dict["Resources"] as! [Any] {
                    var model = GetOwnerApplyOrderDetailResponseBody.OwnerApplyOrderDetail.Resources()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resources = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var ownerApplyOrderDetail: GetOwnerApplyOrderDetailResponseBody.OwnerApplyOrderDetail?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ownerApplyOrderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.ownerApplyOrderDetail != nil {
            map["OwnerApplyOrderDetail"] = self.ownerApplyOrderDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("OwnerApplyOrderDetail") && dict["OwnerApplyOrderDetail"] != nil {
            var model = GetOwnerApplyOrderDetailResponseBody.OwnerApplyOrderDetail()
            model.fromMap(dict["OwnerApplyOrderDetail"] as! [String: Any])
            self.ownerApplyOrderDetail = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetOwnerApplyOrderDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOwnerApplyOrderDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOwnerApplyOrderDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPermApplyOrderDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetPermApplyOrderDetailResponseBody : Tea.TeaModel {
    public class PermApplyOrderDetail : Tea.TeaModel {
        public class Resources : Tea.TeaModel {
            public class ColumnInfo : Tea.TeaModel {
                public var columnName: String?

                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.columnName != nil {
                        map["ColumnName"] = self.columnName!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
                        self.columnName = dict["ColumnName"] as! String
                    }
                    if dict.keys.contains("TableName") && dict["TableName"] != nil {
                        self.tableName = dict["TableName"] as! String
                    }
                }
            }
            public class DatabaseInfo : Tea.TeaModel {
                public var dbId: Int64?

                public var dbType: String?

                public var envType: String?

                public var logic: Bool?

                public var ownerIds: [Int64]?

                public var ownerNickNames: [String]?

                public var searchName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dbId != nil {
                        map["DbId"] = self.dbId!
                    }
                    if self.dbType != nil {
                        map["DbType"] = self.dbType!
                    }
                    if self.envType != nil {
                        map["EnvType"] = self.envType!
                    }
                    if self.logic != nil {
                        map["Logic"] = self.logic!
                    }
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    if self.ownerNickNames != nil {
                        map["OwnerNickNames"] = self.ownerNickNames!
                    }
                    if self.searchName != nil {
                        map["SearchName"] = self.searchName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DbId") && dict["DbId"] != nil {
                        self.dbId = dict["DbId"] as! Int64
                    }
                    if dict.keys.contains("DbType") && dict["DbType"] != nil {
                        self.dbType = dict["DbType"] as! String
                    }
                    if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                        self.envType = dict["EnvType"] as! String
                    }
                    if dict.keys.contains("Logic") && dict["Logic"] != nil {
                        self.logic = dict["Logic"] as! Bool
                    }
                    if dict.keys.contains("OwnerIds") && dict["OwnerIds"] != nil {
                        self.ownerIds = dict["OwnerIds"] as! [Int64]
                    }
                    if dict.keys.contains("OwnerNickNames") && dict["OwnerNickNames"] != nil {
                        self.ownerNickNames = dict["OwnerNickNames"] as! [String]
                    }
                    if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                        self.searchName = dict["SearchName"] as! String
                    }
                }
            }
            public class InstanceInfo : Tea.TeaModel {
                public var dbType: String?

                public var dbaId: Int64?

                public var dbaNickName: String?

                public var envType: String?

                public var host: String?

                public var instanceId: String?

                public var ownerIds: [Int64]?

                public var ownerNickName: [String]?

                public var port: Int64?

                public var searchName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dbType != nil {
                        map["DbType"] = self.dbType!
                    }
                    if self.dbaId != nil {
                        map["DbaId"] = self.dbaId!
                    }
                    if self.dbaNickName != nil {
                        map["DbaNickName"] = self.dbaNickName!
                    }
                    if self.envType != nil {
                        map["EnvType"] = self.envType!
                    }
                    if self.host != nil {
                        map["Host"] = self.host!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    if self.ownerNickName != nil {
                        map["OwnerNickName"] = self.ownerNickName!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.searchName != nil {
                        map["SearchName"] = self.searchName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DbType") && dict["DbType"] != nil {
                        self.dbType = dict["DbType"] as! String
                    }
                    if dict.keys.contains("DbaId") && dict["DbaId"] != nil {
                        self.dbaId = dict["DbaId"] as! Int64
                    }
                    if dict.keys.contains("DbaNickName") && dict["DbaNickName"] != nil {
                        self.dbaNickName = dict["DbaNickName"] as! String
                    }
                    if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                        self.envType = dict["EnvType"] as! String
                    }
                    if dict.keys.contains("Host") && dict["Host"] != nil {
                        self.host = dict["Host"] as! String
                    }
                    if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("OwnerIds") && dict["OwnerIds"] != nil {
                        self.ownerIds = dict["OwnerIds"] as! [Int64]
                    }
                    if dict.keys.contains("OwnerNickName") && dict["OwnerNickName"] != nil {
                        self.ownerNickName = dict["OwnerNickName"] as! [String]
                    }
                    if dict.keys.contains("Port") && dict["Port"] != nil {
                        self.port = dict["Port"] as! Int64
                    }
                    if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                        self.searchName = dict["SearchName"] as! String
                    }
                }
            }
            public class TableInfo : Tea.TeaModel {
                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TableName") && dict["TableName"] != nil {
                        self.tableName = dict["TableName"] as! String
                    }
                }
            }
            public var columnInfo: GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources.ColumnInfo?

            public var databaseInfo: GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources.DatabaseInfo?

            public var instanceInfo: GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources.InstanceInfo?

            public var tableInfo: GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources.TableInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.columnInfo?.validate()
                try self.databaseInfo?.validate()
                try self.instanceInfo?.validate()
                try self.tableInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columnInfo != nil {
                    map["ColumnInfo"] = self.columnInfo?.toMap()
                }
                if self.databaseInfo != nil {
                    map["DatabaseInfo"] = self.databaseInfo?.toMap()
                }
                if self.instanceInfo != nil {
                    map["InstanceInfo"] = self.instanceInfo?.toMap()
                }
                if self.tableInfo != nil {
                    map["TableInfo"] = self.tableInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColumnInfo") && dict["ColumnInfo"] != nil {
                    var model = GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources.ColumnInfo()
                    model.fromMap(dict["ColumnInfo"] as! [String: Any])
                    self.columnInfo = model
                }
                if dict.keys.contains("DatabaseInfo") && dict["DatabaseInfo"] != nil {
                    var model = GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources.DatabaseInfo()
                    model.fromMap(dict["DatabaseInfo"] as! [String: Any])
                    self.databaseInfo = model
                }
                if dict.keys.contains("InstanceInfo") && dict["InstanceInfo"] != nil {
                    var model = GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources.InstanceInfo()
                    model.fromMap(dict["InstanceInfo"] as! [String: Any])
                    self.instanceInfo = model
                }
                if dict.keys.contains("TableInfo") && dict["TableInfo"] != nil {
                    var model = GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources.TableInfo()
                    model.fromMap(dict["TableInfo"] as! [String: Any])
                    self.tableInfo = model
                }
            }
        }
        public var applyType: String?

        public var permType: Int64?

        public var resources: [GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources]?

        public var seconds: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applyType != nil {
                map["ApplyType"] = self.applyType!
            }
            if self.permType != nil {
                map["PermType"] = self.permType!
            }
            if self.resources != nil {
                var tmp : [Any] = []
                for k in self.resources! {
                    tmp.append(k.toMap())
                }
                map["Resources"] = tmp
            }
            if self.seconds != nil {
                map["Seconds"] = self.seconds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplyType") && dict["ApplyType"] != nil {
                self.applyType = dict["ApplyType"] as! String
            }
            if dict.keys.contains("PermType") && dict["PermType"] != nil {
                self.permType = dict["PermType"] as! Int64
            }
            if dict.keys.contains("Resources") && dict["Resources"] != nil {
                var tmp : [GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources] = []
                for v in dict["Resources"] as! [Any] {
                    var model = GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail.Resources()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resources = tmp
            }
            if dict.keys.contains("Seconds") && dict["Seconds"] != nil {
                self.seconds = dict["Seconds"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var permApplyOrderDetail: GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.permApplyOrderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.permApplyOrderDetail != nil {
            map["PermApplyOrderDetail"] = self.permApplyOrderDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("PermApplyOrderDetail") && dict["PermApplyOrderDetail"] != nil {
            var model = GetPermApplyOrderDetailResponseBody.PermApplyOrderDetail()
            model.fromMap(dict["PermApplyOrderDetail"] as! [String: Any])
            self.permApplyOrderDetail = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetPermApplyOrderDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPermApplyOrderDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetPermApplyOrderDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPhysicalDatabaseRequest : Tea.TeaModel {
    public var dbId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") && dict["DbId"] != nil {
            self.dbId = dict["DbId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetPhysicalDatabaseResponseBody : Tea.TeaModel {
    public class Database : Tea.TeaModel {
        public class OwnerIdList : Tea.TeaModel {
            public var ownerIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ownerIds != nil {
                    map["OwnerIds"] = self.ownerIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OwnerIds") && dict["OwnerIds"] != nil {
                    self.ownerIds = dict["OwnerIds"] as! [String]
                }
            }
        }
        public class OwnerNameList : Tea.TeaModel {
            public var ownerNames: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ownerNames != nil {
                    map["OwnerNames"] = self.ownerNames!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OwnerNames") && dict["OwnerNames"] != nil {
                    self.ownerNames = dict["OwnerNames"] as! [String]
                }
            }
        }
        public var catalogName: String?

        public var databaseId: String?

        public var dbType: String?

        public var dbaId: String?

        public var dbaName: String?

        public var encoding: String?

        public var envType: String?

        public var host: String?

        public var instanceAlias: String?

        public var instanceId: String?

        public var ownerIdList: GetPhysicalDatabaseResponseBody.Database.OwnerIdList?

        public var ownerNameList: GetPhysicalDatabaseResponseBody.Database.OwnerNameList?

        public var port: Int32?

        public var schemaName: String?

        public var searchName: String?

        public var sid: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ownerIdList?.validate()
            try self.ownerNameList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.catalogName != nil {
                map["CatalogName"] = self.catalogName!
            }
            if self.databaseId != nil {
                map["DatabaseId"] = self.databaseId!
            }
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.dbaId != nil {
                map["DbaId"] = self.dbaId!
            }
            if self.dbaName != nil {
                map["DbaName"] = self.dbaName!
            }
            if self.encoding != nil {
                map["Encoding"] = self.encoding!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.instanceAlias != nil {
                map["InstanceAlias"] = self.instanceAlias!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.ownerIdList != nil {
                map["OwnerIdList"] = self.ownerIdList?.toMap()
            }
            if self.ownerNameList != nil {
                map["OwnerNameList"] = self.ownerNameList?.toMap()
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.searchName != nil {
                map["SearchName"] = self.searchName!
            }
            if self.sid != nil {
                map["Sid"] = self.sid!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CatalogName") && dict["CatalogName"] != nil {
                self.catalogName = dict["CatalogName"] as! String
            }
            if dict.keys.contains("DatabaseId") && dict["DatabaseId"] != nil {
                self.databaseId = dict["DatabaseId"] as! String
            }
            if dict.keys.contains("DbType") && dict["DbType"] != nil {
                self.dbType = dict["DbType"] as! String
            }
            if dict.keys.contains("DbaId") && dict["DbaId"] != nil {
                self.dbaId = dict["DbaId"] as! String
            }
            if dict.keys.contains("DbaName") && dict["DbaName"] != nil {
                self.dbaName = dict["DbaName"] as! String
            }
            if dict.keys.contains("Encoding") && dict["Encoding"] != nil {
                self.encoding = dict["Encoding"] as! String
            }
            if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                self.envType = dict["EnvType"] as! String
            }
            if dict.keys.contains("Host") && dict["Host"] != nil {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("InstanceAlias") && dict["InstanceAlias"] != nil {
                self.instanceAlias = dict["InstanceAlias"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("OwnerIdList") && dict["OwnerIdList"] != nil {
                var model = GetPhysicalDatabaseResponseBody.Database.OwnerIdList()
                model.fromMap(dict["OwnerIdList"] as! [String: Any])
                self.ownerIdList = model
            }
            if dict.keys.contains("OwnerNameList") && dict["OwnerNameList"] != nil {
                var model = GetPhysicalDatabaseResponseBody.Database.OwnerNameList()
                model.fromMap(dict["OwnerNameList"] as! [String: Any])
                self.ownerNameList = model
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
                self.schemaName = dict["SchemaName"] as! String
            }
            if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                self.searchName = dict["SearchName"] as! String
            }
            if dict.keys.contains("Sid") && dict["Sid"] != nil {
                self.sid = dict["Sid"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
        }
    }
    public var database: GetPhysicalDatabaseResponseBody.Database?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.database?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.database != nil {
            map["Database"] = self.database?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Database") && dict["Database"] != nil {
            var model = GetPhysicalDatabaseResponseBody.Database()
            model.fromMap(dict["Database"] as! [String: Any])
            self.database = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetPhysicalDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPhysicalDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetPhysicalDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProxyRequest : Tea.TeaModel {
    public var proxyId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.proxyId != nil {
            map["ProxyId"] = self.proxyId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProxyId") && dict["ProxyId"] != nil {
            self.proxyId = dict["ProxyId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetProxyResponseBody : Tea.TeaModel {
    public var creatorId: Int64?

    public var creatorName: String?

    public var errorCode: String?

    public var errorMessage: String?

    public var httpsPort: Int32?

    public var instanceId: Int64?

    public var privateEnable: Bool?

    public var privateHost: String?

    public var protocolPort: Int32?

    public var protocolType: String?

    public var proxyId: Int64?

    public var publicEnable: Bool?

    public var publicHost: String?

    public var regionId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creatorId != nil {
            map["CreatorId"] = self.creatorId!
        }
        if self.creatorName != nil {
            map["CreatorName"] = self.creatorName!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.httpsPort != nil {
            map["HttpsPort"] = self.httpsPort!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.privateEnable != nil {
            map["PrivateEnable"] = self.privateEnable!
        }
        if self.privateHost != nil {
            map["PrivateHost"] = self.privateHost!
        }
        if self.protocolPort != nil {
            map["ProtocolPort"] = self.protocolPort!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.proxyId != nil {
            map["ProxyId"] = self.proxyId!
        }
        if self.publicEnable != nil {
            map["PublicEnable"] = self.publicEnable!
        }
        if self.publicHost != nil {
            map["PublicHost"] = self.publicHost!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
            self.creatorId = dict["CreatorId"] as! Int64
        }
        if dict.keys.contains("CreatorName") && dict["CreatorName"] != nil {
            self.creatorName = dict["CreatorName"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("HttpsPort") && dict["HttpsPort"] != nil {
            self.httpsPort = dict["HttpsPort"] as! Int32
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("PrivateEnable") && dict["PrivateEnable"] != nil {
            self.privateEnable = dict["PrivateEnable"] as! Bool
        }
        if dict.keys.contains("PrivateHost") && dict["PrivateHost"] != nil {
            self.privateHost = dict["PrivateHost"] as! String
        }
        if dict.keys.contains("ProtocolPort") && dict["ProtocolPort"] != nil {
            self.protocolPort = dict["ProtocolPort"] as! Int32
        }
        if dict.keys.contains("ProtocolType") && dict["ProtocolType"] != nil {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("ProxyId") && dict["ProxyId"] != nil {
            self.proxyId = dict["ProxyId"] as! Int64
        }
        if dict.keys.contains("PublicEnable") && dict["PublicEnable"] != nil {
            self.publicEnable = dict["PublicEnable"] as! Bool
        }
        if dict.keys.contains("PublicHost") && dict["PublicHost"] != nil {
            self.publicHost = dict["PublicHost"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetProxyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProxyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetProxyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProxyAccessRequest : Tea.TeaModel {
    public var proxyAccessId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.proxyAccessId != nil {
            map["ProxyAccessId"] = self.proxyAccessId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProxyAccessId") && dict["ProxyAccessId"] != nil {
            self.proxyAccessId = dict["ProxyAccessId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetProxyAccessResponseBody : Tea.TeaModel {
    public class ProxyAccess : Tea.TeaModel {
        public var accessId: String?

        public var gmtCreate: String?

        public var indepAccount: String?

        public var instanceId: Int64?

        public var originInfo: String?

        public var proxyAccessId: Int64?

        public var proxyId: Int64?

        public var userId: Int64?

        public var userName: String?

        public var userUid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessId != nil {
                map["AccessId"] = self.accessId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.indepAccount != nil {
                map["IndepAccount"] = self.indepAccount!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.originInfo != nil {
                map["OriginInfo"] = self.originInfo!
            }
            if self.proxyAccessId != nil {
                map["ProxyAccessId"] = self.proxyAccessId!
            }
            if self.proxyId != nil {
                map["ProxyId"] = self.proxyId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.userUid != nil {
                map["UserUid"] = self.userUid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessId") && dict["AccessId"] != nil {
                self.accessId = dict["AccessId"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("IndepAccount") && dict["IndepAccount"] != nil {
                self.indepAccount = dict["IndepAccount"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("OriginInfo") && dict["OriginInfo"] != nil {
                self.originInfo = dict["OriginInfo"] as! String
            }
            if dict.keys.contains("ProxyAccessId") && dict["ProxyAccessId"] != nil {
                self.proxyAccessId = dict["ProxyAccessId"] as! Int64
            }
            if dict.keys.contains("ProxyId") && dict["ProxyId"] != nil {
                self.proxyId = dict["ProxyId"] as! Int64
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! Int64
            }
            if dict.keys.contains("UserName") && dict["UserName"] != nil {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("UserUid") && dict["UserUid"] != nil {
                self.userUid = dict["UserUid"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var proxyAccess: GetProxyAccessResponseBody.ProxyAccess?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.proxyAccess?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.proxyAccess != nil {
            map["ProxyAccess"] = self.proxyAccess?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("ProxyAccess") && dict["ProxyAccess"] != nil {
            var model = GetProxyAccessResponseBody.ProxyAccess()
            model.fromMap(dict["ProxyAccess"] as! [String: Any])
            self.proxyAccess = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetProxyAccessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProxyAccessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetProxyAccessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRuleNumLimitOfSLARequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetRuleNumLimitOfSLAResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var ruleNumLimit: Int32?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleNumLimit != nil {
            map["RuleNumLimit"] = self.ruleNumLimit!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleNumLimit") && dict["RuleNumLimit"] != nil {
            self.ruleNumLimit = dict["RuleNumLimit"] as! Int32
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetRuleNumLimitOfSLAResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRuleNumLimitOfSLAResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetRuleNumLimitOfSLAResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSQLReviewCheckResultStatusRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetSQLReviewCheckResultStatusResponseBody : Tea.TeaModel {
    public class CheckResultStatus : Tea.TeaModel {
        public class CheckStatusResult : Tea.TeaModel {
            public var checkNotPass: Int64?

            public var checkPass: Int64?

            public var forceNotPass: Int64?

            public var forcePass: Int64?

            public var new: Int64?

            public var unknown: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkNotPass != nil {
                    map["CheckNotPass"] = self.checkNotPass!
                }
                if self.checkPass != nil {
                    map["CheckPass"] = self.checkPass!
                }
                if self.forceNotPass != nil {
                    map["ForceNotPass"] = self.forceNotPass!
                }
                if self.forcePass != nil {
                    map["ForcePass"] = self.forcePass!
                }
                if self.new != nil {
                    map["New"] = self.new!
                }
                if self.unknown != nil {
                    map["Unknown"] = self.unknown!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CheckNotPass") && dict["CheckNotPass"] != nil {
                    self.checkNotPass = dict["CheckNotPass"] as! Int64
                }
                if dict.keys.contains("CheckPass") && dict["CheckPass"] != nil {
                    self.checkPass = dict["CheckPass"] as! Int64
                }
                if dict.keys.contains("ForceNotPass") && dict["ForceNotPass"] != nil {
                    self.forceNotPass = dict["ForceNotPass"] as! Int64
                }
                if dict.keys.contains("ForcePass") && dict["ForcePass"] != nil {
                    self.forcePass = dict["ForcePass"] as! Int64
                }
                if dict.keys.contains("New") && dict["New"] != nil {
                    self.new = dict["New"] as! Int64
                }
                if dict.keys.contains("Unknown") && dict["Unknown"] != nil {
                    self.unknown = dict["Unknown"] as! Int64
                }
            }
        }
        public class SQLReviewResult : Tea.TeaModel {
            public var mustImprove: Int64?

            public var potentialIssue: Int64?

            public var suggestImprove: Int64?

            public var tableIndexSuggest: Int64?

            public var useDmsDmlUnlock: Int64?

            public var useDmsToolkit: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mustImprove != nil {
                    map["MustImprove"] = self.mustImprove!
                }
                if self.potentialIssue != nil {
                    map["PotentialIssue"] = self.potentialIssue!
                }
                if self.suggestImprove != nil {
                    map["SuggestImprove"] = self.suggestImprove!
                }
                if self.tableIndexSuggest != nil {
                    map["TableIndexSuggest"] = self.tableIndexSuggest!
                }
                if self.useDmsDmlUnlock != nil {
                    map["UseDmsDmlUnlock"] = self.useDmsDmlUnlock!
                }
                if self.useDmsToolkit != nil {
                    map["UseDmsToolkit"] = self.useDmsToolkit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MustImprove") && dict["MustImprove"] != nil {
                    self.mustImprove = dict["MustImprove"] as! Int64
                }
                if dict.keys.contains("PotentialIssue") && dict["PotentialIssue"] != nil {
                    self.potentialIssue = dict["PotentialIssue"] as! Int64
                }
                if dict.keys.contains("SuggestImprove") && dict["SuggestImprove"] != nil {
                    self.suggestImprove = dict["SuggestImprove"] as! Int64
                }
                if dict.keys.contains("TableIndexSuggest") && dict["TableIndexSuggest"] != nil {
                    self.tableIndexSuggest = dict["TableIndexSuggest"] as! Int64
                }
                if dict.keys.contains("UseDmsDmlUnlock") && dict["UseDmsDmlUnlock"] != nil {
                    self.useDmsDmlUnlock = dict["UseDmsDmlUnlock"] as! Int64
                }
                if dict.keys.contains("UseDmsToolkit") && dict["UseDmsToolkit"] != nil {
                    self.useDmsToolkit = dict["UseDmsToolkit"] as! Int64
                }
            }
        }
        public var checkStatusResult: GetSQLReviewCheckResultStatusResponseBody.CheckResultStatus.CheckStatusResult?

        public var checkedCount: Int64?

        public var SQLReviewResult: GetSQLReviewCheckResultStatusResponseBody.CheckResultStatus.SQLReviewResult?

        public var totalSQLCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkStatusResult?.validate()
            try self.SQLReviewResult?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkStatusResult != nil {
                map["CheckStatusResult"] = self.checkStatusResult?.toMap()
            }
            if self.checkedCount != nil {
                map["CheckedCount"] = self.checkedCount!
            }
            if self.SQLReviewResult != nil {
                map["SQLReviewResult"] = self.SQLReviewResult?.toMap()
            }
            if self.totalSQLCount != nil {
                map["TotalSQLCount"] = self.totalSQLCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckStatusResult") && dict["CheckStatusResult"] != nil {
                var model = GetSQLReviewCheckResultStatusResponseBody.CheckResultStatus.CheckStatusResult()
                model.fromMap(dict["CheckStatusResult"] as! [String: Any])
                self.checkStatusResult = model
            }
            if dict.keys.contains("CheckedCount") && dict["CheckedCount"] != nil {
                self.checkedCount = dict["CheckedCount"] as! Int64
            }
            if dict.keys.contains("SQLReviewResult") && dict["SQLReviewResult"] != nil {
                var model = GetSQLReviewCheckResultStatusResponseBody.CheckResultStatus.SQLReviewResult()
                model.fromMap(dict["SQLReviewResult"] as! [String: Any])
                self.SQLReviewResult = model
            }
            if dict.keys.contains("TotalSQLCount") && dict["TotalSQLCount"] != nil {
                self.totalSQLCount = dict["TotalSQLCount"] as! Int64
            }
        }
    }
    public var checkResultStatus: GetSQLReviewCheckResultStatusResponseBody.CheckResultStatus?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.checkResultStatus?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkResultStatus != nil {
            map["CheckResultStatus"] = self.checkResultStatus?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckResultStatus") && dict["CheckResultStatus"] != nil {
            var model = GetSQLReviewCheckResultStatusResponseBody.CheckResultStatus()
            model.fromMap(dict["CheckResultStatus"] as! [String: Any])
            self.checkResultStatus = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetSQLReviewCheckResultStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSQLReviewCheckResultStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSQLReviewCheckResultStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSQLReviewOptimizeDetailRequest : Tea.TeaModel {
    public var SQLReviewQueryKey: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.SQLReviewQueryKey != nil {
            map["SQLReviewQueryKey"] = self.SQLReviewQueryKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SQLReviewQueryKey") && dict["SQLReviewQueryKey"] != nil {
            self.SQLReviewQueryKey = dict["SQLReviewQueryKey"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetSQLReviewOptimizeDetailResponseBody : Tea.TeaModel {
    public class OptimizeDetail : Tea.TeaModel {
        public class QualityResult : Tea.TeaModel {
            public class Results : Tea.TeaModel {
                public class Scripts : Tea.TeaModel {
                    public var content: String?

                    public var opType: String?

                    public var tableName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.opType != nil {
                            map["OpType"] = self.opType!
                        }
                        if self.tableName != nil {
                            map["TableName"] = self.tableName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Content") && dict["Content"] != nil {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("OpType") && dict["OpType"] != nil {
                            self.opType = dict["OpType"] as! String
                        }
                        if dict.keys.contains("TableName") && dict["TableName"] != nil {
                            self.tableName = dict["TableName"] as! String
                        }
                    }
                }
                public var comments: String?

                public var feedback: String?

                public var messages: [String]?

                public var ruleName: String?

                public var ruleType: String?

                public var scripts: [GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail.QualityResult.Results.Scripts]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.comments != nil {
                        map["Comments"] = self.comments!
                    }
                    if self.feedback != nil {
                        map["Feedback"] = self.feedback!
                    }
                    if self.messages != nil {
                        map["Messages"] = self.messages!
                    }
                    if self.ruleName != nil {
                        map["RuleName"] = self.ruleName!
                    }
                    if self.ruleType != nil {
                        map["RuleType"] = self.ruleType!
                    }
                    if self.scripts != nil {
                        var tmp : [Any] = []
                        for k in self.scripts! {
                            tmp.append(k.toMap())
                        }
                        map["Scripts"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Comments") && dict["Comments"] != nil {
                        self.comments = dict["Comments"] as! String
                    }
                    if dict.keys.contains("Feedback") && dict["Feedback"] != nil {
                        self.feedback = dict["Feedback"] as! String
                    }
                    if dict.keys.contains("Messages") && dict["Messages"] != nil {
                        self.messages = dict["Messages"] as! [String]
                    }
                    if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                        self.ruleName = dict["RuleName"] as! String
                    }
                    if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
                        self.ruleType = dict["RuleType"] as! String
                    }
                    if dict.keys.contains("Scripts") && dict["Scripts"] != nil {
                        var tmp : [GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail.QualityResult.Results.Scripts] = []
                        for v in dict["Scripts"] as! [Any] {
                            var model = GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail.QualityResult.Results.Scripts()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.scripts = tmp
                    }
                }
            }
            public var errorMessage: String?

            public var occurError: Bool?

            public var results: [GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail.QualityResult.Results]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.occurError != nil {
                    map["OccurError"] = self.occurError!
                }
                if self.results != nil {
                    var tmp : [Any] = []
                    for k in self.results! {
                        tmp.append(k.toMap())
                    }
                    map["Results"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("OccurError") && dict["OccurError"] != nil {
                    self.occurError = dict["OccurError"] as! Bool
                }
                if dict.keys.contains("Results") && dict["Results"] != nil {
                    var tmp : [GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail.QualityResult.Results] = []
                    for v in dict["Results"] as! [Any] {
                        var model = GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail.QualityResult.Results()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.results = tmp
                }
            }
        }
        public var dbId: Int32?

        public var instanceId: Int32?

        public var qualityResult: GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail.QualityResult?

        public var queryKey: String?

        public var sqlType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.qualityResult?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.qualityResult != nil {
                map["QualityResult"] = self.qualityResult?.toMap()
            }
            if self.queryKey != nil {
                map["QueryKey"] = self.queryKey!
            }
            if self.sqlType != nil {
                map["SqlType"] = self.sqlType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbId") && dict["DbId"] != nil {
                self.dbId = dict["DbId"] as! Int32
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! Int32
            }
            if dict.keys.contains("QualityResult") && dict["QualityResult"] != nil {
                var model = GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail.QualityResult()
                model.fromMap(dict["QualityResult"] as! [String: Any])
                self.qualityResult = model
            }
            if dict.keys.contains("QueryKey") && dict["QueryKey"] != nil {
                self.queryKey = dict["QueryKey"] as! String
            }
            if dict.keys.contains("SqlType") && dict["SqlType"] != nil {
                self.sqlType = dict["SqlType"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var optimizeDetail: GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.optimizeDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.optimizeDetail != nil {
            map["OptimizeDetail"] = self.optimizeDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("OptimizeDetail") && dict["OptimizeDetail"] != nil {
            var model = GetSQLReviewOptimizeDetailResponseBody.OptimizeDetail()
            model.fromMap(dict["OptimizeDetail"] as! [String: Any])
            self.optimizeDetail = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetSQLReviewOptimizeDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSQLReviewOptimizeDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSQLReviewOptimizeDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetStructSyncExecSqlDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetStructSyncExecSqlDetailResponseBody : Tea.TeaModel {
    public class StructSyncExecSqlDetail : Tea.TeaModel {
        public var execSql: String?

        public var totalSqlCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.execSql != nil {
                map["ExecSql"] = self.execSql!
            }
            if self.totalSqlCount != nil {
                map["TotalSqlCount"] = self.totalSqlCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExecSql") && dict["ExecSql"] != nil {
                self.execSql = dict["ExecSql"] as! String
            }
            if dict.keys.contains("TotalSqlCount") && dict["TotalSqlCount"] != nil {
                self.totalSqlCount = dict["TotalSqlCount"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var structSyncExecSqlDetail: GetStructSyncExecSqlDetailResponseBody.StructSyncExecSqlDetail?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.structSyncExecSqlDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.structSyncExecSqlDetail != nil {
            map["StructSyncExecSqlDetail"] = self.structSyncExecSqlDetail?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StructSyncExecSqlDetail") && dict["StructSyncExecSqlDetail"] != nil {
            var model = GetStructSyncExecSqlDetailResponseBody.StructSyncExecSqlDetail()
            model.fromMap(dict["StructSyncExecSqlDetail"] as! [String: Any])
            self.structSyncExecSqlDetail = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetStructSyncExecSqlDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetStructSyncExecSqlDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetStructSyncExecSqlDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetStructSyncJobAnalyzeResultRequest : Tea.TeaModel {
    public var compareType: String?

    public var orderId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compareType != nil {
            map["CompareType"] = self.compareType!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CompareType") && dict["CompareType"] != nil {
            self.compareType = dict["CompareType"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetStructSyncJobAnalyzeResultResponseBody : Tea.TeaModel {
    public class StructSyncJobAnalyzeResult : Tea.TeaModel {
        public class ResultList : Tea.TeaModel {
            public var script: String?

            public var sourceTableName: String?

            public var targetTableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.script != nil {
                    map["Script"] = self.script!
                }
                if self.sourceTableName != nil {
                    map["SourceTableName"] = self.sourceTableName!
                }
                if self.targetTableName != nil {
                    map["TargetTableName"] = self.targetTableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Script") && dict["Script"] != nil {
                    self.script = dict["Script"] as! String
                }
                if dict.keys.contains("SourceTableName") && dict["SourceTableName"] != nil {
                    self.sourceTableName = dict["SourceTableName"] as! String
                }
                if dict.keys.contains("TargetTableName") && dict["TargetTableName"] != nil {
                    self.targetTableName = dict["TargetTableName"] as! String
                }
            }
        }
        public class SummaryList : Tea.TeaModel {
            public var compareType: String?

            public var count: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.compareType != nil {
                    map["CompareType"] = self.compareType!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CompareType") && dict["CompareType"] != nil {
                    self.compareType = dict["CompareType"] as! String
                }
                if dict.keys.contains("Count") && dict["Count"] != nil {
                    self.count = dict["Count"] as! Int64
                }
            }
        }
        public var resultList: [GetStructSyncJobAnalyzeResultResponseBody.StructSyncJobAnalyzeResult.ResultList]?

        public var summaryList: [GetStructSyncJobAnalyzeResultResponseBody.StructSyncJobAnalyzeResult.SummaryList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resultList != nil {
                var tmp : [Any] = []
                for k in self.resultList! {
                    tmp.append(k.toMap())
                }
                map["ResultList"] = tmp
            }
            if self.summaryList != nil {
                var tmp : [Any] = []
                for k in self.summaryList! {
                    tmp.append(k.toMap())
                }
                map["SummaryList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResultList") && dict["ResultList"] != nil {
                var tmp : [GetStructSyncJobAnalyzeResultResponseBody.StructSyncJobAnalyzeResult.ResultList] = []
                for v in dict["ResultList"] as! [Any] {
                    var model = GetStructSyncJobAnalyzeResultResponseBody.StructSyncJobAnalyzeResult.ResultList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resultList = tmp
            }
            if dict.keys.contains("SummaryList") && dict["SummaryList"] != nil {
                var tmp : [GetStructSyncJobAnalyzeResultResponseBody.StructSyncJobAnalyzeResult.SummaryList] = []
                for v in dict["SummaryList"] as! [Any] {
                    var model = GetStructSyncJobAnalyzeResultResponseBody.StructSyncJobAnalyzeResult.SummaryList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.summaryList = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var structSyncJobAnalyzeResult: GetStructSyncJobAnalyzeResultResponseBody.StructSyncJobAnalyzeResult?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.structSyncJobAnalyzeResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.structSyncJobAnalyzeResult != nil {
            map["StructSyncJobAnalyzeResult"] = self.structSyncJobAnalyzeResult?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StructSyncJobAnalyzeResult") && dict["StructSyncJobAnalyzeResult"] != nil {
            var model = GetStructSyncJobAnalyzeResultResponseBody.StructSyncJobAnalyzeResult()
            model.fromMap(dict["StructSyncJobAnalyzeResult"] as! [String: Any])
            self.structSyncJobAnalyzeResult = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetStructSyncJobAnalyzeResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetStructSyncJobAnalyzeResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetStructSyncJobAnalyzeResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetStructSyncJobDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetStructSyncJobDetailResponseBody : Tea.TeaModel {
    public class StructSyncJobDetail : Tea.TeaModel {
        public var DBTaskGroupId: Int64?

        public var executeCount: Int64?

        public var jobStatus: String?

        public var message: String?

        public var securityRule: String?

        public var sqlCount: Int64?

        public var tableAnalyzed: Int64?

        public var tableCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBTaskGroupId != nil {
                map["DBTaskGroupId"] = self.DBTaskGroupId!
            }
            if self.executeCount != nil {
                map["ExecuteCount"] = self.executeCount!
            }
            if self.jobStatus != nil {
                map["JobStatus"] = self.jobStatus!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.securityRule != nil {
                map["SecurityRule"] = self.securityRule!
            }
            if self.sqlCount != nil {
                map["SqlCount"] = self.sqlCount!
            }
            if self.tableAnalyzed != nil {
                map["TableAnalyzed"] = self.tableAnalyzed!
            }
            if self.tableCount != nil {
                map["TableCount"] = self.tableCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DBTaskGroupId") && dict["DBTaskGroupId"] != nil {
                self.DBTaskGroupId = dict["DBTaskGroupId"] as! Int64
            }
            if dict.keys.contains("ExecuteCount") && dict["ExecuteCount"] != nil {
                self.executeCount = dict["ExecuteCount"] as! Int64
            }
            if dict.keys.contains("JobStatus") && dict["JobStatus"] != nil {
                self.jobStatus = dict["JobStatus"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("SecurityRule") && dict["SecurityRule"] != nil {
                self.securityRule = dict["SecurityRule"] as! String
            }
            if dict.keys.contains("SqlCount") && dict["SqlCount"] != nil {
                self.sqlCount = dict["SqlCount"] as! Int64
            }
            if dict.keys.contains("TableAnalyzed") && dict["TableAnalyzed"] != nil {
                self.tableAnalyzed = dict["TableAnalyzed"] as! Int64
            }
            if dict.keys.contains("TableCount") && dict["TableCount"] != nil {
                self.tableCount = dict["TableCount"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var structSyncJobDetail: GetStructSyncJobDetailResponseBody.StructSyncJobDetail?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.structSyncJobDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.structSyncJobDetail != nil {
            map["StructSyncJobDetail"] = self.structSyncJobDetail?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StructSyncJobDetail") && dict["StructSyncJobDetail"] != nil {
            var model = GetStructSyncJobDetailResponseBody.StructSyncJobDetail()
            model.fromMap(dict["StructSyncJobDetail"] as! [String: Any])
            self.structSyncJobDetail = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetStructSyncJobDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetStructSyncJobDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetStructSyncJobDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetStructSyncOrderDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetStructSyncOrderDetailResponseBody : Tea.TeaModel {
    public class StructSyncOrderDetail : Tea.TeaModel {
        public class SourceDatabaseInfo : Tea.TeaModel {
            public var dbId: Int64?

            public var dbType: String?

            public var envType: String?

            public var logic: Bool?

            public var searchName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("DbType") && dict["DbType"] != nil {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                    self.searchName = dict["SearchName"] as! String
                }
            }
        }
        public class SourceVersionInfo : Tea.TeaModel {
            public var versionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.versionId != nil {
                    map["VersionId"] = self.versionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("VersionId") && dict["VersionId"] != nil {
                    self.versionId = dict["VersionId"] as! String
                }
            }
        }
        public class TableInfoList : Tea.TeaModel {
            public var sourceTableName: String?

            public var targetTableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sourceTableName != nil {
                    map["SourceTableName"] = self.sourceTableName!
                }
                if self.targetTableName != nil {
                    map["TargetTableName"] = self.targetTableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SourceTableName") && dict["SourceTableName"] != nil {
                    self.sourceTableName = dict["SourceTableName"] as! String
                }
                if dict.keys.contains("TargetTableName") && dict["TargetTableName"] != nil {
                    self.targetTableName = dict["TargetTableName"] as! String
                }
            }
        }
        public class TargetDatabaseInfo : Tea.TeaModel {
            public var dbId: Int64?

            public var dbType: String?

            public var envType: String?

            public var logic: Bool?

            public var searchName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("DbType") && dict["DbType"] != nil {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                    self.searchName = dict["SearchName"] as! String
                }
            }
        }
        public class TargetVersionInfo : Tea.TeaModel {
            public var versionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.versionId != nil {
                    map["VersionId"] = self.versionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("VersionId") && dict["VersionId"] != nil {
                    self.versionId = dict["VersionId"] as! String
                }
            }
        }
        public var ignoreError: Bool?

        public var sourceDatabaseInfo: GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.SourceDatabaseInfo?

        public var sourceType: String?

        public var sourceVersionInfo: GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.SourceVersionInfo?

        public var tableInfoList: [GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.TableInfoList]?

        public var targetDatabaseInfo: GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.TargetDatabaseInfo?

        public var targetType: String?

        public var targetVersionInfo: GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.TargetVersionInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sourceDatabaseInfo?.validate()
            try self.sourceVersionInfo?.validate()
            try self.targetDatabaseInfo?.validate()
            try self.targetVersionInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ignoreError != nil {
                map["IgnoreError"] = self.ignoreError!
            }
            if self.sourceDatabaseInfo != nil {
                map["SourceDatabaseInfo"] = self.sourceDatabaseInfo?.toMap()
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.sourceVersionInfo != nil {
                map["SourceVersionInfo"] = self.sourceVersionInfo?.toMap()
            }
            if self.tableInfoList != nil {
                var tmp : [Any] = []
                for k in self.tableInfoList! {
                    tmp.append(k.toMap())
                }
                map["TableInfoList"] = tmp
            }
            if self.targetDatabaseInfo != nil {
                map["TargetDatabaseInfo"] = self.targetDatabaseInfo?.toMap()
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            if self.targetVersionInfo != nil {
                map["TargetVersionInfo"] = self.targetVersionInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IgnoreError") && dict["IgnoreError"] != nil {
                self.ignoreError = dict["IgnoreError"] as! Bool
            }
            if dict.keys.contains("SourceDatabaseInfo") && dict["SourceDatabaseInfo"] != nil {
                var model = GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.SourceDatabaseInfo()
                model.fromMap(dict["SourceDatabaseInfo"] as! [String: Any])
                self.sourceDatabaseInfo = model
            }
            if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("SourceVersionInfo") && dict["SourceVersionInfo"] != nil {
                var model = GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.SourceVersionInfo()
                model.fromMap(dict["SourceVersionInfo"] as! [String: Any])
                self.sourceVersionInfo = model
            }
            if dict.keys.contains("TableInfoList") && dict["TableInfoList"] != nil {
                var tmp : [GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.TableInfoList] = []
                for v in dict["TableInfoList"] as! [Any] {
                    var model = GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.TableInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tableInfoList = tmp
            }
            if dict.keys.contains("TargetDatabaseInfo") && dict["TargetDatabaseInfo"] != nil {
                var model = GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.TargetDatabaseInfo()
                model.fromMap(dict["TargetDatabaseInfo"] as! [String: Any])
                self.targetDatabaseInfo = model
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
            if dict.keys.contains("TargetVersionInfo") && dict["TargetVersionInfo"] != nil {
                var model = GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail.TargetVersionInfo()
                model.fromMap(dict["TargetVersionInfo"] as! [String: Any])
                self.targetVersionInfo = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var structSyncOrderDetail: GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.structSyncOrderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.structSyncOrderDetail != nil {
            map["StructSyncOrderDetail"] = self.structSyncOrderDetail?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StructSyncOrderDetail") && dict["StructSyncOrderDetail"] != nil {
            var model = GetStructSyncOrderDetailResponseBody.StructSyncOrderDetail()
            model.fromMap(dict["StructSyncOrderDetail"] as! [String: Any])
            self.structSyncOrderDetail = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetStructSyncOrderDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetStructSyncOrderDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetStructSyncOrderDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTableDBTopologyRequest : Tea.TeaModel {
    public var tableGuid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TableGuid") && dict["TableGuid"] != nil {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetTableDBTopologyResponseBody : Tea.TeaModel {
    public class DBTopology : Tea.TeaModel {
        public class DataSourceList : Tea.TeaModel {
            public class DatabaseList : Tea.TeaModel {
                public class TableList : Tea.TeaModel {
                    public var tableId: String?

                    public var tableName: String?

                    public var tableType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tableId != nil {
                            map["TableId"] = self.tableId!
                        }
                        if self.tableName != nil {
                            map["TableName"] = self.tableName!
                        }
                        if self.tableType != nil {
                            map["TableType"] = self.tableType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TableId") && dict["TableId"] != nil {
                            self.tableId = dict["TableId"] as! String
                        }
                        if dict.keys.contains("TableName") && dict["TableName"] != nil {
                            self.tableName = dict["TableName"] as! String
                        }
                        if dict.keys.contains("TableType") && dict["TableType"] != nil {
                            self.tableType = dict["TableType"] as! String
                        }
                    }
                }
                public var dbId: String?

                public var dbName: String?

                public var dbType: String?

                public var envType: String?

                public var tableList: [GetTableDBTopologyResponseBody.DBTopology.DataSourceList.DatabaseList.TableList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dbId != nil {
                        map["DbId"] = self.dbId!
                    }
                    if self.dbName != nil {
                        map["DbName"] = self.dbName!
                    }
                    if self.dbType != nil {
                        map["DbType"] = self.dbType!
                    }
                    if self.envType != nil {
                        map["EnvType"] = self.envType!
                    }
                    if self.tableList != nil {
                        var tmp : [Any] = []
                        for k in self.tableList! {
                            tmp.append(k.toMap())
                        }
                        map["TableList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DbId") && dict["DbId"] != nil {
                        self.dbId = dict["DbId"] as! String
                    }
                    if dict.keys.contains("DbName") && dict["DbName"] != nil {
                        self.dbName = dict["DbName"] as! String
                    }
                    if dict.keys.contains("DbType") && dict["DbType"] != nil {
                        self.dbType = dict["DbType"] as! String
                    }
                    if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                        self.envType = dict["EnvType"] as! String
                    }
                    if dict.keys.contains("TableList") && dict["TableList"] != nil {
                        var tmp : [GetTableDBTopologyResponseBody.DBTopology.DataSourceList.DatabaseList.TableList] = []
                        for v in dict["TableList"] as! [Any] {
                            var model = GetTableDBTopologyResponseBody.DBTopology.DataSourceList.DatabaseList.TableList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tableList = tmp
                    }
                }
            }
            public var databaseList: [GetTableDBTopologyResponseBody.DBTopology.DataSourceList.DatabaseList]?

            public var dbType: String?

            public var host: String?

            public var port: Int32?

            public var sid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseList != nil {
                    var tmp : [Any] = []
                    for k in self.databaseList! {
                        tmp.append(k.toMap())
                    }
                    map["DatabaseList"] = tmp
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.sid != nil {
                    map["Sid"] = self.sid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DatabaseList") && dict["DatabaseList"] != nil {
                    var tmp : [GetTableDBTopologyResponseBody.DBTopology.DataSourceList.DatabaseList] = []
                    for v in dict["DatabaseList"] as! [Any] {
                        var model = GetTableDBTopologyResponseBody.DBTopology.DataSourceList.DatabaseList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.databaseList = tmp
                }
                if dict.keys.contains("DbType") && dict["DbType"] != nil {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("Host") && dict["Host"] != nil {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Sid") && dict["Sid"] != nil {
                    self.sid = dict["Sid"] as! String
                }
            }
        }
        public var dataSourceList: [GetTableDBTopologyResponseBody.DBTopology.DataSourceList]?

        public var tableGuid: String?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSourceList != nil {
                var tmp : [Any] = []
                for k in self.dataSourceList! {
                    tmp.append(k.toMap())
                }
                map["DataSourceList"] = tmp
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataSourceList") && dict["DataSourceList"] != nil {
                var tmp : [GetTableDBTopologyResponseBody.DBTopology.DataSourceList] = []
                for v in dict["DataSourceList"] as! [Any] {
                    var model = GetTableDBTopologyResponseBody.DBTopology.DataSourceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataSourceList = tmp
            }
            if dict.keys.contains("TableGuid") && dict["TableGuid"] != nil {
                self.tableGuid = dict["TableGuid"] as! String
            }
            if dict.keys.contains("TableName") && dict["TableName"] != nil {
                self.tableName = dict["TableName"] as! String
            }
        }
    }
    public var DBTopology: GetTableDBTopologyResponseBody.DBTopology?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DBTopology?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBTopology != nil {
            map["DBTopology"] = self.DBTopology?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBTopology") && dict["DBTopology"] != nil {
            var model = GetTableDBTopologyResponseBody.DBTopology()
            model.fromMap(dict["DBTopology"] as! [String: Any])
            self.DBTopology = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetTableDBTopologyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTableDBTopologyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTableDBTopologyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTableTopologyRequest : Tea.TeaModel {
    public var tableGuid: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TableGuid") && dict["TableGuid"] != nil {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetTableTopologyResponseBody : Tea.TeaModel {
    public class TableTopology : Tea.TeaModel {
        public class TableTopologyInfoList : Tea.TeaModel {
            public var dbId: Int64?

            public var dbName: String?

            public var dbSearchName: String?

            public var dbType: String?

            public var instanceId: Int64?

            public var instanceResourceId: String?

            public var instanceSource: String?

            public var regionId: String?

            public var tableCount: Int64?

            public var tableNameExpr: String?

            public var tableNameList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbName != nil {
                    map["DbName"] = self.dbName!
                }
                if self.dbSearchName != nil {
                    map["DbSearchName"] = self.dbSearchName!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceResourceId != nil {
                    map["InstanceResourceId"] = self.instanceResourceId!
                }
                if self.instanceSource != nil {
                    map["InstanceSource"] = self.instanceSource!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.tableCount != nil {
                    map["TableCount"] = self.tableCount!
                }
                if self.tableNameExpr != nil {
                    map["TableNameExpr"] = self.tableNameExpr!
                }
                if self.tableNameList != nil {
                    map["TableNameList"] = self.tableNameList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("DbName") && dict["DbName"] != nil {
                    self.dbName = dict["DbName"] as! String
                }
                if dict.keys.contains("DbSearchName") && dict["DbSearchName"] != nil {
                    self.dbSearchName = dict["DbSearchName"] as! String
                }
                if dict.keys.contains("DbType") && dict["DbType"] != nil {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("InstanceResourceId") && dict["InstanceResourceId"] != nil {
                    self.instanceResourceId = dict["InstanceResourceId"] as! String
                }
                if dict.keys.contains("InstanceSource") && dict["InstanceSource"] != nil {
                    self.instanceSource = dict["InstanceSource"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("TableCount") && dict["TableCount"] != nil {
                    self.tableCount = dict["TableCount"] as! Int64
                }
                if dict.keys.contains("TableNameExpr") && dict["TableNameExpr"] != nil {
                    self.tableNameExpr = dict["TableNameExpr"] as! String
                }
                if dict.keys.contains("TableNameList") && dict["TableNameList"] != nil {
                    self.tableNameList = dict["TableNameList"] as! String
                }
            }
        }
        public var logic: Bool?

        public var tableGuid: String?

        public var tableName: String?

        public var tableTopologyInfoList: [GetTableTopologyResponseBody.TableTopology.TableTopologyInfoList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logic != nil {
                map["Logic"] = self.logic!
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            if self.tableTopologyInfoList != nil {
                var tmp : [Any] = []
                for k in self.tableTopologyInfoList! {
                    tmp.append(k.toMap())
                }
                map["TableTopologyInfoList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Logic") && dict["Logic"] != nil {
                self.logic = dict["Logic"] as! Bool
            }
            if dict.keys.contains("TableGuid") && dict["TableGuid"] != nil {
                self.tableGuid = dict["TableGuid"] as! String
            }
            if dict.keys.contains("TableName") && dict["TableName"] != nil {
                self.tableName = dict["TableName"] as! String
            }
            if dict.keys.contains("TableTopologyInfoList") && dict["TableTopologyInfoList"] != nil {
                var tmp : [GetTableTopologyResponseBody.TableTopology.TableTopologyInfoList] = []
                for v in dict["TableTopologyInfoList"] as! [Any] {
                    var model = GetTableTopologyResponseBody.TableTopology.TableTopologyInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tableTopologyInfoList = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tableTopology: GetTableTopologyResponseBody.TableTopology?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tableTopology?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tableTopology != nil {
            map["TableTopology"] = self.tableTopology?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TableTopology") && dict["TableTopology"] != nil {
            var model = GetTableTopologyResponseBody.TableTopology()
            model.fromMap(dict["TableTopology"] as! [String: Any])
            self.tableTopology = model
        }
    }
}

public class GetTableTopologyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTableTopologyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTableTopologyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTaskRequest : Tea.TeaModel {
    public var nodeId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetTaskResponseBody : Tea.TeaModel {
    public class Task : Tea.TeaModel {
        public var dagId: Int64?

        public var graphParam: String?

        public var nodeConfig: String?

        public var nodeContent: String?

        public var nodeName: String?

        public var nodeOutput: String?

        public var nodeType: String?

        public var timeVariables: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dagId != nil {
                map["DagId"] = self.dagId!
            }
            if self.graphParam != nil {
                map["GraphParam"] = self.graphParam!
            }
            if self.nodeConfig != nil {
                map["NodeConfig"] = self.nodeConfig!
            }
            if self.nodeContent != nil {
                map["NodeContent"] = self.nodeContent!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.nodeOutput != nil {
                map["NodeOutput"] = self.nodeOutput!
            }
            if self.nodeType != nil {
                map["NodeType"] = self.nodeType!
            }
            if self.timeVariables != nil {
                map["TimeVariables"] = self.timeVariables!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DagId") && dict["DagId"] != nil {
                self.dagId = dict["DagId"] as! Int64
            }
            if dict.keys.contains("GraphParam") && dict["GraphParam"] != nil {
                self.graphParam = dict["GraphParam"] as! String
            }
            if dict.keys.contains("NodeConfig") && dict["NodeConfig"] != nil {
                self.nodeConfig = dict["NodeConfig"] as! String
            }
            if dict.keys.contains("NodeContent") && dict["NodeContent"] != nil {
                self.nodeContent = dict["NodeContent"] as! String
            }
            if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("NodeOutput") && dict["NodeOutput"] != nil {
                self.nodeOutput = dict["NodeOutput"] as! String
            }
            if dict.keys.contains("NodeType") && dict["NodeType"] != nil {
                self.nodeType = dict["NodeType"] as! String
            }
            if dict.keys.contains("TimeVariables") && dict["TimeVariables"] != nil {
                self.timeVariables = dict["TimeVariables"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var task: GetTaskResponseBody.Task?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.task?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.task != nil {
            map["Task"] = self.task?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Task") && dict["Task"] != nil {
            var model = GetTaskResponseBody.Task()
            model.fromMap(dict["Task"] as! [String: Any])
            self.task = model
        }
    }
}

public class GetTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTaskFlowGraphRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetTaskFlowGraphResponseBody : Tea.TeaModel {
    public class TaskFlowGraph : Tea.TeaModel {
        public class Edges : Tea.TeaModel {
            public class Edge : Tea.TeaModel {
                public var dagId: Int64?

                public var id: Int64?

                public var nodeEnd: Int64?

                public var nodeFrom: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dagId != nil {
                        map["DagId"] = self.dagId!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.nodeEnd != nil {
                        map["NodeEnd"] = self.nodeEnd!
                    }
                    if self.nodeFrom != nil {
                        map["NodeFrom"] = self.nodeFrom!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DagId") && dict["DagId"] != nil {
                        self.dagId = dict["DagId"] as! Int64
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("NodeEnd") && dict["NodeEnd"] != nil {
                        self.nodeEnd = dict["NodeEnd"] as! Int64
                    }
                    if dict.keys.contains("NodeFrom") && dict["NodeFrom"] != nil {
                        self.nodeFrom = dict["NodeFrom"] as! Int64
                    }
                }
            }
            public var edge: [GetTaskFlowGraphResponseBody.TaskFlowGraph.Edges.Edge]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.edge != nil {
                    var tmp : [Any] = []
                    for k in self.edge! {
                        tmp.append(k.toMap())
                    }
                    map["Edge"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Edge") && dict["Edge"] != nil {
                    var tmp : [GetTaskFlowGraphResponseBody.TaskFlowGraph.Edges.Edge] = []
                    for v in dict["Edge"] as! [Any] {
                        var model = GetTaskFlowGraphResponseBody.TaskFlowGraph.Edges.Edge()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.edge = tmp
                }
            }
        }
        public class Nodes : Tea.TeaModel {
            public class Node : Tea.TeaModel {
                public var dagId: Int64?

                public var graphParam: String?

                public var nodeConfig: String?

                public var nodeContent: String?

                public var nodeId: Int64?

                public var nodeName: String?

                public var nodeType: Int64?

                public var timeVariables: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dagId != nil {
                        map["DagId"] = self.dagId!
                    }
                    if self.graphParam != nil {
                        map["GraphParam"] = self.graphParam!
                    }
                    if self.nodeConfig != nil {
                        map["NodeConfig"] = self.nodeConfig!
                    }
                    if self.nodeContent != nil {
                        map["NodeContent"] = self.nodeContent!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.nodeName != nil {
                        map["NodeName"] = self.nodeName!
                    }
                    if self.nodeType != nil {
                        map["NodeType"] = self.nodeType!
                    }
                    if self.timeVariables != nil {
                        map["TimeVariables"] = self.timeVariables!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DagId") && dict["DagId"] != nil {
                        self.dagId = dict["DagId"] as! Int64
                    }
                    if dict.keys.contains("GraphParam") && dict["GraphParam"] != nil {
                        self.graphParam = dict["GraphParam"] as! String
                    }
                    if dict.keys.contains("NodeConfig") && dict["NodeConfig"] != nil {
                        self.nodeConfig = dict["NodeConfig"] as! String
                    }
                    if dict.keys.contains("NodeContent") && dict["NodeContent"] != nil {
                        self.nodeContent = dict["NodeContent"] as! String
                    }
                    if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                        self.nodeId = dict["NodeId"] as! Int64
                    }
                    if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                        self.nodeName = dict["NodeName"] as! String
                    }
                    if dict.keys.contains("NodeType") && dict["NodeType"] != nil {
                        self.nodeType = dict["NodeType"] as! Int64
                    }
                    if dict.keys.contains("TimeVariables") && dict["TimeVariables"] != nil {
                        self.timeVariables = dict["TimeVariables"] as! String
                    }
                }
            }
            public var node: [GetTaskFlowGraphResponseBody.TaskFlowGraph.Nodes.Node]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.node != nil {
                    var tmp : [Any] = []
                    for k in self.node! {
                        tmp.append(k.toMap())
                    }
                    map["Node"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Node") && dict["Node"] != nil {
                    var tmp : [GetTaskFlowGraphResponseBody.TaskFlowGraph.Nodes.Node] = []
                    for v in dict["Node"] as! [Any] {
                        var model = GetTaskFlowGraphResponseBody.TaskFlowGraph.Nodes.Node()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.node = tmp
                }
            }
        }
        public var canEdit: Bool?

        public var dagName: String?

        public var edges: GetTaskFlowGraphResponseBody.TaskFlowGraph.Edges?

        public var nodes: GetTaskFlowGraphResponseBody.TaskFlowGraph.Nodes?

        public var status: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.edges?.validate()
            try self.nodes?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.canEdit != nil {
                map["CanEdit"] = self.canEdit!
            }
            if self.dagName != nil {
                map["DagName"] = self.dagName!
            }
            if self.edges != nil {
                map["Edges"] = self.edges?.toMap()
            }
            if self.nodes != nil {
                map["Nodes"] = self.nodes?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CanEdit") && dict["CanEdit"] != nil {
                self.canEdit = dict["CanEdit"] as! Bool
            }
            if dict.keys.contains("DagName") && dict["DagName"] != nil {
                self.dagName = dict["DagName"] as! String
            }
            if dict.keys.contains("Edges") && dict["Edges"] != nil {
                var model = GetTaskFlowGraphResponseBody.TaskFlowGraph.Edges()
                model.fromMap(dict["Edges"] as! [String: Any])
                self.edges = model
            }
            if dict.keys.contains("Nodes") && dict["Nodes"] != nil {
                var model = GetTaskFlowGraphResponseBody.TaskFlowGraph.Nodes()
                model.fromMap(dict["Nodes"] as! [String: Any])
                self.nodes = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var taskFlowGraph: GetTaskFlowGraphResponseBody.TaskFlowGraph?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskFlowGraph?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskFlowGraph != nil {
            map["TaskFlowGraph"] = self.taskFlowGraph?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TaskFlowGraph") && dict["TaskFlowGraph"] != nil {
            var model = GetTaskFlowGraphResponseBody.TaskFlowGraph()
            model.fromMap(dict["TaskFlowGraph"] as! [String: Any])
            self.taskFlowGraph = model
        }
    }
}

public class GetTaskFlowGraphResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTaskFlowGraphResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTaskFlowGraphResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTaskFlowNotificationRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetTaskFlowNotificationResponseBody : Tea.TeaModel {
    public class Notification : Tea.TeaModel {
        public var dagNotificationFail: Bool?

        public var dagNotificationSla: Bool?

        public var dagNotificationSuccess: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dagNotificationFail != nil {
                map["DagNotificationFail"] = self.dagNotificationFail!
            }
            if self.dagNotificationSla != nil {
                map["DagNotificationSla"] = self.dagNotificationSla!
            }
            if self.dagNotificationSuccess != nil {
                map["DagNotificationSuccess"] = self.dagNotificationSuccess!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DagNotificationFail") && dict["DagNotificationFail"] != nil {
                self.dagNotificationFail = dict["DagNotificationFail"] as! Bool
            }
            if dict.keys.contains("DagNotificationSla") && dict["DagNotificationSla"] != nil {
                self.dagNotificationSla = dict["DagNotificationSla"] as! Bool
            }
            if dict.keys.contains("DagNotificationSuccess") && dict["DagNotificationSuccess"] != nil {
                self.dagNotificationSuccess = dict["DagNotificationSuccess"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var notification: GetTaskFlowNotificationResponseBody.Notification?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notification?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.notification != nil {
            map["Notification"] = self.notification?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("Notification") && dict["Notification"] != nil {
            var model = GetTaskFlowNotificationResponseBody.Notification()
            model.fromMap(dict["Notification"] as! [String: Any])
            self.notification = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetTaskFlowNotificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTaskFlowNotificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTaskFlowNotificationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTaskInstanceRelationRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var dagInstanceId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.dagInstanceId != nil {
            map["DagInstanceId"] = self.dagInstanceId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("DagInstanceId") && dict["DagInstanceId"] != nil {
            self.dagInstanceId = dict["DagInstanceId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetTaskInstanceRelationResponseBody : Tea.TeaModel {
    public class NodeList : Tea.TeaModel {
        public class Node : Tea.TeaModel {
            public var businessTime: String?

            public var endTime: String?

            public var executeTime: Int64?

            public var id: Int64?

            public var message: String?

            public var nodeId: Int64?

            public var nodeName: String?

            public var nodeType: Int32?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessTime != nil {
                    map["BusinessTime"] = self.businessTime!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.executeTime != nil {
                    map["ExecuteTime"] = self.executeTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.nodeType != nil {
                    map["NodeType"] = self.nodeType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessTime") && dict["BusinessTime"] != nil {
                    self.businessTime = dict["BusinessTime"] as! String
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("ExecuteTime") && dict["ExecuteTime"] != nil {
                    self.executeTime = dict["ExecuteTime"] as! Int64
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("NodeType") && dict["NodeType"] != nil {
                    self.nodeType = dict["NodeType"] as! Int32
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public var node: [GetTaskInstanceRelationResponseBody.NodeList.Node]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.node != nil {
                var tmp : [Any] = []
                for k in self.node! {
                    tmp.append(k.toMap())
                }
                map["Node"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Node") && dict["Node"] != nil {
                var tmp : [GetTaskInstanceRelationResponseBody.NodeList.Node] = []
                for v in dict["Node"] as! [Any] {
                    var model = GetTaskInstanceRelationResponseBody.NodeList.Node()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.node = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var nodeList: GetTaskInstanceRelationResponseBody.NodeList?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.nodeList != nil {
            map["NodeList"] = self.nodeList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("NodeList") && dict["NodeList"] != nil {
            var model = GetTaskInstanceRelationResponseBody.NodeList()
            model.fromMap(dict["NodeList"] as! [String: Any])
            self.nodeList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetTaskInstanceRelationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTaskInstanceRelationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTaskInstanceRelationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserRequest : Tea.TeaModel {
    public var tid: Int64?

    public var uid: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("Uid") && dict["Uid"] != nil {
            self.uid = dict["Uid"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GetUserResponseBody : Tea.TeaModel {
    public class User : Tea.TeaModel {
        public class RoleIdList : Tea.TeaModel {
            public var roleIds: [Int32]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.roleIds != nil {
                    map["RoleIds"] = self.roleIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RoleIds") && dict["RoleIds"] != nil {
                    self.roleIds = dict["RoleIds"] as! [Int32]
                }
            }
        }
        public class RoleNameList : Tea.TeaModel {
            public var roleNames: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.roleNames != nil {
                    map["RoleNames"] = self.roleNames!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RoleNames") && dict["RoleNames"] != nil {
                    self.roleNames = dict["RoleNames"] as! [String]
                }
            }
        }
        public var curExecuteCount: Int64?

        public var curResultCount: Int64?

        public var dingRobot: String?

        public var email: String?

        public var lastLoginTime: String?

        public var maxExecuteCount: Int64?

        public var maxResultCount: Int64?

        public var mobile: String?

        public var nickName: String?

        public var notificationMode: String?

        public var parentUid: Int64?

        public var roleIdList: GetUserResponseBody.User.RoleIdList?

        public var roleNameList: GetUserResponseBody.User.RoleNameList?

        public var signatureMethod: String?

        public var state: String?

        public var uid: String?

        public var userId: String?

        public var webhook: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.roleIdList?.validate()
            try self.roleNameList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.curExecuteCount != nil {
                map["CurExecuteCount"] = self.curExecuteCount!
            }
            if self.curResultCount != nil {
                map["CurResultCount"] = self.curResultCount!
            }
            if self.dingRobot != nil {
                map["DingRobot"] = self.dingRobot!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.lastLoginTime != nil {
                map["LastLoginTime"] = self.lastLoginTime!
            }
            if self.maxExecuteCount != nil {
                map["MaxExecuteCount"] = self.maxExecuteCount!
            }
            if self.maxResultCount != nil {
                map["MaxResultCount"] = self.maxResultCount!
            }
            if self.mobile != nil {
                map["Mobile"] = self.mobile!
            }
            if self.nickName != nil {
                map["NickName"] = self.nickName!
            }
            if self.notificationMode != nil {
                map["NotificationMode"] = self.notificationMode!
            }
            if self.parentUid != nil {
                map["ParentUid"] = self.parentUid!
            }
            if self.roleIdList != nil {
                map["RoleIdList"] = self.roleIdList?.toMap()
            }
            if self.roleNameList != nil {
                map["RoleNameList"] = self.roleNameList?.toMap()
            }
            if self.signatureMethod != nil {
                map["SignatureMethod"] = self.signatureMethod!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.uid != nil {
                map["Uid"] = self.uid!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.webhook != nil {
                map["Webhook"] = self.webhook!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurExecuteCount") && dict["CurExecuteCount"] != nil {
                self.curExecuteCount = dict["CurExecuteCount"] as! Int64
            }
            if dict.keys.contains("CurResultCount") && dict["CurResultCount"] != nil {
                self.curResultCount = dict["CurResultCount"] as! Int64
            }
            if dict.keys.contains("DingRobot") && dict["DingRobot"] != nil {
                self.dingRobot = dict["DingRobot"] as! String
            }
            if dict.keys.contains("Email") && dict["Email"] != nil {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("LastLoginTime") && dict["LastLoginTime"] != nil {
                self.lastLoginTime = dict["LastLoginTime"] as! String
            }
            if dict.keys.contains("MaxExecuteCount") && dict["MaxExecuteCount"] != nil {
                self.maxExecuteCount = dict["MaxExecuteCount"] as! Int64
            }
            if dict.keys.contains("MaxResultCount") && dict["MaxResultCount"] != nil {
                self.maxResultCount = dict["MaxResultCount"] as! Int64
            }
            if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                self.mobile = dict["Mobile"] as! String
            }
            if dict.keys.contains("NickName") && dict["NickName"] != nil {
                self.nickName = dict["NickName"] as! String
            }
            if dict.keys.contains("NotificationMode") && dict["NotificationMode"] != nil {
                self.notificationMode = dict["NotificationMode"] as! String
            }
            if dict.keys.contains("ParentUid") && dict["ParentUid"] != nil {
                self.parentUid = dict["ParentUid"] as! Int64
            }
            if dict.keys.contains("RoleIdList") && dict["RoleIdList"] != nil {
                var model = GetUserResponseBody.User.RoleIdList()
                model.fromMap(dict["RoleIdList"] as! [String: Any])
                self.roleIdList = model
            }
            if dict.keys.contains("RoleNameList") && dict["RoleNameList"] != nil {
                var model = GetUserResponseBody.User.RoleNameList()
                model.fromMap(dict["RoleNameList"] as! [String: Any])
                self.roleNameList = model
            }
            if dict.keys.contains("SignatureMethod") && dict["SignatureMethod"] != nil {
                self.signatureMethod = dict["SignatureMethod"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Uid") && dict["Uid"] != nil {
                self.uid = dict["Uid"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
                self.webhook = dict["Webhook"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var user: GetUserResponseBody.User?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.user?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.user != nil {
            map["User"] = self.user?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("User") && dict["User"] != nil {
            var model = GetUserResponseBody.User()
            model.fromMap(dict["User"] as! [String: Any])
            self.user = model
        }
    }
}

public class GetUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserActiveTenantRequest : Tea.TeaModel {
    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetUserActiveTenantResponseBody : Tea.TeaModel {
    public class Tenant : Tea.TeaModel {
        public var status: String?

        public var tenantName: String?

        public var tid: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tenantName != nil {
                map["TenantName"] = self.tenantName!
            }
            if self.tid != nil {
                map["Tid"] = self.tid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TenantName") && dict["TenantName"] != nil {
                self.tenantName = dict["TenantName"] as! String
            }
            if dict.keys.contains("Tid") && dict["Tid"] != nil {
                self.tid = dict["Tid"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tenant: GetUserActiveTenantResponseBody.Tenant?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenant?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tenant != nil {
            map["Tenant"] = self.tenant?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Tenant") && dict["Tenant"] != nil {
            var model = GetUserActiveTenantResponseBody.Tenant()
            model.fromMap(dict["Tenant"] as! [String: Any])
            self.tenant = model
        }
    }
}

public class GetUserActiveTenantResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserActiveTenantResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetUserActiveTenantResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserUploadFileJobRequest : Tea.TeaModel {
    public var jobKey: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobKey != nil {
            map["JobKey"] = self.jobKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobKey") && dict["JobKey"] != nil {
            self.jobKey = dict["JobKey"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class GetUserUploadFileJobResponseBody : Tea.TeaModel {
    public class UploadFileJobDetail : Tea.TeaModel {
        public class UploadOSSParam : Tea.TeaModel {
            public var bucketName: String?

            public var endpoint: String?

            public var objectName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucketName != nil {
                    map["BucketName"] = self.bucketName!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.objectName != nil {
                    map["ObjectName"] = self.objectName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BucketName") && dict["BucketName"] != nil {
                    self.bucketName = dict["BucketName"] as! String
                }
                if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("ObjectName") && dict["ObjectName"] != nil {
                    self.objectName = dict["ObjectName"] as! String
                }
            }
        }
        public var attachmentKey: String?

        public var fileName: String?

        public var fileSize: Int64?

        public var fileSource: String?

        public var jobKey: String?

        public var jobStatus: String?

        public var jobStatusDesc: String?

        public var uploadOSSParam: GetUserUploadFileJobResponseBody.UploadFileJobDetail.UploadOSSParam?

        public var uploadType: String?

        public var uploadURL: String?

        public var uploadedSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.uploadOSSParam?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachmentKey != nil {
                map["AttachmentKey"] = self.attachmentKey!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.fileSource != nil {
                map["FileSource"] = self.fileSource!
            }
            if self.jobKey != nil {
                map["JobKey"] = self.jobKey!
            }
            if self.jobStatus != nil {
                map["JobStatus"] = self.jobStatus!
            }
            if self.jobStatusDesc != nil {
                map["JobStatusDesc"] = self.jobStatusDesc!
            }
            if self.uploadOSSParam != nil {
                map["UploadOSSParam"] = self.uploadOSSParam?.toMap()
            }
            if self.uploadType != nil {
                map["UploadType"] = self.uploadType!
            }
            if self.uploadURL != nil {
                map["UploadURL"] = self.uploadURL!
            }
            if self.uploadedSize != nil {
                map["UploadedSize"] = self.uploadedSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachmentKey") && dict["AttachmentKey"] != nil {
                self.attachmentKey = dict["AttachmentKey"] as! String
            }
            if dict.keys.contains("FileName") && dict["FileName"] != nil {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                self.fileSize = dict["FileSize"] as! Int64
            }
            if dict.keys.contains("FileSource") && dict["FileSource"] != nil {
                self.fileSource = dict["FileSource"] as! String
            }
            if dict.keys.contains("JobKey") && dict["JobKey"] != nil {
                self.jobKey = dict["JobKey"] as! String
            }
            if dict.keys.contains("JobStatus") && dict["JobStatus"] != nil {
                self.jobStatus = dict["JobStatus"] as! String
            }
            if dict.keys.contains("JobStatusDesc") && dict["JobStatusDesc"] != nil {
                self.jobStatusDesc = dict["JobStatusDesc"] as! String
            }
            if dict.keys.contains("UploadOSSParam") && dict["UploadOSSParam"] != nil {
                var model = GetUserUploadFileJobResponseBody.UploadFileJobDetail.UploadOSSParam()
                model.fromMap(dict["UploadOSSParam"] as! [String: Any])
                self.uploadOSSParam = model
            }
            if dict.keys.contains("UploadType") && dict["UploadType"] != nil {
                self.uploadType = dict["UploadType"] as! String
            }
            if dict.keys.contains("UploadURL") && dict["UploadURL"] != nil {
                self.uploadURL = dict["UploadURL"] as! String
            }
            if dict.keys.contains("UploadedSize") && dict["UploadedSize"] != nil {
                self.uploadedSize = dict["UploadedSize"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var uploadFileJobDetail: GetUserUploadFileJobResponseBody.UploadFileJobDetail?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.uploadFileJobDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.uploadFileJobDetail != nil {
            map["UploadFileJobDetail"] = self.uploadFileJobDetail?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("UploadFileJobDetail") && dict["UploadFileJobDetail"] != nil {
            var model = GetUserUploadFileJobResponseBody.UploadFileJobDetail()
            model.fromMap(dict["UploadFileJobDetail"] as! [String: Any])
            self.uploadFileJobDetail = model
        }
    }
}

public class GetUserUploadFileJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserUploadFileJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetUserUploadFileJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GrantTemplateAuthorityRequest : Tea.TeaModel {
    public var comment: String?

    public var expireDate: String?

    public var templateId: Int64?

    public var tid: Int64?

    public var userIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.expireDate != nil {
            map["ExpireDate"] = self.expireDate!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("ExpireDate") && dict["ExpireDate"] != nil {
            self.expireDate = dict["ExpireDate"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserIds") && dict["UserIds"] != nil {
            self.userIds = dict["UserIds"] as! String
        }
    }
}

public class GrantTemplateAuthorityResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GrantTemplateAuthorityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GrantTemplateAuthorityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GrantTemplateAuthorityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GrantUserPermissionRequest : Tea.TeaModel {
    public var dbId: String?

    public var dsType: String?

    public var expireDate: String?

    public var instanceId: Int64?

    public var logic: Bool?

    public var permTypes: String?

    public var tableId: String?

    public var tableName: String?

    public var tid: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.dsType != nil {
            map["DsType"] = self.dsType!
        }
        if self.expireDate != nil {
            map["ExpireDate"] = self.expireDate!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.permTypes != nil {
            map["PermTypes"] = self.permTypes!
        }
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") && dict["DbId"] != nil {
            self.dbId = dict["DbId"] as! String
        }
        if dict.keys.contains("DsType") && dict["DsType"] != nil {
            self.dsType = dict["DsType"] as! String
        }
        if dict.keys.contains("ExpireDate") && dict["ExpireDate"] != nil {
            self.expireDate = dict["ExpireDate"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("Logic") && dict["Logic"] != nil {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("PermTypes") && dict["PermTypes"] != nil {
            self.permTypes = dict["PermTypes"] as! String
        }
        if dict.keys.contains("TableId") && dict["TableId"] != nil {
            self.tableId = dict["TableId"] as! String
        }
        if dict.keys.contains("TableName") && dict["TableName"] != nil {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GrantUserPermissionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GrantUserPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GrantUserPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GrantUserPermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InspectProxyAccessSecretRequest : Tea.TeaModel {
    public var proxyAccessId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.proxyAccessId != nil {
            map["ProxyAccessId"] = self.proxyAccessId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProxyAccessId") && dict["ProxyAccessId"] != nil {
            self.proxyAccessId = dict["ProxyAccessId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class InspectProxyAccessSecretResponseBody : Tea.TeaModel {
    public var accessSecret: String?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessSecret != nil {
            map["AccessSecret"] = self.accessSecret!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessSecret") && dict["AccessSecret"] != nil {
            self.accessSecret = dict["AccessSecret"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class InspectProxyAccessSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InspectProxyAccessSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InspectProxyAccessSecretResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClassificationTemplatesRequest : Tea.TeaModel {
    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListClassificationTemplatesResponseBody : Tea.TeaModel {
    public class TemplateList : Tea.TeaModel {
        public var name: String?

        public var remark: String?

        public var templateId: Int64?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Remark") && dict["Remark"] != nil {
                self.remark = dict["Remark"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! Int64
            }
            if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
                self.templateType = dict["TemplateType"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var templateList: [ListClassificationTemplatesResponseBody.TemplateList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.templateList != nil {
            var tmp : [Any] = []
            for k in self.templateList! {
                tmp.append(k.toMap())
            }
            map["TemplateList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TemplateList") && dict["TemplateList"] != nil {
            var tmp : [ListClassificationTemplatesResponseBody.TemplateList] = []
            for v in dict["TemplateList"] as! [Any] {
                var model = ListClassificationTemplatesResponseBody.TemplateList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templateList = tmp
        }
    }
}

public class ListClassificationTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClassificationTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClassificationTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListColumnsRequest : Tea.TeaModel {
    public var logic: Bool?

    public var tableId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Logic") && dict["Logic"] != nil {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("TableId") && dict["TableId"] != nil {
            self.tableId = dict["TableId"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListColumnsResponseBody : Tea.TeaModel {
    public class ColumnList : Tea.TeaModel {
        public class Column : Tea.TeaModel {
            public var autoIncrement: Bool?

            public var columnId: String?

            public var columnName: String?

            public var columnType: String?

            public var dataLength: Int64?

            public var dataPrecision: Int32?

            public var dataScale: Int32?

            public var defaultValue: String?

            public var description_: String?

            public var functionType: String?

            public var nullable: Bool?

            public var securityLevel: String?

            public var sensitive: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoIncrement != nil {
                    map["AutoIncrement"] = self.autoIncrement!
                }
                if self.columnId != nil {
                    map["ColumnId"] = self.columnId!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.columnType != nil {
                    map["ColumnType"] = self.columnType!
                }
                if self.dataLength != nil {
                    map["DataLength"] = self.dataLength!
                }
                if self.dataPrecision != nil {
                    map["DataPrecision"] = self.dataPrecision!
                }
                if self.dataScale != nil {
                    map["DataScale"] = self.dataScale!
                }
                if self.defaultValue != nil {
                    map["DefaultValue"] = self.defaultValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.functionType != nil {
                    map["FunctionType"] = self.functionType!
                }
                if self.nullable != nil {
                    map["Nullable"] = self.nullable!
                }
                if self.securityLevel != nil {
                    map["SecurityLevel"] = self.securityLevel!
                }
                if self.sensitive != nil {
                    map["Sensitive"] = self.sensitive!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoIncrement") && dict["AutoIncrement"] != nil {
                    self.autoIncrement = dict["AutoIncrement"] as! Bool
                }
                if dict.keys.contains("ColumnId") && dict["ColumnId"] != nil {
                    self.columnId = dict["ColumnId"] as! String
                }
                if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("ColumnType") && dict["ColumnType"] != nil {
                    self.columnType = dict["ColumnType"] as! String
                }
                if dict.keys.contains("DataLength") && dict["DataLength"] != nil {
                    self.dataLength = dict["DataLength"] as! Int64
                }
                if dict.keys.contains("DataPrecision") && dict["DataPrecision"] != nil {
                    self.dataPrecision = dict["DataPrecision"] as! Int32
                }
                if dict.keys.contains("DataScale") && dict["DataScale"] != nil {
                    self.dataScale = dict["DataScale"] as! Int32
                }
                if dict.keys.contains("DefaultValue") && dict["DefaultValue"] != nil {
                    self.defaultValue = dict["DefaultValue"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("FunctionType") && dict["FunctionType"] != nil {
                    self.functionType = dict["FunctionType"] as! String
                }
                if dict.keys.contains("Nullable") && dict["Nullable"] != nil {
                    self.nullable = dict["Nullable"] as! Bool
                }
                if dict.keys.contains("SecurityLevel") && dict["SecurityLevel"] != nil {
                    self.securityLevel = dict["SecurityLevel"] as! String
                }
                if dict.keys.contains("Sensitive") && dict["Sensitive"] != nil {
                    self.sensitive = dict["Sensitive"] as! Bool
                }
            }
        }
        public var column: [ListColumnsResponseBody.ColumnList.Column]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.column != nil {
                var tmp : [Any] = []
                for k in self.column! {
                    tmp.append(k.toMap())
                }
                map["Column"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Column") && dict["Column"] != nil {
                var tmp : [ListColumnsResponseBody.ColumnList.Column] = []
                for v in dict["Column"] as! [Any] {
                    var model = ListColumnsResponseBody.ColumnList.Column()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.column = tmp
            }
        }
    }
    public var columnList: ListColumnsResponseBody.ColumnList?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.columnList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnList != nil {
            map["ColumnList"] = self.columnList?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnList") && dict["ColumnList"] != nil {
            var model = ListColumnsResponseBody.ColumnList()
            model.fromMap(dict["ColumnList"] as! [String: Any])
            self.columnList = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListColumnsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListColumnsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListColumnsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDAGVersionsRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var pageIndex: Int32?

    public var pageSize: Int32?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("PageIndex") && dict["PageIndex"] != nil {
            self.pageIndex = dict["PageIndex"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDAGVersionsResponseBody : Tea.TeaModel {
    public class DagVersionList : Tea.TeaModel {
        public class DagVersion : Tea.TeaModel {
            public var dagName: String?

            public var dagOwnerId: String?

            public var dagOwnerNickName: String?

            public var lastVersionId: Int64?

            public var versionComments: String?

            public var versionId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dagName != nil {
                    map["DagName"] = self.dagName!
                }
                if self.dagOwnerId != nil {
                    map["DagOwnerId"] = self.dagOwnerId!
                }
                if self.dagOwnerNickName != nil {
                    map["DagOwnerNickName"] = self.dagOwnerNickName!
                }
                if self.lastVersionId != nil {
                    map["LastVersionId"] = self.lastVersionId!
                }
                if self.versionComments != nil {
                    map["VersionComments"] = self.versionComments!
                }
                if self.versionId != nil {
                    map["VersionId"] = self.versionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DagName") && dict["DagName"] != nil {
                    self.dagName = dict["DagName"] as! String
                }
                if dict.keys.contains("DagOwnerId") && dict["DagOwnerId"] != nil {
                    self.dagOwnerId = dict["DagOwnerId"] as! String
                }
                if dict.keys.contains("DagOwnerNickName") && dict["DagOwnerNickName"] != nil {
                    self.dagOwnerNickName = dict["DagOwnerNickName"] as! String
                }
                if dict.keys.contains("LastVersionId") && dict["LastVersionId"] != nil {
                    self.lastVersionId = dict["LastVersionId"] as! Int64
                }
                if dict.keys.contains("VersionComments") && dict["VersionComments"] != nil {
                    self.versionComments = dict["VersionComments"] as! String
                }
                if dict.keys.contains("VersionId") && dict["VersionId"] != nil {
                    self.versionId = dict["VersionId"] as! Int64
                }
            }
        }
        public var dagVersion: [ListDAGVersionsResponseBody.DagVersionList.DagVersion]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dagVersion != nil {
                var tmp : [Any] = []
                for k in self.dagVersion! {
                    tmp.append(k.toMap())
                }
                map["DagVersion"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DagVersion") && dict["DagVersion"] != nil {
                var tmp : [ListDAGVersionsResponseBody.DagVersionList.DagVersion] = []
                for v in dict["DagVersion"] as! [Any] {
                    var model = ListDAGVersionsResponseBody.DagVersionList.DagVersion()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dagVersion = tmp
            }
        }
    }
    public var dagVersionList: ListDAGVersionsResponseBody.DagVersionList?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dagVersionList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagVersionList != nil {
            map["DagVersionList"] = self.dagVersionList?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagVersionList") && dict["DagVersionList"] != nil {
            var model = ListDAGVersionsResponseBody.DagVersionList()
            model.fromMap(dict["DagVersionList"] as! [String: Any])
            self.dagVersionList = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListDAGVersionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDAGVersionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDAGVersionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDBTaskSQLJobRequest : Tea.TeaModel {
    public var DBTaskGroupId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBTaskGroupId != nil {
            map["DBTaskGroupId"] = self.DBTaskGroupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBTaskGroupId") && dict["DBTaskGroupId"] != nil {
            self.DBTaskGroupId = dict["DBTaskGroupId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDBTaskSQLJobResponseBody : Tea.TeaModel {
    public class DBTaskSQLJobList : Tea.TeaModel {
        public var comment: String?

        public var createTime: String?

        public var dbId: Int64?

        public var dbSearchName: String?

        public var dbTaskGroupId: Int64?

        public var jobId: Int64?

        public var jobType: String?

        public var lastExecTime: String?

        public var logic: Bool?

        public var status: String?

        public var transactional: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.dbSearchName != nil {
                map["DbSearchName"] = self.dbSearchName!
            }
            if self.dbTaskGroupId != nil {
                map["DbTaskGroupId"] = self.dbTaskGroupId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.lastExecTime != nil {
                map["LastExecTime"] = self.lastExecTime!
            }
            if self.logic != nil {
                map["Logic"] = self.logic!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.transactional != nil {
                map["Transactional"] = self.transactional!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Comment") && dict["Comment"] != nil {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DbId") && dict["DbId"] != nil {
                self.dbId = dict["DbId"] as! Int64
            }
            if dict.keys.contains("DbSearchName") && dict["DbSearchName"] != nil {
                self.dbSearchName = dict["DbSearchName"] as! String
            }
            if dict.keys.contains("DbTaskGroupId") && dict["DbTaskGroupId"] != nil {
                self.dbTaskGroupId = dict["DbTaskGroupId"] as! Int64
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! Int64
            }
            if dict.keys.contains("JobType") && dict["JobType"] != nil {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("LastExecTime") && dict["LastExecTime"] != nil {
                self.lastExecTime = dict["LastExecTime"] as! String
            }
            if dict.keys.contains("Logic") && dict["Logic"] != nil {
                self.logic = dict["Logic"] as! Bool
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Transactional") && dict["Transactional"] != nil {
                self.transactional = dict["Transactional"] as! Bool
            }
        }
    }
    public var DBTaskSQLJobList: [ListDBTaskSQLJobResponseBody.DBTaskSQLJobList]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBTaskSQLJobList != nil {
            var tmp : [Any] = []
            for k in self.DBTaskSQLJobList! {
                tmp.append(k.toMap())
            }
            map["DBTaskSQLJobList"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBTaskSQLJobList") && dict["DBTaskSQLJobList"] != nil {
            var tmp : [ListDBTaskSQLJobResponseBody.DBTaskSQLJobList] = []
            for v in dict["DBTaskSQLJobList"] as! [Any] {
                var model = ListDBTaskSQLJobResponseBody.DBTaskSQLJobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.DBTaskSQLJobList = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListDBTaskSQLJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDBTaskSQLJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDBTaskSQLJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDBTaskSQLJobDetailRequest : Tea.TeaModel {
    public var jobId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDBTaskSQLJobDetailResponseBody : Tea.TeaModel {
    public class DBTaskSQLJobDetailList : Tea.TeaModel {
        public var affectRows: Int64?

        public var currentSql: String?

        public var dbId: Int64?

        public var endTime: String?

        public var executeCount: Int64?

        public var jobDetailId: Int64?

        public var jobId: Int64?

        public var log: String?

        public var logic: Bool?

        public var skip: Bool?

        public var sqlType: String?

        public var startTime: String?

        public var status: String?

        public var timeDelay: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.affectRows != nil {
                map["AffectRows"] = self.affectRows!
            }
            if self.currentSql != nil {
                map["CurrentSql"] = self.currentSql!
            }
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.executeCount != nil {
                map["ExecuteCount"] = self.executeCount!
            }
            if self.jobDetailId != nil {
                map["JobDetailId"] = self.jobDetailId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.log != nil {
                map["Log"] = self.log!
            }
            if self.logic != nil {
                map["Logic"] = self.logic!
            }
            if self.skip != nil {
                map["Skip"] = self.skip!
            }
            if self.sqlType != nil {
                map["SqlType"] = self.sqlType!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.timeDelay != nil {
                map["TimeDelay"] = self.timeDelay!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AffectRows") && dict["AffectRows"] != nil {
                self.affectRows = dict["AffectRows"] as! Int64
            }
            if dict.keys.contains("CurrentSql") && dict["CurrentSql"] != nil {
                self.currentSql = dict["CurrentSql"] as! String
            }
            if dict.keys.contains("DbId") && dict["DbId"] != nil {
                self.dbId = dict["DbId"] as! Int64
            }
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("ExecuteCount") && dict["ExecuteCount"] != nil {
                self.executeCount = dict["ExecuteCount"] as! Int64
            }
            if dict.keys.contains("JobDetailId") && dict["JobDetailId"] != nil {
                self.jobDetailId = dict["JobDetailId"] as! Int64
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! Int64
            }
            if dict.keys.contains("Log") && dict["Log"] != nil {
                self.log = dict["Log"] as! String
            }
            if dict.keys.contains("Logic") && dict["Logic"] != nil {
                self.logic = dict["Logic"] as! Bool
            }
            if dict.keys.contains("Skip") && dict["Skip"] != nil {
                self.skip = dict["Skip"] as! Bool
            }
            if dict.keys.contains("SqlType") && dict["SqlType"] != nil {
                self.sqlType = dict["SqlType"] as! String
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TimeDelay") && dict["TimeDelay"] != nil {
                self.timeDelay = dict["TimeDelay"] as! Int64
            }
        }
    }
    public var DBTaskSQLJobDetailList: [ListDBTaskSQLJobDetailResponseBody.DBTaskSQLJobDetailList]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBTaskSQLJobDetailList != nil {
            var tmp : [Any] = []
            for k in self.DBTaskSQLJobDetailList! {
                tmp.append(k.toMap())
            }
            map["DBTaskSQLJobDetailList"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBTaskSQLJobDetailList") && dict["DBTaskSQLJobDetailList"] != nil {
            var tmp : [ListDBTaskSQLJobDetailResponseBody.DBTaskSQLJobDetailList] = []
            for v in dict["DBTaskSQLJobDetailList"] as! [Any] {
                var model = ListDBTaskSQLJobDetailResponseBody.DBTaskSQLJobDetailList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.DBTaskSQLJobDetailList = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListDBTaskSQLJobDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDBTaskSQLJobDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDBTaskSQLJobDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDDLPublishRecordsRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDDLPublishRecordsResponseBody : Tea.TeaModel {
    public class DDLPublishRecordList : Tea.TeaModel {
        public class PublishTaskInfoList : Tea.TeaModel {
            public class PublishJobList : Tea.TeaModel {
                public var DBTaskGroupId: Int64?

                public var executeCount: Int64?

                public var scripts: String?

                public var statusDesc: String?

                public var tableName: String?

                public var taskJobStatus: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.DBTaskGroupId != nil {
                        map["DBTaskGroupId"] = self.DBTaskGroupId!
                    }
                    if self.executeCount != nil {
                        map["ExecuteCount"] = self.executeCount!
                    }
                    if self.scripts != nil {
                        map["Scripts"] = self.scripts!
                    }
                    if self.statusDesc != nil {
                        map["StatusDesc"] = self.statusDesc!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    if self.taskJobStatus != nil {
                        map["TaskJobStatus"] = self.taskJobStatus!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DBTaskGroupId") && dict["DBTaskGroupId"] != nil {
                        self.DBTaskGroupId = dict["DBTaskGroupId"] as! Int64
                    }
                    if dict.keys.contains("ExecuteCount") && dict["ExecuteCount"] != nil {
                        self.executeCount = dict["ExecuteCount"] as! Int64
                    }
                    if dict.keys.contains("Scripts") && dict["Scripts"] != nil {
                        self.scripts = dict["Scripts"] as! String
                    }
                    if dict.keys.contains("StatusDesc") && dict["StatusDesc"] != nil {
                        self.statusDesc = dict["StatusDesc"] as! String
                    }
                    if dict.keys.contains("TableName") && dict["TableName"] != nil {
                        self.tableName = dict["TableName"] as! String
                    }
                    if dict.keys.contains("TaskJobStatus") && dict["TaskJobStatus"] != nil {
                        self.taskJobStatus = dict["TaskJobStatus"] as! String
                    }
                }
            }
            public var dbId: Int64?

            public var logic: Bool?

            public var planTime: String?

            public var publishJobList: [ListDDLPublishRecordsResponseBody.DDLPublishRecordList.PublishTaskInfoList.PublishJobList]?

            public var publishStrategy: String?

            public var statusDesc: String?

            public var taskJobStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.planTime != nil {
                    map["PlanTime"] = self.planTime!
                }
                if self.publishJobList != nil {
                    var tmp : [Any] = []
                    for k in self.publishJobList! {
                        tmp.append(k.toMap())
                    }
                    map["PublishJobList"] = tmp
                }
                if self.publishStrategy != nil {
                    map["PublishStrategy"] = self.publishStrategy!
                }
                if self.statusDesc != nil {
                    map["StatusDesc"] = self.statusDesc!
                }
                if self.taskJobStatus != nil {
                    map["TaskJobStatus"] = self.taskJobStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("PlanTime") && dict["PlanTime"] != nil {
                    self.planTime = dict["PlanTime"] as! String
                }
                if dict.keys.contains("PublishJobList") && dict["PublishJobList"] != nil {
                    var tmp : [ListDDLPublishRecordsResponseBody.DDLPublishRecordList.PublishTaskInfoList.PublishJobList] = []
                    for v in dict["PublishJobList"] as! [Any] {
                        var model = ListDDLPublishRecordsResponseBody.DDLPublishRecordList.PublishTaskInfoList.PublishJobList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.publishJobList = tmp
                }
                if dict.keys.contains("PublishStrategy") && dict["PublishStrategy"] != nil {
                    self.publishStrategy = dict["PublishStrategy"] as! String
                }
                if dict.keys.contains("StatusDesc") && dict["StatusDesc"] != nil {
                    self.statusDesc = dict["StatusDesc"] as! String
                }
                if dict.keys.contains("TaskJobStatus") && dict["TaskJobStatus"] != nil {
                    self.taskJobStatus = dict["TaskJobStatus"] as! String
                }
            }
        }
        public var auditExpireTime: String?

        public var auditStatus: String?

        public var comment: String?

        public var creatorId: Int64?

        public var finality: Bool?

        public var finalityReason: String?

        public var publishStatus: String?

        public var publishTaskInfoList: [ListDDLPublishRecordsResponseBody.DDLPublishRecordList.PublishTaskInfoList]?

        public var riskLevel: String?

        public var statusDesc: String?

        public var workflowInstanceId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.auditExpireTime != nil {
                map["AuditExpireTime"] = self.auditExpireTime!
            }
            if self.auditStatus != nil {
                map["AuditStatus"] = self.auditStatus!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.finality != nil {
                map["Finality"] = self.finality!
            }
            if self.finalityReason != nil {
                map["FinalityReason"] = self.finalityReason!
            }
            if self.publishStatus != nil {
                map["PublishStatus"] = self.publishStatus!
            }
            if self.publishTaskInfoList != nil {
                var tmp : [Any] = []
                for k in self.publishTaskInfoList! {
                    tmp.append(k.toMap())
                }
                map["PublishTaskInfoList"] = tmp
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.workflowInstanceId != nil {
                map["WorkflowInstanceId"] = self.workflowInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuditExpireTime") && dict["AuditExpireTime"] != nil {
                self.auditExpireTime = dict["AuditExpireTime"] as! String
            }
            if dict.keys.contains("AuditStatus") && dict["AuditStatus"] != nil {
                self.auditStatus = dict["AuditStatus"] as! String
            }
            if dict.keys.contains("Comment") && dict["Comment"] != nil {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! Int64
            }
            if dict.keys.contains("Finality") && dict["Finality"] != nil {
                self.finality = dict["Finality"] as! Bool
            }
            if dict.keys.contains("FinalityReason") && dict["FinalityReason"] != nil {
                self.finalityReason = dict["FinalityReason"] as! String
            }
            if dict.keys.contains("PublishStatus") && dict["PublishStatus"] != nil {
                self.publishStatus = dict["PublishStatus"] as! String
            }
            if dict.keys.contains("PublishTaskInfoList") && dict["PublishTaskInfoList"] != nil {
                var tmp : [ListDDLPublishRecordsResponseBody.DDLPublishRecordList.PublishTaskInfoList] = []
                for v in dict["PublishTaskInfoList"] as! [Any] {
                    var model = ListDDLPublishRecordsResponseBody.DDLPublishRecordList.PublishTaskInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.publishTaskInfoList = tmp
            }
            if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
                self.riskLevel = dict["RiskLevel"] as! String
            }
            if dict.keys.contains("StatusDesc") && dict["StatusDesc"] != nil {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("WorkflowInstanceId") && dict["WorkflowInstanceId"] != nil {
                self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
            }
        }
    }
    public var DDLPublishRecordList: [ListDDLPublishRecordsResponseBody.DDLPublishRecordList]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DDLPublishRecordList != nil {
            var tmp : [Any] = []
            for k in self.DDLPublishRecordList! {
                tmp.append(k.toMap())
            }
            map["DDLPublishRecordList"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DDLPublishRecordList") && dict["DDLPublishRecordList"] != nil {
            var tmp : [ListDDLPublishRecordsResponseBody.DDLPublishRecordList] = []
            for v in dict["DDLPublishRecordList"] as! [Any] {
                var model = ListDDLPublishRecordsResponseBody.DDLPublishRecordList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.DDLPublishRecordList = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDDLPublishRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDDLPublishRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDDLPublishRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataCorrectPreCheckDBRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDataCorrectPreCheckDBResponseBody : Tea.TeaModel {
    public class PreCheckDBList : Tea.TeaModel {
        public var dbId: Int64?

        public var searchName: String?

        public var sqlNum: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.searchName != nil {
                map["SearchName"] = self.searchName!
            }
            if self.sqlNum != nil {
                map["SqlNum"] = self.sqlNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbId") && dict["DbId"] != nil {
                self.dbId = dict["DbId"] as! Int64
            }
            if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                self.searchName = dict["SearchName"] as! String
            }
            if dict.keys.contains("SqlNum") && dict["SqlNum"] != nil {
                self.sqlNum = dict["SqlNum"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var preCheckDBList: [ListDataCorrectPreCheckDBResponseBody.PreCheckDBList]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.preCheckDBList != nil {
            var tmp : [Any] = []
            for k in self.preCheckDBList! {
                tmp.append(k.toMap())
            }
            map["PreCheckDBList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("PreCheckDBList") && dict["PreCheckDBList"] != nil {
            var tmp : [ListDataCorrectPreCheckDBResponseBody.PreCheckDBList] = []
            for v in dict["PreCheckDBList"] as! [Any] {
                var model = ListDataCorrectPreCheckDBResponseBody.PreCheckDBList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.preCheckDBList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDataCorrectPreCheckDBResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataCorrectPreCheckDBResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDataCorrectPreCheckDBResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataCorrectPreCheckSQLRequest : Tea.TeaModel {
    public var dbId: Int64?

    public var orderId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") && dict["DbId"] != nil {
            self.dbId = dict["DbId"] as! Int64
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDataCorrectPreCheckSQLResponseBody : Tea.TeaModel {
    public class PreCheckSQLList : Tea.TeaModel {
        public var affectRows: Int64?

        public var checkSQL: String?

        public var dbId: Int64?

        public var SQLReviewQueryKey: String?

        public var sqlReviewStatus: String?

        public var sqlType: String?

        public var tableNames: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.affectRows != nil {
                map["AffectRows"] = self.affectRows!
            }
            if self.checkSQL != nil {
                map["CheckSQL"] = self.checkSQL!
            }
            if self.dbId != nil {
                map["DbId"] = self.dbId!
            }
            if self.SQLReviewQueryKey != nil {
                map["SQLReviewQueryKey"] = self.SQLReviewQueryKey!
            }
            if self.sqlReviewStatus != nil {
                map["SqlReviewStatus"] = self.sqlReviewStatus!
            }
            if self.sqlType != nil {
                map["SqlType"] = self.sqlType!
            }
            if self.tableNames != nil {
                map["TableNames"] = self.tableNames!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AffectRows") && dict["AffectRows"] != nil {
                self.affectRows = dict["AffectRows"] as! Int64
            }
            if dict.keys.contains("CheckSQL") && dict["CheckSQL"] != nil {
                self.checkSQL = dict["CheckSQL"] as! String
            }
            if dict.keys.contains("DbId") && dict["DbId"] != nil {
                self.dbId = dict["DbId"] as! Int64
            }
            if dict.keys.contains("SQLReviewQueryKey") && dict["SQLReviewQueryKey"] != nil {
                self.SQLReviewQueryKey = dict["SQLReviewQueryKey"] as! String
            }
            if dict.keys.contains("SqlReviewStatus") && dict["SqlReviewStatus"] != nil {
                self.sqlReviewStatus = dict["SqlReviewStatus"] as! String
            }
            if dict.keys.contains("SqlType") && dict["SqlType"] != nil {
                self.sqlType = dict["SqlType"] as! String
            }
            if dict.keys.contains("TableNames") && dict["TableNames"] != nil {
                self.tableNames = dict["TableNames"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var preCheckSQLList: [ListDataCorrectPreCheckSQLResponseBody.PreCheckSQLList]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.preCheckSQLList != nil {
            var tmp : [Any] = []
            for k in self.preCheckSQLList! {
                tmp.append(k.toMap())
            }
            map["PreCheckSQLList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("PreCheckSQLList") && dict["PreCheckSQLList"] != nil {
            var tmp : [ListDataCorrectPreCheckSQLResponseBody.PreCheckSQLList] = []
            for v in dict["PreCheckSQLList"] as! [Any] {
                var model = ListDataCorrectPreCheckSQLResponseBody.PreCheckSQLList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.preCheckSQLList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDataCorrectPreCheckSQLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataCorrectPreCheckSQLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDataCorrectPreCheckSQLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataImportSQLPreCheckDetailRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var pageNumer: Int64?

    public var pageSize: Int64?

    public var sqlType: String?

    public var statusCode: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.pageNumer != nil {
            map["PageNumer"] = self.pageNumer!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sqlType != nil {
            map["SqlType"] = self.sqlType!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("PageNumer") && dict["PageNumer"] != nil {
            self.pageNumer = dict["PageNumer"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SqlType") && dict["SqlType"] != nil {
            self.sqlType = dict["SqlType"] as! String
        }
        if dict.keys.contains("StatusCode") && dict["StatusCode"] != nil {
            self.statusCode = dict["StatusCode"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDataImportSQLPreCheckDetailResponseBody : Tea.TeaModel {
    public class PreCheckSQLDetailList : Tea.TeaModel {
        public var skip: Bool?

        public var sqlId: Int64?

        public var sqlType: String?

        public var statusCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.skip != nil {
                map["Skip"] = self.skip!
            }
            if self.sqlId != nil {
                map["SqlId"] = self.sqlId!
            }
            if self.sqlType != nil {
                map["SqlType"] = self.sqlType!
            }
            if self.statusCode != nil {
                map["StatusCode"] = self.statusCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Skip") && dict["Skip"] != nil {
                self.skip = dict["Skip"] as! Bool
            }
            if dict.keys.contains("SqlId") && dict["SqlId"] != nil {
                self.sqlId = dict["SqlId"] as! Int64
            }
            if dict.keys.contains("SqlType") && dict["SqlType"] != nil {
                self.sqlType = dict["SqlType"] as! String
            }
            if dict.keys.contains("StatusCode") && dict["StatusCode"] != nil {
                self.statusCode = dict["StatusCode"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var preCheckSQLDetailList: [ListDataImportSQLPreCheckDetailResponseBody.PreCheckSQLDetailList]?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.preCheckSQLDetailList != nil {
            var tmp : [Any] = []
            for k in self.preCheckSQLDetailList! {
                tmp.append(k.toMap())
            }
            map["PreCheckSQLDetailList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("PreCheckSQLDetailList") && dict["PreCheckSQLDetailList"] != nil {
            var tmp : [ListDataImportSQLPreCheckDetailResponseBody.PreCheckSQLDetailList] = []
            for v in dict["PreCheckSQLDetailList"] as! [Any] {
                var model = ListDataImportSQLPreCheckDetailResponseBody.PreCheckSQLDetailList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.preCheckSQLDetailList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListDataImportSQLPreCheckDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataImportSQLPreCheckDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDataImportSQLPreCheckDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataImportSQLTypeRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDataImportSQLTypeResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var sqlTypeResult: [String]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sqlTypeResult != nil {
            map["SqlTypeResult"] = self.sqlTypeResult!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SqlTypeResult") && dict["SqlTypeResult"] != nil {
            self.sqlTypeResult = dict["SqlTypeResult"] as! [String]
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDataImportSQLTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataImportSQLTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDataImportSQLTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDatabaseUserPermssionsRequest : Tea.TeaModel {
    public var dbId: String?

    public var logic: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var permType: String?

    public var tid: Int64?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.permType != nil {
            map["PermType"] = self.permType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") && dict["DbId"] != nil {
            self.dbId = dict["DbId"] as! String
        }
        if dict.keys.contains("Logic") && dict["Logic"] != nil {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PermType") && dict["PermType"] != nil {
            self.permType = dict["PermType"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserName") && dict["UserName"] != nil {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class ListDatabaseUserPermssionsResponseBody : Tea.TeaModel {
    public class UserPermissions : Tea.TeaModel {
        public class UserPermission : Tea.TeaModel {
            public class PermDetails : Tea.TeaModel {
                public class PermDetail : Tea.TeaModel {
                    public var createDate: String?

                    public var expireDate: String?

                    public var extraData: String?

                    public var originFrom: String?

                    public var permType: String?

                    public var userAccessId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.createDate != nil {
                            map["CreateDate"] = self.createDate!
                        }
                        if self.expireDate != nil {
                            map["ExpireDate"] = self.expireDate!
                        }
                        if self.extraData != nil {
                            map["ExtraData"] = self.extraData!
                        }
                        if self.originFrom != nil {
                            map["OriginFrom"] = self.originFrom!
                        }
                        if self.permType != nil {
                            map["PermType"] = self.permType!
                        }
                        if self.userAccessId != nil {
                            map["UserAccessId"] = self.userAccessId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CreateDate") && dict["CreateDate"] != nil {
                            self.createDate = dict["CreateDate"] as! String
                        }
                        if dict.keys.contains("ExpireDate") && dict["ExpireDate"] != nil {
                            self.expireDate = dict["ExpireDate"] as! String
                        }
                        if dict.keys.contains("ExtraData") && dict["ExtraData"] != nil {
                            self.extraData = dict["ExtraData"] as! String
                        }
                        if dict.keys.contains("OriginFrom") && dict["OriginFrom"] != nil {
                            self.originFrom = dict["OriginFrom"] as! String
                        }
                        if dict.keys.contains("PermType") && dict["PermType"] != nil {
                            self.permType = dict["PermType"] as! String
                        }
                        if dict.keys.contains("UserAccessId") && dict["UserAccessId"] != nil {
                            self.userAccessId = dict["UserAccessId"] as! String
                        }
                    }
                }
                public var permDetail: [ListDatabaseUserPermssionsResponseBody.UserPermissions.UserPermission.PermDetails.PermDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.permDetail != nil {
                        var tmp : [Any] = []
                        for k in self.permDetail! {
                            tmp.append(k.toMap())
                        }
                        map["PermDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PermDetail") && dict["PermDetail"] != nil {
                        var tmp : [ListDatabaseUserPermssionsResponseBody.UserPermissions.UserPermission.PermDetails.PermDetail] = []
                        for v in dict["PermDetail"] as! [Any] {
                            var model = ListDatabaseUserPermssionsResponseBody.UserPermissions.UserPermission.PermDetails.PermDetail()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.permDetail = tmp
                    }
                }
            }
            public var alias: String?

            public var columnName: String?

            public var dbId: String?

            public var dbType: String?

            public var dsType: String?

            public var envType: String?

            public var instanceId: String?

            public var logic: Bool?

            public var permDetails: ListDatabaseUserPermssionsResponseBody.UserPermissions.UserPermission.PermDetails?

            public var schemaName: String?

            public var searchName: String?

            public var tableId: String?

            public var tableName: String?

            public var userId: String?

            public var userNickName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.permDetails?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.dsType != nil {
                    map["DsType"] = self.dsType!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.permDetails != nil {
                    map["PermDetails"] = self.permDetails?.toMap()
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                if self.tableId != nil {
                    map["TableId"] = self.tableId!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userNickName != nil {
                    map["UserNickName"] = self.userNickName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") && dict["Alias"] != nil {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! String
                }
                if dict.keys.contains("DbType") && dict["DbType"] != nil {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("DsType") && dict["DsType"] != nil {
                    self.dsType = dict["DsType"] as! String
                }
                if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("PermDetails") && dict["PermDetails"] != nil {
                    var model = ListDatabaseUserPermssionsResponseBody.UserPermissions.UserPermission.PermDetails()
                    model.fromMap(dict["PermDetails"] as! [String: Any])
                    self.permDetails = model
                }
                if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                    self.searchName = dict["SearchName"] as! String
                }
                if dict.keys.contains("TableId") && dict["TableId"] != nil {
                    self.tableId = dict["TableId"] as! String
                }
                if dict.keys.contains("TableName") && dict["TableName"] != nil {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserNickName") && dict["UserNickName"] != nil {
                    self.userNickName = dict["UserNickName"] as! String
                }
            }
        }
        public var userPermission: [ListDatabaseUserPermssionsResponseBody.UserPermissions.UserPermission]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userPermission != nil {
                var tmp : [Any] = []
                for k in self.userPermission! {
                    tmp.append(k.toMap())
                }
                map["UserPermission"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserPermission") && dict["UserPermission"] != nil {
                var tmp : [ListDatabaseUserPermssionsResponseBody.UserPermissions.UserPermission] = []
                for v in dict["UserPermission"] as! [Any] {
                    var model = ListDatabaseUserPermssionsResponseBody.UserPermissions.UserPermission()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.userPermission = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public var userPermissions: ListDatabaseUserPermssionsResponseBody.UserPermissions?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userPermissions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.userPermissions != nil {
            map["UserPermissions"] = self.userPermissions?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("UserPermissions") && dict["UserPermissions"] != nil {
            var model = ListDatabaseUserPermssionsResponseBody.UserPermissions()
            model.fromMap(dict["UserPermissions"] as! [String: Any])
            self.userPermissions = model
        }
    }
}

public class ListDatabaseUserPermssionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDatabaseUserPermssionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDatabaseUserPermssionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDatabasesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDatabasesResponseBody : Tea.TeaModel {
    public class DatabaseList : Tea.TeaModel {
        public class Database : Tea.TeaModel {
            public class OwnerIdList : Tea.TeaModel {
                public var ownerIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerIds") && dict["OwnerIds"] != nil {
                        self.ownerIds = dict["OwnerIds"] as! [String]
                    }
                }
            }
            public class OwnerNameList : Tea.TeaModel {
                public var ownerNames: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerNames != nil {
                        map["OwnerNames"] = self.ownerNames!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerNames") && dict["OwnerNames"] != nil {
                        self.ownerNames = dict["OwnerNames"] as! [String]
                    }
                }
            }
            public var catalogName: String?

            public var databaseId: String?

            public var dbType: String?

            public var dbaId: String?

            public var dbaName: String?

            public var encoding: String?

            public var envType: String?

            public var host: String?

            public var instanceId: String?

            public var ownerIdList: ListDatabasesResponseBody.DatabaseList.Database.OwnerIdList?

            public var ownerNameList: ListDatabasesResponseBody.DatabaseList.Database.OwnerNameList?

            public var port: Int32?

            public var schemaName: String?

            public var searchName: String?

            public var sid: String?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ownerIdList?.validate()
                try self.ownerNameList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.catalogName != nil {
                    map["CatalogName"] = self.catalogName!
                }
                if self.databaseId != nil {
                    map["DatabaseId"] = self.databaseId!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.dbaId != nil {
                    map["DbaId"] = self.dbaId!
                }
                if self.dbaName != nil {
                    map["DbaName"] = self.dbaName!
                }
                if self.encoding != nil {
                    map["Encoding"] = self.encoding!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ownerIdList != nil {
                    map["OwnerIdList"] = self.ownerIdList?.toMap()
                }
                if self.ownerNameList != nil {
                    map["OwnerNameList"] = self.ownerNameList?.toMap()
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                if self.sid != nil {
                    map["Sid"] = self.sid!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CatalogName") && dict["CatalogName"] != nil {
                    self.catalogName = dict["CatalogName"] as! String
                }
                if dict.keys.contains("DatabaseId") && dict["DatabaseId"] != nil {
                    self.databaseId = dict["DatabaseId"] as! String
                }
                if dict.keys.contains("DbType") && dict["DbType"] != nil {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("DbaId") && dict["DbaId"] != nil {
                    self.dbaId = dict["DbaId"] as! String
                }
                if dict.keys.contains("DbaName") && dict["DbaName"] != nil {
                    self.dbaName = dict["DbaName"] as! String
                }
                if dict.keys.contains("Encoding") && dict["Encoding"] != nil {
                    self.encoding = dict["Encoding"] as! String
                }
                if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("Host") && dict["Host"] != nil {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("OwnerIdList") && dict["OwnerIdList"] != nil {
                    var model = ListDatabasesResponseBody.DatabaseList.Database.OwnerIdList()
                    model.fromMap(dict["OwnerIdList"] as! [String: Any])
                    self.ownerIdList = model
                }
                if dict.keys.contains("OwnerNameList") && dict["OwnerNameList"] != nil {
                    var model = ListDatabasesResponseBody.DatabaseList.Database.OwnerNameList()
                    model.fromMap(dict["OwnerNameList"] as! [String: Any])
                    self.ownerNameList = model
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                    self.searchName = dict["SearchName"] as! String
                }
                if dict.keys.contains("Sid") && dict["Sid"] != nil {
                    self.sid = dict["Sid"] as! String
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var database: [ListDatabasesResponseBody.DatabaseList.Database]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.database != nil {
                var tmp : [Any] = []
                for k in self.database! {
                    tmp.append(k.toMap())
                }
                map["Database"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Database") && dict["Database"] != nil {
                var tmp : [ListDatabasesResponseBody.DatabaseList.Database] = []
                for v in dict["Database"] as! [Any] {
                    var model = ListDatabasesResponseBody.DatabaseList.Database()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.database = tmp
            }
        }
    }
    public var databaseList: ListDatabasesResponseBody.DatabaseList?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.databaseList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseList != nil {
            map["DatabaseList"] = self.databaseList?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseList") && dict["DatabaseList"] != nil {
            var model = ListDatabasesResponseBody.DatabaseList()
            model.fromMap(dict["DatabaseList"] as! [String: Any])
            self.databaseList = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListDatabasesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDatabasesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDatabasesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDefaultSLARulesRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDefaultSLARulesResponseBody : Tea.TeaModel {
    public class SLARuleList : Tea.TeaModel {
        public class SLARule : Tea.TeaModel {
            public var dagId: Int64?

            public var id: Int64?

            public var intervalMinutes: Int32?

            public var nodeId: Int64?

            public var ruleType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dagId != nil {
                    map["DagId"] = self.dagId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.intervalMinutes != nil {
                    map["IntervalMinutes"] = self.intervalMinutes!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.ruleType != nil {
                    map["RuleType"] = self.ruleType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DagId") && dict["DagId"] != nil {
                    self.dagId = dict["DagId"] as! Int64
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IntervalMinutes") && dict["IntervalMinutes"] != nil {
                    self.intervalMinutes = dict["IntervalMinutes"] as! Int32
                }
                if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
                    self.ruleType = dict["RuleType"] as! Int32
                }
            }
        }
        public var SLARule: [ListDefaultSLARulesResponseBody.SLARuleList.SLARule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.SLARule != nil {
                var tmp : [Any] = []
                for k in self.SLARule! {
                    tmp.append(k.toMap())
                }
                map["SLARule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SLARule") && dict["SLARule"] != nil {
                var tmp : [ListDefaultSLARulesResponseBody.SLARuleList.SLARule] = []
                for v in dict["SLARule"] as! [Any] {
                    var model = ListDefaultSLARulesResponseBody.SLARuleList.SLARule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.SLARule = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var SLARuleList: ListDefaultSLARulesResponseBody.SLARuleList?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.SLARuleList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SLARuleList != nil {
            map["SLARuleList"] = self.SLARuleList?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SLARuleList") && dict["SLARuleList"] != nil {
            var model = ListDefaultSLARulesResponseBody.SLARuleList()
            model.fromMap(dict["SLARuleList"] as! [String: Any])
            self.SLARuleList = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDefaultSLARulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDefaultSLARulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDefaultSLARulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDesensitizationRuleRequest : Tea.TeaModel {
    public var funcType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var ruleId: Int32?

    public var ruleName: String?

    public var ruleType: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.funcType != nil {
            map["FuncType"] = self.funcType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.ruleType != nil {
            map["RuleType"] = self.ruleType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FuncType") && dict["FuncType"] != nil {
            self.funcType = dict["FuncType"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! Int32
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
            self.ruleType = dict["RuleType"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListDesensitizationRuleResponseBody : Tea.TeaModel {
    public class DesensitizationRuleList : Tea.TeaModel {
        public var funcParams: String?

        public var funcSample: String?

        public var functionType: String?

        public var lastModifierId: String?

        public var lastModifierName: String?

        public var referenceCount: Int32?

        public var ruleDesc: String?

        public var ruleId: Int32?

        public var ruleName: String?

        public var ruleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.funcParams != nil {
                map["FuncParams"] = self.funcParams!
            }
            if self.funcSample != nil {
                map["FuncSample"] = self.funcSample!
            }
            if self.functionType != nil {
                map["FunctionType"] = self.functionType!
            }
            if self.lastModifierId != nil {
                map["LastModifierId"] = self.lastModifierId!
            }
            if self.lastModifierName != nil {
                map["LastModifierName"] = self.lastModifierName!
            }
            if self.referenceCount != nil {
                map["ReferenceCount"] = self.referenceCount!
            }
            if self.ruleDesc != nil {
                map["RuleDesc"] = self.ruleDesc!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.ruleType != nil {
                map["RuleType"] = self.ruleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FuncParams") && dict["FuncParams"] != nil {
                self.funcParams = dict["FuncParams"] as! String
            }
            if dict.keys.contains("FuncSample") && dict["FuncSample"] != nil {
                self.funcSample = dict["FuncSample"] as! String
            }
            if dict.keys.contains("FunctionType") && dict["FunctionType"] != nil {
                self.functionType = dict["FunctionType"] as! String
            }
            if dict.keys.contains("LastModifierId") && dict["LastModifierId"] != nil {
                self.lastModifierId = dict["LastModifierId"] as! String
            }
            if dict.keys.contains("LastModifierName") && dict["LastModifierName"] != nil {
                self.lastModifierName = dict["LastModifierName"] as! String
            }
            if dict.keys.contains("ReferenceCount") && dict["ReferenceCount"] != nil {
                self.referenceCount = dict["ReferenceCount"] as! Int32
            }
            if dict.keys.contains("RuleDesc") && dict["RuleDesc"] != nil {
                self.ruleDesc = dict["RuleDesc"] as! String
            }
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! Int32
            }
            if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
                self.ruleType = dict["RuleType"] as! String
            }
        }
    }
    public var desensitizationRuleList: [ListDesensitizationRuleResponseBody.DesensitizationRuleList]?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.desensitizationRuleList != nil {
            var tmp : [Any] = []
            for k in self.desensitizationRuleList! {
                tmp.append(k.toMap())
            }
            map["DesensitizationRuleList"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DesensitizationRuleList") && dict["DesensitizationRuleList"] != nil {
            var tmp : [ListDesensitizationRuleResponseBody.DesensitizationRuleList] = []
            for v in dict["DesensitizationRuleList"] as! [Any] {
                var model = ListDesensitizationRuleResponseBody.DesensitizationRuleList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.desensitizationRuleList = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListDesensitizationRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDesensitizationRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDesensitizationRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEffectiveOrdersRequest : Tea.TeaModel {
    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListEffectiveOrdersResponseBody : Tea.TeaModel {
    public class OrderSummary : Tea.TeaModel {
        public class OrderList : Tea.TeaModel {
            public var buyerId: String?

            public var endTime: String?

            public var insNum: String?

            public var instanceId: String?

            public var orderId: String?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.buyerId != nil {
                    map["BuyerId"] = self.buyerId!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.insNum != nil {
                    map["InsNum"] = self.insNum!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.orderId != nil {
                    map["OrderId"] = self.orderId!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BuyerId") && dict["BuyerId"] != nil {
                    self.buyerId = dict["BuyerId"] as! String
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("InsNum") && dict["InsNum"] != nil {
                    self.insNum = dict["InsNum"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
                    self.orderId = dict["OrderId"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! String
                }
            }
        }
        public var commodityCode: String?

        public var commodityType: String?

        public var orderList: [ListEffectiveOrdersResponseBody.OrderSummary.OrderList]?

        public var totalQuota: Int32?

        public var versionType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commodityCode != nil {
                map["CommodityCode"] = self.commodityCode!
            }
            if self.commodityType != nil {
                map["CommodityType"] = self.commodityType!
            }
            if self.orderList != nil {
                var tmp : [Any] = []
                for k in self.orderList! {
                    tmp.append(k.toMap())
                }
                map["OrderList"] = tmp
            }
            if self.totalQuota != nil {
                map["TotalQuota"] = self.totalQuota!
            }
            if self.versionType != nil {
                map["VersionType"] = self.versionType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CommodityCode") && dict["CommodityCode"] != nil {
                self.commodityCode = dict["CommodityCode"] as! String
            }
            if dict.keys.contains("CommodityType") && dict["CommodityType"] != nil {
                self.commodityType = dict["CommodityType"] as! String
            }
            if dict.keys.contains("OrderList") && dict["OrderList"] != nil {
                var tmp : [ListEffectiveOrdersResponseBody.OrderSummary.OrderList] = []
                for v in dict["OrderList"] as! [Any] {
                    var model = ListEffectiveOrdersResponseBody.OrderSummary.OrderList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.orderList = tmp
            }
            if dict.keys.contains("TotalQuota") && dict["TotalQuota"] != nil {
                self.totalQuota = dict["TotalQuota"] as! Int32
            }
            if dict.keys.contains("VersionType") && dict["VersionType"] != nil {
                self.versionType = dict["VersionType"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var orderSummary: [ListEffectiveOrdersResponseBody.OrderSummary]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.orderSummary != nil {
            var tmp : [Any] = []
            for k in self.orderSummary! {
                tmp.append(k.toMap())
            }
            map["OrderSummary"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("OrderSummary") && dict["OrderSummary"] != nil {
            var tmp : [ListEffectiveOrdersResponseBody.OrderSummary] = []
            for v in dict["OrderSummary"] as! [Any] {
                var model = ListEffectiveOrdersResponseBody.OrderSummary()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.orderSummary = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListEffectiveOrdersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEffectiveOrdersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEffectiveOrdersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIndexesRequest : Tea.TeaModel {
    public var logic: Bool?

    public var tableId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Logic") && dict["Logic"] != nil {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("TableId") && dict["TableId"] != nil {
            self.tableId = dict["TableId"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListIndexesResponseBody : Tea.TeaModel {
    public class IndexList : Tea.TeaModel {
        public class Index : Tea.TeaModel {
            public var indexComment: String?

            public var indexId: String?

            public var indexName: String?

            public var indexType: String?

            public var tableId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.indexComment != nil {
                    map["IndexComment"] = self.indexComment!
                }
                if self.indexId != nil {
                    map["IndexId"] = self.indexId!
                }
                if self.indexName != nil {
                    map["IndexName"] = self.indexName!
                }
                if self.indexType != nil {
                    map["IndexType"] = self.indexType!
                }
                if self.tableId != nil {
                    map["TableId"] = self.tableId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IndexComment") && dict["IndexComment"] != nil {
                    self.indexComment = dict["IndexComment"] as! String
                }
                if dict.keys.contains("IndexId") && dict["IndexId"] != nil {
                    self.indexId = dict["IndexId"] as! String
                }
                if dict.keys.contains("IndexName") && dict["IndexName"] != nil {
                    self.indexName = dict["IndexName"] as! String
                }
                if dict.keys.contains("IndexType") && dict["IndexType"] != nil {
                    self.indexType = dict["IndexType"] as! String
                }
                if dict.keys.contains("TableId") && dict["TableId"] != nil {
                    self.tableId = dict["TableId"] as! String
                }
            }
        }
        public var index: [ListIndexesResponseBody.IndexList.Index]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.index != nil {
                var tmp : [Any] = []
                for k in self.index! {
                    tmp.append(k.toMap())
                }
                map["Index"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Index") && dict["Index"] != nil {
                var tmp : [ListIndexesResponseBody.IndexList.Index] = []
                for v in dict["Index"] as! [Any] {
                    var model = ListIndexesResponseBody.IndexList.Index()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.index = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var indexList: ListIndexesResponseBody.IndexList?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.indexList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.indexList != nil {
            map["IndexList"] = self.indexList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("IndexList") && dict["IndexList"] != nil {
            var model = ListIndexesResponseBody.IndexList()
            model.fromMap(dict["IndexList"] as! [String: Any])
            self.indexList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListIndexesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIndexesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListIndexesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstanceLoginAuditLogRequest : Tea.TeaModel {
    public var endTime: String?

    public var opUserName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchName: String?

    public var startTime: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.opUserName != nil {
            map["OpUserName"] = self.opUserName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchName != nil {
            map["SearchName"] = self.searchName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OpUserName") && dict["OpUserName"] != nil {
            self.opUserName = dict["OpUserName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
            self.searchName = dict["SearchName"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListInstanceLoginAuditLogResponseBody : Tea.TeaModel {
    public class InstanceLoginAuditLogList : Tea.TeaModel {
        public class InstanceLoginAuditLog : Tea.TeaModel {
            public var dbUser: String?

            public var instanceId: Int64?

            public var instanceName: String?

            public var opTime: String?

            public var requestIp: String?

            public var userId: Int64?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbUser != nil {
                    map["DbUser"] = self.dbUser!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.opTime != nil {
                    map["OpTime"] = self.opTime!
                }
                if self.requestIp != nil {
                    map["RequestIp"] = self.requestIp!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbUser") && dict["DbUser"] != nil {
                    self.dbUser = dict["DbUser"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("OpTime") && dict["OpTime"] != nil {
                    self.opTime = dict["OpTime"] as! String
                }
                if dict.keys.contains("RequestIp") && dict["RequestIp"] != nil {
                    self.requestIp = dict["RequestIp"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! Int64
                }
                if dict.keys.contains("UserName") && dict["UserName"] != nil {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public var instanceLoginAuditLog: [ListInstanceLoginAuditLogResponseBody.InstanceLoginAuditLogList.InstanceLoginAuditLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceLoginAuditLog != nil {
                var tmp : [Any] = []
                for k in self.instanceLoginAuditLog! {
                    tmp.append(k.toMap())
                }
                map["InstanceLoginAuditLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceLoginAuditLog") && dict["InstanceLoginAuditLog"] != nil {
                var tmp : [ListInstanceLoginAuditLogResponseBody.InstanceLoginAuditLogList.InstanceLoginAuditLog] = []
                for v in dict["InstanceLoginAuditLog"] as! [Any] {
                    var model = ListInstanceLoginAuditLogResponseBody.InstanceLoginAuditLogList.InstanceLoginAuditLog()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceLoginAuditLog = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var instanceLoginAuditLogList: ListInstanceLoginAuditLogResponseBody.InstanceLoginAuditLogList?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceLoginAuditLogList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.instanceLoginAuditLogList != nil {
            map["InstanceLoginAuditLogList"] = self.instanceLoginAuditLogList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("InstanceLoginAuditLogList") && dict["InstanceLoginAuditLogList"] != nil {
            var model = ListInstanceLoginAuditLogResponseBody.InstanceLoginAuditLogList()
            model.fromMap(dict["InstanceLoginAuditLogList"] as! [String: Any])
            self.instanceLoginAuditLogList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListInstanceLoginAuditLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceLoginAuditLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListInstanceLoginAuditLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstanceUserPermissionsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var tid: Int64?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserName") && dict["UserName"] != nil {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class ListInstanceUserPermissionsResponseBody : Tea.TeaModel {
    public class UserPermissions : Tea.TeaModel {
        public class UserPermission : Tea.TeaModel {
            public class PermDetails : Tea.TeaModel {
                public class PermDetail : Tea.TeaModel {
                    public var createDate: String?

                    public var expireDate: String?

                    public var extraData: String?

                    public var originFrom: String?

                    public var permType: String?

                    public var userAccessId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.createDate != nil {
                            map["CreateDate"] = self.createDate!
                        }
                        if self.expireDate != nil {
                            map["ExpireDate"] = self.expireDate!
                        }
                        if self.extraData != nil {
                            map["ExtraData"] = self.extraData!
                        }
                        if self.originFrom != nil {
                            map["OriginFrom"] = self.originFrom!
                        }
                        if self.permType != nil {
                            map["PermType"] = self.permType!
                        }
                        if self.userAccessId != nil {
                            map["UserAccessId"] = self.userAccessId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CreateDate") && dict["CreateDate"] != nil {
                            self.createDate = dict["CreateDate"] as! String
                        }
                        if dict.keys.contains("ExpireDate") && dict["ExpireDate"] != nil {
                            self.expireDate = dict["ExpireDate"] as! String
                        }
                        if dict.keys.contains("ExtraData") && dict["ExtraData"] != nil {
                            self.extraData = dict["ExtraData"] as! String
                        }
                        if dict.keys.contains("OriginFrom") && dict["OriginFrom"] != nil {
                            self.originFrom = dict["OriginFrom"] as! String
                        }
                        if dict.keys.contains("PermType") && dict["PermType"] != nil {
                            self.permType = dict["PermType"] as! String
                        }
                        if dict.keys.contains("UserAccessId") && dict["UserAccessId"] != nil {
                            self.userAccessId = dict["UserAccessId"] as! String
                        }
                    }
                }
                public var permDetail: [ListInstanceUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails.PermDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.permDetail != nil {
                        var tmp : [Any] = []
                        for k in self.permDetail! {
                            tmp.append(k.toMap())
                        }
                        map["PermDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PermDetail") && dict["PermDetail"] != nil {
                        var tmp : [ListInstanceUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails.PermDetail] = []
                        for v in dict["PermDetail"] as! [Any] {
                            var model = ListInstanceUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails.PermDetail()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.permDetail = tmp
                    }
                }
            }
            public var instanceId: String?

            public var permDetails: ListInstanceUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails?

            public var userId: String?

            public var userNickName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.permDetails?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.permDetails != nil {
                    map["PermDetails"] = self.permDetails?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userNickName != nil {
                    map["UserNickName"] = self.userNickName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("PermDetails") && dict["PermDetails"] != nil {
                    var model = ListInstanceUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails()
                    model.fromMap(dict["PermDetails"] as! [String: Any])
                    self.permDetails = model
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserNickName") && dict["UserNickName"] != nil {
                    self.userNickName = dict["UserNickName"] as! String
                }
            }
        }
        public var userPermission: [ListInstanceUserPermissionsResponseBody.UserPermissions.UserPermission]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userPermission != nil {
                var tmp : [Any] = []
                for k in self.userPermission! {
                    tmp.append(k.toMap())
                }
                map["UserPermission"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserPermission") && dict["UserPermission"] != nil {
                var tmp : [ListInstanceUserPermissionsResponseBody.UserPermissions.UserPermission] = []
                for v in dict["UserPermission"] as! [Any] {
                    var model = ListInstanceUserPermissionsResponseBody.UserPermissions.UserPermission()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.userPermission = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public var userPermissions: ListInstanceUserPermissionsResponseBody.UserPermissions?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userPermissions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.userPermissions != nil {
            map["UserPermissions"] = self.userPermissions?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("UserPermissions") && dict["UserPermissions"] != nil {
            var model = ListInstanceUserPermissionsResponseBody.UserPermissions()
            model.fromMap(dict["UserPermissions"] as! [String: Any])
            self.userPermissions = model
        }
    }
}

public class ListInstanceUserPermissionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceUserPermissionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListInstanceUserPermissionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstancesRequest : Tea.TeaModel {
    public var dbType: String?

    public var envType: String?

    public var instanceSource: String?

    public var instanceState: String?

    public var netType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchKey: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbType != nil {
            map["DbType"] = self.dbType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.instanceSource != nil {
            map["InstanceSource"] = self.instanceSource!
        }
        if self.instanceState != nil {
            map["InstanceState"] = self.instanceState!
        }
        if self.netType != nil {
            map["NetType"] = self.netType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbType") && dict["DbType"] != nil {
            self.dbType = dict["DbType"] as! String
        }
        if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("InstanceSource") && dict["InstanceSource"] != nil {
            self.instanceSource = dict["InstanceSource"] as! String
        }
        if dict.keys.contains("InstanceState") && dict["InstanceState"] != nil {
            self.instanceState = dict["InstanceState"] as! String
        }
        if dict.keys.contains("NetType") && dict["NetType"] != nil {
            self.netType = dict["NetType"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchKey") && dict["SearchKey"] != nil {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListInstancesResponseBody : Tea.TeaModel {
    public class InstanceList : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public class OwnerIdList : Tea.TeaModel {
                public var ownerIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerIds") && dict["OwnerIds"] != nil {
                        self.ownerIds = dict["OwnerIds"] as! [String]
                    }
                }
            }
            public class OwnerNameList : Tea.TeaModel {
                public var ownerNames: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerNames != nil {
                        map["OwnerNames"] = self.ownerNames!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerNames") && dict["OwnerNames"] != nil {
                        self.ownerNames = dict["OwnerNames"] as! [String]
                    }
                }
            }
            public class StandardGroup : Tea.TeaModel {
                public var groupMode: String?

                public var groupName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.groupMode != nil {
                        map["GroupMode"] = self.groupMode!
                    }
                    if self.groupName != nil {
                        map["GroupName"] = self.groupName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("GroupMode") && dict["GroupMode"] != nil {
                        self.groupMode = dict["GroupMode"] as! String
                    }
                    if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                        self.groupName = dict["GroupName"] as! String
                    }
                }
            }
            public var dataLinkName: String?

            public var databasePassword: String?

            public var databaseUser: String?

            public var dbaId: String?

            public var dbaNickName: String?

            public var ddlOnline: Int32?

            public var ecsInstanceId: String?

            public var ecsRegion: String?

            public var envType: String?

            public var exportTimeout: Int32?

            public var host: String?

            public var instanceAlias: String?

            public var instanceId: String?

            public var instanceSource: String?

            public var instanceType: String?

            public var ownerIdList: ListInstancesResponseBody.InstanceList.Instance.OwnerIdList?

            public var ownerNameList: ListInstancesResponseBody.InstanceList.Instance.OwnerNameList?

            public var port: Int32?

            public var queryTimeout: Int32?

            public var safeRuleId: String?

            public var sellSitd: Bool?

            public var sid: String?

            public var standardGroup: ListInstancesResponseBody.InstanceList.Instance.StandardGroup?

            public var state: String?

            public var useDsql: Int32?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ownerIdList?.validate()
                try self.ownerNameList?.validate()
                try self.standardGroup?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataLinkName != nil {
                    map["DataLinkName"] = self.dataLinkName!
                }
                if self.databasePassword != nil {
                    map["DatabasePassword"] = self.databasePassword!
                }
                if self.databaseUser != nil {
                    map["DatabaseUser"] = self.databaseUser!
                }
                if self.dbaId != nil {
                    map["DbaId"] = self.dbaId!
                }
                if self.dbaNickName != nil {
                    map["DbaNickName"] = self.dbaNickName!
                }
                if self.ddlOnline != nil {
                    map["DdlOnline"] = self.ddlOnline!
                }
                if self.ecsInstanceId != nil {
                    map["EcsInstanceId"] = self.ecsInstanceId!
                }
                if self.ecsRegion != nil {
                    map["EcsRegion"] = self.ecsRegion!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.exportTimeout != nil {
                    map["ExportTimeout"] = self.exportTimeout!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.instanceAlias != nil {
                    map["InstanceAlias"] = self.instanceAlias!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceSource != nil {
                    map["InstanceSource"] = self.instanceSource!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ownerIdList != nil {
                    map["OwnerIdList"] = self.ownerIdList?.toMap()
                }
                if self.ownerNameList != nil {
                    map["OwnerNameList"] = self.ownerNameList?.toMap()
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.queryTimeout != nil {
                    map["QueryTimeout"] = self.queryTimeout!
                }
                if self.safeRuleId != nil {
                    map["SafeRuleId"] = self.safeRuleId!
                }
                if self.sellSitd != nil {
                    map["SellSitd"] = self.sellSitd!
                }
                if self.sid != nil {
                    map["Sid"] = self.sid!
                }
                if self.standardGroup != nil {
                    map["StandardGroup"] = self.standardGroup?.toMap()
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.useDsql != nil {
                    map["UseDsql"] = self.useDsql!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataLinkName") && dict["DataLinkName"] != nil {
                    self.dataLinkName = dict["DataLinkName"] as! String
                }
                if dict.keys.contains("DatabasePassword") && dict["DatabasePassword"] != nil {
                    self.databasePassword = dict["DatabasePassword"] as! String
                }
                if dict.keys.contains("DatabaseUser") && dict["DatabaseUser"] != nil {
                    self.databaseUser = dict["DatabaseUser"] as! String
                }
                if dict.keys.contains("DbaId") && dict["DbaId"] != nil {
                    self.dbaId = dict["DbaId"] as! String
                }
                if dict.keys.contains("DbaNickName") && dict["DbaNickName"] != nil {
                    self.dbaNickName = dict["DbaNickName"] as! String
                }
                if dict.keys.contains("DdlOnline") && dict["DdlOnline"] != nil {
                    self.ddlOnline = dict["DdlOnline"] as! Int32
                }
                if dict.keys.contains("EcsInstanceId") && dict["EcsInstanceId"] != nil {
                    self.ecsInstanceId = dict["EcsInstanceId"] as! String
                }
                if dict.keys.contains("EcsRegion") && dict["EcsRegion"] != nil {
                    self.ecsRegion = dict["EcsRegion"] as! String
                }
                if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("ExportTimeout") && dict["ExportTimeout"] != nil {
                    self.exportTimeout = dict["ExportTimeout"] as! Int32
                }
                if dict.keys.contains("Host") && dict["Host"] != nil {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("InstanceAlias") && dict["InstanceAlias"] != nil {
                    self.instanceAlias = dict["InstanceAlias"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceSource") && dict["InstanceSource"] != nil {
                    self.instanceSource = dict["InstanceSource"] as! String
                }
                if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("OwnerIdList") && dict["OwnerIdList"] != nil {
                    var model = ListInstancesResponseBody.InstanceList.Instance.OwnerIdList()
                    model.fromMap(dict["OwnerIdList"] as! [String: Any])
                    self.ownerIdList = model
                }
                if dict.keys.contains("OwnerNameList") && dict["OwnerNameList"] != nil {
                    var model = ListInstancesResponseBody.InstanceList.Instance.OwnerNameList()
                    model.fromMap(dict["OwnerNameList"] as! [String: Any])
                    self.ownerNameList = model
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("QueryTimeout") && dict["QueryTimeout"] != nil {
                    self.queryTimeout = dict["QueryTimeout"] as! Int32
                }
                if dict.keys.contains("SafeRuleId") && dict["SafeRuleId"] != nil {
                    self.safeRuleId = dict["SafeRuleId"] as! String
                }
                if dict.keys.contains("SellSitd") && dict["SellSitd"] != nil {
                    self.sellSitd = dict["SellSitd"] as! Bool
                }
                if dict.keys.contains("Sid") && dict["Sid"] != nil {
                    self.sid = dict["Sid"] as! String
                }
                if dict.keys.contains("StandardGroup") && dict["StandardGroup"] != nil {
                    var model = ListInstancesResponseBody.InstanceList.Instance.StandardGroup()
                    model.fromMap(dict["StandardGroup"] as! [String: Any])
                    self.standardGroup = model
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("UseDsql") && dict["UseDsql"] != nil {
                    self.useDsql = dict["UseDsql"] as! Int32
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var instance: [ListInstancesResponseBody.InstanceList.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Instance") && dict["Instance"] != nil {
                var tmp : [ListInstancesResponseBody.InstanceList.Instance] = []
                for v in dict["Instance"] as! [Any] {
                    var model = ListInstancesResponseBody.InstanceList.Instance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instance = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var instanceList: ListInstancesResponseBody.InstanceList?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.instanceList != nil {
            map["InstanceList"] = self.instanceList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("InstanceList") && dict["InstanceList"] != nil {
            var model = ListInstancesResponseBody.InstanceList()
            model.fromMap(dict["InstanceList"] as! [String: Any])
            self.instanceList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLhTaskFlowAndScenarioRequest : Tea.TeaModel {
    public var spaceId: Int64?

    public var tid: Int64?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
            self.spaceId = dict["SpaceId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class ListLhTaskFlowAndScenarioResponseBody : Tea.TeaModel {
    public class RawDAGList : Tea.TeaModel {
        public class Dag : Tea.TeaModel {
            public var canEdit: Bool?

            public var creatorId: String?

            public var creatorNickName: String?

            public var dagName: String?

            public var dagOwnerId: String?

            public var dagOwnerNickName: String?

            public var dataFlowId: Int64?

            public var demoId: String?

            public var deployId: Int64?

            public var id: Int64?

            public var isDeleted: Bool?

            public var latestInstanceStatus: Int32?

            public var latestInstanceTime: Int32?

            public var scenarioId: Int64?

            public var spaceId: Int64?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.canEdit != nil {
                    map["CanEdit"] = self.canEdit!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.creatorNickName != nil {
                    map["CreatorNickName"] = self.creatorNickName!
                }
                if self.dagName != nil {
                    map["DagName"] = self.dagName!
                }
                if self.dagOwnerId != nil {
                    map["DagOwnerId"] = self.dagOwnerId!
                }
                if self.dagOwnerNickName != nil {
                    map["DagOwnerNickName"] = self.dagOwnerNickName!
                }
                if self.dataFlowId != nil {
                    map["DataFlowId"] = self.dataFlowId!
                }
                if self.demoId != nil {
                    map["DemoId"] = self.demoId!
                }
                if self.deployId != nil {
                    map["DeployId"] = self.deployId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isDeleted != nil {
                    map["IsDeleted"] = self.isDeleted!
                }
                if self.latestInstanceStatus != nil {
                    map["LatestInstanceStatus"] = self.latestInstanceStatus!
                }
                if self.latestInstanceTime != nil {
                    map["LatestInstanceTime"] = self.latestInstanceTime!
                }
                if self.scenarioId != nil {
                    map["ScenarioId"] = self.scenarioId!
                }
                if self.spaceId != nil {
                    map["SpaceId"] = self.spaceId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CanEdit") && dict["CanEdit"] != nil {
                    self.canEdit = dict["CanEdit"] as! Bool
                }
                if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                    self.creatorId = dict["CreatorId"] as! String
                }
                if dict.keys.contains("CreatorNickName") && dict["CreatorNickName"] != nil {
                    self.creatorNickName = dict["CreatorNickName"] as! String
                }
                if dict.keys.contains("DagName") && dict["DagName"] != nil {
                    self.dagName = dict["DagName"] as! String
                }
                if dict.keys.contains("DagOwnerId") && dict["DagOwnerId"] != nil {
                    self.dagOwnerId = dict["DagOwnerId"] as! String
                }
                if dict.keys.contains("DagOwnerNickName") && dict["DagOwnerNickName"] != nil {
                    self.dagOwnerNickName = dict["DagOwnerNickName"] as! String
                }
                if dict.keys.contains("DataFlowId") && dict["DataFlowId"] != nil {
                    self.dataFlowId = dict["DataFlowId"] as! Int64
                }
                if dict.keys.contains("DemoId") && dict["DemoId"] != nil {
                    self.demoId = dict["DemoId"] as! String
                }
                if dict.keys.contains("DeployId") && dict["DeployId"] != nil {
                    self.deployId = dict["DeployId"] as! Int64
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IsDeleted") && dict["IsDeleted"] != nil {
                    self.isDeleted = dict["IsDeleted"] as! Bool
                }
                if dict.keys.contains("LatestInstanceStatus") && dict["LatestInstanceStatus"] != nil {
                    self.latestInstanceStatus = dict["LatestInstanceStatus"] as! Int32
                }
                if dict.keys.contains("LatestInstanceTime") && dict["LatestInstanceTime"] != nil {
                    self.latestInstanceTime = dict["LatestInstanceTime"] as! Int32
                }
                if dict.keys.contains("ScenarioId") && dict["ScenarioId"] != nil {
                    self.scenarioId = dict["ScenarioId"] as! Int64
                }
                if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
                    self.spaceId = dict["SpaceId"] as! Int64
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public var dag: [ListLhTaskFlowAndScenarioResponseBody.RawDAGList.Dag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dag != nil {
                var tmp : [Any] = []
                for k in self.dag! {
                    tmp.append(k.toMap())
                }
                map["Dag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Dag") && dict["Dag"] != nil {
                var tmp : [ListLhTaskFlowAndScenarioResponseBody.RawDAGList.Dag] = []
                for v in dict["Dag"] as! [Any] {
                    var model = ListLhTaskFlowAndScenarioResponseBody.RawDAGList.Dag()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dag = tmp
            }
        }
    }
    public class ScenarioDAGList : Tea.TeaModel {
        public class ScenarioDAG : Tea.TeaModel {
            public class DagList : Tea.TeaModel {
                public class Dag : Tea.TeaModel {
                    public var canEdit: Bool?

                    public var creatorId: String?

                    public var creatorNickName: String?

                    public var dagName: String?

                    public var dagOwnerId: String?

                    public var dagOwnerNickName: String?

                    public var dataFlowId: Int64?

                    public var demoId: String?

                    public var deployId: Int64?

                    public var id: Int64?

                    public var isDeleted: Bool?

                    public var latestInstanceStatus: Int32?

                    public var latestInstanceTime: Int32?

                    public var scenarioId: Int64?

                    public var spaceId: Int64?

                    public var status: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.canEdit != nil {
                            map["CanEdit"] = self.canEdit!
                        }
                        if self.creatorId != nil {
                            map["CreatorId"] = self.creatorId!
                        }
                        if self.creatorNickName != nil {
                            map["CreatorNickName"] = self.creatorNickName!
                        }
                        if self.dagName != nil {
                            map["DagName"] = self.dagName!
                        }
                        if self.dagOwnerId != nil {
                            map["DagOwnerId"] = self.dagOwnerId!
                        }
                        if self.dagOwnerNickName != nil {
                            map["DagOwnerNickName"] = self.dagOwnerNickName!
                        }
                        if self.dataFlowId != nil {
                            map["DataFlowId"] = self.dataFlowId!
                        }
                        if self.demoId != nil {
                            map["DemoId"] = self.demoId!
                        }
                        if self.deployId != nil {
                            map["DeployId"] = self.deployId!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.isDeleted != nil {
                            map["IsDeleted"] = self.isDeleted!
                        }
                        if self.latestInstanceStatus != nil {
                            map["LatestInstanceStatus"] = self.latestInstanceStatus!
                        }
                        if self.latestInstanceTime != nil {
                            map["LatestInstanceTime"] = self.latestInstanceTime!
                        }
                        if self.scenarioId != nil {
                            map["ScenarioId"] = self.scenarioId!
                        }
                        if self.spaceId != nil {
                            map["SpaceId"] = self.spaceId!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CanEdit") && dict["CanEdit"] != nil {
                            self.canEdit = dict["CanEdit"] as! Bool
                        }
                        if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                            self.creatorId = dict["CreatorId"] as! String
                        }
                        if dict.keys.contains("CreatorNickName") && dict["CreatorNickName"] != nil {
                            self.creatorNickName = dict["CreatorNickName"] as! String
                        }
                        if dict.keys.contains("DagName") && dict["DagName"] != nil {
                            self.dagName = dict["DagName"] as! String
                        }
                        if dict.keys.contains("DagOwnerId") && dict["DagOwnerId"] != nil {
                            self.dagOwnerId = dict["DagOwnerId"] as! String
                        }
                        if dict.keys.contains("DagOwnerNickName") && dict["DagOwnerNickName"] != nil {
                            self.dagOwnerNickName = dict["DagOwnerNickName"] as! String
                        }
                        if dict.keys.contains("DataFlowId") && dict["DataFlowId"] != nil {
                            self.dataFlowId = dict["DataFlowId"] as! Int64
                        }
                        if dict.keys.contains("DemoId") && dict["DemoId"] != nil {
                            self.demoId = dict["DemoId"] as! String
                        }
                        if dict.keys.contains("DeployId") && dict["DeployId"] != nil {
                            self.deployId = dict["DeployId"] as! Int64
                        }
                        if dict.keys.contains("Id") && dict["Id"] != nil {
                            self.id = dict["Id"] as! Int64
                        }
                        if dict.keys.contains("IsDeleted") && dict["IsDeleted"] != nil {
                            self.isDeleted = dict["IsDeleted"] as! Bool
                        }
                        if dict.keys.contains("LatestInstanceStatus") && dict["LatestInstanceStatus"] != nil {
                            self.latestInstanceStatus = dict["LatestInstanceStatus"] as! Int32
                        }
                        if dict.keys.contains("LatestInstanceTime") && dict["LatestInstanceTime"] != nil {
                            self.latestInstanceTime = dict["LatestInstanceTime"] as! Int32
                        }
                        if dict.keys.contains("ScenarioId") && dict["ScenarioId"] != nil {
                            self.scenarioId = dict["ScenarioId"] as! Int64
                        }
                        if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
                            self.spaceId = dict["SpaceId"] as! Int64
                        }
                        if dict.keys.contains("Status") && dict["Status"] != nil {
                            self.status = dict["Status"] as! Int32
                        }
                    }
                }
                public var dag: [ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG.DagList.Dag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dag != nil {
                        var tmp : [Any] = []
                        for k in self.dag! {
                            tmp.append(k.toMap())
                        }
                        map["Dag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Dag") && dict["Dag"] != nil {
                        var tmp : [ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG.DagList.Dag] = []
                        for v in dict["Dag"] as! [Any] {
                            var model = ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG.DagList.Dag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dag = tmp
                    }
                }
            }
            public class Scenario : Tea.TeaModel {
                public var creatorId: String?

                public var description_: String?

                public var scenarioName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.creatorId != nil {
                        map["CreatorId"] = self.creatorId!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.scenarioName != nil {
                        map["ScenarioName"] = self.scenarioName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                        self.creatorId = dict["CreatorId"] as! String
                    }
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("ScenarioName") && dict["ScenarioName"] != nil {
                        self.scenarioName = dict["ScenarioName"] as! String
                    }
                }
            }
            public var dagList: ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG.DagList?

            public var scenario: ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG.Scenario?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dagList?.validate()
                try self.scenario?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dagList != nil {
                    map["DagList"] = self.dagList?.toMap()
                }
                if self.scenario != nil {
                    map["Scenario"] = self.scenario?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DagList") && dict["DagList"] != nil {
                    var model = ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG.DagList()
                    model.fromMap(dict["DagList"] as! [String: Any])
                    self.dagList = model
                }
                if dict.keys.contains("Scenario") && dict["Scenario"] != nil {
                    var model = ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG.Scenario()
                    model.fromMap(dict["Scenario"] as! [String: Any])
                    self.scenario = model
                }
            }
        }
        public var scenarioDAG: [ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.scenarioDAG != nil {
                var tmp : [Any] = []
                for k in self.scenarioDAG! {
                    tmp.append(k.toMap())
                }
                map["ScenarioDAG"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ScenarioDAG") && dict["ScenarioDAG"] != nil {
                var tmp : [ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG] = []
                for v in dict["ScenarioDAG"] as! [Any] {
                    var model = ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList.ScenarioDAG()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.scenarioDAG = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var rawDAGList: ListLhTaskFlowAndScenarioResponseBody.RawDAGList?

    public var requestId: String?

    public var scenarioDAGList: ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.rawDAGList?.validate()
        try self.scenarioDAGList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.rawDAGList != nil {
            map["RawDAGList"] = self.rawDAGList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scenarioDAGList != nil {
            map["ScenarioDAGList"] = self.scenarioDAGList?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RawDAGList") && dict["RawDAGList"] != nil {
            var model = ListLhTaskFlowAndScenarioResponseBody.RawDAGList()
            model.fromMap(dict["RawDAGList"] as! [String: Any])
            self.rawDAGList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScenarioDAGList") && dict["ScenarioDAGList"] != nil {
            var model = ListLhTaskFlowAndScenarioResponseBody.ScenarioDAGList()
            model.fromMap(dict["ScenarioDAGList"] as! [String: Any])
            self.scenarioDAGList = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListLhTaskFlowAndScenarioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLhTaskFlowAndScenarioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListLhTaskFlowAndScenarioResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLogicDatabasesRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListLogicDatabasesResponseBody : Tea.TeaModel {
    public class LogicDatabaseList : Tea.TeaModel {
        public class LogicDatabase : Tea.TeaModel {
            public class DatabaseIds : Tea.TeaModel {
                public var databaseIds: [Int64]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.databaseIds != nil {
                        map["DatabaseIds"] = self.databaseIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DatabaseIds") && dict["DatabaseIds"] != nil {
                        self.databaseIds = dict["DatabaseIds"] as! [Int64]
                    }
                }
            }
            public class OwnerIdList : Tea.TeaModel {
                public var ownerIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerIds") && dict["OwnerIds"] != nil {
                        self.ownerIds = dict["OwnerIds"] as! [String]
                    }
                }
            }
            public class OwnerNameList : Tea.TeaModel {
                public var ownerNames: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerNames != nil {
                        map["OwnerNames"] = self.ownerNames!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerNames") && dict["OwnerNames"] != nil {
                        self.ownerNames = dict["OwnerNames"] as! [String]
                    }
                }
            }
            public var alias: String?

            public var databaseId: String?

            public var databaseIds: ListLogicDatabasesResponseBody.LogicDatabaseList.LogicDatabase.DatabaseIds?

            public var dbType: String?

            public var envType: String?

            public var logic: Bool?

            public var ownerIdList: ListLogicDatabasesResponseBody.LogicDatabaseList.LogicDatabase.OwnerIdList?

            public var ownerNameList: ListLogicDatabasesResponseBody.LogicDatabaseList.LogicDatabase.OwnerNameList?

            public var schemaName: String?

            public var searchName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.databaseIds?.validate()
                try self.ownerIdList?.validate()
                try self.ownerNameList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.databaseId != nil {
                    map["DatabaseId"] = self.databaseId!
                }
                if self.databaseIds != nil {
                    map["DatabaseIds"] = self.databaseIds?.toMap()
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.ownerIdList != nil {
                    map["OwnerIdList"] = self.ownerIdList?.toMap()
                }
                if self.ownerNameList != nil {
                    map["OwnerNameList"] = self.ownerNameList?.toMap()
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") && dict["Alias"] != nil {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("DatabaseId") && dict["DatabaseId"] != nil {
                    self.databaseId = dict["DatabaseId"] as! String
                }
                if dict.keys.contains("DatabaseIds") && dict["DatabaseIds"] != nil {
                    var model = ListLogicDatabasesResponseBody.LogicDatabaseList.LogicDatabase.DatabaseIds()
                    model.fromMap(dict["DatabaseIds"] as! [String: Any])
                    self.databaseIds = model
                }
                if dict.keys.contains("DbType") && dict["DbType"] != nil {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("OwnerIdList") && dict["OwnerIdList"] != nil {
                    var model = ListLogicDatabasesResponseBody.LogicDatabaseList.LogicDatabase.OwnerIdList()
                    model.fromMap(dict["OwnerIdList"] as! [String: Any])
                    self.ownerIdList = model
                }
                if dict.keys.contains("OwnerNameList") && dict["OwnerNameList"] != nil {
                    var model = ListLogicDatabasesResponseBody.LogicDatabaseList.LogicDatabase.OwnerNameList()
                    model.fromMap(dict["OwnerNameList"] as! [String: Any])
                    self.ownerNameList = model
                }
                if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                    self.searchName = dict["SearchName"] as! String
                }
            }
        }
        public var logicDatabase: [ListLogicDatabasesResponseBody.LogicDatabaseList.LogicDatabase]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logicDatabase != nil {
                var tmp : [Any] = []
                for k in self.logicDatabase! {
                    tmp.append(k.toMap())
                }
                map["LogicDatabase"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LogicDatabase") && dict["LogicDatabase"] != nil {
                var tmp : [ListLogicDatabasesResponseBody.LogicDatabaseList.LogicDatabase] = []
                for v in dict["LogicDatabase"] as! [Any] {
                    var model = ListLogicDatabasesResponseBody.LogicDatabaseList.LogicDatabase()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logicDatabase = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var logicDatabaseList: ListLogicDatabasesResponseBody.LogicDatabaseList?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logicDatabaseList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.logicDatabaseList != nil {
            map["LogicDatabaseList"] = self.logicDatabaseList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("LogicDatabaseList") && dict["LogicDatabaseList"] != nil {
            var model = ListLogicDatabasesResponseBody.LogicDatabaseList()
            model.fromMap(dict["LogicDatabaseList"] as! [String: Any])
            self.logicDatabaseList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLogicDatabasesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLogicDatabasesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListLogicDatabasesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLogicTableRouteConfigRequest : Tea.TeaModel {
    public var tableId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TableId") && dict["TableId"] != nil {
            self.tableId = dict["TableId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListLogicTableRouteConfigResponseBody : Tea.TeaModel {
    public class LogicTableRouteConfigList : Tea.TeaModel {
        public class LogicTableRouteConfig : Tea.TeaModel {
            public var routeExpr: String?

            public var routeKey: String?

            public var tableId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.routeExpr != nil {
                    map["RouteExpr"] = self.routeExpr!
                }
                if self.routeKey != nil {
                    map["RouteKey"] = self.routeKey!
                }
                if self.tableId != nil {
                    map["TableId"] = self.tableId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RouteExpr") && dict["RouteExpr"] != nil {
                    self.routeExpr = dict["RouteExpr"] as! String
                }
                if dict.keys.contains("RouteKey") && dict["RouteKey"] != nil {
                    self.routeKey = dict["RouteKey"] as! String
                }
                if dict.keys.contains("TableId") && dict["TableId"] != nil {
                    self.tableId = dict["TableId"] as! Int64
                }
            }
        }
        public var logicTableRouteConfig: [ListLogicTableRouteConfigResponseBody.LogicTableRouteConfigList.LogicTableRouteConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logicTableRouteConfig != nil {
                var tmp : [Any] = []
                for k in self.logicTableRouteConfig! {
                    tmp.append(k.toMap())
                }
                map["LogicTableRouteConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LogicTableRouteConfig") && dict["LogicTableRouteConfig"] != nil {
                var tmp : [ListLogicTableRouteConfigResponseBody.LogicTableRouteConfigList.LogicTableRouteConfig] = []
                for v in dict["LogicTableRouteConfig"] as! [Any] {
                    var model = ListLogicTableRouteConfigResponseBody.LogicTableRouteConfigList.LogicTableRouteConfig()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logicTableRouteConfig = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var logicTableRouteConfigList: ListLogicTableRouteConfigResponseBody.LogicTableRouteConfigList?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logicTableRouteConfigList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.logicTableRouteConfigList != nil {
            map["LogicTableRouteConfigList"] = self.logicTableRouteConfigList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("LogicTableRouteConfigList") && dict["LogicTableRouteConfigList"] != nil {
            var model = ListLogicTableRouteConfigResponseBody.LogicTableRouteConfigList()
            model.fromMap(dict["LogicTableRouteConfigList"] as! [String: Any])
            self.logicTableRouteConfigList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListLogicTableRouteConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLogicTableRouteConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListLogicTableRouteConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLogicTablesRequest : Tea.TeaModel {
    public var databaseId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var returnGuid: Bool?

    public var searchName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseId != nil {
            map["DatabaseId"] = self.databaseId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.returnGuid != nil {
            map["ReturnGuid"] = self.returnGuid!
        }
        if self.searchName != nil {
            map["SearchName"] = self.searchName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseId") && dict["DatabaseId"] != nil {
            self.databaseId = dict["DatabaseId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ReturnGuid") && dict["ReturnGuid"] != nil {
            self.returnGuid = dict["ReturnGuid"] as! Bool
        }
        if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
            self.searchName = dict["SearchName"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListLogicTablesResponseBody : Tea.TeaModel {
    public class LogicTableList : Tea.TeaModel {
        public class LogicTable : Tea.TeaModel {
            public class OwnerIdList : Tea.TeaModel {
                public var ownerIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerIds") && dict["OwnerIds"] != nil {
                        self.ownerIds = dict["OwnerIds"] as! [String]
                    }
                }
            }
            public class OwnerNameList : Tea.TeaModel {
                public var ownerNames: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerNames != nil {
                        map["OwnerNames"] = self.ownerNames!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerNames") && dict["OwnerNames"] != nil {
                        self.ownerNames = dict["OwnerNames"] as! [String]
                    }
                }
            }
            public var databaseId: String?

            public var logic: Bool?

            public var ownerIdList: ListLogicTablesResponseBody.LogicTableList.LogicTable.OwnerIdList?

            public var ownerNameList: ListLogicTablesResponseBody.LogicTableList.LogicTable.OwnerNameList?

            public var schemaName: String?

            public var tableCount: String?

            public var tableExpr: String?

            public var tableGuid: String?

            public var tableId: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ownerIdList?.validate()
                try self.ownerNameList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseId != nil {
                    map["DatabaseId"] = self.databaseId!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.ownerIdList != nil {
                    map["OwnerIdList"] = self.ownerIdList?.toMap()
                }
                if self.ownerNameList != nil {
                    map["OwnerNameList"] = self.ownerNameList?.toMap()
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.tableCount != nil {
                    map["TableCount"] = self.tableCount!
                }
                if self.tableExpr != nil {
                    map["TableExpr"] = self.tableExpr!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.tableId != nil {
                    map["TableId"] = self.tableId!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DatabaseId") && dict["DatabaseId"] != nil {
                    self.databaseId = dict["DatabaseId"] as! String
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("OwnerIdList") && dict["OwnerIdList"] != nil {
                    var model = ListLogicTablesResponseBody.LogicTableList.LogicTable.OwnerIdList()
                    model.fromMap(dict["OwnerIdList"] as! [String: Any])
                    self.ownerIdList = model
                }
                if dict.keys.contains("OwnerNameList") && dict["OwnerNameList"] != nil {
                    var model = ListLogicTablesResponseBody.LogicTableList.LogicTable.OwnerNameList()
                    model.fromMap(dict["OwnerNameList"] as! [String: Any])
                    self.ownerNameList = model
                }
                if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("TableCount") && dict["TableCount"] != nil {
                    self.tableCount = dict["TableCount"] as! String
                }
                if dict.keys.contains("TableExpr") && dict["TableExpr"] != nil {
                    self.tableExpr = dict["TableExpr"] as! String
                }
                if dict.keys.contains("TableGuid") && dict["TableGuid"] != nil {
                    self.tableGuid = dict["TableGuid"] as! String
                }
                if dict.keys.contains("TableId") && dict["TableId"] != nil {
                    self.tableId = dict["TableId"] as! String
                }
                if dict.keys.contains("TableName") && dict["TableName"] != nil {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public var logicTable: [ListLogicTablesResponseBody.LogicTableList.LogicTable]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logicTable != nil {
                var tmp : [Any] = []
                for k in self.logicTable! {
                    tmp.append(k.toMap())
                }
                map["LogicTable"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LogicTable") && dict["LogicTable"] != nil {
                var tmp : [ListLogicTablesResponseBody.LogicTableList.LogicTable] = []
                for v in dict["LogicTable"] as! [Any] {
                    var model = ListLogicTablesResponseBody.LogicTableList.LogicTable()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logicTable = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var logicTableList: ListLogicTablesResponseBody.LogicTableList?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logicTableList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.logicTableList != nil {
            map["LogicTableList"] = self.logicTableList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("LogicTableList") && dict["LogicTableList"] != nil {
            var model = ListLogicTablesResponseBody.LogicTableList()
            model.fromMap(dict["LogicTableList"] as! [String: Any])
            self.logicTableList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListLogicTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLogicTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListLogicTablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListOrdersRequest : Tea.TeaModel {
    public var endTime: String?

    public var orderResultType: String?

    public var orderStatus: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var pluginType: String?

    public var searchContent: String?

    public var searchDateType: String?

    public var startTime: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.orderResultType != nil {
            map["OrderResultType"] = self.orderResultType!
        }
        if self.orderStatus != nil {
            map["OrderStatus"] = self.orderStatus!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pluginType != nil {
            map["PluginType"] = self.pluginType!
        }
        if self.searchContent != nil {
            map["SearchContent"] = self.searchContent!
        }
        if self.searchDateType != nil {
            map["SearchDateType"] = self.searchDateType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OrderResultType") && dict["OrderResultType"] != nil {
            self.orderResultType = dict["OrderResultType"] as! String
        }
        if dict.keys.contains("OrderStatus") && dict["OrderStatus"] != nil {
            self.orderStatus = dict["OrderStatus"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PluginType") && dict["PluginType"] != nil {
            self.pluginType = dict["PluginType"] as! String
        }
        if dict.keys.contains("SearchContent") && dict["SearchContent"] != nil {
            self.searchContent = dict["SearchContent"] as! String
        }
        if dict.keys.contains("SearchDateType") && dict["SearchDateType"] != nil {
            self.searchDateType = dict["SearchDateType"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListOrdersResponseBody : Tea.TeaModel {
    public class Orders : Tea.TeaModel {
        public class Order : Tea.TeaModel {
            public var comment: String?

            public var committer: String?

            public var committerId: Int64?

            public var createTime: String?

            public var lastModifyTime: String?

            public var orderId: Int64?

            public var pluginType: String?

            public var statusCode: String?

            public var statusDesc: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.committer != nil {
                    map["Committer"] = self.committer!
                }
                if self.committerId != nil {
                    map["CommitterId"] = self.committerId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.lastModifyTime != nil {
                    map["LastModifyTime"] = self.lastModifyTime!
                }
                if self.orderId != nil {
                    map["OrderId"] = self.orderId!
                }
                if self.pluginType != nil {
                    map["PluginType"] = self.pluginType!
                }
                if self.statusCode != nil {
                    map["StatusCode"] = self.statusCode!
                }
                if self.statusDesc != nil {
                    map["StatusDesc"] = self.statusDesc!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Comment") && dict["Comment"] != nil {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("Committer") && dict["Committer"] != nil {
                    self.committer = dict["Committer"] as! String
                }
                if dict.keys.contains("CommitterId") && dict["CommitterId"] != nil {
                    self.committerId = dict["CommitterId"] as! Int64
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("LastModifyTime") && dict["LastModifyTime"] != nil {
                    self.lastModifyTime = dict["LastModifyTime"] as! String
                }
                if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
                    self.orderId = dict["OrderId"] as! Int64
                }
                if dict.keys.contains("PluginType") && dict["PluginType"] != nil {
                    self.pluginType = dict["PluginType"] as! String
                }
                if dict.keys.contains("StatusCode") && dict["StatusCode"] != nil {
                    self.statusCode = dict["StatusCode"] as! String
                }
                if dict.keys.contains("StatusDesc") && dict["StatusDesc"] != nil {
                    self.statusDesc = dict["StatusDesc"] as! String
                }
            }
        }
        public var order: [ListOrdersResponseBody.Orders.Order]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.order != nil {
                var tmp : [Any] = []
                for k in self.order! {
                    tmp.append(k.toMap())
                }
                map["Order"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Order") && dict["Order"] != nil {
                var tmp : [ListOrdersResponseBody.Orders.Order] = []
                for v in dict["Order"] as! [Any] {
                    var model = ListOrdersResponseBody.Orders.Order()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.order = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var orders: ListOrdersResponseBody.Orders?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.orders?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.orders != nil {
            map["Orders"] = self.orders?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("Orders") && dict["Orders"] != nil {
            var model = ListOrdersResponseBody.Orders()
            model.fromMap(dict["Orders"] as! [String: Any])
            self.orders = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListOrdersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListOrdersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListOrdersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProxiesRequest : Tea.TeaModel {
    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListProxiesResponseBody : Tea.TeaModel {
    public class ProxyList : Tea.TeaModel {
        public var creatorId: Int64?

        public var creatorName: String?

        public var httpsPort: Int32?

        public var instanceId: Int64?

        public var privateEnable: Bool?

        public var privateHost: String?

        public var protocolPort: Int32?

        public var protocolType: String?

        public var proxyId: Int64?

        public var publicEnable: Bool?

        public var publicHost: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.creatorName != nil {
                map["CreatorName"] = self.creatorName!
            }
            if self.httpsPort != nil {
                map["HttpsPort"] = self.httpsPort!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.privateEnable != nil {
                map["PrivateEnable"] = self.privateEnable!
            }
            if self.privateHost != nil {
                map["PrivateHost"] = self.privateHost!
            }
            if self.protocolPort != nil {
                map["ProtocolPort"] = self.protocolPort!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.proxyId != nil {
                map["ProxyId"] = self.proxyId!
            }
            if self.publicEnable != nil {
                map["PublicEnable"] = self.publicEnable!
            }
            if self.publicHost != nil {
                map["PublicHost"] = self.publicHost!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! Int64
            }
            if dict.keys.contains("CreatorName") && dict["CreatorName"] != nil {
                self.creatorName = dict["CreatorName"] as! String
            }
            if dict.keys.contains("HttpsPort") && dict["HttpsPort"] != nil {
                self.httpsPort = dict["HttpsPort"] as! Int32
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("PrivateEnable") && dict["PrivateEnable"] != nil {
                self.privateEnable = dict["PrivateEnable"] as! Bool
            }
            if dict.keys.contains("PrivateHost") && dict["PrivateHost"] != nil {
                self.privateHost = dict["PrivateHost"] as! String
            }
            if dict.keys.contains("ProtocolPort") && dict["ProtocolPort"] != nil {
                self.protocolPort = dict["ProtocolPort"] as! Int32
            }
            if dict.keys.contains("ProtocolType") && dict["ProtocolType"] != nil {
                self.protocolType = dict["ProtocolType"] as! String
            }
            if dict.keys.contains("ProxyId") && dict["ProxyId"] != nil {
                self.proxyId = dict["ProxyId"] as! Int64
            }
            if dict.keys.contains("PublicEnable") && dict["PublicEnable"] != nil {
                self.publicEnable = dict["PublicEnable"] as! Bool
            }
            if dict.keys.contains("PublicHost") && dict["PublicHost"] != nil {
                self.publicHost = dict["PublicHost"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var proxyList: [ListProxiesResponseBody.ProxyList]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.proxyList != nil {
            var tmp : [Any] = []
            for k in self.proxyList! {
                tmp.append(k.toMap())
            }
            map["ProxyList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("ProxyList") && dict["ProxyList"] != nil {
            var tmp : [ListProxiesResponseBody.ProxyList] = []
            for v in dict["ProxyList"] as! [Any] {
                var model = ListProxiesResponseBody.ProxyList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.proxyList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListProxiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProxiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListProxiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProxyAccessesRequest : Tea.TeaModel {
    public var proxyId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.proxyId != nil {
            map["ProxyId"] = self.proxyId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProxyId") && dict["ProxyId"] != nil {
            self.proxyId = dict["ProxyId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListProxyAccessesResponseBody : Tea.TeaModel {
    public class ProxyAccessList : Tea.TeaModel {
        public var accessId: String?

        public var gmtCreate: String?

        public var indepAccount: String?

        public var instanceId: Int64?

        public var originInfo: String?

        public var proxyAccessId: Int64?

        public var proxyId: Int64?

        public var userId: Int64?

        public var userName: String?

        public var userUid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessId != nil {
                map["AccessId"] = self.accessId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.indepAccount != nil {
                map["IndepAccount"] = self.indepAccount!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.originInfo != nil {
                map["OriginInfo"] = self.originInfo!
            }
            if self.proxyAccessId != nil {
                map["ProxyAccessId"] = self.proxyAccessId!
            }
            if self.proxyId != nil {
                map["ProxyId"] = self.proxyId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.userUid != nil {
                map["UserUid"] = self.userUid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessId") && dict["AccessId"] != nil {
                self.accessId = dict["AccessId"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("IndepAccount") && dict["IndepAccount"] != nil {
                self.indepAccount = dict["IndepAccount"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("OriginInfo") && dict["OriginInfo"] != nil {
                self.originInfo = dict["OriginInfo"] as! String
            }
            if dict.keys.contains("ProxyAccessId") && dict["ProxyAccessId"] != nil {
                self.proxyAccessId = dict["ProxyAccessId"] as! Int64
            }
            if dict.keys.contains("ProxyId") && dict["ProxyId"] != nil {
                self.proxyId = dict["ProxyId"] as! Int64
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! Int64
            }
            if dict.keys.contains("UserName") && dict["UserName"] != nil {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("UserUid") && dict["UserUid"] != nil {
                self.userUid = dict["UserUid"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var proxyAccessList: [ListProxyAccessesResponseBody.ProxyAccessList]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.proxyAccessList != nil {
            var tmp : [Any] = []
            for k in self.proxyAccessList! {
                tmp.append(k.toMap())
            }
            map["ProxyAccessList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("ProxyAccessList") && dict["ProxyAccessList"] != nil {
            var tmp : [ListProxyAccessesResponseBody.ProxyAccessList] = []
            for v in dict["ProxyAccessList"] as! [Any] {
                var model = ListProxyAccessesResponseBody.ProxyAccessList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.proxyAccessList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListProxyAccessesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProxyAccessesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListProxyAccessesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProxySQLExecAuditLogRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var execState: String?

    public var opUserName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var SQLType: String?

    public var searchName: String?

    public var startTime: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.execState != nil {
            map["ExecState"] = self.execState!
        }
        if self.opUserName != nil {
            map["OpUserName"] = self.opUserName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.SQLType != nil {
            map["SQLType"] = self.SQLType!
        }
        if self.searchName != nil {
            map["SearchName"] = self.searchName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ExecState") && dict["ExecState"] != nil {
            self.execState = dict["ExecState"] as! String
        }
        if dict.keys.contains("OpUserName") && dict["OpUserName"] != nil {
            self.opUserName = dict["OpUserName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SQLType") && dict["SQLType"] != nil {
            self.SQLType = dict["SQLType"] as! String
        }
        if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
            self.searchName = dict["SearchName"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListProxySQLExecAuditLogResponseBody : Tea.TeaModel {
    public class ProxySQLExecAuditLogList : Tea.TeaModel {
        public class ProxySQLExecAuditLog : Tea.TeaModel {
            public var affectRows: Int64?

            public var elapsedTime: Int64?

            public var execState: String?

            public var instanceId: Int64?

            public var instanceName: String?

            public var opTime: String?

            public var remark: String?

            public var SQL: String?

            public var SQLType: String?

            public var schemaName: String?

            public var userId: Int64?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.affectRows != nil {
                    map["AffectRows"] = self.affectRows!
                }
                if self.elapsedTime != nil {
                    map["ElapsedTime"] = self.elapsedTime!
                }
                if self.execState != nil {
                    map["ExecState"] = self.execState!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.opTime != nil {
                    map["OpTime"] = self.opTime!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.SQL != nil {
                    map["SQL"] = self.SQL!
                }
                if self.SQLType != nil {
                    map["SQLType"] = self.SQLType!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AffectRows") && dict["AffectRows"] != nil {
                    self.affectRows = dict["AffectRows"] as! Int64
                }
                if dict.keys.contains("ElapsedTime") && dict["ElapsedTime"] != nil {
                    self.elapsedTime = dict["ElapsedTime"] as! Int64
                }
                if dict.keys.contains("ExecState") && dict["ExecState"] != nil {
                    self.execState = dict["ExecState"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("OpTime") && dict["OpTime"] != nil {
                    self.opTime = dict["OpTime"] as! String
                }
                if dict.keys.contains("Remark") && dict["Remark"] != nil {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("SQL") && dict["SQL"] != nil {
                    self.SQL = dict["SQL"] as! String
                }
                if dict.keys.contains("SQLType") && dict["SQLType"] != nil {
                    self.SQLType = dict["SQLType"] as! String
                }
                if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! Int64
                }
                if dict.keys.contains("UserName") && dict["UserName"] != nil {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public var proxySQLExecAuditLog: [ListProxySQLExecAuditLogResponseBody.ProxySQLExecAuditLogList.ProxySQLExecAuditLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.proxySQLExecAuditLog != nil {
                var tmp : [Any] = []
                for k in self.proxySQLExecAuditLog! {
                    tmp.append(k.toMap())
                }
                map["ProxySQLExecAuditLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ProxySQLExecAuditLog") && dict["ProxySQLExecAuditLog"] != nil {
                var tmp : [ListProxySQLExecAuditLogResponseBody.ProxySQLExecAuditLogList.ProxySQLExecAuditLog] = []
                for v in dict["ProxySQLExecAuditLog"] as! [Any] {
                    var model = ListProxySQLExecAuditLogResponseBody.ProxySQLExecAuditLogList.ProxySQLExecAuditLog()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.proxySQLExecAuditLog = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var proxySQLExecAuditLogList: ListProxySQLExecAuditLogResponseBody.ProxySQLExecAuditLogList?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.proxySQLExecAuditLogList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.proxySQLExecAuditLogList != nil {
            map["ProxySQLExecAuditLogList"] = self.proxySQLExecAuditLogList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("ProxySQLExecAuditLogList") && dict["ProxySQLExecAuditLogList"] != nil {
            var model = ListProxySQLExecAuditLogResponseBody.ProxySQLExecAuditLogList()
            model.fromMap(dict["ProxySQLExecAuditLogList"] as! [String: Any])
            self.proxySQLExecAuditLogList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListProxySQLExecAuditLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProxySQLExecAuditLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListProxySQLExecAuditLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSLARulesRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListSLARulesResponseBody : Tea.TeaModel {
    public class SLARuleList : Tea.TeaModel {
        public class SLARule : Tea.TeaModel {
            public var dagId: Int64?

            public var id: Int64?

            public var intervalMinutes: Int32?

            public var nodeId: Int64?

            public var ruleType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dagId != nil {
                    map["DagId"] = self.dagId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.intervalMinutes != nil {
                    map["IntervalMinutes"] = self.intervalMinutes!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.ruleType != nil {
                    map["RuleType"] = self.ruleType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DagId") && dict["DagId"] != nil {
                    self.dagId = dict["DagId"] as! Int64
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IntervalMinutes") && dict["IntervalMinutes"] != nil {
                    self.intervalMinutes = dict["IntervalMinutes"] as! Int32
                }
                if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
                    self.ruleType = dict["RuleType"] as! Int32
                }
            }
        }
        public var SLARule: [ListSLARulesResponseBody.SLARuleList.SLARule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.SLARule != nil {
                var tmp : [Any] = []
                for k in self.SLARule! {
                    tmp.append(k.toMap())
                }
                map["SLARule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SLARule") && dict["SLARule"] != nil {
                var tmp : [ListSLARulesResponseBody.SLARuleList.SLARule] = []
                for v in dict["SLARule"] as! [Any] {
                    var model = ListSLARulesResponseBody.SLARuleList.SLARule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.SLARule = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var SLARuleList: ListSLARulesResponseBody.SLARuleList?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.SLARuleList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SLARuleList != nil {
            map["SLARuleList"] = self.SLARuleList?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SLARuleList") && dict["SLARuleList"] != nil {
            var model = ListSLARulesResponseBody.SLARuleList()
            model.fromMap(dict["SLARuleList"] as! [String: Any])
            self.SLARuleList = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSLARulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSLARulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSLARulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSQLExecAuditLogRequest : Tea.TeaModel {
    public var endTime: String?

    public var execState: String?

    public var opUserName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchName: String?

    public var sqlType: String?

    public var startTime: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.execState != nil {
            map["ExecState"] = self.execState!
        }
        if self.opUserName != nil {
            map["OpUserName"] = self.opUserName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchName != nil {
            map["SearchName"] = self.searchName!
        }
        if self.sqlType != nil {
            map["SqlType"] = self.sqlType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("ExecState") && dict["ExecState"] != nil {
            self.execState = dict["ExecState"] as! String
        }
        if dict.keys.contains("OpUserName") && dict["OpUserName"] != nil {
            self.opUserName = dict["OpUserName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
            self.searchName = dict["SearchName"] as! String
        }
        if dict.keys.contains("SqlType") && dict["SqlType"] != nil {
            self.sqlType = dict["SqlType"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListSQLExecAuditLogResponseBody : Tea.TeaModel {
    public class SQLExecAuditLogList : Tea.TeaModel {
        public class SQLExecAuditLog : Tea.TeaModel {
            public var affectRows: Int64?

            public var dbId: Int64?

            public var elapsedTime: Int64?

            public var execState: String?

            public var instanceId: Int64?

            public var instanceName: String?

            public var logic: Bool?

            public var opTime: String?

            public var remark: String?

            public var SQL: String?

            public var SQLType: String?

            public var schemaName: String?

            public var userId: Int64?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.affectRows != nil {
                    map["AffectRows"] = self.affectRows!
                }
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.elapsedTime != nil {
                    map["ElapsedTime"] = self.elapsedTime!
                }
                if self.execState != nil {
                    map["ExecState"] = self.execState!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.opTime != nil {
                    map["OpTime"] = self.opTime!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.SQL != nil {
                    map["SQL"] = self.SQL!
                }
                if self.SQLType != nil {
                    map["SQLType"] = self.SQLType!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AffectRows") && dict["AffectRows"] != nil {
                    self.affectRows = dict["AffectRows"] as! Int64
                }
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("ElapsedTime") && dict["ElapsedTime"] != nil {
                    self.elapsedTime = dict["ElapsedTime"] as! Int64
                }
                if dict.keys.contains("ExecState") && dict["ExecState"] != nil {
                    self.execState = dict["ExecState"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! Int64
                }
                if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("OpTime") && dict["OpTime"] != nil {
                    self.opTime = dict["OpTime"] as! String
                }
                if dict.keys.contains("Remark") && dict["Remark"] != nil {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("SQL") && dict["SQL"] != nil {
                    self.SQL = dict["SQL"] as! String
                }
                if dict.keys.contains("SQLType") && dict["SQLType"] != nil {
                    self.SQLType = dict["SQLType"] as! String
                }
                if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! Int64
                }
                if dict.keys.contains("UserName") && dict["UserName"] != nil {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public var SQLExecAuditLog: [ListSQLExecAuditLogResponseBody.SQLExecAuditLogList.SQLExecAuditLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.SQLExecAuditLog != nil {
                var tmp : [Any] = []
                for k in self.SQLExecAuditLog! {
                    tmp.append(k.toMap())
                }
                map["SQLExecAuditLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SQLExecAuditLog") && dict["SQLExecAuditLog"] != nil {
                var tmp : [ListSQLExecAuditLogResponseBody.SQLExecAuditLogList.SQLExecAuditLog] = []
                for v in dict["SQLExecAuditLog"] as! [Any] {
                    var model = ListSQLExecAuditLogResponseBody.SQLExecAuditLogList.SQLExecAuditLog()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.SQLExecAuditLog = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var SQLExecAuditLogList: ListSQLExecAuditLogResponseBody.SQLExecAuditLogList?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.SQLExecAuditLogList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SQLExecAuditLogList != nil {
            map["SQLExecAuditLogList"] = self.SQLExecAuditLogList?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SQLExecAuditLogList") && dict["SQLExecAuditLogList"] != nil {
            var model = ListSQLExecAuditLogResponseBody.SQLExecAuditLogList()
            model.fromMap(dict["SQLExecAuditLogList"] as! [String: Any])
            self.SQLExecAuditLogList = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListSQLExecAuditLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSQLExecAuditLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSQLExecAuditLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSQLReviewOriginSQLRequest : Tea.TeaModel {
    public class OrderActionDetail : Tea.TeaModel {
        public class Page : Tea.TeaModel {
            public var pageNumber: Int32?

            public var pageSize: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                    self.pageNumber = dict["PageNumber"] as! Int32
                }
                if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                    self.pageSize = dict["PageSize"] as! Int32
                }
            }
        }
        public var checkStatusResult: String?

        public var fileId: Int64?

        public var page: ListSQLReviewOriginSQLRequest.OrderActionDetail.Page?

        public var SQLReviewResult: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.page?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkStatusResult != nil {
                map["CheckStatusResult"] = self.checkStatusResult!
            }
            if self.fileId != nil {
                map["FileId"] = self.fileId!
            }
            if self.page != nil {
                map["Page"] = self.page?.toMap()
            }
            if self.SQLReviewResult != nil {
                map["SQLReviewResult"] = self.SQLReviewResult!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckStatusResult") && dict["CheckStatusResult"] != nil {
                self.checkStatusResult = dict["CheckStatusResult"] as! String
            }
            if dict.keys.contains("FileId") && dict["FileId"] != nil {
                self.fileId = dict["FileId"] as! Int64
            }
            if dict.keys.contains("Page") && dict["Page"] != nil {
                var model = ListSQLReviewOriginSQLRequest.OrderActionDetail.Page()
                model.fromMap(dict["Page"] as! [String: Any])
                self.page = model
            }
            if dict.keys.contains("SQLReviewResult") && dict["SQLReviewResult"] != nil {
                self.SQLReviewResult = dict["SQLReviewResult"] as! String
            }
        }
    }
    public var orderActionDetail: ListSQLReviewOriginSQLRequest.OrderActionDetail?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.orderActionDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderActionDetail != nil {
            map["OrderActionDetail"] = self.orderActionDetail?.toMap()
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderActionDetail") && dict["OrderActionDetail"] != nil {
            var model = ListSQLReviewOriginSQLRequest.OrderActionDetail()
            model.fromMap(dict["OrderActionDetail"] as! [String: Any])
            self.orderActionDetail = model
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListSQLReviewOriginSQLShrinkRequest : Tea.TeaModel {
    public var orderActionDetailShrink: String?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderActionDetailShrink != nil {
            map["OrderActionDetail"] = self.orderActionDetailShrink!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderActionDetail") && dict["OrderActionDetail"] != nil {
            self.orderActionDetailShrink = dict["OrderActionDetail"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListSQLReviewOriginSQLResponseBody : Tea.TeaModel {
    public class OriginSQLList : Tea.TeaModel {
        public var checkStatus: String?

        public var checkedTime: String?

        public var fileId: Int64?

        public var fileName: String?

        public var reviewSummary: String?

        public var SQLContent: String?

        public var SQLId: Int64?

        public var SQLName: String?

        public var SQLReviewQueryKey: String?

        public var sqlHash: String?

        public var statusDesc: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkStatus != nil {
                map["CheckStatus"] = self.checkStatus!
            }
            if self.checkedTime != nil {
                map["CheckedTime"] = self.checkedTime!
            }
            if self.fileId != nil {
                map["FileId"] = self.fileId!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.reviewSummary != nil {
                map["ReviewSummary"] = self.reviewSummary!
            }
            if self.SQLContent != nil {
                map["SQLContent"] = self.SQLContent!
            }
            if self.SQLId != nil {
                map["SQLId"] = self.SQLId!
            }
            if self.SQLName != nil {
                map["SQLName"] = self.SQLName!
            }
            if self.SQLReviewQueryKey != nil {
                map["SQLReviewQueryKey"] = self.SQLReviewQueryKey!
            }
            if self.sqlHash != nil {
                map["SqlHash"] = self.sqlHash!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckStatus") && dict["CheckStatus"] != nil {
                self.checkStatus = dict["CheckStatus"] as! String
            }
            if dict.keys.contains("CheckedTime") && dict["CheckedTime"] != nil {
                self.checkedTime = dict["CheckedTime"] as! String
            }
            if dict.keys.contains("FileId") && dict["FileId"] != nil {
                self.fileId = dict["FileId"] as! Int64
            }
            if dict.keys.contains("FileName") && dict["FileName"] != nil {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("ReviewSummary") && dict["ReviewSummary"] != nil {
                self.reviewSummary = dict["ReviewSummary"] as! String
            }
            if dict.keys.contains("SQLContent") && dict["SQLContent"] != nil {
                self.SQLContent = dict["SQLContent"] as! String
            }
            if dict.keys.contains("SQLId") && dict["SQLId"] != nil {
                self.SQLId = dict["SQLId"] as! Int64
            }
            if dict.keys.contains("SQLName") && dict["SQLName"] != nil {
                self.SQLName = dict["SQLName"] as! String
            }
            if dict.keys.contains("SQLReviewQueryKey") && dict["SQLReviewQueryKey"] != nil {
                self.SQLReviewQueryKey = dict["SQLReviewQueryKey"] as! String
            }
            if dict.keys.contains("SqlHash") && dict["SqlHash"] != nil {
                self.sqlHash = dict["SqlHash"] as! String
            }
            if dict.keys.contains("StatusDesc") && dict["StatusDesc"] != nil {
                self.statusDesc = dict["StatusDesc"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var originSQLList: [ListSQLReviewOriginSQLResponseBody.OriginSQLList]?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.originSQLList != nil {
            var tmp : [Any] = []
            for k in self.originSQLList! {
                tmp.append(k.toMap())
            }
            map["OriginSQLList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("OriginSQLList") && dict["OriginSQLList"] != nil {
            var tmp : [ListSQLReviewOriginSQLResponseBody.OriginSQLList] = []
            for v in dict["OriginSQLList"] as! [Any] {
                var model = ListSQLReviewOriginSQLResponseBody.OriginSQLList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.originSQLList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListSQLReviewOriginSQLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSQLReviewOriginSQLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSQLReviewOriginSQLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListScenariosRequest : Tea.TeaModel {
    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListScenariosResponseBody : Tea.TeaModel {
    public class ScenarioList : Tea.TeaModel {
        public var creatorId: String?

        public var description_: String?

        public var id: Int64?

        public var scenarioName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.scenarioName != nil {
                map["ScenarioName"] = self.scenarioName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("ScenarioName") && dict["ScenarioName"] != nil {
                self.scenarioName = dict["ScenarioName"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var scenarioList: [ListScenariosResponseBody.ScenarioList]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scenarioList != nil {
            var tmp : [Any] = []
            for k in self.scenarioList! {
                tmp.append(k.toMap())
            }
            map["ScenarioList"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScenarioList") && dict["ScenarioList"] != nil {
            var tmp : [ListScenariosResponseBody.ScenarioList] = []
            for v in dict["ScenarioList"] as! [Any] {
                var model = ListScenariosResponseBody.ScenarioList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scenarioList = tmp
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListScenariosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListScenariosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListScenariosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSensitiveColumnsRequest : Tea.TeaModel {
    public var columnName: String?

    public var dbId: Int64?

    public var logic: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var schemaName: String?

    public var securityLevel: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnName != nil {
            map["ColumnName"] = self.columnName!
        }
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.securityLevel != nil {
            map["SecurityLevel"] = self.securityLevel!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
            self.columnName = dict["ColumnName"] as! String
        }
        if dict.keys.contains("DbId") && dict["DbId"] != nil {
            self.dbId = dict["DbId"] as! Int64
        }
        if dict.keys.contains("Logic") && dict["Logic"] != nil {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
            self.schemaName = dict["SchemaName"] as! String
        }
        if dict.keys.contains("SecurityLevel") && dict["SecurityLevel"] != nil {
            self.securityLevel = dict["SecurityLevel"] as! String
        }
        if dict.keys.contains("TableName") && dict["TableName"] != nil {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListSensitiveColumnsResponseBody : Tea.TeaModel {
    public class SensitiveColumnList : Tea.TeaModel {
        public class SensitiveColumn : Tea.TeaModel {
            public var columnCount: Int64?

            public var columnName: String?

            public var functionType: String?

            public var schemaName: String?

            public var securityLevel: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columnCount != nil {
                    map["ColumnCount"] = self.columnCount!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.functionType != nil {
                    map["FunctionType"] = self.functionType!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.securityLevel != nil {
                    map["SecurityLevel"] = self.securityLevel!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColumnCount") && dict["ColumnCount"] != nil {
                    self.columnCount = dict["ColumnCount"] as! Int64
                }
                if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("FunctionType") && dict["FunctionType"] != nil {
                    self.functionType = dict["FunctionType"] as! String
                }
                if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SecurityLevel") && dict["SecurityLevel"] != nil {
                    self.securityLevel = dict["SecurityLevel"] as! String
                }
                if dict.keys.contains("TableName") && dict["TableName"] != nil {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public var sensitiveColumn: [ListSensitiveColumnsResponseBody.SensitiveColumnList.SensitiveColumn]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sensitiveColumn != nil {
                var tmp : [Any] = []
                for k in self.sensitiveColumn! {
                    tmp.append(k.toMap())
                }
                map["SensitiveColumn"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SensitiveColumn") && dict["SensitiveColumn"] != nil {
                var tmp : [ListSensitiveColumnsResponseBody.SensitiveColumnList.SensitiveColumn] = []
                for v in dict["SensitiveColumn"] as! [Any] {
                    var model = ListSensitiveColumnsResponseBody.SensitiveColumnList.SensitiveColumn()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sensitiveColumn = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var sensitiveColumnList: ListSensitiveColumnsResponseBody.SensitiveColumnList?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sensitiveColumnList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sensitiveColumnList != nil {
            map["SensitiveColumnList"] = self.sensitiveColumnList?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SensitiveColumnList") && dict["SensitiveColumnList"] != nil {
            var model = ListSensitiveColumnsResponseBody.SensitiveColumnList()
            model.fromMap(dict["SensitiveColumnList"] as! [String: Any])
            self.sensitiveColumnList = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListSensitiveColumnsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSensitiveColumnsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSensitiveColumnsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSensitiveColumnsDetailRequest : Tea.TeaModel {
    public var columnName: String?

    public var dbId: Int64?

    public var logic: Bool?

    public var schemaName: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnName != nil {
            map["ColumnName"] = self.columnName!
        }
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
            self.columnName = dict["ColumnName"] as! String
        }
        if dict.keys.contains("DbId") && dict["DbId"] != nil {
            self.dbId = dict["DbId"] as! Int64
        }
        if dict.keys.contains("Logic") && dict["Logic"] != nil {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
            self.schemaName = dict["SchemaName"] as! String
        }
        if dict.keys.contains("TableName") && dict["TableName"] != nil {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListSensitiveColumnsDetailResponseBody : Tea.TeaModel {
    public class SensitiveColumnsDetailList : Tea.TeaModel {
        public class SensitiveColumnsDetail : Tea.TeaModel {
            public var columnDescription: String?

            public var columnName: String?

            public var columnType: String?

            public var dbId: Int64?

            public var dbType: String?

            public var envType: String?

            public var logic: Bool?

            public var schemaName: String?

            public var searchName: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columnDescription != nil {
                    map["ColumnDescription"] = self.columnDescription!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.columnType != nil {
                    map["ColumnType"] = self.columnType!
                }
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColumnDescription") && dict["ColumnDescription"] != nil {
                    self.columnDescription = dict["ColumnDescription"] as! String
                }
                if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("ColumnType") && dict["ColumnType"] != nil {
                    self.columnType = dict["ColumnType"] as! String
                }
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! Int64
                }
                if dict.keys.contains("DbType") && dict["DbType"] != nil {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                    self.searchName = dict["SearchName"] as! String
                }
                if dict.keys.contains("TableName") && dict["TableName"] != nil {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public var sensitiveColumnsDetail: [ListSensitiveColumnsDetailResponseBody.SensitiveColumnsDetailList.SensitiveColumnsDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sensitiveColumnsDetail != nil {
                var tmp : [Any] = []
                for k in self.sensitiveColumnsDetail! {
                    tmp.append(k.toMap())
                }
                map["SensitiveColumnsDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SensitiveColumnsDetail") && dict["SensitiveColumnsDetail"] != nil {
                var tmp : [ListSensitiveColumnsDetailResponseBody.SensitiveColumnsDetailList.SensitiveColumnsDetail] = []
                for v in dict["SensitiveColumnsDetail"] as! [Any] {
                    var model = ListSensitiveColumnsDetailResponseBody.SensitiveColumnsDetailList.SensitiveColumnsDetail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sensitiveColumnsDetail = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var sensitiveColumnsDetailList: ListSensitiveColumnsDetailResponseBody.SensitiveColumnsDetailList?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sensitiveColumnsDetailList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sensitiveColumnsDetailList != nil {
            map["SensitiveColumnsDetailList"] = self.sensitiveColumnsDetailList?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SensitiveColumnsDetailList") && dict["SensitiveColumnsDetailList"] != nil {
            var model = ListSensitiveColumnsDetailResponseBody.SensitiveColumnsDetailList()
            model.fromMap(dict["SensitiveColumnsDetailList"] as! [String: Any])
            self.sensitiveColumnsDetailList = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSensitiveColumnsDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSensitiveColumnsDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSensitiveColumnsDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSensitiveDataAuditLogRequest : Tea.TeaModel {
    public var columnName: String?

    public var dbName: String?

    public var endTime: String?

    public var moduleName: String?

    public var opUserName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnName != nil {
            map["ColumnName"] = self.columnName!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.moduleName != nil {
            map["ModuleName"] = self.moduleName!
        }
        if self.opUserName != nil {
            map["OpUserName"] = self.opUserName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
            self.columnName = dict["ColumnName"] as! String
        }
        if dict.keys.contains("DbName") && dict["DbName"] != nil {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("ModuleName") && dict["ModuleName"] != nil {
            self.moduleName = dict["ModuleName"] as! String
        }
        if dict.keys.contains("OpUserName") && dict["OpUserName"] != nil {
            self.opUserName = dict["OpUserName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TableName") && dict["TableName"] != nil {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListSensitiveDataAuditLogResponseBody : Tea.TeaModel {
    public class SensitiveDataAuditLogList : Tea.TeaModel {
        public class SensitiveDataLog : Tea.TeaModel {
            public var columnName: String?

            public var columnPermissionType: String?

            public var desensitizationRule: String?

            public var securityLevel: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.columnPermissionType != nil {
                    map["ColumnPermissionType"] = self.columnPermissionType!
                }
                if self.desensitizationRule != nil {
                    map["DesensitizationRule"] = self.desensitizationRule!
                }
                if self.securityLevel != nil {
                    map["SecurityLevel"] = self.securityLevel!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("ColumnPermissionType") && dict["ColumnPermissionType"] != nil {
                    self.columnPermissionType = dict["ColumnPermissionType"] as! String
                }
                if dict.keys.contains("DesensitizationRule") && dict["DesensitizationRule"] != nil {
                    self.desensitizationRule = dict["DesensitizationRule"] as! String
                }
                if dict.keys.contains("SecurityLevel") && dict["SecurityLevel"] != nil {
                    self.securityLevel = dict["SecurityLevel"] as! String
                }
                if dict.keys.contains("TableName") && dict["TableName"] != nil {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public var dbDisplayName: String?

        public var instanceId: Int64?

        public var moduleName: String?

        public var opTime: String?

        public var sensitiveDataLog: [ListSensitiveDataAuditLogResponseBody.SensitiveDataAuditLogList.SensitiveDataLog]?

        public var targetName: String?

        public var userId: Int64?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbDisplayName != nil {
                map["DbDisplayName"] = self.dbDisplayName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.moduleName != nil {
                map["ModuleName"] = self.moduleName!
            }
            if self.opTime != nil {
                map["OpTime"] = self.opTime!
            }
            if self.sensitiveDataLog != nil {
                var tmp : [Any] = []
                for k in self.sensitiveDataLog! {
                    tmp.append(k.toMap())
                }
                map["SensitiveDataLog"] = tmp
            }
            if self.targetName != nil {
                map["TargetName"] = self.targetName!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbDisplayName") && dict["DbDisplayName"] != nil {
                self.dbDisplayName = dict["DbDisplayName"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("ModuleName") && dict["ModuleName"] != nil {
                self.moduleName = dict["ModuleName"] as! String
            }
            if dict.keys.contains("OpTime") && dict["OpTime"] != nil {
                self.opTime = dict["OpTime"] as! String
            }
            if dict.keys.contains("SensitiveDataLog") && dict["SensitiveDataLog"] != nil {
                var tmp : [ListSensitiveDataAuditLogResponseBody.SensitiveDataAuditLogList.SensitiveDataLog] = []
                for v in dict["SensitiveDataLog"] as! [Any] {
                    var model = ListSensitiveDataAuditLogResponseBody.SensitiveDataAuditLogList.SensitiveDataLog()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sensitiveDataLog = tmp
            }
            if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                self.targetName = dict["TargetName"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! Int64
            }
            if dict.keys.contains("UserName") && dict["UserName"] != nil {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var sensitiveDataAuditLogList: [ListSensitiveDataAuditLogResponseBody.SensitiveDataAuditLogList]?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sensitiveDataAuditLogList != nil {
            var tmp : [Any] = []
            for k in self.sensitiveDataAuditLogList! {
                tmp.append(k.toMap())
            }
            map["SensitiveDataAuditLogList"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SensitiveDataAuditLogList") && dict["SensitiveDataAuditLogList"] != nil {
            var tmp : [ListSensitiveDataAuditLogResponseBody.SensitiveDataAuditLogList] = []
            for v in dict["SensitiveDataAuditLogList"] as! [Any] {
                var model = ListSensitiveDataAuditLogResponseBody.SensitiveDataAuditLogList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sensitiveDataAuditLogList = tmp
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListSensitiveDataAuditLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSensitiveDataAuditLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSensitiveDataAuditLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListStandardGroupsRequest : Tea.TeaModel {
    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListStandardGroupsResponseBody : Tea.TeaModel {
    public class StandardGroupList : Tea.TeaModel {
        public var dbType: String?

        public var description_: String?

        public var groupId: Int64?

        public var groupMode: String?

        public var groupName: String?

        public var lastMenderId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupMode != nil {
                map["GroupMode"] = self.groupMode!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.lastMenderId != nil {
                map["LastMenderId"] = self.lastMenderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbType") && dict["DbType"] != nil {
                self.dbType = dict["DbType"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! Int64
            }
            if dict.keys.contains("GroupMode") && dict["GroupMode"] != nil {
                self.groupMode = dict["GroupMode"] as! String
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("LastMenderId") && dict["LastMenderId"] != nil {
                self.lastMenderId = dict["LastMenderId"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var standardGroupList: [ListStandardGroupsResponseBody.StandardGroupList]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.standardGroupList != nil {
            var tmp : [Any] = []
            for k in self.standardGroupList! {
                tmp.append(k.toMap())
            }
            map["StandardGroupList"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StandardGroupList") && dict["StandardGroupList"] != nil {
            var tmp : [ListStandardGroupsResponseBody.StandardGroupList] = []
            for v in dict["StandardGroupList"] as! [Any] {
                var model = ListStandardGroupsResponseBody.StandardGroupList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.standardGroupList = tmp
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListStandardGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListStandardGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListStandardGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTablesRequest : Tea.TeaModel {
    public var databaseId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var returnGuid: Bool?

    public var searchName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseId != nil {
            map["DatabaseId"] = self.databaseId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.returnGuid != nil {
            map["ReturnGuid"] = self.returnGuid!
        }
        if self.searchName != nil {
            map["SearchName"] = self.searchName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseId") && dict["DatabaseId"] != nil {
            self.databaseId = dict["DatabaseId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ReturnGuid") && dict["ReturnGuid"] != nil {
            self.returnGuid = dict["ReturnGuid"] as! Bool
        }
        if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
            self.searchName = dict["SearchName"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListTablesResponseBody : Tea.TeaModel {
    public class TableList : Tea.TeaModel {
        public class Table : Tea.TeaModel {
            public class OwnerIdList : Tea.TeaModel {
                public var ownerIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerIds") && dict["OwnerIds"] != nil {
                        self.ownerIds = dict["OwnerIds"] as! [String]
                    }
                }
            }
            public class OwnerNameList : Tea.TeaModel {
                public var ownerNames: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerNames != nil {
                        map["OwnerNames"] = self.ownerNames!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerNames") && dict["OwnerNames"] != nil {
                        self.ownerNames = dict["OwnerNames"] as! [String]
                    }
                }
            }
            public var databaseId: String?

            public var description_: String?

            public var encoding: String?

            public var engine: String?

            public var numRows: Int64?

            public var ownerIdList: ListTablesResponseBody.TableList.Table.OwnerIdList?

            public var ownerNameList: ListTablesResponseBody.TableList.Table.OwnerNameList?

            public var storeCapacity: Int64?

            public var tableGuid: String?

            public var tableId: String?

            public var tableName: String?

            public var tableSchemaName: String?

            public var tableType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ownerIdList?.validate()
                try self.ownerNameList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseId != nil {
                    map["DatabaseId"] = self.databaseId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.encoding != nil {
                    map["Encoding"] = self.encoding!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.numRows != nil {
                    map["NumRows"] = self.numRows!
                }
                if self.ownerIdList != nil {
                    map["OwnerIdList"] = self.ownerIdList?.toMap()
                }
                if self.ownerNameList != nil {
                    map["OwnerNameList"] = self.ownerNameList?.toMap()
                }
                if self.storeCapacity != nil {
                    map["StoreCapacity"] = self.storeCapacity!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.tableId != nil {
                    map["TableId"] = self.tableId!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.tableSchemaName != nil {
                    map["TableSchemaName"] = self.tableSchemaName!
                }
                if self.tableType != nil {
                    map["TableType"] = self.tableType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DatabaseId") && dict["DatabaseId"] != nil {
                    self.databaseId = dict["DatabaseId"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Encoding") && dict["Encoding"] != nil {
                    self.encoding = dict["Encoding"] as! String
                }
                if dict.keys.contains("Engine") && dict["Engine"] != nil {
                    self.engine = dict["Engine"] as! String
                }
                if dict.keys.contains("NumRows") && dict["NumRows"] != nil {
                    self.numRows = dict["NumRows"] as! Int64
                }
                if dict.keys.contains("OwnerIdList") && dict["OwnerIdList"] != nil {
                    var model = ListTablesResponseBody.TableList.Table.OwnerIdList()
                    model.fromMap(dict["OwnerIdList"] as! [String: Any])
                    self.ownerIdList = model
                }
                if dict.keys.contains("OwnerNameList") && dict["OwnerNameList"] != nil {
                    var model = ListTablesResponseBody.TableList.Table.OwnerNameList()
                    model.fromMap(dict["OwnerNameList"] as! [String: Any])
                    self.ownerNameList = model
                }
                if dict.keys.contains("StoreCapacity") && dict["StoreCapacity"] != nil {
                    self.storeCapacity = dict["StoreCapacity"] as! Int64
                }
                if dict.keys.contains("TableGuid") && dict["TableGuid"] != nil {
                    self.tableGuid = dict["TableGuid"] as! String
                }
                if dict.keys.contains("TableId") && dict["TableId"] != nil {
                    self.tableId = dict["TableId"] as! String
                }
                if dict.keys.contains("TableName") && dict["TableName"] != nil {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("TableSchemaName") && dict["TableSchemaName"] != nil {
                    self.tableSchemaName = dict["TableSchemaName"] as! String
                }
                if dict.keys.contains("TableType") && dict["TableType"] != nil {
                    self.tableType = dict["TableType"] as! String
                }
            }
        }
        public var table: [ListTablesResponseBody.TableList.Table]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.table != nil {
                var tmp : [Any] = []
                for k in self.table! {
                    tmp.append(k.toMap())
                }
                map["Table"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Table") && dict["Table"] != nil {
                var tmp : [ListTablesResponseBody.TableList.Table] = []
                for v in dict["Table"] as! [Any] {
                    var model = ListTablesResponseBody.TableList.Table()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.table = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tableList: ListTablesResponseBody.TableList?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tableList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tableList != nil {
            map["TableList"] = self.tableList?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TableList") && dict["TableList"] != nil {
            var model = ListTablesResponseBody.TableList()
            model.fromMap(dict["TableList"] as! [String: Any])
            self.tableList = model
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTaskFlowRequest : Tea.TeaModel {
    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListTaskFlowResponseBody : Tea.TeaModel {
    public class TaskFlowList : Tea.TeaModel {
        public class TaskFlow : Tea.TeaModel {
            public var creatorId: String?

            public var creatorNickName: String?

            public var dagOwnerNickName: String?

            public var deployId: Int64?

            public var id: Int64?

            public var latestInstanceStatus: Int32?

            public var latestInstanceTime: String?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.creatorNickName != nil {
                    map["CreatorNickName"] = self.creatorNickName!
                }
                if self.dagOwnerNickName != nil {
                    map["DagOwnerNickName"] = self.dagOwnerNickName!
                }
                if self.deployId != nil {
                    map["DeployId"] = self.deployId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.latestInstanceStatus != nil {
                    map["LatestInstanceStatus"] = self.latestInstanceStatus!
                }
                if self.latestInstanceTime != nil {
                    map["LatestInstanceTime"] = self.latestInstanceTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                    self.creatorId = dict["CreatorId"] as! String
                }
                if dict.keys.contains("CreatorNickName") && dict["CreatorNickName"] != nil {
                    self.creatorNickName = dict["CreatorNickName"] as! String
                }
                if dict.keys.contains("DagOwnerNickName") && dict["DagOwnerNickName"] != nil {
                    self.dagOwnerNickName = dict["DagOwnerNickName"] as! String
                }
                if dict.keys.contains("DeployId") && dict["DeployId"] != nil {
                    self.deployId = dict["DeployId"] as! Int64
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("LatestInstanceStatus") && dict["LatestInstanceStatus"] != nil {
                    self.latestInstanceStatus = dict["LatestInstanceStatus"] as! Int32
                }
                if dict.keys.contains("LatestInstanceTime") && dict["LatestInstanceTime"] != nil {
                    self.latestInstanceTime = dict["LatestInstanceTime"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public var taskFlow: [ListTaskFlowResponseBody.TaskFlowList.TaskFlow]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskFlow != nil {
                var tmp : [Any] = []
                for k in self.taskFlow! {
                    tmp.append(k.toMap())
                }
                map["TaskFlow"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskFlow") && dict["TaskFlow"] != nil {
                var tmp : [ListTaskFlowResponseBody.TaskFlowList.TaskFlow] = []
                for v in dict["TaskFlow"] as! [Any] {
                    var model = ListTaskFlowResponseBody.TaskFlowList.TaskFlow()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.taskFlow = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var taskFlowList: ListTaskFlowResponseBody.TaskFlowList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskFlowList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskFlowList != nil {
            map["TaskFlowList"] = self.taskFlowList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TaskFlowList") && dict["TaskFlowList"] != nil {
            var model = ListTaskFlowResponseBody.TaskFlowList()
            model.fromMap(dict["TaskFlowList"] as! [String: Any])
            self.taskFlowList = model
        }
    }
}

public class ListTaskFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTaskFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTaskFlowConstantsRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListTaskFlowConstantsResponseBody : Tea.TeaModel {
    public class DagConstants : Tea.TeaModel {
        public class DagConstant : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dagConstant: [ListTaskFlowConstantsResponseBody.DagConstants.DagConstant]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dagConstant != nil {
                var tmp : [Any] = []
                for k in self.dagConstant! {
                    tmp.append(k.toMap())
                }
                map["DagConstant"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DagConstant") && dict["DagConstant"] != nil {
                var tmp : [ListTaskFlowConstantsResponseBody.DagConstants.DagConstant] = []
                for v in dict["DagConstant"] as! [Any] {
                    var model = ListTaskFlowConstantsResponseBody.DagConstants.DagConstant()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dagConstant = tmp
            }
        }
    }
    public var dagConstants: ListTaskFlowConstantsResponseBody.DagConstants?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dagConstants?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagConstants != nil {
            map["DagConstants"] = self.dagConstants?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagConstants") && dict["DagConstants"] != nil {
            var model = ListTaskFlowConstantsResponseBody.DagConstants()
            model.fromMap(dict["DagConstants"] as! [String: Any])
            self.dagConstants = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListTaskFlowConstantsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskFlowConstantsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTaskFlowConstantsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTaskFlowCooperatorsRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListTaskFlowCooperatorsResponseBody : Tea.TeaModel {
    public class CooperatorList : Tea.TeaModel {
        public class Cooperator : Tea.TeaModel {
            public var email: String?

            public var loginName: String?

            public var nickName: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.loginName != nil {
                    map["LoginName"] = self.loginName!
                }
                if self.nickName != nil {
                    map["NickName"] = self.nickName!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Email") && dict["Email"] != nil {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("LoginName") && dict["LoginName"] != nil {
                    self.loginName = dict["LoginName"] as! String
                }
                if dict.keys.contains("NickName") && dict["NickName"] != nil {
                    self.nickName = dict["NickName"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var cooperator: [ListTaskFlowCooperatorsResponseBody.CooperatorList.Cooperator]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cooperator != nil {
                var tmp : [Any] = []
                for k in self.cooperator! {
                    tmp.append(k.toMap())
                }
                map["Cooperator"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cooperator") && dict["Cooperator"] != nil {
                var tmp : [ListTaskFlowCooperatorsResponseBody.CooperatorList.Cooperator] = []
                for v in dict["Cooperator"] as! [Any] {
                    var model = ListTaskFlowCooperatorsResponseBody.CooperatorList.Cooperator()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.cooperator = tmp
            }
        }
    }
    public var cooperatorList: ListTaskFlowCooperatorsResponseBody.CooperatorList?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cooperatorList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cooperatorList != nil {
            map["CooperatorList"] = self.cooperatorList?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CooperatorList") && dict["CooperatorList"] != nil {
            var model = ListTaskFlowCooperatorsResponseBody.CooperatorList()
            model.fromMap(dict["CooperatorList"] as! [String: Any])
            self.cooperatorList = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListTaskFlowCooperatorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskFlowCooperatorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTaskFlowCooperatorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTaskFlowEdgesByConditionRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var id: Int64?

    public var nodeEnd: Int64?

    public var nodeFrom: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.nodeEnd != nil {
            map["NodeEnd"] = self.nodeEnd!
        }
        if self.nodeFrom != nil {
            map["NodeFrom"] = self.nodeFrom!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("NodeEnd") && dict["NodeEnd"] != nil {
            self.nodeEnd = dict["NodeEnd"] as! Int64
        }
        if dict.keys.contains("NodeFrom") && dict["NodeFrom"] != nil {
            self.nodeFrom = dict["NodeFrom"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListTaskFlowEdgesByConditionResponseBody : Tea.TeaModel {
    public class Edges : Tea.TeaModel {
        public class Edge : Tea.TeaModel {
            public var id: Int64?

            public var nodeEnd: Int64?

            public var nodeFrom: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.nodeEnd != nil {
                    map["NodeEnd"] = self.nodeEnd!
                }
                if self.nodeFrom != nil {
                    map["NodeFrom"] = self.nodeFrom!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("NodeEnd") && dict["NodeEnd"] != nil {
                    self.nodeEnd = dict["NodeEnd"] as! Int64
                }
                if dict.keys.contains("NodeFrom") && dict["NodeFrom"] != nil {
                    self.nodeFrom = dict["NodeFrom"] as! Int64
                }
            }
        }
        public var edge: [ListTaskFlowEdgesByConditionResponseBody.Edges.Edge]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.edge != nil {
                var tmp : [Any] = []
                for k in self.edge! {
                    tmp.append(k.toMap())
                }
                map["Edge"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Edge") && dict["Edge"] != nil {
                var tmp : [ListTaskFlowEdgesByConditionResponseBody.Edges.Edge] = []
                for v in dict["Edge"] as! [Any] {
                    var model = ListTaskFlowEdgesByConditionResponseBody.Edges.Edge()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.edge = tmp
            }
        }
    }
    public var edges: ListTaskFlowEdgesByConditionResponseBody.Edges?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.edges?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.edges != nil {
            map["Edges"] = self.edges?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Edges") && dict["Edges"] != nil {
            var model = ListTaskFlowEdgesByConditionResponseBody.Edges()
            model.fromMap(dict["Edges"] as! [String: Any])
            self.edges = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListTaskFlowEdgesByConditionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskFlowEdgesByConditionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTaskFlowEdgesByConditionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTaskFlowInstanceRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var pageIndex: Int32?

    public var pageSize: Int32?

    public var startTimeBegin: String?

    public var startTimeEnd: String?

    public var status: Int32?

    public var tid: Int64?

    public var triggerType: Int32?

    public var useBizDate: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTimeBegin != nil {
            map["StartTimeBegin"] = self.startTimeBegin!
        }
        if self.startTimeEnd != nil {
            map["StartTimeEnd"] = self.startTimeEnd!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.triggerType != nil {
            map["TriggerType"] = self.triggerType!
        }
        if self.useBizDate != nil {
            map["UseBizDate"] = self.useBizDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("PageIndex") && dict["PageIndex"] != nil {
            self.pageIndex = dict["PageIndex"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTimeBegin") && dict["StartTimeBegin"] != nil {
            self.startTimeBegin = dict["StartTimeBegin"] as! String
        }
        if dict.keys.contains("StartTimeEnd") && dict["StartTimeEnd"] != nil {
            self.startTimeEnd = dict["StartTimeEnd"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("TriggerType") && dict["TriggerType"] != nil {
            self.triggerType = dict["TriggerType"] as! Int32
        }
        if dict.keys.contains("UseBizDate") && dict["UseBizDate"] != nil {
            self.useBizDate = dict["UseBizDate"] as! Bool
        }
    }
}

public class ListTaskFlowInstanceResponseBody : Tea.TeaModel {
    public class DAGInstanceList : Tea.TeaModel {
        public class DAGInstance : Tea.TeaModel {
            public var businessTime: String?

            public var dagId: String?

            public var dagName: String?

            public var dagVersion: String?

            public var endTime: String?

            public var historyDagId: Int64?

            public var id: Int64?

            public var message: String?

            public var ownerName: String?

            public var status: Int32?

            public var triggerType: Int32?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessTime != nil {
                    map["BusinessTime"] = self.businessTime!
                }
                if self.dagId != nil {
                    map["DagId"] = self.dagId!
                }
                if self.dagName != nil {
                    map["DagName"] = self.dagName!
                }
                if self.dagVersion != nil {
                    map["DagVersion"] = self.dagVersion!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.historyDagId != nil {
                    map["HistoryDagId"] = self.historyDagId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.ownerName != nil {
                    map["OwnerName"] = self.ownerName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.triggerType != nil {
                    map["TriggerType"] = self.triggerType!
                }
                if self.startTime != nil {
                    map["startTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessTime") && dict["BusinessTime"] != nil {
                    self.businessTime = dict["BusinessTime"] as! String
                }
                if dict.keys.contains("DagId") && dict["DagId"] != nil {
                    self.dagId = dict["DagId"] as! String
                }
                if dict.keys.contains("DagName") && dict["DagName"] != nil {
                    self.dagName = dict["DagName"] as! String
                }
                if dict.keys.contains("DagVersion") && dict["DagVersion"] != nil {
                    self.dagVersion = dict["DagVersion"] as! String
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("HistoryDagId") && dict["HistoryDagId"] != nil {
                    self.historyDagId = dict["HistoryDagId"] as! Int64
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("OwnerName") && dict["OwnerName"] != nil {
                    self.ownerName = dict["OwnerName"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("TriggerType") && dict["TriggerType"] != nil {
                    self.triggerType = dict["TriggerType"] as! Int32
                }
                if dict.keys.contains("startTime") && dict["startTime"] != nil {
                    self.startTime = dict["startTime"] as! String
                }
            }
        }
        public var DAGInstance: [ListTaskFlowInstanceResponseBody.DAGInstanceList.DAGInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DAGInstance != nil {
                var tmp : [Any] = []
                for k in self.DAGInstance! {
                    tmp.append(k.toMap())
                }
                map["DAGInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DAGInstance") && dict["DAGInstance"] != nil {
                var tmp : [ListTaskFlowInstanceResponseBody.DAGInstanceList.DAGInstance] = []
                for v in dict["DAGInstance"] as! [Any] {
                    var model = ListTaskFlowInstanceResponseBody.DAGInstanceList.DAGInstance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.DAGInstance = tmp
            }
        }
    }
    public var DAGInstanceList: ListTaskFlowInstanceResponseBody.DAGInstanceList?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DAGInstanceList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DAGInstanceList != nil {
            map["DAGInstanceList"] = self.DAGInstanceList?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DAGInstanceList") && dict["DAGInstanceList"] != nil {
            var model = ListTaskFlowInstanceResponseBody.DAGInstanceList()
            model.fromMap(dict["DAGInstanceList"] as! [String: Any])
            self.DAGInstanceList = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListTaskFlowInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskFlowInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTaskFlowInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTaskFlowTimeVariablesRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListTaskFlowTimeVariablesResponseBody : Tea.TeaModel {
    public class TimeVariables : Tea.TeaModel {
        public class TimeVariable : Tea.TeaModel {
            public var name: String?

            public var pattern: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.pattern != nil {
                    map["Pattern"] = self.pattern!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Pattern") && dict["Pattern"] != nil {
                    self.pattern = dict["Pattern"] as! String
                }
            }
        }
        public var timeVariable: [ListTaskFlowTimeVariablesResponseBody.TimeVariables.TimeVariable]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.timeVariable != nil {
                var tmp : [Any] = []
                for k in self.timeVariable! {
                    tmp.append(k.toMap())
                }
                map["TimeVariable"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TimeVariable") && dict["TimeVariable"] != nil {
                var tmp : [ListTaskFlowTimeVariablesResponseBody.TimeVariables.TimeVariable] = []
                for v in dict["TimeVariable"] as! [Any] {
                    var model = ListTaskFlowTimeVariablesResponseBody.TimeVariables.TimeVariable()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.timeVariable = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var timeVariables: ListTaskFlowTimeVariablesResponseBody.TimeVariables?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.timeVariables?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.timeVariables != nil {
            map["TimeVariables"] = self.timeVariables?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TimeVariables") && dict["TimeVariables"] != nil {
            var model = ListTaskFlowTimeVariablesResponseBody.TimeVariables()
            model.fromMap(dict["TimeVariables"] as! [String: Any])
            self.timeVariables = model
        }
    }
}

public class ListTaskFlowTimeVariablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskFlowTimeVariablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTaskFlowTimeVariablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTaskFlowsByPageRequest : Tea.TeaModel {
    public var dagIdList: [Int64]?

    public var pageIndex: Int32?

    public var pageSize: Int32?

    public var scenarioId: Int64?

    public var searchKey: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagIdList != nil {
            map["DagIdList"] = self.dagIdList!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagIdList") && dict["DagIdList"] != nil {
            self.dagIdList = dict["DagIdList"] as! [Int64]
        }
        if dict.keys.contains("PageIndex") && dict["PageIndex"] != nil {
            self.pageIndex = dict["PageIndex"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ScenarioId") && dict["ScenarioId"] != nil {
            self.scenarioId = dict["ScenarioId"] as! Int64
        }
        if dict.keys.contains("SearchKey") && dict["SearchKey"] != nil {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListTaskFlowsByPageShrinkRequest : Tea.TeaModel {
    public var dagIdListShrink: String?

    public var pageIndex: Int32?

    public var pageSize: Int32?

    public var scenarioId: Int64?

    public var searchKey: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagIdListShrink != nil {
            map["DagIdList"] = self.dagIdListShrink!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagIdList") && dict["DagIdList"] != nil {
            self.dagIdListShrink = dict["DagIdList"] as! String
        }
        if dict.keys.contains("PageIndex") && dict["PageIndex"] != nil {
            self.pageIndex = dict["PageIndex"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ScenarioId") && dict["ScenarioId"] != nil {
            self.scenarioId = dict["ScenarioId"] as! Int64
        }
        if dict.keys.contains("SearchKey") && dict["SearchKey"] != nil {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListTaskFlowsByPageResponseBody : Tea.TeaModel {
    public class TaskFlowList : Tea.TeaModel {
        public class TaskFlow : Tea.TeaModel {
            public var creatorId: String?

            public var creatorNickName: String?

            public var cronBeginDate: String?

            public var cronEndDate: String?

            public var cronStr: String?

            public var cronSwitch: Bool?

            public var cronType: Int32?

            public var dagName: String?

            public var dagOwnerId: String?

            public var dagOwnerNickName: String?

            public var deployId: Int64?

            public var description_: String?

            public var id: Int64?

            public var latestInstanceStatus: Int32?

            public var latestInstanceTime: String?

            public var scenarioId: String?

            public var scheduleParam: String?

            public var status: Int32?

            public var timeZoneId: String?

            public var triggerType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.creatorNickName != nil {
                    map["CreatorNickName"] = self.creatorNickName!
                }
                if self.cronBeginDate != nil {
                    map["CronBeginDate"] = self.cronBeginDate!
                }
                if self.cronEndDate != nil {
                    map["CronEndDate"] = self.cronEndDate!
                }
                if self.cronStr != nil {
                    map["CronStr"] = self.cronStr!
                }
                if self.cronSwitch != nil {
                    map["CronSwitch"] = self.cronSwitch!
                }
                if self.cronType != nil {
                    map["CronType"] = self.cronType!
                }
                if self.dagName != nil {
                    map["DagName"] = self.dagName!
                }
                if self.dagOwnerId != nil {
                    map["DagOwnerId"] = self.dagOwnerId!
                }
                if self.dagOwnerNickName != nil {
                    map["DagOwnerNickName"] = self.dagOwnerNickName!
                }
                if self.deployId != nil {
                    map["DeployId"] = self.deployId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.latestInstanceStatus != nil {
                    map["LatestInstanceStatus"] = self.latestInstanceStatus!
                }
                if self.latestInstanceTime != nil {
                    map["LatestInstanceTime"] = self.latestInstanceTime!
                }
                if self.scenarioId != nil {
                    map["ScenarioId"] = self.scenarioId!
                }
                if self.scheduleParam != nil {
                    map["ScheduleParam"] = self.scheduleParam!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.timeZoneId != nil {
                    map["TimeZoneId"] = self.timeZoneId!
                }
                if self.triggerType != nil {
                    map["TriggerType"] = self.triggerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                    self.creatorId = dict["CreatorId"] as! String
                }
                if dict.keys.contains("CreatorNickName") && dict["CreatorNickName"] != nil {
                    self.creatorNickName = dict["CreatorNickName"] as! String
                }
                if dict.keys.contains("CronBeginDate") && dict["CronBeginDate"] != nil {
                    self.cronBeginDate = dict["CronBeginDate"] as! String
                }
                if dict.keys.contains("CronEndDate") && dict["CronEndDate"] != nil {
                    self.cronEndDate = dict["CronEndDate"] as! String
                }
                if dict.keys.contains("CronStr") && dict["CronStr"] != nil {
                    self.cronStr = dict["CronStr"] as! String
                }
                if dict.keys.contains("CronSwitch") && dict["CronSwitch"] != nil {
                    self.cronSwitch = dict["CronSwitch"] as! Bool
                }
                if dict.keys.contains("CronType") && dict["CronType"] != nil {
                    self.cronType = dict["CronType"] as! Int32
                }
                if dict.keys.contains("DagName") && dict["DagName"] != nil {
                    self.dagName = dict["DagName"] as! String
                }
                if dict.keys.contains("DagOwnerId") && dict["DagOwnerId"] != nil {
                    self.dagOwnerId = dict["DagOwnerId"] as! String
                }
                if dict.keys.contains("DagOwnerNickName") && dict["DagOwnerNickName"] != nil {
                    self.dagOwnerNickName = dict["DagOwnerNickName"] as! String
                }
                if dict.keys.contains("DeployId") && dict["DeployId"] != nil {
                    self.deployId = dict["DeployId"] as! Int64
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("LatestInstanceStatus") && dict["LatestInstanceStatus"] != nil {
                    self.latestInstanceStatus = dict["LatestInstanceStatus"] as! Int32
                }
                if dict.keys.contains("LatestInstanceTime") && dict["LatestInstanceTime"] != nil {
                    self.latestInstanceTime = dict["LatestInstanceTime"] as! String
                }
                if dict.keys.contains("ScenarioId") && dict["ScenarioId"] != nil {
                    self.scenarioId = dict["ScenarioId"] as! String
                }
                if dict.keys.contains("ScheduleParam") && dict["ScheduleParam"] != nil {
                    self.scheduleParam = dict["ScheduleParam"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("TimeZoneId") && dict["TimeZoneId"] != nil {
                    self.timeZoneId = dict["TimeZoneId"] as! String
                }
                if dict.keys.contains("TriggerType") && dict["TriggerType"] != nil {
                    self.triggerType = dict["TriggerType"] as! Int32
                }
            }
        }
        public var taskFlow: [ListTaskFlowsByPageResponseBody.TaskFlowList.TaskFlow]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskFlow != nil {
                var tmp : [Any] = []
                for k in self.taskFlow! {
                    tmp.append(k.toMap())
                }
                map["TaskFlow"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskFlow") && dict["TaskFlow"] != nil {
                var tmp : [ListTaskFlowsByPageResponseBody.TaskFlowList.TaskFlow] = []
                for v in dict["TaskFlow"] as! [Any] {
                    var model = ListTaskFlowsByPageResponseBody.TaskFlowList.TaskFlow()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.taskFlow = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var taskFlowList: ListTaskFlowsByPageResponseBody.TaskFlowList?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskFlowList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskFlowList != nil {
            map["TaskFlowList"] = self.taskFlowList?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TaskFlowList") && dict["TaskFlowList"] != nil {
            var model = ListTaskFlowsByPageResponseBody.TaskFlowList()
            model.fromMap(dict["TaskFlowList"] as! [String: Any])
            self.taskFlowList = model
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListTaskFlowsByPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskFlowsByPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTaskFlowsByPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTasksInTaskFlowRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListTasksInTaskFlowResponseBody : Tea.TeaModel {
    public class Tasks : Tea.TeaModel {
        public class Task : Tea.TeaModel {
            public var graphParam: String?

            public var nodeConfig: String?

            public var nodeContent: String?

            public var nodeId: String?

            public var nodeName: String?

            public var nodeOutput: String?

            public var nodeType: String?

            public var timeVariables: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.graphParam != nil {
                    map["GraphParam"] = self.graphParam!
                }
                if self.nodeConfig != nil {
                    map["NodeConfig"] = self.nodeConfig!
                }
                if self.nodeContent != nil {
                    map["NodeContent"] = self.nodeContent!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.nodeOutput != nil {
                    map["NodeOutput"] = self.nodeOutput!
                }
                if self.nodeType != nil {
                    map["NodeType"] = self.nodeType!
                }
                if self.timeVariables != nil {
                    map["TimeVariables"] = self.timeVariables!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GraphParam") && dict["GraphParam"] != nil {
                    self.graphParam = dict["GraphParam"] as! String
                }
                if dict.keys.contains("NodeConfig") && dict["NodeConfig"] != nil {
                    self.nodeConfig = dict["NodeConfig"] as! String
                }
                if dict.keys.contains("NodeContent") && dict["NodeContent"] != nil {
                    self.nodeContent = dict["NodeContent"] as! String
                }
                if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                    self.nodeId = dict["NodeId"] as! String
                }
                if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("NodeOutput") && dict["NodeOutput"] != nil {
                    self.nodeOutput = dict["NodeOutput"] as! String
                }
                if dict.keys.contains("NodeType") && dict["NodeType"] != nil {
                    self.nodeType = dict["NodeType"] as! String
                }
                if dict.keys.contains("TimeVariables") && dict["TimeVariables"] != nil {
                    self.timeVariables = dict["TimeVariables"] as! String
                }
            }
        }
        public var task: [ListTasksInTaskFlowResponseBody.Tasks.Task]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.task != nil {
                var tmp : [Any] = []
                for k in self.task! {
                    tmp.append(k.toMap())
                }
                map["Task"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Task") && dict["Task"] != nil {
                var tmp : [ListTasksInTaskFlowResponseBody.Tasks.Task] = []
                for v in dict["Task"] as! [Any] {
                    var model = ListTasksInTaskFlowResponseBody.Tasks.Task()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.task = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tasks: ListTasksInTaskFlowResponseBody.Tasks?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tasks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tasks != nil {
            map["Tasks"] = self.tasks?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Tasks") && dict["Tasks"] != nil {
            var model = ListTasksInTaskFlowResponseBody.Tasks()
            model.fromMap(dict["Tasks"] as! [String: Any])
            self.tasks = model
        }
    }
}

public class ListTasksInTaskFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTasksInTaskFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTasksInTaskFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUserPermissionsRequest : Tea.TeaModel {
    public var databaseName: String?

    public var dbType: String?

    public var envType: String?

    public var logic: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var permType: String?

    public var searchKey: String?

    public var tid: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.dbType != nil {
            map["DbType"] = self.dbType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.permType != nil {
            map["PermType"] = self.permType!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseName") && dict["DatabaseName"] != nil {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("DbType") && dict["DbType"] != nil {
            self.dbType = dict["DbType"] as! String
        }
        if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("Logic") && dict["Logic"] != nil {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PermType") && dict["PermType"] != nil {
            self.permType = dict["PermType"] as! String
        }
        if dict.keys.contains("SearchKey") && dict["SearchKey"] != nil {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ListUserPermissionsResponseBody : Tea.TeaModel {
    public class UserPermissions : Tea.TeaModel {
        public class UserPermission : Tea.TeaModel {
            public class PermDetails : Tea.TeaModel {
                public class PermDetail : Tea.TeaModel {
                    public var createDate: String?

                    public var expireDate: String?

                    public var extraData: String?

                    public var originFrom: String?

                    public var permType: String?

                    public var userAccessId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.createDate != nil {
                            map["CreateDate"] = self.createDate!
                        }
                        if self.expireDate != nil {
                            map["ExpireDate"] = self.expireDate!
                        }
                        if self.extraData != nil {
                            map["ExtraData"] = self.extraData!
                        }
                        if self.originFrom != nil {
                            map["OriginFrom"] = self.originFrom!
                        }
                        if self.permType != nil {
                            map["PermType"] = self.permType!
                        }
                        if self.userAccessId != nil {
                            map["UserAccessId"] = self.userAccessId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CreateDate") && dict["CreateDate"] != nil {
                            self.createDate = dict["CreateDate"] as! String
                        }
                        if dict.keys.contains("ExpireDate") && dict["ExpireDate"] != nil {
                            self.expireDate = dict["ExpireDate"] as! String
                        }
                        if dict.keys.contains("ExtraData") && dict["ExtraData"] != nil {
                            self.extraData = dict["ExtraData"] as! String
                        }
                        if dict.keys.contains("OriginFrom") && dict["OriginFrom"] != nil {
                            self.originFrom = dict["OriginFrom"] as! String
                        }
                        if dict.keys.contains("PermType") && dict["PermType"] != nil {
                            self.permType = dict["PermType"] as! String
                        }
                        if dict.keys.contains("UserAccessId") && dict["UserAccessId"] != nil {
                            self.userAccessId = dict["UserAccessId"] as! String
                        }
                    }
                }
                public var permDetail: [ListUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails.PermDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.permDetail != nil {
                        var tmp : [Any] = []
                        for k in self.permDetail! {
                            tmp.append(k.toMap())
                        }
                        map["PermDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PermDetail") && dict["PermDetail"] != nil {
                        var tmp : [ListUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails.PermDetail] = []
                        for v in dict["PermDetail"] as! [Any] {
                            var model = ListUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails.PermDetail()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.permDetail = tmp
                    }
                }
            }
            public var alias: String?

            public var columnName: String?

            public var dbId: String?

            public var dbType: String?

            public var dsType: String?

            public var envType: String?

            public var host: String?

            public var instanceId: String?

            public var logic: Bool?

            public var permDetails: ListUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails?

            public var port: Int64?

            public var schemaName: String?

            public var searchName: String?

            public var tableId: String?

            public var tableName: String?

            public var userId: String?

            public var userNickName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.permDetails?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.dsType != nil {
                    map["DsType"] = self.dsType!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.permDetails != nil {
                    map["PermDetails"] = self.permDetails?.toMap()
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                if self.tableId != nil {
                    map["TableId"] = self.tableId!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userNickName != nil {
                    map["UserNickName"] = self.userNickName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") && dict["Alias"] != nil {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! String
                }
                if dict.keys.contains("DbType") && dict["DbType"] != nil {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("DsType") && dict["DsType"] != nil {
                    self.dsType = dict["DsType"] as! String
                }
                if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("Host") && dict["Host"] != nil {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("PermDetails") && dict["PermDetails"] != nil {
                    var model = ListUserPermissionsResponseBody.UserPermissions.UserPermission.PermDetails()
                    model.fromMap(dict["PermDetails"] as! [String: Any])
                    self.permDetails = model
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int64
                }
                if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                    self.searchName = dict["SearchName"] as! String
                }
                if dict.keys.contains("TableId") && dict["TableId"] != nil {
                    self.tableId = dict["TableId"] as! String
                }
                if dict.keys.contains("TableName") && dict["TableName"] != nil {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserNickName") && dict["UserNickName"] != nil {
                    self.userNickName = dict["UserNickName"] as! String
                }
            }
        }
        public var userPermission: [ListUserPermissionsResponseBody.UserPermissions.UserPermission]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userPermission != nil {
                var tmp : [Any] = []
                for k in self.userPermission! {
                    tmp.append(k.toMap())
                }
                map["UserPermission"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserPermission") && dict["UserPermission"] != nil {
                var tmp : [ListUserPermissionsResponseBody.UserPermissions.UserPermission] = []
                for v in dict["UserPermission"] as! [Any] {
                    var model = ListUserPermissionsResponseBody.UserPermissions.UserPermission()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.userPermission = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public var userPermissions: ListUserPermissionsResponseBody.UserPermissions?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userPermissions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.userPermissions != nil {
            map["UserPermissions"] = self.userPermissions?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("UserPermissions") && dict["UserPermissions"] != nil {
            var model = ListUserPermissionsResponseBody.UserPermissions()
            model.fromMap(dict["UserPermissions"] as! [String: Any])
            self.userPermissions = model
        }
    }
}

public class ListUserPermissionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserPermissionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListUserPermissionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUserTenantsRequest : Tea.TeaModel {
    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListUserTenantsResponseBody : Tea.TeaModel {
    public class TenantList : Tea.TeaModel {
        public var status: String?

        public var tenantName: String?

        public var tid: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tenantName != nil {
                map["TenantName"] = self.tenantName!
            }
            if self.tid != nil {
                map["Tid"] = self.tid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TenantName") && dict["TenantName"] != nil {
                self.tenantName = dict["TenantName"] as! String
            }
            if dict.keys.contains("Tid") && dict["Tid"] != nil {
                self.tid = dict["Tid"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var tenantList: [ListUserTenantsResponseBody.TenantList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tenantList != nil {
            var tmp : [Any] = []
            for k in self.tenantList! {
                tmp.append(k.toMap())
            }
            map["TenantList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TenantList") && dict["TenantList"] != nil {
            var tmp : [ListUserTenantsResponseBody.TenantList] = []
            for v in dict["TenantList"] as! [Any] {
                var model = ListUserTenantsResponseBody.TenantList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tenantList = tmp
        }
    }
}

public class ListUserTenantsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserTenantsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListUserTenantsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUsersRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var role: String?

    public var searchKey: String?

    public var tid: Int64?

    public var userState: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userState != nil {
            map["UserState"] = self.userState!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Role") && dict["Role"] != nil {
            self.role = dict["Role"] as! String
        }
        if dict.keys.contains("SearchKey") && dict["SearchKey"] != nil {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserState") && dict["UserState"] != nil {
            self.userState = dict["UserState"] as! String
        }
    }
}

public class ListUsersResponseBody : Tea.TeaModel {
    public class UserList : Tea.TeaModel {
        public class User : Tea.TeaModel {
            public class RoleIdList : Tea.TeaModel {
                public var roleIds: [Int32]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.roleIds != nil {
                        map["RoleIds"] = self.roleIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RoleIds") && dict["RoleIds"] != nil {
                        self.roleIds = dict["RoleIds"] as! [Int32]
                    }
                }
            }
            public class RoleNameList : Tea.TeaModel {
                public var roleNames: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.roleNames != nil {
                        map["RoleNames"] = self.roleNames!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RoleNames") && dict["RoleNames"] != nil {
                        self.roleNames = dict["RoleNames"] as! [String]
                    }
                }
            }
            public var curExecuteCount: Int64?

            public var curResultCount: Int64?

            public var dingRobot: String?

            public var email: String?

            public var lastLoginTime: String?

            public var maxExecuteCount: Int64?

            public var maxResultCount: Int64?

            public var mobile: String?

            public var nickName: String?

            public var notificationMode: String?

            public var parentUid: String?

            public var roleIdList: ListUsersResponseBody.UserList.User.RoleIdList?

            public var roleNameList: ListUsersResponseBody.UserList.User.RoleNameList?

            public var signatureMethod: String?

            public var state: String?

            public var uid: String?

            public var userId: String?

            public var webhook: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.roleIdList?.validate()
                try self.roleNameList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.curExecuteCount != nil {
                    map["CurExecuteCount"] = self.curExecuteCount!
                }
                if self.curResultCount != nil {
                    map["CurResultCount"] = self.curResultCount!
                }
                if self.dingRobot != nil {
                    map["DingRobot"] = self.dingRobot!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.lastLoginTime != nil {
                    map["LastLoginTime"] = self.lastLoginTime!
                }
                if self.maxExecuteCount != nil {
                    map["MaxExecuteCount"] = self.maxExecuteCount!
                }
                if self.maxResultCount != nil {
                    map["MaxResultCount"] = self.maxResultCount!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.nickName != nil {
                    map["NickName"] = self.nickName!
                }
                if self.notificationMode != nil {
                    map["NotificationMode"] = self.notificationMode!
                }
                if self.parentUid != nil {
                    map["ParentUid"] = self.parentUid!
                }
                if self.roleIdList != nil {
                    map["RoleIdList"] = self.roleIdList?.toMap()
                }
                if self.roleNameList != nil {
                    map["RoleNameList"] = self.roleNameList?.toMap()
                }
                if self.signatureMethod != nil {
                    map["SignatureMethod"] = self.signatureMethod!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.uid != nil {
                    map["Uid"] = self.uid!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.webhook != nil {
                    map["Webhook"] = self.webhook!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CurExecuteCount") && dict["CurExecuteCount"] != nil {
                    self.curExecuteCount = dict["CurExecuteCount"] as! Int64
                }
                if dict.keys.contains("CurResultCount") && dict["CurResultCount"] != nil {
                    self.curResultCount = dict["CurResultCount"] as! Int64
                }
                if dict.keys.contains("DingRobot") && dict["DingRobot"] != nil {
                    self.dingRobot = dict["DingRobot"] as! String
                }
                if dict.keys.contains("Email") && dict["Email"] != nil {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("LastLoginTime") && dict["LastLoginTime"] != nil {
                    self.lastLoginTime = dict["LastLoginTime"] as! String
                }
                if dict.keys.contains("MaxExecuteCount") && dict["MaxExecuteCount"] != nil {
                    self.maxExecuteCount = dict["MaxExecuteCount"] as! Int64
                }
                if dict.keys.contains("MaxResultCount") && dict["MaxResultCount"] != nil {
                    self.maxResultCount = dict["MaxResultCount"] as! Int64
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("NickName") && dict["NickName"] != nil {
                    self.nickName = dict["NickName"] as! String
                }
                if dict.keys.contains("NotificationMode") && dict["NotificationMode"] != nil {
                    self.notificationMode = dict["NotificationMode"] as! String
                }
                if dict.keys.contains("ParentUid") && dict["ParentUid"] != nil {
                    self.parentUid = dict["ParentUid"] as! String
                }
                if dict.keys.contains("RoleIdList") && dict["RoleIdList"] != nil {
                    var model = ListUsersResponseBody.UserList.User.RoleIdList()
                    model.fromMap(dict["RoleIdList"] as! [String: Any])
                    self.roleIdList = model
                }
                if dict.keys.contains("RoleNameList") && dict["RoleNameList"] != nil {
                    var model = ListUsersResponseBody.UserList.User.RoleNameList()
                    model.fromMap(dict["RoleNameList"] as! [String: Any])
                    self.roleNameList = model
                }
                if dict.keys.contains("SignatureMethod") && dict["SignatureMethod"] != nil {
                    self.signatureMethod = dict["SignatureMethod"] as! String
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Uid") && dict["Uid"] != nil {
                    self.uid = dict["Uid"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
                    self.webhook = dict["Webhook"] as! String
                }
            }
        }
        public var user: [ListUsersResponseBody.UserList.User]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.user != nil {
                var tmp : [Any] = []
                for k in self.user! {
                    tmp.append(k.toMap())
                }
                map["User"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("User") && dict["User"] != nil {
                var tmp : [ListUsersResponseBody.UserList.User] = []
                for v in dict["User"] as! [Any] {
                    var model = ListUsersResponseBody.UserList.User()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.user = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public var userList: ListUsersResponseBody.UserList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.userList != nil {
            map["UserList"] = self.userList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("UserList") && dict["UserList"] != nil {
            var model = ListUsersResponseBody.UserList()
            model.fromMap(dict["UserList"] as! [String: Any])
            self.userList = model
        }
    }
}

public class ListUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWorkFlowNodesRequest : Tea.TeaModel {
    public var searchName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.searchName != nil {
            map["SearchName"] = self.searchName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
            self.searchName = dict["SearchName"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListWorkFlowNodesResponseBody : Tea.TeaModel {
    public class WorkflowNodes : Tea.TeaModel {
        public class WorkflowNode : Tea.TeaModel {
            public class AuditUsers : Tea.TeaModel {
                public class AuditUser : Tea.TeaModel {
                    public var nickName: String?

                    public var realName: String?

                    public var userId: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.nickName != nil {
                            map["NickName"] = self.nickName!
                        }
                        if self.realName != nil {
                            map["RealName"] = self.realName!
                        }
                        if self.userId != nil {
                            map["UserId"] = self.userId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("NickName") && dict["NickName"] != nil {
                            self.nickName = dict["NickName"] as! String
                        }
                        if dict.keys.contains("RealName") && dict["RealName"] != nil {
                            self.realName = dict["RealName"] as! String
                        }
                        if dict.keys.contains("UserId") && dict["UserId"] != nil {
                            self.userId = dict["UserId"] as! Int64
                        }
                    }
                }
                public var auditUser: [ListWorkFlowNodesResponseBody.WorkflowNodes.WorkflowNode.AuditUsers.AuditUser]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.auditUser != nil {
                        var tmp : [Any] = []
                        for k in self.auditUser! {
                            tmp.append(k.toMap())
                        }
                        map["AuditUser"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AuditUser") && dict["AuditUser"] != nil {
                        var tmp : [ListWorkFlowNodesResponseBody.WorkflowNodes.WorkflowNode.AuditUsers.AuditUser] = []
                        for v in dict["AuditUser"] as! [Any] {
                            var model = ListWorkFlowNodesResponseBody.WorkflowNodes.WorkflowNode.AuditUsers.AuditUser()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.auditUser = tmp
                    }
                }
            }
            public var auditUsers: ListWorkFlowNodesResponseBody.WorkflowNodes.WorkflowNode.AuditUsers?

            public var comment: String?

            public var createUserId: Int64?

            public var createUserNickName: String?

            public var nodeId: Int64?

            public var nodeName: String?

            public var nodeType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.auditUsers?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.auditUsers != nil {
                    map["AuditUsers"] = self.auditUsers?.toMap()
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.createUserId != nil {
                    map["CreateUserId"] = self.createUserId!
                }
                if self.createUserNickName != nil {
                    map["CreateUserNickName"] = self.createUserNickName!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.nodeType != nil {
                    map["NodeType"] = self.nodeType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuditUsers") && dict["AuditUsers"] != nil {
                    var model = ListWorkFlowNodesResponseBody.WorkflowNodes.WorkflowNode.AuditUsers()
                    model.fromMap(dict["AuditUsers"] as! [String: Any])
                    self.auditUsers = model
                }
                if dict.keys.contains("Comment") && dict["Comment"] != nil {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("CreateUserId") && dict["CreateUserId"] != nil {
                    self.createUserId = dict["CreateUserId"] as! Int64
                }
                if dict.keys.contains("CreateUserNickName") && dict["CreateUserNickName"] != nil {
                    self.createUserNickName = dict["CreateUserNickName"] as! String
                }
                if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                    self.nodeId = dict["NodeId"] as! Int64
                }
                if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("NodeType") && dict["NodeType"] != nil {
                    self.nodeType = dict["NodeType"] as! String
                }
            }
        }
        public var workflowNode: [ListWorkFlowNodesResponseBody.WorkflowNodes.WorkflowNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.workflowNode != nil {
                var tmp : [Any] = []
                for k in self.workflowNode! {
                    tmp.append(k.toMap())
                }
                map["WorkflowNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WorkflowNode") && dict["WorkflowNode"] != nil {
                var tmp : [ListWorkFlowNodesResponseBody.WorkflowNodes.WorkflowNode] = []
                for v in dict["WorkflowNode"] as! [Any] {
                    var model = ListWorkFlowNodesResponseBody.WorkflowNodes.WorkflowNode()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.workflowNode = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var workflowNodes: ListWorkFlowNodesResponseBody.WorkflowNodes?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workflowNodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.workflowNodes != nil {
            map["WorkflowNodes"] = self.workflowNodes?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("WorkflowNodes") && dict["WorkflowNodes"] != nil {
            var model = ListWorkFlowNodesResponseBody.WorkflowNodes()
            model.fromMap(dict["WorkflowNodes"] as! [String: Any])
            self.workflowNodes = model
        }
    }
}

public class ListWorkFlowNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkFlowNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListWorkFlowNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWorkFlowTemplatesRequest : Tea.TeaModel {
    public var searchName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.searchName != nil {
            map["SearchName"] = self.searchName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
            self.searchName = dict["SearchName"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ListWorkFlowTemplatesResponseBody : Tea.TeaModel {
    public class WorkFlowTemplates : Tea.TeaModel {
        public class WorkFlowTemplate : Tea.TeaModel {
            public class WorkflowNodes : Tea.TeaModel {
                public class WorkflowNode : Tea.TeaModel {
                    public var comment: String?

                    public var createUserId: Int64?

                    public var nodeId: Int64?

                    public var nodeName: String?

                    public var nodeType: String?

                    public var position: Int32?

                    public var templateId: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.comment != nil {
                            map["Comment"] = self.comment!
                        }
                        if self.createUserId != nil {
                            map["CreateUserId"] = self.createUserId!
                        }
                        if self.nodeId != nil {
                            map["NodeId"] = self.nodeId!
                        }
                        if self.nodeName != nil {
                            map["NodeName"] = self.nodeName!
                        }
                        if self.nodeType != nil {
                            map["NodeType"] = self.nodeType!
                        }
                        if self.position != nil {
                            map["Position"] = self.position!
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Comment") && dict["Comment"] != nil {
                            self.comment = dict["Comment"] as! String
                        }
                        if dict.keys.contains("CreateUserId") && dict["CreateUserId"] != nil {
                            self.createUserId = dict["CreateUserId"] as! Int64
                        }
                        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                            self.nodeId = dict["NodeId"] as! Int64
                        }
                        if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                            self.nodeName = dict["NodeName"] as! String
                        }
                        if dict.keys.contains("NodeType") && dict["NodeType"] != nil {
                            self.nodeType = dict["NodeType"] as! String
                        }
                        if dict.keys.contains("Position") && dict["Position"] != nil {
                            self.position = dict["Position"] as! Int32
                        }
                        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                            self.templateId = dict["TemplateId"] as! Int64
                        }
                    }
                }
                public var workflowNode: [ListWorkFlowTemplatesResponseBody.WorkFlowTemplates.WorkFlowTemplate.WorkflowNodes.WorkflowNode]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.workflowNode != nil {
                        var tmp : [Any] = []
                        for k in self.workflowNode! {
                            tmp.append(k.toMap())
                        }
                        map["WorkflowNode"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("WorkflowNode") && dict["WorkflowNode"] != nil {
                        var tmp : [ListWorkFlowTemplatesResponseBody.WorkFlowTemplates.WorkFlowTemplate.WorkflowNodes.WorkflowNode] = []
                        for v in dict["WorkflowNode"] as! [Any] {
                            var model = ListWorkFlowTemplatesResponseBody.WorkFlowTemplates.WorkFlowTemplate.WorkflowNodes.WorkflowNode()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.workflowNode = tmp
                    }
                }
            }
            public var comment: String?

            public var createUserId: Int64?

            public var enabled: String?

            public var isSystem: Int32?

            public var templateId: Int64?

            public var templateName: String?

            public var workflowNodes: ListWorkFlowTemplatesResponseBody.WorkFlowTemplates.WorkFlowTemplate.WorkflowNodes?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.workflowNodes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.createUserId != nil {
                    map["CreateUserId"] = self.createUserId!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.isSystem != nil {
                    map["IsSystem"] = self.isSystem!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                if self.workflowNodes != nil {
                    map["WorkflowNodes"] = self.workflowNodes?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Comment") && dict["Comment"] != nil {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("CreateUserId") && dict["CreateUserId"] != nil {
                    self.createUserId = dict["CreateUserId"] as! Int64
                }
                if dict.keys.contains("Enabled") && dict["Enabled"] != nil {
                    self.enabled = dict["Enabled"] as! String
                }
                if dict.keys.contains("IsSystem") && dict["IsSystem"] != nil {
                    self.isSystem = dict["IsSystem"] as! Int32
                }
                if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                    self.templateId = dict["TemplateId"] as! Int64
                }
                if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                    self.templateName = dict["TemplateName"] as! String
                }
                if dict.keys.contains("WorkflowNodes") && dict["WorkflowNodes"] != nil {
                    var model = ListWorkFlowTemplatesResponseBody.WorkFlowTemplates.WorkFlowTemplate.WorkflowNodes()
                    model.fromMap(dict["WorkflowNodes"] as! [String: Any])
                    self.workflowNodes = model
                }
            }
        }
        public var workFlowTemplate: [ListWorkFlowTemplatesResponseBody.WorkFlowTemplates.WorkFlowTemplate]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.workFlowTemplate != nil {
                var tmp : [Any] = []
                for k in self.workFlowTemplate! {
                    tmp.append(k.toMap())
                }
                map["WorkFlowTemplate"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WorkFlowTemplate") && dict["WorkFlowTemplate"] != nil {
                var tmp : [ListWorkFlowTemplatesResponseBody.WorkFlowTemplates.WorkFlowTemplate] = []
                for v in dict["WorkFlowTemplate"] as! [Any] {
                    var model = ListWorkFlowTemplatesResponseBody.WorkFlowTemplates.WorkFlowTemplate()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.workFlowTemplate = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var workFlowTemplates: ListWorkFlowTemplatesResponseBody.WorkFlowTemplates?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workFlowTemplates?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.workFlowTemplates != nil {
            map["WorkFlowTemplates"] = self.workFlowTemplates?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("WorkFlowTemplates") && dict["WorkFlowTemplates"] != nil {
            var model = ListWorkFlowTemplatesResponseBody.WorkFlowTemplates()
            model.fromMap(dict["WorkFlowTemplates"] as! [String: Any])
            self.workFlowTemplates = model
        }
    }
}

public class ListWorkFlowTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkFlowTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListWorkFlowTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MakeTaskFlowInstanceSuccessRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var dagInstanceId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.dagInstanceId != nil {
            map["DagInstanceId"] = self.dagInstanceId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("DagInstanceId") && dict["DagInstanceId"] != nil {
            self.dagInstanceId = dict["DagInstanceId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class MakeTaskFlowInstanceSuccessResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class MakeTaskFlowInstanceSuccessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MakeTaskFlowInstanceSuccessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = MakeTaskFlowInstanceSuccessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDataCorrectExecSQLRequest : Tea.TeaModel {
    public var execSQL: String?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.execSQL != nil {
            map["ExecSQL"] = self.execSQL!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExecSQL") && dict["ExecSQL"] != nil {
            self.execSQL = dict["ExecSQL"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ModifyDataCorrectExecSQLResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyDataCorrectExecSQLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDataCorrectExecSQLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyDataCorrectExecSQLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDesensitizationStrategyRequest : Tea.TeaModel {
    public var columnName: String?

    public var dbId: Int32?

    public var isDefault: Bool?

    public var isLogic: Bool?

    public var isReset: Bool?

    public var ruleId: Int32?

    public var schemaName: String?

    public var tableName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnName != nil {
            map["ColumnName"] = self.columnName!
        }
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.isLogic != nil {
            map["IsLogic"] = self.isLogic!
        }
        if self.isReset != nil {
            map["IsReset"] = self.isReset!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
            self.columnName = dict["ColumnName"] as! String
        }
        if dict.keys.contains("DbId") && dict["DbId"] != nil {
            self.dbId = dict["DbId"] as! Int32
        }
        if dict.keys.contains("IsDefault") && dict["IsDefault"] != nil {
            self.isDefault = dict["IsDefault"] as! Bool
        }
        if dict.keys.contains("IsLogic") && dict["IsLogic"] != nil {
            self.isLogic = dict["IsLogic"] as! Bool
        }
        if dict.keys.contains("IsReset") && dict["IsReset"] != nil {
            self.isReset = dict["IsReset"] as! Bool
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! Int32
        }
        if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
            self.schemaName = dict["SchemaName"] as! String
        }
        if dict.keys.contains("TableName") && dict["TableName"] != nil {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ModifyDesensitizationStrategyResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyDesensitizationStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDesensitizationStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyDesensitizationStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MoveTaskFlowToScenarioRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var scenarioId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("ScenarioId") && dict["ScenarioId"] != nil {
            self.scenarioId = dict["ScenarioId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class MoveTaskFlowToScenarioResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class MoveTaskFlowToScenarioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveTaskFlowToScenarioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = MoveTaskFlowToScenarioResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OfflineTaskFlowRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class OfflineTaskFlowResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class OfflineTaskFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OfflineTaskFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OfflineTaskFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PauseDataCorrectSQLJobRequest : Tea.TeaModel {
    public var jobId: Int64?

    public var orderId: Int64?

    public var tid: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! Int64
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class PauseDataCorrectSQLJobResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PauseDataCorrectSQLJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PauseDataCorrectSQLJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PauseDataCorrectSQLJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PublishAndDeployTaskFlowRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public var versionComments: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.versionComments != nil {
            map["VersionComments"] = self.versionComments!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("VersionComments") && dict["VersionComments"] != nil {
            self.versionComments = dict["VersionComments"] as! String
        }
    }
}

public class PublishAndDeployTaskFlowResponseBody : Tea.TeaModel {
    public var deployId: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deployId != nil {
            map["DeployId"] = self.deployId!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeployId") && dict["DeployId"] != nil {
            self.deployId = dict["DeployId"] as! Int64
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PublishAndDeployTaskFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PublishAndDeployTaskFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PublishAndDeployTaskFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryDataTrackResultDownloadStatusRequest : Tea.TeaModel {
    public var downloadKeyId: String?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadKeyId != nil {
            map["DownloadKeyId"] = self.downloadKeyId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadKeyId") && dict["DownloadKeyId"] != nil {
            self.downloadKeyId = dict["DownloadKeyId"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class QueryDataTrackResultDownloadStatusResponseBody : Tea.TeaModel {
    public class StatusResult : Tea.TeaModel {
        public var downloadStatus: String?

        public var downloadUrl: String?

        public var statusDesc: String?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadStatus != nil {
                map["DownloadStatus"] = self.downloadStatus!
            }
            if self.downloadUrl != nil {
                map["DownloadUrl"] = self.downloadUrl!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DownloadStatus") && dict["DownloadStatus"] != nil {
                self.downloadStatus = dict["DownloadStatus"] as! String
            }
            if dict.keys.contains("DownloadUrl") && dict["DownloadUrl"] != nil {
                self.downloadUrl = dict["DownloadUrl"] as! String
            }
            if dict.keys.contains("StatusDesc") && dict["StatusDesc"] != nil {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var statusResult: QueryDataTrackResultDownloadStatusResponseBody.StatusResult?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.statusResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusResult != nil {
            map["StatusResult"] = self.statusResult?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusResult") && dict["StatusResult"] != nil {
            var model = QueryDataTrackResultDownloadStatusResponseBody.StatusResult()
            model.fromMap(dict["StatusResult"] as! [String: Any])
            self.statusResult = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryDataTrackResultDownloadStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryDataTrackResultDownloadStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryDataTrackResultDownloadStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReDeployLhDagVersionRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var dagVersion: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.dagVersion != nil {
            map["DagVersion"] = self.dagVersion!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("DagVersion") && dict["DagVersion"] != nil {
            self.dagVersion = dict["DagVersion"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ReDeployLhDagVersionResponseBody : Tea.TeaModel {
    public var deployId: Int64?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deployId != nil {
            map["DeployId"] = self.deployId!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeployId") && dict["DeployId"] != nil {
            self.deployId = dict["DeployId"] as! Int64
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ReDeployLhDagVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReDeployLhDagVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReDeployLhDagVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReRunTaskFlowInstanceRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var dagInstanceId: Int64?

    public var dagVersion: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.dagInstanceId != nil {
            map["DagInstanceId"] = self.dagInstanceId!
        }
        if self.dagVersion != nil {
            map["DagVersion"] = self.dagVersion!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("DagInstanceId") && dict["DagInstanceId"] != nil {
            self.dagInstanceId = dict["DagInstanceId"] as! Int64
        }
        if dict.keys.contains("DagVersion") && dict["DagVersion"] != nil {
            self.dagVersion = dict["DagVersion"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ReRunTaskFlowInstanceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ReRunTaskFlowInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReRunTaskFlowInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReRunTaskFlowInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefundPayAsYouGoOrderRequest : Tea.TeaModel {
    public var instanceId: String?

    public var orderId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class RefundPayAsYouGoOrderResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RefundPayAsYouGoOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefundPayAsYouGoOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RefundPayAsYouGoOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterInstanceRequest : Tea.TeaModel {
    public var dataLinkName: String?

    public var databasePassword: String?

    public var databaseUser: String?

    public var dbaUid: Int64?

    public var ddlOnline: Int32?

    public var ecsInstanceId: String?

    public var ecsRegion: String?

    public var enableSellSitd: String?

    public var envType: String?

    public var exportTimeout: Int32?

    public var host: String?

    public var instanceAlias: String?

    public var instanceSource: String?

    public var instanceType: String?

    public var networkType: String?

    public var port: Int32?

    public var queryTimeout: Int32?

    public var safeRule: String?

    public var sid: String?

    public var skipTest: Bool?

    public var templateId: Int64?

    public var templateType: String?

    public var tid: Int64?

    public var useDsql: Int32?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataLinkName != nil {
            map["DataLinkName"] = self.dataLinkName!
        }
        if self.databasePassword != nil {
            map["DatabasePassword"] = self.databasePassword!
        }
        if self.databaseUser != nil {
            map["DatabaseUser"] = self.databaseUser!
        }
        if self.dbaUid != nil {
            map["DbaUid"] = self.dbaUid!
        }
        if self.ddlOnline != nil {
            map["DdlOnline"] = self.ddlOnline!
        }
        if self.ecsInstanceId != nil {
            map["EcsInstanceId"] = self.ecsInstanceId!
        }
        if self.ecsRegion != nil {
            map["EcsRegion"] = self.ecsRegion!
        }
        if self.enableSellSitd != nil {
            map["EnableSellSitd"] = self.enableSellSitd!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.exportTimeout != nil {
            map["ExportTimeout"] = self.exportTimeout!
        }
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.instanceAlias != nil {
            map["InstanceAlias"] = self.instanceAlias!
        }
        if self.instanceSource != nil {
            map["InstanceSource"] = self.instanceSource!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.queryTimeout != nil {
            map["QueryTimeout"] = self.queryTimeout!
        }
        if self.safeRule != nil {
            map["SafeRule"] = self.safeRule!
        }
        if self.sid != nil {
            map["Sid"] = self.sid!
        }
        if self.skipTest != nil {
            map["SkipTest"] = self.skipTest!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.useDsql != nil {
            map["UseDsql"] = self.useDsql!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataLinkName") && dict["DataLinkName"] != nil {
            self.dataLinkName = dict["DataLinkName"] as! String
        }
        if dict.keys.contains("DatabasePassword") && dict["DatabasePassword"] != nil {
            self.databasePassword = dict["DatabasePassword"] as! String
        }
        if dict.keys.contains("DatabaseUser") && dict["DatabaseUser"] != nil {
            self.databaseUser = dict["DatabaseUser"] as! String
        }
        if dict.keys.contains("DbaUid") && dict["DbaUid"] != nil {
            self.dbaUid = dict["DbaUid"] as! Int64
        }
        if dict.keys.contains("DdlOnline") && dict["DdlOnline"] != nil {
            self.ddlOnline = dict["DdlOnline"] as! Int32
        }
        if dict.keys.contains("EcsInstanceId") && dict["EcsInstanceId"] != nil {
            self.ecsInstanceId = dict["EcsInstanceId"] as! String
        }
        if dict.keys.contains("EcsRegion") && dict["EcsRegion"] != nil {
            self.ecsRegion = dict["EcsRegion"] as! String
        }
        if dict.keys.contains("EnableSellSitd") && dict["EnableSellSitd"] != nil {
            self.enableSellSitd = dict["EnableSellSitd"] as! String
        }
        if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("ExportTimeout") && dict["ExportTimeout"] != nil {
            self.exportTimeout = dict["ExportTimeout"] as! Int32
        }
        if dict.keys.contains("Host") && dict["Host"] != nil {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("InstanceAlias") && dict["InstanceAlias"] != nil {
            self.instanceAlias = dict["InstanceAlias"] as! String
        }
        if dict.keys.contains("InstanceSource") && dict["InstanceSource"] != nil {
            self.instanceSource = dict["InstanceSource"] as! String
        }
        if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("NetworkType") && dict["NetworkType"] != nil {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("QueryTimeout") && dict["QueryTimeout"] != nil {
            self.queryTimeout = dict["QueryTimeout"] as! Int32
        }
        if dict.keys.contains("SafeRule") && dict["SafeRule"] != nil {
            self.safeRule = dict["SafeRule"] as! String
        }
        if dict.keys.contains("Sid") && dict["Sid"] != nil {
            self.sid = dict["Sid"] as! String
        }
        if dict.keys.contains("SkipTest") && dict["SkipTest"] != nil {
            self.skipTest = dict["SkipTest"] as! Bool
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UseDsql") && dict["UseDsql"] != nil {
            self.useDsql = dict["UseDsql"] as! Int32
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class RegisterInstanceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RegisterInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RegisterInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterUserRequest : Tea.TeaModel {
    public var mobile: String?

    public var roleNames: String?

    public var tid: Int64?

    public var uid: String?

    public var userNick: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mobile != nil {
            map["Mobile"] = self.mobile!
        }
        if self.roleNames != nil {
            map["RoleNames"] = self.roleNames!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        if self.userNick != nil {
            map["UserNick"] = self.userNick!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
            self.mobile = dict["Mobile"] as! String
        }
        if dict.keys.contains("RoleNames") && dict["RoleNames"] != nil {
            self.roleNames = dict["RoleNames"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("Uid") && dict["Uid"] != nil {
            self.uid = dict["Uid"] as! String
        }
        if dict.keys.contains("UserNick") && dict["UserNick"] != nil {
            self.userNick = dict["UserNick"] as! String
        }
    }
}

public class RegisterUserResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RegisterUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RegisterUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestartDataCorrectSQLJobRequest : Tea.TeaModel {
    public var jobId: Int64?

    public var orderId: Int64?

    public var tid: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! Int64
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class RestartDataCorrectSQLJobResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RestartDataCorrectSQLJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartDataCorrectSQLJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RestartDataCorrectSQLJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResumeTaskFlowInstanceRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var dagInstanceId: Int64?

    public var dagVersion: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.dagInstanceId != nil {
            map["DagInstanceId"] = self.dagInstanceId!
        }
        if self.dagVersion != nil {
            map["DagVersion"] = self.dagVersion!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("DagInstanceId") && dict["DagInstanceId"] != nil {
            self.dagInstanceId = dict["DagInstanceId"] as! Int64
        }
        if dict.keys.contains("DagVersion") && dict["DagVersion"] != nil {
            self.dagVersion = dict["DagVersion"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class ResumeTaskFlowInstanceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ResumeTaskFlowInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeTaskFlowInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ResumeTaskFlowInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RetryDataCorrectPreCheckRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class RetryDataCorrectPreCheckResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RetryDataCorrectPreCheckResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetryDataCorrectPreCheckResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RetryDataCorrectPreCheckResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RevokeTemplateAuthorityRequest : Tea.TeaModel {
    public var templateId: Int64?

    public var tid: Int64?

    public var userIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserIds") && dict["UserIds"] != nil {
            self.userIds = dict["UserIds"] as! String
        }
    }
}

public class RevokeTemplateAuthorityResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RevokeTemplateAuthorityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeTemplateAuthorityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RevokeTemplateAuthorityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RevokeUserPermissionRequest : Tea.TeaModel {
    public var dbId: String?

    public var dsType: String?

    public var instanceId: Int64?

    public var logic: Bool?

    public var permTypes: String?

    public var tableId: String?

    public var tableName: String?

    public var tid: Int64?

    public var userAccessId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.dsType != nil {
            map["DsType"] = self.dsType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.permTypes != nil {
            map["PermTypes"] = self.permTypes!
        }
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.userAccessId != nil {
            map["UserAccessId"] = self.userAccessId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") && dict["DbId"] != nil {
            self.dbId = dict["DbId"] as! String
        }
        if dict.keys.contains("DsType") && dict["DsType"] != nil {
            self.dsType = dict["DsType"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("Logic") && dict["Logic"] != nil {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("PermTypes") && dict["PermTypes"] != nil {
            self.permTypes = dict["PermTypes"] as! String
        }
        if dict.keys.contains("TableId") && dict["TableId"] != nil {
            self.tableId = dict["TableId"] as! String
        }
        if dict.keys.contains("TableName") && dict["TableName"] != nil {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UserAccessId") && dict["UserAccessId"] != nil {
            self.userAccessId = dict["UserAccessId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class RevokeUserPermissionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RevokeUserPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeUserPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RevokeUserPermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchDataTrackResultRequest : Tea.TeaModel {
    public class ColumnFilter : Tea.TeaModel {
        public var betweenEnd: String?

        public var betweenStart: String?

        public var columnName: String?

        public var inList: [String]?

        public var operator_: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.betweenEnd != nil {
                map["BetweenEnd"] = self.betweenEnd!
            }
            if self.betweenStart != nil {
                map["BetweenStart"] = self.betweenStart!
            }
            if self.columnName != nil {
                map["ColumnName"] = self.columnName!
            }
            if self.inList != nil {
                map["InList"] = self.inList!
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BetweenEnd") && dict["BetweenEnd"] != nil {
                self.betweenEnd = dict["BetweenEnd"] as! String
            }
            if dict.keys.contains("BetweenStart") && dict["BetweenStart"] != nil {
                self.betweenStart = dict["BetweenStart"] as! String
            }
            if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
                self.columnName = dict["ColumnName"] as! String
            }
            if dict.keys.contains("InList") && dict["InList"] != nil {
                self.inList = dict["InList"] as! [String]
            }
            if dict.keys.contains("Operator") && dict["Operator"] != nil {
                self.operator_ = dict["Operator"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var columnFilter: SearchDataTrackResultRequest.ColumnFilter?

    public var filterEndTime: String?

    public var filterStartTime: String?

    public var filterTableList: [String]?

    public var filterTypeList: [String]?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.columnFilter?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnFilter != nil {
            map["ColumnFilter"] = self.columnFilter?.toMap()
        }
        if self.filterEndTime != nil {
            map["FilterEndTime"] = self.filterEndTime!
        }
        if self.filterStartTime != nil {
            map["FilterStartTime"] = self.filterStartTime!
        }
        if self.filterTableList != nil {
            map["FilterTableList"] = self.filterTableList!
        }
        if self.filterTypeList != nil {
            map["FilterTypeList"] = self.filterTypeList!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnFilter") && dict["ColumnFilter"] != nil {
            var model = SearchDataTrackResultRequest.ColumnFilter()
            model.fromMap(dict["ColumnFilter"] as! [String: Any])
            self.columnFilter = model
        }
        if dict.keys.contains("FilterEndTime") && dict["FilterEndTime"] != nil {
            self.filterEndTime = dict["FilterEndTime"] as! String
        }
        if dict.keys.contains("FilterStartTime") && dict["FilterStartTime"] != nil {
            self.filterStartTime = dict["FilterStartTime"] as! String
        }
        if dict.keys.contains("FilterTableList") && dict["FilterTableList"] != nil {
            self.filterTableList = dict["FilterTableList"] as! [String]
        }
        if dict.keys.contains("FilterTypeList") && dict["FilterTypeList"] != nil {
            self.filterTypeList = dict["FilterTypeList"] as! [String]
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SearchDataTrackResultShrinkRequest : Tea.TeaModel {
    public var columnFilterShrink: String?

    public var filterEndTime: String?

    public var filterStartTime: String?

    public var filterTableListShrink: String?

    public var filterTypeListShrink: String?

    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnFilterShrink != nil {
            map["ColumnFilter"] = self.columnFilterShrink!
        }
        if self.filterEndTime != nil {
            map["FilterEndTime"] = self.filterEndTime!
        }
        if self.filterStartTime != nil {
            map["FilterStartTime"] = self.filterStartTime!
        }
        if self.filterTableListShrink != nil {
            map["FilterTableList"] = self.filterTableListShrink!
        }
        if self.filterTypeListShrink != nil {
            map["FilterTypeList"] = self.filterTypeListShrink!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ColumnFilter") && dict["ColumnFilter"] != nil {
            self.columnFilterShrink = dict["ColumnFilter"] as! String
        }
        if dict.keys.contains("FilterEndTime") && dict["FilterEndTime"] != nil {
            self.filterEndTime = dict["FilterEndTime"] as! String
        }
        if dict.keys.contains("FilterStartTime") && dict["FilterStartTime"] != nil {
            self.filterStartTime = dict["FilterStartTime"] as! String
        }
        if dict.keys.contains("FilterTableList") && dict["FilterTableList"] != nil {
            self.filterTableListShrink = dict["FilterTableList"] as! String
        }
        if dict.keys.contains("FilterTypeList") && dict["FilterTypeList"] != nil {
            self.filterTypeListShrink = dict["FilterTypeList"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SearchDataTrackResultResponseBody : Tea.TeaModel {
    public class TrackResult : Tea.TeaModel {
        public class EventList : Tea.TeaModel {
            public var dataAfter: [String]?

            public var dataBefore: [String]?

            public var eventId: Int64?

            public var eventLength: Int64?

            public var eventTimestamp: String?

            public var eventType: String?

            public var rollSQL: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataAfter != nil {
                    map["DataAfter"] = self.dataAfter!
                }
                if self.dataBefore != nil {
                    map["DataBefore"] = self.dataBefore!
                }
                if self.eventId != nil {
                    map["EventId"] = self.eventId!
                }
                if self.eventLength != nil {
                    map["EventLength"] = self.eventLength!
                }
                if self.eventTimestamp != nil {
                    map["EventTimestamp"] = self.eventTimestamp!
                }
                if self.eventType != nil {
                    map["EventType"] = self.eventType!
                }
                if self.rollSQL != nil {
                    map["RollSQL"] = self.rollSQL!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataAfter") && dict["DataAfter"] != nil {
                    self.dataAfter = dict["DataAfter"] as! [String]
                }
                if dict.keys.contains("DataBefore") && dict["DataBefore"] != nil {
                    self.dataBefore = dict["DataBefore"] as! [String]
                }
                if dict.keys.contains("EventId") && dict["EventId"] != nil {
                    self.eventId = dict["EventId"] as! Int64
                }
                if dict.keys.contains("EventLength") && dict["EventLength"] != nil {
                    self.eventLength = dict["EventLength"] as! Int64
                }
                if dict.keys.contains("EventTimestamp") && dict["EventTimestamp"] != nil {
                    self.eventTimestamp = dict["EventTimestamp"] as! String
                }
                if dict.keys.contains("EventType") && dict["EventType"] != nil {
                    self.eventType = dict["EventType"] as! String
                }
                if dict.keys.contains("RollSQL") && dict["RollSQL"] != nil {
                    self.rollSQL = dict["RollSQL"] as! String
                }
            }
        }
        public class TableInfoList : Tea.TeaModel {
            public class Columns : Tea.TeaModel {
                public var columnName: String?

                public var columnPosition: Int32?

                public var columnType: String?

                public var fictive: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.columnName != nil {
                        map["ColumnName"] = self.columnName!
                    }
                    if self.columnPosition != nil {
                        map["ColumnPosition"] = self.columnPosition!
                    }
                    if self.columnType != nil {
                        map["ColumnType"] = self.columnType!
                    }
                    if self.fictive != nil {
                        map["Fictive"] = self.fictive!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ColumnName") && dict["ColumnName"] != nil {
                        self.columnName = dict["ColumnName"] as! String
                    }
                    if dict.keys.contains("ColumnPosition") && dict["ColumnPosition"] != nil {
                        self.columnPosition = dict["ColumnPosition"] as! Int32
                    }
                    if dict.keys.contains("ColumnType") && dict["ColumnType"] != nil {
                        self.columnType = dict["ColumnType"] as! String
                    }
                    if dict.keys.contains("Fictive") && dict["Fictive"] != nil {
                        self.fictive = dict["Fictive"] as! Bool
                    }
                }
            }
            public var columns: [SearchDataTrackResultResponseBody.TrackResult.TableInfoList.Columns]?

            public var description_: String?

            public var schemaName: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columns != nil {
                    var tmp : [Any] = []
                    for k in self.columns! {
                        tmp.append(k.toMap())
                    }
                    map["Columns"] = tmp
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Columns") && dict["Columns"] != nil {
                    var tmp : [SearchDataTrackResultResponseBody.TrackResult.TableInfoList.Columns] = []
                    for v in dict["Columns"] as! [Any] {
                        var model = SearchDataTrackResultResponseBody.TrackResult.TableInfoList.Columns()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.columns = tmp
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("TableName") && dict["TableName"] != nil {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public var eventList: [SearchDataTrackResultResponseBody.TrackResult.EventList]?

        public var tableInfoList: [SearchDataTrackResultResponseBody.TrackResult.TableInfoList]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventList != nil {
                var tmp : [Any] = []
                for k in self.eventList! {
                    tmp.append(k.toMap())
                }
                map["EventList"] = tmp
            }
            if self.tableInfoList != nil {
                var tmp : [Any] = []
                for k in self.tableInfoList! {
                    tmp.append(k.toMap())
                }
                map["TableInfoList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventList") && dict["EventList"] != nil {
                var tmp : [SearchDataTrackResultResponseBody.TrackResult.EventList] = []
                for v in dict["EventList"] as! [Any] {
                    var model = SearchDataTrackResultResponseBody.TrackResult.EventList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eventList = tmp
            }
            if dict.keys.contains("TableInfoList") && dict["TableInfoList"] != nil {
                var tmp : [SearchDataTrackResultResponseBody.TrackResult.TableInfoList] = []
                for v in dict["TableInfoList"] as! [Any] {
                    var model = SearchDataTrackResultResponseBody.TrackResult.TableInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tableInfoList = tmp
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var trackResult: SearchDataTrackResultResponseBody.TrackResult?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.trackResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.trackResult != nil {
            map["TrackResult"] = self.trackResult?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TrackResult") && dict["TrackResult"] != nil {
            var model = SearchDataTrackResultResponseBody.TrackResult()
            model.fromMap(dict["TrackResult"] as! [String: Any])
            self.trackResult = model
        }
    }
}

public class SearchDataTrackResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchDataTrackResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchDataTrackResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchDatabaseRequest : Tea.TeaModel {
    public var dbType: String?

    public var envType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchKey: String?

    public var searchRange: String?

    public var searchTarget: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbType != nil {
            map["DbType"] = self.dbType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.searchRange != nil {
            map["SearchRange"] = self.searchRange!
        }
        if self.searchTarget != nil {
            map["SearchTarget"] = self.searchTarget!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbType") && dict["DbType"] != nil {
            self.dbType = dict["DbType"] as! String
        }
        if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchKey") && dict["SearchKey"] != nil {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("SearchRange") && dict["SearchRange"] != nil {
            self.searchRange = dict["SearchRange"] as! String
        }
        if dict.keys.contains("SearchTarget") && dict["SearchTarget"] != nil {
            self.searchTarget = dict["SearchTarget"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SearchDatabaseResponseBody : Tea.TeaModel {
    public class SearchDatabaseList : Tea.TeaModel {
        public class SearchDatabase : Tea.TeaModel {
            public class OwnerIdList : Tea.TeaModel {
                public var ownerIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerIds") && dict["OwnerIds"] != nil {
                        self.ownerIds = dict["OwnerIds"] as! [String]
                    }
                }
            }
            public class OwnerNameList : Tea.TeaModel {
                public var ownerNames: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerNames != nil {
                        map["OwnerNames"] = self.ownerNames!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerNames") && dict["OwnerNames"] != nil {
                        self.ownerNames = dict["OwnerNames"] as! [String]
                    }
                }
            }
            public var alias: String?

            public var catalogName: String?

            public var databaseId: String?

            public var datalinkName: String?

            public var dbType: String?

            public var dbaId: String?

            public var encoding: String?

            public var envType: String?

            public var host: String?

            public var logic: Bool?

            public var ownerIdList: SearchDatabaseResponseBody.SearchDatabaseList.SearchDatabase.OwnerIdList?

            public var ownerNameList: SearchDatabaseResponseBody.SearchDatabaseList.SearchDatabase.OwnerNameList?

            public var port: Int32?

            public var schemaName: String?

            public var searchName: String?

            public var sid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ownerIdList?.validate()
                try self.ownerNameList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.catalogName != nil {
                    map["CatalogName"] = self.catalogName!
                }
                if self.databaseId != nil {
                    map["DatabaseId"] = self.databaseId!
                }
                if self.datalinkName != nil {
                    map["DatalinkName"] = self.datalinkName!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.dbaId != nil {
                    map["DbaId"] = self.dbaId!
                }
                if self.encoding != nil {
                    map["Encoding"] = self.encoding!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.ownerIdList != nil {
                    map["OwnerIdList"] = self.ownerIdList?.toMap()
                }
                if self.ownerNameList != nil {
                    map["OwnerNameList"] = self.ownerNameList?.toMap()
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.searchName != nil {
                    map["SearchName"] = self.searchName!
                }
                if self.sid != nil {
                    map["Sid"] = self.sid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") && dict["Alias"] != nil {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("CatalogName") && dict["CatalogName"] != nil {
                    self.catalogName = dict["CatalogName"] as! String
                }
                if dict.keys.contains("DatabaseId") && dict["DatabaseId"] != nil {
                    self.databaseId = dict["DatabaseId"] as! String
                }
                if dict.keys.contains("DatalinkName") && dict["DatalinkName"] != nil {
                    self.datalinkName = dict["DatalinkName"] as! String
                }
                if dict.keys.contains("DbType") && dict["DbType"] != nil {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("DbaId") && dict["DbaId"] != nil {
                    self.dbaId = dict["DbaId"] as! String
                }
                if dict.keys.contains("Encoding") && dict["Encoding"] != nil {
                    self.encoding = dict["Encoding"] as! String
                }
                if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("Host") && dict["Host"] != nil {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("OwnerIdList") && dict["OwnerIdList"] != nil {
                    var model = SearchDatabaseResponseBody.SearchDatabaseList.SearchDatabase.OwnerIdList()
                    model.fromMap(dict["OwnerIdList"] as! [String: Any])
                    self.ownerIdList = model
                }
                if dict.keys.contains("OwnerNameList") && dict["OwnerNameList"] != nil {
                    var model = SearchDatabaseResponseBody.SearchDatabaseList.SearchDatabase.OwnerNameList()
                    model.fromMap(dict["OwnerNameList"] as! [String: Any])
                    self.ownerNameList = model
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("SchemaName") && dict["SchemaName"] != nil {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SearchName") && dict["SearchName"] != nil {
                    self.searchName = dict["SearchName"] as! String
                }
                if dict.keys.contains("Sid") && dict["Sid"] != nil {
                    self.sid = dict["Sid"] as! String
                }
            }
        }
        public var searchDatabase: [SearchDatabaseResponseBody.SearchDatabaseList.SearchDatabase]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.searchDatabase != nil {
                var tmp : [Any] = []
                for k in self.searchDatabase! {
                    tmp.append(k.toMap())
                }
                map["SearchDatabase"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SearchDatabase") && dict["SearchDatabase"] != nil {
                var tmp : [SearchDatabaseResponseBody.SearchDatabaseList.SearchDatabase] = []
                for v in dict["SearchDatabase"] as! [Any] {
                    var model = SearchDatabaseResponseBody.SearchDatabaseList.SearchDatabase()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.searchDatabase = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var searchDatabaseList: SearchDatabaseResponseBody.SearchDatabaseList?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.searchDatabaseList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.searchDatabaseList != nil {
            map["SearchDatabaseList"] = self.searchDatabaseList?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SearchDatabaseList") && dict["SearchDatabaseList"] != nil {
            var model = SearchDatabaseResponseBody.SearchDatabaseList()
            model.fromMap(dict["SearchDatabaseList"] as! [String: Any])
            self.searchDatabaseList = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SearchDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchTableRequest : Tea.TeaModel {
    public var dbType: String?

    public var envType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var returnGuid: Bool?

    public var searchKey: String?

    public var searchRange: String?

    public var searchTarget: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbType != nil {
            map["DbType"] = self.dbType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.returnGuid != nil {
            map["ReturnGuid"] = self.returnGuid!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.searchRange != nil {
            map["SearchRange"] = self.searchRange!
        }
        if self.searchTarget != nil {
            map["SearchTarget"] = self.searchTarget!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbType") && dict["DbType"] != nil {
            self.dbType = dict["DbType"] as! String
        }
        if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ReturnGuid") && dict["ReturnGuid"] != nil {
            self.returnGuid = dict["ReturnGuid"] as! Bool
        }
        if dict.keys.contains("SearchKey") && dict["SearchKey"] != nil {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("SearchRange") && dict["SearchRange"] != nil {
            self.searchRange = dict["SearchRange"] as! String
        }
        if dict.keys.contains("SearchTarget") && dict["SearchTarget"] != nil {
            self.searchTarget = dict["SearchTarget"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SearchTableResponseBody : Tea.TeaModel {
    public class SearchTableList : Tea.TeaModel {
        public class SearchTable : Tea.TeaModel {
            public class OwnerIdList : Tea.TeaModel {
                public var ownerIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerIds != nil {
                        map["OwnerIds"] = self.ownerIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerIds") && dict["OwnerIds"] != nil {
                        self.ownerIds = dict["OwnerIds"] as! [String]
                    }
                }
            }
            public class OwnerNameList : Tea.TeaModel {
                public var ownerNames: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ownerNames != nil {
                        map["OwnerNames"] = self.ownerNames!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OwnerNames") && dict["OwnerNames"] != nil {
                        self.ownerNames = dict["OwnerNames"] as! [String]
                    }
                }
            }
            public var DBSearchName: String?

            public var databaseId: String?

            public var dbName: String?

            public var dbType: String?

            public var description_: String?

            public var encoding: String?

            public var engine: String?

            public var envType: String?

            public var logic: Bool?

            public var ownerIdList: SearchTableResponseBody.SearchTableList.SearchTable.OwnerIdList?

            public var ownerNameList: SearchTableResponseBody.SearchTableList.SearchTable.OwnerNameList?

            public var tableGuid: String?

            public var tableId: String?

            public var tableName: String?

            public var tableSchemaName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ownerIdList?.validate()
                try self.ownerNameList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBSearchName != nil {
                    map["DBSearchName"] = self.DBSearchName!
                }
                if self.databaseId != nil {
                    map["DatabaseId"] = self.databaseId!
                }
                if self.dbName != nil {
                    map["DbName"] = self.dbName!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.encoding != nil {
                    map["Encoding"] = self.encoding!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.logic != nil {
                    map["Logic"] = self.logic!
                }
                if self.ownerIdList != nil {
                    map["OwnerIdList"] = self.ownerIdList?.toMap()
                }
                if self.ownerNameList != nil {
                    map["OwnerNameList"] = self.ownerNameList?.toMap()
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.tableId != nil {
                    map["TableId"] = self.tableId!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.tableSchemaName != nil {
                    map["TableSchemaName"] = self.tableSchemaName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DBSearchName") && dict["DBSearchName"] != nil {
                    self.DBSearchName = dict["DBSearchName"] as! String
                }
                if dict.keys.contains("DatabaseId") && dict["DatabaseId"] != nil {
                    self.databaseId = dict["DatabaseId"] as! String
                }
                if dict.keys.contains("DbName") && dict["DbName"] != nil {
                    self.dbName = dict["DbName"] as! String
                }
                if dict.keys.contains("DbType") && dict["DbType"] != nil {
                    self.dbType = dict["DbType"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Encoding") && dict["Encoding"] != nil {
                    self.encoding = dict["Encoding"] as! String
                }
                if dict.keys.contains("Engine") && dict["Engine"] != nil {
                    self.engine = dict["Engine"] as! String
                }
                if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
                    self.envType = dict["EnvType"] as! String
                }
                if dict.keys.contains("Logic") && dict["Logic"] != nil {
                    self.logic = dict["Logic"] as! Bool
                }
                if dict.keys.contains("OwnerIdList") && dict["OwnerIdList"] != nil {
                    var model = SearchTableResponseBody.SearchTableList.SearchTable.OwnerIdList()
                    model.fromMap(dict["OwnerIdList"] as! [String: Any])
                    self.ownerIdList = model
                }
                if dict.keys.contains("OwnerNameList") && dict["OwnerNameList"] != nil {
                    var model = SearchTableResponseBody.SearchTableList.SearchTable.OwnerNameList()
                    model.fromMap(dict["OwnerNameList"] as! [String: Any])
                    self.ownerNameList = model
                }
                if dict.keys.contains("TableGuid") && dict["TableGuid"] != nil {
                    self.tableGuid = dict["TableGuid"] as! String
                }
                if dict.keys.contains("TableId") && dict["TableId"] != nil {
                    self.tableId = dict["TableId"] as! String
                }
                if dict.keys.contains("TableName") && dict["TableName"] != nil {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("TableSchemaName") && dict["TableSchemaName"] != nil {
                    self.tableSchemaName = dict["TableSchemaName"] as! String
                }
            }
        }
        public var searchTable: [SearchTableResponseBody.SearchTableList.SearchTable]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.searchTable != nil {
                var tmp : [Any] = []
                for k in self.searchTable! {
                    tmp.append(k.toMap())
                }
                map["SearchTable"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SearchTable") && dict["SearchTable"] != nil {
                var tmp : [SearchTableResponseBody.SearchTableList.SearchTable] = []
                for v in dict["SearchTable"] as! [Any] {
                    var model = SearchTableResponseBody.SearchTableList.SearchTable()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.searchTable = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var searchTableList: SearchTableResponseBody.SearchTableList?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.searchTableList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.searchTableList != nil {
            map["SearchTableList"] = self.searchTableList?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SearchTableList") && dict["SearchTableList"] != nil {
            var model = SearchTableResponseBody.SearchTableList()
            model.fromMap(dict["SearchTableList"] as! [String: Any])
            self.searchTableList = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SearchTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetOwnersRequest : Tea.TeaModel {
    public var ownerIds: String?

    public var ownerType: String?

    public var resourceId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerIds != nil {
            map["OwnerIds"] = self.ownerIds!
        }
        if self.ownerType != nil {
            map["OwnerType"] = self.ownerType!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerIds") && dict["OwnerIds"] != nil {
            self.ownerIds = dict["OwnerIds"] as! String
        }
        if dict.keys.contains("OwnerType") && dict["OwnerType"] != nil {
            self.ownerType = dict["OwnerType"] as! String
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SetOwnersResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SetOwnersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetOwnersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetOwnersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SkipDataCorrectRowCheckRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var reason: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Reason") && dict["Reason"] != nil {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SkipDataCorrectRowCheckResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SkipDataCorrectRowCheckResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SkipDataCorrectRowCheckResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SkipDataCorrectRowCheckResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopTaskFlowInstanceRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var dagInstanceId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.dagInstanceId != nil {
            map["DagInstanceId"] = self.dagInstanceId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("DagInstanceId") && dict["DagInstanceId"] != nil {
            self.dagInstanceId = dict["DagInstanceId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class StopTaskFlowInstanceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StopTaskFlowInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopTaskFlowInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StopTaskFlowInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitOrderApprovalRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SubmitOrderApprovalResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SubmitOrderApprovalResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitOrderApprovalResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitOrderApprovalResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitStructSyncOrderApprovalRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SubmitStructSyncOrderApprovalResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var workflowInstanceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.workflowInstanceId != nil {
            map["WorkflowInstanceId"] = self.workflowInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("WorkflowInstanceId") && dict["WorkflowInstanceId"] != nil {
            self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
        }
    }
}

public class SubmitStructSyncOrderApprovalResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitStructSyncOrderApprovalResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitStructSyncOrderApprovalResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SuspendTaskFlowInstanceRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var dagInstanceId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.dagInstanceId != nil {
            map["DagInstanceId"] = self.dagInstanceId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("DagInstanceId") && dict["DagInstanceId"] != nil {
            self.dagInstanceId = dict["DagInstanceId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SuspendTaskFlowInstanceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SuspendTaskFlowInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendTaskFlowInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SuspendTaskFlowInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SyncDatabaseMetaRequest : Tea.TeaModel {
    public var dbId: String?

    public var logic: Bool?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbId != nil {
            map["DbId"] = self.dbId!
        }
        if self.logic != nil {
            map["Logic"] = self.logic!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbId") && dict["DbId"] != nil {
            self.dbId = dict["DbId"] as! String
        }
        if dict.keys.contains("Logic") && dict["Logic"] != nil {
            self.logic = dict["Logic"] as! Bool
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SyncDatabaseMetaResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SyncDatabaseMetaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SyncDatabaseMetaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SyncDatabaseMetaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SyncInstanceMetaRequest : Tea.TeaModel {
    public var ignoreTable: Bool?

    public var instanceId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ignoreTable != nil {
            map["IgnoreTable"] = self.ignoreTable!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IgnoreTable") && dict["IgnoreTable"] != nil {
            self.ignoreTable = dict["IgnoreTable"] as! Bool
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class SyncInstanceMetaResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SyncInstanceMetaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SyncInstanceMetaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SyncInstanceMetaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAuthorityTemplateRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var templateId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateAuthorityTemplateResponseBody : Tea.TeaModel {
    public class AuthorityTemplateView : Tea.TeaModel {
        public var creatorId: Int64?

        public var description_: String?

        public var name: String?

        public var templateId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! Int64
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! Int64
            }
        }
    }
    public var authorityTemplateView: UpdateAuthorityTemplateResponseBody.AuthorityTemplateView?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authorityTemplateView?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorityTemplateView != nil {
            map["AuthorityTemplateView"] = self.authorityTemplateView?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorityTemplateView") && dict["AuthorityTemplateView"] != nil {
            var model = UpdateAuthorityTemplateResponseBody.AuthorityTemplateView()
            model.fromMap(dict["AuthorityTemplateView"] as! [String: Any])
            self.authorityTemplateView = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateAuthorityTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAuthorityTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAuthorityTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateInstanceRequest : Tea.TeaModel {
    public var dataLinkName: String?

    public var databasePassword: String?

    public var databaseUser: String?

    public var dbaId: String?

    public var ddlOnline: Int32?

    public var ecsInstanceId: String?

    public var ecsRegion: String?

    public var enableSellSitd: String?

    public var envType: String?

    public var exportTimeout: Int32?

    public var host: String?

    public var instanceAlias: String?

    public var instanceId: String?

    public var instanceSource: String?

    public var instanceType: String?

    public var port: Int32?

    public var queryTimeout: Int32?

    public var safeRuleId: String?

    public var sid: String?

    public var skipTest: Bool?

    public var templateId: Int64?

    public var templateType: String?

    public var tid: Int64?

    public var useDsql: Int32?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataLinkName != nil {
            map["DataLinkName"] = self.dataLinkName!
        }
        if self.databasePassword != nil {
            map["DatabasePassword"] = self.databasePassword!
        }
        if self.databaseUser != nil {
            map["DatabaseUser"] = self.databaseUser!
        }
        if self.dbaId != nil {
            map["DbaId"] = self.dbaId!
        }
        if self.ddlOnline != nil {
            map["DdlOnline"] = self.ddlOnline!
        }
        if self.ecsInstanceId != nil {
            map["EcsInstanceId"] = self.ecsInstanceId!
        }
        if self.ecsRegion != nil {
            map["EcsRegion"] = self.ecsRegion!
        }
        if self.enableSellSitd != nil {
            map["EnableSellSitd"] = self.enableSellSitd!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.exportTimeout != nil {
            map["ExportTimeout"] = self.exportTimeout!
        }
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.instanceAlias != nil {
            map["InstanceAlias"] = self.instanceAlias!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceSource != nil {
            map["InstanceSource"] = self.instanceSource!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.queryTimeout != nil {
            map["QueryTimeout"] = self.queryTimeout!
        }
        if self.safeRuleId != nil {
            map["SafeRuleId"] = self.safeRuleId!
        }
        if self.sid != nil {
            map["Sid"] = self.sid!
        }
        if self.skipTest != nil {
            map["SkipTest"] = self.skipTest!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.useDsql != nil {
            map["UseDsql"] = self.useDsql!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataLinkName") && dict["DataLinkName"] != nil {
            self.dataLinkName = dict["DataLinkName"] as! String
        }
        if dict.keys.contains("DatabasePassword") && dict["DatabasePassword"] != nil {
            self.databasePassword = dict["DatabasePassword"] as! String
        }
        if dict.keys.contains("DatabaseUser") && dict["DatabaseUser"] != nil {
            self.databaseUser = dict["DatabaseUser"] as! String
        }
        if dict.keys.contains("DbaId") && dict["DbaId"] != nil {
            self.dbaId = dict["DbaId"] as! String
        }
        if dict.keys.contains("DdlOnline") && dict["DdlOnline"] != nil {
            self.ddlOnline = dict["DdlOnline"] as! Int32
        }
        if dict.keys.contains("EcsInstanceId") && dict["EcsInstanceId"] != nil {
            self.ecsInstanceId = dict["EcsInstanceId"] as! String
        }
        if dict.keys.contains("EcsRegion") && dict["EcsRegion"] != nil {
            self.ecsRegion = dict["EcsRegion"] as! String
        }
        if dict.keys.contains("EnableSellSitd") && dict["EnableSellSitd"] != nil {
            self.enableSellSitd = dict["EnableSellSitd"] as! String
        }
        if dict.keys.contains("EnvType") && dict["EnvType"] != nil {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("ExportTimeout") && dict["ExportTimeout"] != nil {
            self.exportTimeout = dict["ExportTimeout"] as! Int32
        }
        if dict.keys.contains("Host") && dict["Host"] != nil {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("InstanceAlias") && dict["InstanceAlias"] != nil {
            self.instanceAlias = dict["InstanceAlias"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceSource") && dict["InstanceSource"] != nil {
            self.instanceSource = dict["InstanceSource"] as! String
        }
        if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("QueryTimeout") && dict["QueryTimeout"] != nil {
            self.queryTimeout = dict["QueryTimeout"] as! Int32
        }
        if dict.keys.contains("SafeRuleId") && dict["SafeRuleId"] != nil {
            self.safeRuleId = dict["SafeRuleId"] as! String
        }
        if dict.keys.contains("Sid") && dict["Sid"] != nil {
            self.sid = dict["Sid"] as! String
        }
        if dict.keys.contains("SkipTest") && dict["SkipTest"] != nil {
            self.skipTest = dict["SkipTest"] as! Bool
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! Int64
        }
        if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("UseDsql") && dict["UseDsql"] != nil {
            self.useDsql = dict["UseDsql"] as! Int32
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class UpdateInstanceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSLARulesRequest : Tea.TeaModel {
    public class SlaRuleList : Tea.TeaModel {
        public var dagId: Int64?

        public var intervalMinutes: Int32?

        public var nodeId: Int64?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dagId != nil {
                map["DagId"] = self.dagId!
            }
            if self.intervalMinutes != nil {
                map["IntervalMinutes"] = self.intervalMinutes!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DagId") && dict["DagId"] != nil {
                self.dagId = dict["DagId"] as! Int64
            }
            if dict.keys.contains("IntervalMinutes") && dict["IntervalMinutes"] != nil {
                self.intervalMinutes = dict["IntervalMinutes"] as! Int32
            }
            if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                self.nodeId = dict["NodeId"] as! Int64
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var dagId: Int64?

    public var slaRuleList: [UpdateSLARulesRequest.SlaRuleList]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.slaRuleList != nil {
            var tmp : [Any] = []
            for k in self.slaRuleList! {
                tmp.append(k.toMap())
            }
            map["SlaRuleList"] = tmp
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("SlaRuleList") && dict["SlaRuleList"] != nil {
            var tmp : [UpdateSLARulesRequest.SlaRuleList] = []
            for v in dict["SlaRuleList"] as! [Any] {
                var model = UpdateSLARulesRequest.SlaRuleList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.slaRuleList = tmp
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateSLARulesShrinkRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var slaRuleListShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.slaRuleListShrink != nil {
            map["SlaRuleList"] = self.slaRuleListShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("SlaRuleList") && dict["SlaRuleList"] != nil {
            self.slaRuleListShrink = dict["SlaRuleList"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateSLARulesResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateSLARulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSLARulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateSLARulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateScenarioRequest : Tea.TeaModel {
    public var description_: String?

    public var scenarioId: String?

    public var scenarioName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.scenarioName != nil {
            map["ScenarioName"] = self.scenarioName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ScenarioId") && dict["ScenarioId"] != nil {
            self.scenarioId = dict["ScenarioId"] as! String
        }
        if dict.keys.contains("ScenarioName") && dict["ScenarioName"] != nil {
            self.scenarioName = dict["ScenarioName"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateScenarioResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateScenarioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateScenarioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateScenarioResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskConfigRequest : Tea.TeaModel {
    public var nodeConfig: String?

    public var nodeId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeConfig != nil {
            map["NodeConfig"] = self.nodeConfig!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeConfig") && dict["NodeConfig"] != nil {
            self.nodeConfig = dict["NodeConfig"] as! String
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskConfigResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTaskConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskContentRequest : Tea.TeaModel {
    public var nodeContent: String?

    public var nodeId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeContent != nil {
            map["NodeContent"] = self.nodeContent!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeContent") && dict["NodeContent"] != nil {
            self.nodeContent = dict["NodeContent"] as! String
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskContentResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTaskContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskFlowConstantsRequest : Tea.TeaModel {
    public class DagConstants : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var dagConstants: [UpdateTaskFlowConstantsRequest.DagConstants]?

    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagConstants != nil {
            var tmp : [Any] = []
            for k in self.dagConstants! {
                tmp.append(k.toMap())
            }
            map["DagConstants"] = tmp
        }
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagConstants") && dict["DagConstants"] != nil {
            var tmp : [UpdateTaskFlowConstantsRequest.DagConstants] = []
            for v in dict["DagConstants"] as! [Any] {
                var model = UpdateTaskFlowConstantsRequest.DagConstants()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dagConstants = tmp
        }
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowConstantsShrinkRequest : Tea.TeaModel {
    public var dagConstantsShrink: String?

    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagConstantsShrink != nil {
            map["DagConstants"] = self.dagConstantsShrink!
        }
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagConstants") && dict["DagConstants"] != nil {
            self.dagConstantsShrink = dict["DagConstants"] as! String
        }
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowConstantsResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskFlowConstantsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskFlowConstantsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTaskFlowConstantsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskFlowCooperatorsRequest : Tea.TeaModel {
    public var cooperatorIds: [String]?

    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cooperatorIds != nil {
            map["CooperatorIds"] = self.cooperatorIds!
        }
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CooperatorIds") && dict["CooperatorIds"] != nil {
            self.cooperatorIds = dict["CooperatorIds"] as! [String]
        }
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowCooperatorsShrinkRequest : Tea.TeaModel {
    public var cooperatorIdsShrink: String?

    public var dagId: Int64?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cooperatorIdsShrink != nil {
            map["CooperatorIds"] = self.cooperatorIdsShrink!
        }
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CooperatorIds") && dict["CooperatorIds"] != nil {
            self.cooperatorIdsShrink = dict["CooperatorIds"] as! String
        }
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowCooperatorsResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskFlowCooperatorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskFlowCooperatorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTaskFlowCooperatorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskFlowEdgesRequest : Tea.TeaModel {
    public class Edges : Tea.TeaModel {
        public var id: Int64?

        public var nodeEnd: Int64?

        public var nodeFrom: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.nodeEnd != nil {
                map["NodeEnd"] = self.nodeEnd!
            }
            if self.nodeFrom != nil {
                map["NodeFrom"] = self.nodeFrom!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("NodeEnd") && dict["NodeEnd"] != nil {
                self.nodeEnd = dict["NodeEnd"] as! Int64
            }
            if dict.keys.contains("NodeFrom") && dict["NodeFrom"] != nil {
                self.nodeFrom = dict["NodeFrom"] as! Int64
            }
        }
    }
    public var dagId: Int64?

    public var edges: [UpdateTaskFlowEdgesRequest.Edges]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.edges != nil {
            var tmp : [Any] = []
            for k in self.edges! {
                tmp.append(k.toMap())
            }
            map["Edges"] = tmp
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Edges") && dict["Edges"] != nil {
            var tmp : [UpdateTaskFlowEdgesRequest.Edges] = []
            for v in dict["Edges"] as! [Any] {
                var model = UpdateTaskFlowEdgesRequest.Edges()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.edges = tmp
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowEdgesShrinkRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var edgesShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.edgesShrink != nil {
            map["Edges"] = self.edgesShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Edges") && dict["Edges"] != nil {
            self.edgesShrink = dict["Edges"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowEdgesResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskFlowEdgesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskFlowEdgesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTaskFlowEdgesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskFlowNameAndDescRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var dagName: String?

    public var description_: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.dagName != nil {
            map["DagName"] = self.dagName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("DagName") && dict["DagName"] != nil {
            self.dagName = dict["DagName"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowNameAndDescResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskFlowNameAndDescResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskFlowNameAndDescResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTaskFlowNameAndDescResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskFlowNotificationRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var dagNotificationFail: Bool?

    public var dagNotificationSla: Bool?

    public var dagNotificationSuccess: Bool?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.dagNotificationFail != nil {
            map["DagNotificationFail"] = self.dagNotificationFail!
        }
        if self.dagNotificationSla != nil {
            map["DagNotificationSla"] = self.dagNotificationSla!
        }
        if self.dagNotificationSuccess != nil {
            map["DagNotificationSuccess"] = self.dagNotificationSuccess!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("DagNotificationFail") && dict["DagNotificationFail"] != nil {
            self.dagNotificationFail = dict["DagNotificationFail"] as! Bool
        }
        if dict.keys.contains("DagNotificationSla") && dict["DagNotificationSla"] != nil {
            self.dagNotificationSla = dict["DagNotificationSla"] as! Bool
        }
        if dict.keys.contains("DagNotificationSuccess") && dict["DagNotificationSuccess"] != nil {
            self.dagNotificationSuccess = dict["DagNotificationSuccess"] as! Bool
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowNotificationResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskFlowNotificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskFlowNotificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTaskFlowNotificationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskFlowOwnerRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var newOwnerId: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.newOwnerId != nil {
            map["NewOwnerId"] = self.newOwnerId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("NewOwnerId") && dict["NewOwnerId"] != nil {
            self.newOwnerId = dict["NewOwnerId"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowOwnerResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskFlowOwnerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskFlowOwnerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTaskFlowOwnerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskFlowRelationsRequest : Tea.TeaModel {
    public class Edges : Tea.TeaModel {
        public var id: Int64?

        public var nodeEnd: Int64?

        public var nodeFrom: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.nodeEnd != nil {
                map["NodeEnd"] = self.nodeEnd!
            }
            if self.nodeFrom != nil {
                map["NodeFrom"] = self.nodeFrom!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("NodeEnd") && dict["NodeEnd"] != nil {
                self.nodeEnd = dict["NodeEnd"] as! Int64
            }
            if dict.keys.contains("NodeFrom") && dict["NodeFrom"] != nil {
                self.nodeFrom = dict["NodeFrom"] as! Int64
            }
        }
    }
    public var dagId: Int64?

    public var edges: [UpdateTaskFlowRelationsRequest.Edges]?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.edges != nil {
            var tmp : [Any] = []
            for k in self.edges! {
                tmp.append(k.toMap())
            }
            map["Edges"] = tmp
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Edges") && dict["Edges"] != nil {
            var tmp : [UpdateTaskFlowRelationsRequest.Edges] = []
            for v in dict["Edges"] as! [Any] {
                var model = UpdateTaskFlowRelationsRequest.Edges()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.edges = tmp
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowRelationsShrinkRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var edgesShrink: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.edgesShrink != nil {
            map["Edges"] = self.edgesShrink!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Edges") && dict["Edges"] != nil {
            self.edgesShrink = dict["Edges"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskFlowRelationsResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskFlowRelationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskFlowRelationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTaskFlowRelationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskFlowScheduleRequest : Tea.TeaModel {
    public var cronBeginDate: String?

    public var cronEndDate: String?

    public var cronStr: String?

    public var cronType: String?

    public var dagId: Int64?

    public var scheduleParam: String?

    public var scheduleSwitch: Bool?

    public var tid: Int64?

    public var timeZoneId: String?

    public var triggerType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cronBeginDate != nil {
            map["CronBeginDate"] = self.cronBeginDate!
        }
        if self.cronEndDate != nil {
            map["CronEndDate"] = self.cronEndDate!
        }
        if self.cronStr != nil {
            map["CronStr"] = self.cronStr!
        }
        if self.cronType != nil {
            map["CronType"] = self.cronType!
        }
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.scheduleParam != nil {
            map["ScheduleParam"] = self.scheduleParam!
        }
        if self.scheduleSwitch != nil {
            map["ScheduleSwitch"] = self.scheduleSwitch!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.timeZoneId != nil {
            map["TimeZoneId"] = self.timeZoneId!
        }
        if self.triggerType != nil {
            map["TriggerType"] = self.triggerType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CronBeginDate") && dict["CronBeginDate"] != nil {
            self.cronBeginDate = dict["CronBeginDate"] as! String
        }
        if dict.keys.contains("CronEndDate") && dict["CronEndDate"] != nil {
            self.cronEndDate = dict["CronEndDate"] as! String
        }
        if dict.keys.contains("CronStr") && dict["CronStr"] != nil {
            self.cronStr = dict["CronStr"] as! String
        }
        if dict.keys.contains("CronType") && dict["CronType"] != nil {
            self.cronType = dict["CronType"] as! String
        }
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("ScheduleParam") && dict["ScheduleParam"] != nil {
            self.scheduleParam = dict["ScheduleParam"] as! String
        }
        if dict.keys.contains("ScheduleSwitch") && dict["ScheduleSwitch"] != nil {
            self.scheduleSwitch = dict["ScheduleSwitch"] as! Bool
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("TimeZoneId") && dict["TimeZoneId"] != nil {
            self.timeZoneId = dict["TimeZoneId"] as! String
        }
        if dict.keys.contains("TriggerType") && dict["TriggerType"] != nil {
            self.triggerType = dict["TriggerType"] as! String
        }
    }
}

public class UpdateTaskFlowScheduleResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskFlowScheduleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskFlowScheduleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTaskFlowScheduleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskFlowTimeVariablesRequest : Tea.TeaModel {
    public var dagId: Int64?

    public var tid: Int64?

    public var timeVariables: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dagId != nil {
            map["DagId"] = self.dagId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.timeVariables != nil {
            map["TimeVariables"] = self.timeVariables!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DagId") && dict["DagId"] != nil {
            self.dagId = dict["DagId"] as! Int64
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("TimeVariables") && dict["TimeVariables"] != nil {
            self.timeVariables = dict["TimeVariables"] as! String
        }
    }
}

public class UpdateTaskFlowTimeVariablesResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskFlowTimeVariablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskFlowTimeVariablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTaskFlowTimeVariablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskNameRequest : Tea.TeaModel {
    public var nodeId: String?

    public var nodeName: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
            self.nodeName = dict["NodeName"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskNameResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTaskNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskOutputRequest : Tea.TeaModel {
    public var nodeId: String?

    public var nodeOutput: String?

    public var tid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeOutput != nil {
            map["NodeOutput"] = self.nodeOutput!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("NodeOutput") && dict["NodeOutput"] != nil {
            self.nodeOutput = dict["NodeOutput"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
    }
}

public class UpdateTaskOutputResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTaskOutputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskTimeVariablesRequest : Tea.TeaModel {
    public var nodeId: String?

    public var tid: Int64?

    public var timeVariables: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.timeVariables != nil {
            map["TimeVariables"] = self.timeVariables!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("TimeVariables") && dict["TimeVariables"] != nil {
            self.timeVariables = dict["TimeVariables"] as! String
        }
    }
}

public class UpdateTaskTimeVariablesResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTaskTimeVariablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskTimeVariablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTaskTimeVariablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateUserRequest : Tea.TeaModel {
    public var maxExecuteCount: Int64?

    public var maxResultCount: Int64?

    public var mobile: String?

    public var roleNames: String?

    public var tid: Int64?

    public var uid: Int64?

    public var userNick: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxExecuteCount != nil {
            map["MaxExecuteCount"] = self.maxExecuteCount!
        }
        if self.maxResultCount != nil {
            map["MaxResultCount"] = self.maxResultCount!
        }
        if self.mobile != nil {
            map["Mobile"] = self.mobile!
        }
        if self.roleNames != nil {
            map["RoleNames"] = self.roleNames!
        }
        if self.tid != nil {
            map["Tid"] = self.tid!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        if self.userNick != nil {
            map["UserNick"] = self.userNick!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxExecuteCount") && dict["MaxExecuteCount"] != nil {
            self.maxExecuteCount = dict["MaxExecuteCount"] as! Int64
        }
        if dict.keys.contains("MaxResultCount") && dict["MaxResultCount"] != nil {
            self.maxResultCount = dict["MaxResultCount"] as! Int64
        }
        if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
            self.mobile = dict["Mobile"] as! String
        }
        if dict.keys.contains("RoleNames") && dict["RoleNames"] != nil {
            self.roleNames = dict["RoleNames"] as! String
        }
        if dict.keys.contains("Tid") && dict["Tid"] != nil {
            self.tid = dict["Tid"] as! Int64
        }
        if dict.keys.contains("Uid") && dict["Uid"] != nil {
            self.uid = dict["Uid"] as! Int64
        }
        if dict.keys.contains("UserNick") && dict["UserNick"] != nil {
            self.userNick = dict["UserNick"] as! String
        }
    }
}

public class UpdateUserResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
