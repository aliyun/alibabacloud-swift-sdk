import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class CreateApiDestinationRequest : Tea.TeaModel {
    public class HttpApiParameters : Tea.TeaModel {
        public var endpoint: String?

        public var method: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.method != nil {
                map["Method"] = self.method!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("Method") {
                self.method = dict["Method"] as! String
            }
        }
    }
    public var apiDestinationName: String?

    public var connectionName: String?

    public var description_: String?

    public var httpApiParameters: CreateApiDestinationRequest.HttpApiParameters?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.httpApiParameters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiDestinationName != nil {
            map["ApiDestinationName"] = self.apiDestinationName!
        }
        if self.connectionName != nil {
            map["ConnectionName"] = self.connectionName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.httpApiParameters != nil {
            map["HttpApiParameters"] = self.httpApiParameters?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiDestinationName") {
            self.apiDestinationName = dict["ApiDestinationName"] as! String
        }
        if dict.keys.contains("ConnectionName") {
            self.connectionName = dict["ConnectionName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("HttpApiParameters") {
            var model = CreateApiDestinationRequest.HttpApiParameters()
            model.fromMap(dict["HttpApiParameters"] as! [String: Any])
            self.httpApiParameters = model
        }
    }
}

public class CreateApiDestinationShrinkRequest : Tea.TeaModel {
    public var apiDestinationName: String?

    public var connectionName: String?

    public var description_: String?

    public var httpApiParametersShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiDestinationName != nil {
            map["ApiDestinationName"] = self.apiDestinationName!
        }
        if self.connectionName != nil {
            map["ConnectionName"] = self.connectionName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.httpApiParametersShrink != nil {
            map["HttpApiParameters"] = self.httpApiParametersShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiDestinationName") {
            self.apiDestinationName = dict["ApiDestinationName"] as! String
        }
        if dict.keys.contains("ConnectionName") {
            self.connectionName = dict["ConnectionName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("HttpApiParameters") {
            self.httpApiParametersShrink = dict["HttpApiParameters"] as! String
        }
    }
}

public class CreateApiDestinationResponseBody : Tea.TeaModel {
    public class Date : Tea.TeaModel {
        public var apiDestinationName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiDestinationName != nil {
                map["ApiDestinationName"] = self.apiDestinationName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiDestinationName") {
                self.apiDestinationName = dict["ApiDestinationName"] as! String
            }
        }
    }
    public var code: String?

    public var date: CreateApiDestinationResponseBody.Date?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.date?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.date != nil {
            map["Date"] = self.date?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Date") {
            var model = CreateApiDestinationResponseBody.Date()
            model.fromMap(dict["Date"] as! [String: Any])
            self.date = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateApiDestinationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApiDestinationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateApiDestinationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateConnectionRequest : Tea.TeaModel {
    public class AuthParameters : Tea.TeaModel {
        public class ApiKeyAuthParameters : Tea.TeaModel {
            public var apiKeyName: String?

            public var apiKeyValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiKeyName != nil {
                    map["ApiKeyName"] = self.apiKeyName!
                }
                if self.apiKeyValue != nil {
                    map["ApiKeyValue"] = self.apiKeyValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiKeyName") {
                    self.apiKeyName = dict["ApiKeyName"] as! String
                }
                if dict.keys.contains("ApiKeyValue") {
                    self.apiKeyValue = dict["ApiKeyValue"] as! String
                }
            }
        }
        public class BasicAuthParameters : Tea.TeaModel {
            public var password: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Password") {
                    self.password = dict["Password"] as! String
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
            }
        }
        public class OAuthParameters : Tea.TeaModel {
            public class ClientParameters : Tea.TeaModel {
                public var clientID: String?

                public var clientSecret: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clientID != nil {
                        map["ClientID"] = self.clientID!
                    }
                    if self.clientSecret != nil {
                        map["ClientSecret"] = self.clientSecret!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClientID") {
                        self.clientID = dict["ClientID"] as! String
                    }
                    if dict.keys.contains("ClientSecret") {
                        self.clientSecret = dict["ClientSecret"] as! String
                    }
                }
            }
            public class OAuthHttpParameters : Tea.TeaModel {
                public class BodyParameters : Tea.TeaModel {
                    public var isValueSecret: String?

                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.isValueSecret != nil {
                            map["IsValueSecret"] = self.isValueSecret!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IsValueSecret") {
                            self.isValueSecret = dict["IsValueSecret"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class HeaderParameters : Tea.TeaModel {
                    public var isValueSecret: String?

                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.isValueSecret != nil {
                            map["IsValueSecret"] = self.isValueSecret!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IsValueSecret") {
                            self.isValueSecret = dict["IsValueSecret"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class QueryStringParameters : Tea.TeaModel {
                    public var isValueSecret: String?

                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.isValueSecret != nil {
                            map["IsValueSecret"] = self.isValueSecret!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IsValueSecret") {
                            self.isValueSecret = dict["IsValueSecret"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var bodyParameters: [CreateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters.BodyParameters]?

                public var headerParameters: [CreateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters.HeaderParameters]?

                public var queryStringParameters: [CreateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters.QueryStringParameters]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bodyParameters != nil {
                        var tmp : [Any] = []
                        for k in self.bodyParameters! {
                            tmp.append(k.toMap())
                        }
                        map["BodyParameters"] = tmp
                    }
                    if self.headerParameters != nil {
                        var tmp : [Any] = []
                        for k in self.headerParameters! {
                            tmp.append(k.toMap())
                        }
                        map["HeaderParameters"] = tmp
                    }
                    if self.queryStringParameters != nil {
                        var tmp : [Any] = []
                        for k in self.queryStringParameters! {
                            tmp.append(k.toMap())
                        }
                        map["QueryStringParameters"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BodyParameters") {
                        var tmp : [CreateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters.BodyParameters] = []
                        for v in dict["BodyParameters"] as! [Any] {
                            var model = CreateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters.BodyParameters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.bodyParameters = tmp
                    }
                    if dict.keys.contains("HeaderParameters") {
                        var tmp : [CreateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters.HeaderParameters] = []
                        for v in dict["HeaderParameters"] as! [Any] {
                            var model = CreateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters.HeaderParameters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.headerParameters = tmp
                    }
                    if dict.keys.contains("QueryStringParameters") {
                        var tmp : [CreateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters.QueryStringParameters] = []
                        for v in dict["QueryStringParameters"] as! [Any] {
                            var model = CreateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters.QueryStringParameters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.queryStringParameters = tmp
                    }
                }
            }
            public var authorizationEndpoint: String?

            public var clientParameters: CreateConnectionRequest.AuthParameters.OAuthParameters.ClientParameters?

            public var httpMethod: String?

            public var OAuthHttpParameters: CreateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.clientParameters?.validate()
                try self.OAuthHttpParameters?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorizationEndpoint != nil {
                    map["AuthorizationEndpoint"] = self.authorizationEndpoint!
                }
                if self.clientParameters != nil {
                    map["ClientParameters"] = self.clientParameters?.toMap()
                }
                if self.httpMethod != nil {
                    map["HttpMethod"] = self.httpMethod!
                }
                if self.OAuthHttpParameters != nil {
                    map["OAuthHttpParameters"] = self.OAuthHttpParameters?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuthorizationEndpoint") {
                    self.authorizationEndpoint = dict["AuthorizationEndpoint"] as! String
                }
                if dict.keys.contains("ClientParameters") {
                    var model = CreateConnectionRequest.AuthParameters.OAuthParameters.ClientParameters()
                    model.fromMap(dict["ClientParameters"] as! [String: Any])
                    self.clientParameters = model
                }
                if dict.keys.contains("HttpMethod") {
                    self.httpMethod = dict["HttpMethod"] as! String
                }
                if dict.keys.contains("OAuthHttpParameters") {
                    var model = CreateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters()
                    model.fromMap(dict["OAuthHttpParameters"] as! [String: Any])
                    self.OAuthHttpParameters = model
                }
            }
        }
        public var apiKeyAuthParameters: CreateConnectionRequest.AuthParameters.ApiKeyAuthParameters?

        public var authorizationType: String?

        public var basicAuthParameters: CreateConnectionRequest.AuthParameters.BasicAuthParameters?

        public var OAuthParameters: CreateConnectionRequest.AuthParameters.OAuthParameters?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.apiKeyAuthParameters?.validate()
            try self.basicAuthParameters?.validate()
            try self.OAuthParameters?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiKeyAuthParameters != nil {
                map["ApiKeyAuthParameters"] = self.apiKeyAuthParameters?.toMap()
            }
            if self.authorizationType != nil {
                map["AuthorizationType"] = self.authorizationType!
            }
            if self.basicAuthParameters != nil {
                map["BasicAuthParameters"] = self.basicAuthParameters?.toMap()
            }
            if self.OAuthParameters != nil {
                map["OAuthParameters"] = self.OAuthParameters?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiKeyAuthParameters") {
                var model = CreateConnectionRequest.AuthParameters.ApiKeyAuthParameters()
                model.fromMap(dict["ApiKeyAuthParameters"] as! [String: Any])
                self.apiKeyAuthParameters = model
            }
            if dict.keys.contains("AuthorizationType") {
                self.authorizationType = dict["AuthorizationType"] as! String
            }
            if dict.keys.contains("BasicAuthParameters") {
                var model = CreateConnectionRequest.AuthParameters.BasicAuthParameters()
                model.fromMap(dict["BasicAuthParameters"] as! [String: Any])
                self.basicAuthParameters = model
            }
            if dict.keys.contains("OAuthParameters") {
                var model = CreateConnectionRequest.AuthParameters.OAuthParameters()
                model.fromMap(dict["OAuthParameters"] as! [String: Any])
                self.OAuthParameters = model
            }
        }
    }
    public class NetworkParameters : Tea.TeaModel {
        public var networkType: String?

        public var securityGroupId: String?

        public var vpcId: String?

        public var vswitcheId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkType != nil {
                map["NetworkType"] = self.networkType!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.vswitcheId != nil {
                map["VswitcheId"] = self.vswitcheId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetworkType") {
                self.networkType = dict["NetworkType"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
            if dict.keys.contains("VswitcheId") {
                self.vswitcheId = dict["VswitcheId"] as! String
            }
        }
    }
    public var authParameters: CreateConnectionRequest.AuthParameters?

    public var connectionName: String?

    public var description_: String?

    public var networkParameters: CreateConnectionRequest.NetworkParameters?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authParameters?.validate()
        try self.networkParameters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authParameters != nil {
            map["AuthParameters"] = self.authParameters?.toMap()
        }
        if self.connectionName != nil {
            map["ConnectionName"] = self.connectionName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.networkParameters != nil {
            map["NetworkParameters"] = self.networkParameters?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthParameters") {
            var model = CreateConnectionRequest.AuthParameters()
            model.fromMap(dict["AuthParameters"] as! [String: Any])
            self.authParameters = model
        }
        if dict.keys.contains("ConnectionName") {
            self.connectionName = dict["ConnectionName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("NetworkParameters") {
            var model = CreateConnectionRequest.NetworkParameters()
            model.fromMap(dict["NetworkParameters"] as! [String: Any])
            self.networkParameters = model
        }
    }
}

public class CreateConnectionShrinkRequest : Tea.TeaModel {
    public var authParametersShrink: String?

    public var connectionName: String?

    public var description_: String?

    public var networkParametersShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authParametersShrink != nil {
            map["AuthParameters"] = self.authParametersShrink!
        }
        if self.connectionName != nil {
            map["ConnectionName"] = self.connectionName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.networkParametersShrink != nil {
            map["NetworkParameters"] = self.networkParametersShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthParameters") {
            self.authParametersShrink = dict["AuthParameters"] as! String
        }
        if dict.keys.contains("ConnectionName") {
            self.connectionName = dict["ConnectionName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("NetworkParameters") {
            self.networkParametersShrink = dict["NetworkParameters"] as! String
        }
    }
}

public class CreateConnectionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var connectionName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectionName != nil {
                map["ConnectionName"] = self.connectionName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConnectionName") {
                self.connectionName = dict["ConnectionName"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateConnectionResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateConnectionResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEventBusRequest : Tea.TeaModel {
    public var description_: String?

    public var eventBusName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
    }
}

public class CreateEventBusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var eventBusARN: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventBusARN != nil {
                map["EventBusARN"] = self.eventBusARN!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventBusARN") {
                self.eventBusARN = dict["EventBusARN"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateEventBusResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateEventBusResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateEventBusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEventBusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEventBusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEventSourceRequest : Tea.TeaModel {
    public class SourceHttpEventParameters : Tea.TeaModel {
        public var ip: [String]?

        public var method: [String]?

        public var referer: [String]?

        public var securityConfig: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.method != nil {
                map["Method"] = self.method!
            }
            if self.referer != nil {
                map["Referer"] = self.referer!
            }
            if self.securityConfig != nil {
                map["SecurityConfig"] = self.securityConfig!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! [String]
            }
            if dict.keys.contains("Method") {
                self.method = dict["Method"] as! [String]
            }
            if dict.keys.contains("Referer") {
                self.referer = dict["Referer"] as! [String]
            }
            if dict.keys.contains("SecurityConfig") {
                self.securityConfig = dict["SecurityConfig"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class SourceKafkaParameters : Tea.TeaModel {
        public var consumerGroup: String?

        public var instanceId: String?

        public var maximumTasks: Int32?

        public var network: String?

        public var offsetReset: String?

        public var regionId: String?

        public var securityGroupId: String?

        public var topic: String?

        public var vSwitchIds: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consumerGroup != nil {
                map["ConsumerGroup"] = self.consumerGroup!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.maximumTasks != nil {
                map["MaximumTasks"] = self.maximumTasks!
            }
            if self.network != nil {
                map["Network"] = self.network!
            }
            if self.offsetReset != nil {
                map["OffsetReset"] = self.offsetReset!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.topic != nil {
                map["Topic"] = self.topic!
            }
            if self.vSwitchIds != nil {
                map["VSwitchIds"] = self.vSwitchIds!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsumerGroup") {
                self.consumerGroup = dict["ConsumerGroup"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("MaximumTasks") {
                self.maximumTasks = dict["MaximumTasks"] as! Int32
            }
            if dict.keys.contains("Network") {
                self.network = dict["Network"] as! String
            }
            if dict.keys.contains("OffsetReset") {
                self.offsetReset = dict["OffsetReset"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("Topic") {
                self.topic = dict["Topic"] as! String
            }
            if dict.keys.contains("VSwitchIds") {
                self.vSwitchIds = dict["VSwitchIds"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public class SourceMNSParameters : Tea.TeaModel {
        public var isBase64Decode: Bool?

        public var queueName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.isBase64Decode != nil {
                map["IsBase64Decode"] = self.isBase64Decode!
            }
            if self.queueName != nil {
                map["QueueName"] = self.queueName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IsBase64Decode") {
                self.isBase64Decode = dict["IsBase64Decode"] as! Bool
            }
            if dict.keys.contains("QueueName") {
                self.queueName = dict["QueueName"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public class SourceRabbitMQParameters : Tea.TeaModel {
        public var instanceId: String?

        public var queueName: String?

        public var regionId: String?

        public var virtualHostName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.queueName != nil {
                map["QueueName"] = self.queueName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.virtualHostName != nil {
                map["VirtualHostName"] = self.virtualHostName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("QueueName") {
                self.queueName = dict["QueueName"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("VirtualHostName") {
                self.virtualHostName = dict["VirtualHostName"] as! String
            }
        }
    }
    public class SourceRocketMQParameters : Tea.TeaModel {
        public var authType: String?

        public var groupID: String?

        public var instanceEndpoint: String?

        public var instanceId: String?

        public var instanceNetwork: String?

        public var instancePassword: String?

        public var instanceSecurityGroupId: String?

        public var instanceType: String?

        public var instanceUsername: String?

        public var instanceVSwitchIds: String?

        public var instanceVpcId: String?

        public var offset: String?

        public var regionId: String?

        public var tag: String?

        public var timestamp: Int64?

        public var topic: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authType != nil {
                map["AuthType"] = self.authType!
            }
            if self.groupID != nil {
                map["GroupID"] = self.groupID!
            }
            if self.instanceEndpoint != nil {
                map["InstanceEndpoint"] = self.instanceEndpoint!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceNetwork != nil {
                map["InstanceNetwork"] = self.instanceNetwork!
            }
            if self.instancePassword != nil {
                map["InstancePassword"] = self.instancePassword!
            }
            if self.instanceSecurityGroupId != nil {
                map["InstanceSecurityGroupId"] = self.instanceSecurityGroupId!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.instanceUsername != nil {
                map["InstanceUsername"] = self.instanceUsername!
            }
            if self.instanceVSwitchIds != nil {
                map["InstanceVSwitchIds"] = self.instanceVSwitchIds!
            }
            if self.instanceVpcId != nil {
                map["InstanceVpcId"] = self.instanceVpcId!
            }
            if self.offset != nil {
                map["Offset"] = self.offset!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.topic != nil {
                map["Topic"] = self.topic!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthType") {
                self.authType = dict["AuthType"] as! String
            }
            if dict.keys.contains("GroupID") {
                self.groupID = dict["GroupID"] as! String
            }
            if dict.keys.contains("InstanceEndpoint") {
                self.instanceEndpoint = dict["InstanceEndpoint"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceNetwork") {
                self.instanceNetwork = dict["InstanceNetwork"] as! String
            }
            if dict.keys.contains("InstancePassword") {
                self.instancePassword = dict["InstancePassword"] as! String
            }
            if dict.keys.contains("InstanceSecurityGroupId") {
                self.instanceSecurityGroupId = dict["InstanceSecurityGroupId"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("InstanceUsername") {
                self.instanceUsername = dict["InstanceUsername"] as! String
            }
            if dict.keys.contains("InstanceVSwitchIds") {
                self.instanceVSwitchIds = dict["InstanceVSwitchIds"] as! String
            }
            if dict.keys.contains("InstanceVpcId") {
                self.instanceVpcId = dict["InstanceVpcId"] as! String
            }
            if dict.keys.contains("Offset") {
                self.offset = dict["Offset"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Tag") {
                self.tag = dict["Tag"] as! String
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("Topic") {
                self.topic = dict["Topic"] as! String
            }
        }
    }
    public class SourceSLSParameters : Tea.TeaModel {
        public var consumePosition: String?

        public var logStore: String?

        public var project: String?

        public var roleName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consumePosition != nil {
                map["ConsumePosition"] = self.consumePosition!
            }
            if self.logStore != nil {
                map["LogStore"] = self.logStore!
            }
            if self.project != nil {
                map["Project"] = self.project!
            }
            if self.roleName != nil {
                map["RoleName"] = self.roleName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsumePosition") {
                self.consumePosition = dict["ConsumePosition"] as! String
            }
            if dict.keys.contains("LogStore") {
                self.logStore = dict["LogStore"] as! String
            }
            if dict.keys.contains("Project") {
                self.project = dict["Project"] as! String
            }
            if dict.keys.contains("RoleName") {
                self.roleName = dict["RoleName"] as! String
            }
        }
    }
    public class SourceScheduledEventParameters : Tea.TeaModel {
        public var schedule: String?

        public var timeZone: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.schedule != nil {
                map["Schedule"] = self.schedule!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Schedule") {
                self.schedule = dict["Schedule"] as! String
            }
            if dict.keys.contains("TimeZone") {
                self.timeZone = dict["TimeZone"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var description_: String?

    public var eventBusName: String?

    public var eventSourceName: String?

    public var sourceHttpEventParameters: CreateEventSourceRequest.SourceHttpEventParameters?

    public var sourceKafkaParameters: CreateEventSourceRequest.SourceKafkaParameters?

    public var sourceMNSParameters: CreateEventSourceRequest.SourceMNSParameters?

    public var sourceRabbitMQParameters: CreateEventSourceRequest.SourceRabbitMQParameters?

    public var sourceRocketMQParameters: CreateEventSourceRequest.SourceRocketMQParameters?

    public var sourceSLSParameters: CreateEventSourceRequest.SourceSLSParameters?

    public var sourceScheduledEventParameters: CreateEventSourceRequest.SourceScheduledEventParameters?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sourceHttpEventParameters?.validate()
        try self.sourceKafkaParameters?.validate()
        try self.sourceMNSParameters?.validate()
        try self.sourceRabbitMQParameters?.validate()
        try self.sourceRocketMQParameters?.validate()
        try self.sourceSLSParameters?.validate()
        try self.sourceScheduledEventParameters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.eventSourceName != nil {
            map["EventSourceName"] = self.eventSourceName!
        }
        if self.sourceHttpEventParameters != nil {
            map["SourceHttpEventParameters"] = self.sourceHttpEventParameters?.toMap()
        }
        if self.sourceKafkaParameters != nil {
            map["SourceKafkaParameters"] = self.sourceKafkaParameters?.toMap()
        }
        if self.sourceMNSParameters != nil {
            map["SourceMNSParameters"] = self.sourceMNSParameters?.toMap()
        }
        if self.sourceRabbitMQParameters != nil {
            map["SourceRabbitMQParameters"] = self.sourceRabbitMQParameters?.toMap()
        }
        if self.sourceRocketMQParameters != nil {
            map["SourceRocketMQParameters"] = self.sourceRocketMQParameters?.toMap()
        }
        if self.sourceSLSParameters != nil {
            map["SourceSLSParameters"] = self.sourceSLSParameters?.toMap()
        }
        if self.sourceScheduledEventParameters != nil {
            map["SourceScheduledEventParameters"] = self.sourceScheduledEventParameters?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("EventSourceName") {
            self.eventSourceName = dict["EventSourceName"] as! String
        }
        if dict.keys.contains("SourceHttpEventParameters") {
            var model = CreateEventSourceRequest.SourceHttpEventParameters()
            model.fromMap(dict["SourceHttpEventParameters"] as! [String: Any])
            self.sourceHttpEventParameters = model
        }
        if dict.keys.contains("SourceKafkaParameters") {
            var model = CreateEventSourceRequest.SourceKafkaParameters()
            model.fromMap(dict["SourceKafkaParameters"] as! [String: Any])
            self.sourceKafkaParameters = model
        }
        if dict.keys.contains("SourceMNSParameters") {
            var model = CreateEventSourceRequest.SourceMNSParameters()
            model.fromMap(dict["SourceMNSParameters"] as! [String: Any])
            self.sourceMNSParameters = model
        }
        if dict.keys.contains("SourceRabbitMQParameters") {
            var model = CreateEventSourceRequest.SourceRabbitMQParameters()
            model.fromMap(dict["SourceRabbitMQParameters"] as! [String: Any])
            self.sourceRabbitMQParameters = model
        }
        if dict.keys.contains("SourceRocketMQParameters") {
            var model = CreateEventSourceRequest.SourceRocketMQParameters()
            model.fromMap(dict["SourceRocketMQParameters"] as! [String: Any])
            self.sourceRocketMQParameters = model
        }
        if dict.keys.contains("SourceSLSParameters") {
            var model = CreateEventSourceRequest.SourceSLSParameters()
            model.fromMap(dict["SourceSLSParameters"] as! [String: Any])
            self.sourceSLSParameters = model
        }
        if dict.keys.contains("SourceScheduledEventParameters") {
            var model = CreateEventSourceRequest.SourceScheduledEventParameters()
            model.fromMap(dict["SourceScheduledEventParameters"] as! [String: Any])
            self.sourceScheduledEventParameters = model
        }
    }
}

public class CreateEventSourceShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var eventBusName: String?

    public var eventSourceName: String?

    public var sourceHttpEventParametersShrink: String?

    public var sourceKafkaParametersShrink: String?

    public var sourceMNSParametersShrink: String?

    public var sourceRabbitMQParametersShrink: String?

    public var sourceRocketMQParametersShrink: String?

    public var sourceSLSParametersShrink: String?

    public var sourceScheduledEventParametersShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.eventSourceName != nil {
            map["EventSourceName"] = self.eventSourceName!
        }
        if self.sourceHttpEventParametersShrink != nil {
            map["SourceHttpEventParameters"] = self.sourceHttpEventParametersShrink!
        }
        if self.sourceKafkaParametersShrink != nil {
            map["SourceKafkaParameters"] = self.sourceKafkaParametersShrink!
        }
        if self.sourceMNSParametersShrink != nil {
            map["SourceMNSParameters"] = self.sourceMNSParametersShrink!
        }
        if self.sourceRabbitMQParametersShrink != nil {
            map["SourceRabbitMQParameters"] = self.sourceRabbitMQParametersShrink!
        }
        if self.sourceRocketMQParametersShrink != nil {
            map["SourceRocketMQParameters"] = self.sourceRocketMQParametersShrink!
        }
        if self.sourceSLSParametersShrink != nil {
            map["SourceSLSParameters"] = self.sourceSLSParametersShrink!
        }
        if self.sourceScheduledEventParametersShrink != nil {
            map["SourceScheduledEventParameters"] = self.sourceScheduledEventParametersShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("EventSourceName") {
            self.eventSourceName = dict["EventSourceName"] as! String
        }
        if dict.keys.contains("SourceHttpEventParameters") {
            self.sourceHttpEventParametersShrink = dict["SourceHttpEventParameters"] as! String
        }
        if dict.keys.contains("SourceKafkaParameters") {
            self.sourceKafkaParametersShrink = dict["SourceKafkaParameters"] as! String
        }
        if dict.keys.contains("SourceMNSParameters") {
            self.sourceMNSParametersShrink = dict["SourceMNSParameters"] as! String
        }
        if dict.keys.contains("SourceRabbitMQParameters") {
            self.sourceRabbitMQParametersShrink = dict["SourceRabbitMQParameters"] as! String
        }
        if dict.keys.contains("SourceRocketMQParameters") {
            self.sourceRocketMQParametersShrink = dict["SourceRocketMQParameters"] as! String
        }
        if dict.keys.contains("SourceSLSParameters") {
            self.sourceSLSParametersShrink = dict["SourceSLSParameters"] as! String
        }
        if dict.keys.contains("SourceScheduledEventParameters") {
            self.sourceScheduledEventParametersShrink = dict["SourceScheduledEventParameters"] as! String
        }
    }
}

public class CreateEventSourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var eventSourceARN: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventSourceARN != nil {
                map["EventSourceARN"] = self.eventSourceARN!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventSourceARN") {
                self.eventSourceARN = dict["EventSourceARN"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateEventSourceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateEventSourceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateEventSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEventSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEventSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEventStreamingRequest : Tea.TeaModel {
    public class RunOptions : Tea.TeaModel {
        public class BatchWindow : Tea.TeaModel {
            public var countBasedWindow: Int32?

            public var timeBasedWindow: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.countBasedWindow != nil {
                    map["CountBasedWindow"] = self.countBasedWindow!
                }
                if self.timeBasedWindow != nil {
                    map["TimeBasedWindow"] = self.timeBasedWindow!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CountBasedWindow") {
                    self.countBasedWindow = dict["CountBasedWindow"] as! Int32
                }
                if dict.keys.contains("TimeBasedWindow") {
                    self.timeBasedWindow = dict["TimeBasedWindow"] as! Int32
                }
            }
        }
        public class DeadLetterQueue : Tea.TeaModel {
            public var arn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.arn != nil {
                    map["Arn"] = self.arn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Arn") {
                    self.arn = dict["Arn"] as! String
                }
            }
        }
        public class RetryStrategy : Tea.TeaModel {
            public var maximumEventAgeInSeconds: Int64?

            public var maximumRetryAttempts: Int64?

            public var pushRetryStrategy: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maximumEventAgeInSeconds != nil {
                    map["MaximumEventAgeInSeconds"] = self.maximumEventAgeInSeconds!
                }
                if self.maximumRetryAttempts != nil {
                    map["MaximumRetryAttempts"] = self.maximumRetryAttempts!
                }
                if self.pushRetryStrategy != nil {
                    map["PushRetryStrategy"] = self.pushRetryStrategy!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaximumEventAgeInSeconds") {
                    self.maximumEventAgeInSeconds = dict["MaximumEventAgeInSeconds"] as! Int64
                }
                if dict.keys.contains("MaximumRetryAttempts") {
                    self.maximumRetryAttempts = dict["MaximumRetryAttempts"] as! Int64
                }
                if dict.keys.contains("PushRetryStrategy") {
                    self.pushRetryStrategy = dict["PushRetryStrategy"] as! String
                }
            }
        }
        public var batchWindow: CreateEventStreamingRequest.RunOptions.BatchWindow?

        public var deadLetterQueue: CreateEventStreamingRequest.RunOptions.DeadLetterQueue?

        public var errorsTolerance: String?

        public var maximumTasks: Int64?

        public var retryStrategy: CreateEventStreamingRequest.RunOptions.RetryStrategy?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.batchWindow?.validate()
            try self.deadLetterQueue?.validate()
            try self.retryStrategy?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.batchWindow != nil {
                map["BatchWindow"] = self.batchWindow?.toMap()
            }
            if self.deadLetterQueue != nil {
                map["DeadLetterQueue"] = self.deadLetterQueue?.toMap()
            }
            if self.errorsTolerance != nil {
                map["ErrorsTolerance"] = self.errorsTolerance!
            }
            if self.maximumTasks != nil {
                map["MaximumTasks"] = self.maximumTasks!
            }
            if self.retryStrategy != nil {
                map["RetryStrategy"] = self.retryStrategy?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BatchWindow") {
                var model = CreateEventStreamingRequest.RunOptions.BatchWindow()
                model.fromMap(dict["BatchWindow"] as! [String: Any])
                self.batchWindow = model
            }
            if dict.keys.contains("DeadLetterQueue") {
                var model = CreateEventStreamingRequest.RunOptions.DeadLetterQueue()
                model.fromMap(dict["DeadLetterQueue"] as! [String: Any])
                self.deadLetterQueue = model
            }
            if dict.keys.contains("ErrorsTolerance") {
                self.errorsTolerance = dict["ErrorsTolerance"] as! String
            }
            if dict.keys.contains("MaximumTasks") {
                self.maximumTasks = dict["MaximumTasks"] as! Int64
            }
            if dict.keys.contains("RetryStrategy") {
                var model = CreateEventStreamingRequest.RunOptions.RetryStrategy()
                model.fromMap(dict["RetryStrategy"] as! [String: Any])
                self.retryStrategy = model
            }
        }
    }
    public class Sink : Tea.TeaModel {
        public class SinkDataHubParameters : Tea.TeaModel {
            public class Body : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Project : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class RoleName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Topic : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class TopicSchema : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class TopicType : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var body: CreateEventStreamingRequest.Sink.SinkDataHubParameters.Body?

            public var project: CreateEventStreamingRequest.Sink.SinkDataHubParameters.Project?

            public var roleName: CreateEventStreamingRequest.Sink.SinkDataHubParameters.RoleName?

            public var topic: CreateEventStreamingRequest.Sink.SinkDataHubParameters.Topic?

            public var topicSchema: CreateEventStreamingRequest.Sink.SinkDataHubParameters.TopicSchema?

            public var topicType: CreateEventStreamingRequest.Sink.SinkDataHubParameters.TopicType?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.body?.validate()
                try self.project?.validate()
                try self.roleName?.validate()
                try self.topic?.validate()
                try self.topicSchema?.validate()
                try self.topicType?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body?.toMap()
                }
                if self.project != nil {
                    map["Project"] = self.project?.toMap()
                }
                if self.roleName != nil {
                    map["RoleName"] = self.roleName?.toMap()
                }
                if self.topic != nil {
                    map["Topic"] = self.topic?.toMap()
                }
                if self.topicSchema != nil {
                    map["TopicSchema"] = self.topicSchema?.toMap()
                }
                if self.topicType != nil {
                    map["TopicType"] = self.topicType?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") {
                    var model = CreateEventStreamingRequest.Sink.SinkDataHubParameters.Body()
                    model.fromMap(dict["Body"] as! [String: Any])
                    self.body = model
                }
                if dict.keys.contains("Project") {
                    var model = CreateEventStreamingRequest.Sink.SinkDataHubParameters.Project()
                    model.fromMap(dict["Project"] as! [String: Any])
                    self.project = model
                }
                if dict.keys.contains("RoleName") {
                    var model = CreateEventStreamingRequest.Sink.SinkDataHubParameters.RoleName()
                    model.fromMap(dict["RoleName"] as! [String: Any])
                    self.roleName = model
                }
                if dict.keys.contains("Topic") {
                    var model = CreateEventStreamingRequest.Sink.SinkDataHubParameters.Topic()
                    model.fromMap(dict["Topic"] as! [String: Any])
                    self.topic = model
                }
                if dict.keys.contains("TopicSchema") {
                    var model = CreateEventStreamingRequest.Sink.SinkDataHubParameters.TopicSchema()
                    model.fromMap(dict["TopicSchema"] as! [String: Any])
                    self.topicSchema = model
                }
                if dict.keys.contains("TopicType") {
                    var model = CreateEventStreamingRequest.Sink.SinkDataHubParameters.TopicType()
                    model.fromMap(dict["TopicType"] as! [String: Any])
                    self.topicType = model
                }
            }
        }
        public class SinkFcParameters : Tea.TeaModel {
            public class Body : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Concurrency : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class FunctionName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class InvocationType : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Qualifier : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class ServiceName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var body: CreateEventStreamingRequest.Sink.SinkFcParameters.Body?

            public var concurrency: CreateEventStreamingRequest.Sink.SinkFcParameters.Concurrency?

            public var functionName: CreateEventStreamingRequest.Sink.SinkFcParameters.FunctionName?

            public var invocationType: CreateEventStreamingRequest.Sink.SinkFcParameters.InvocationType?

            public var qualifier: CreateEventStreamingRequest.Sink.SinkFcParameters.Qualifier?

            public var serviceName: CreateEventStreamingRequest.Sink.SinkFcParameters.ServiceName?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.body?.validate()
                try self.concurrency?.validate()
                try self.functionName?.validate()
                try self.invocationType?.validate()
                try self.qualifier?.validate()
                try self.serviceName?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body?.toMap()
                }
                if self.concurrency != nil {
                    map["Concurrency"] = self.concurrency?.toMap()
                }
                if self.functionName != nil {
                    map["FunctionName"] = self.functionName?.toMap()
                }
                if self.invocationType != nil {
                    map["InvocationType"] = self.invocationType?.toMap()
                }
                if self.qualifier != nil {
                    map["Qualifier"] = self.qualifier?.toMap()
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") {
                    var model = CreateEventStreamingRequest.Sink.SinkFcParameters.Body()
                    model.fromMap(dict["Body"] as! [String: Any])
                    self.body = model
                }
                if dict.keys.contains("Concurrency") {
                    var model = CreateEventStreamingRequest.Sink.SinkFcParameters.Concurrency()
                    model.fromMap(dict["Concurrency"] as! [String: Any])
                    self.concurrency = model
                }
                if dict.keys.contains("FunctionName") {
                    var model = CreateEventStreamingRequest.Sink.SinkFcParameters.FunctionName()
                    model.fromMap(dict["FunctionName"] as! [String: Any])
                    self.functionName = model
                }
                if dict.keys.contains("InvocationType") {
                    var model = CreateEventStreamingRequest.Sink.SinkFcParameters.InvocationType()
                    model.fromMap(dict["InvocationType"] as! [String: Any])
                    self.invocationType = model
                }
                if dict.keys.contains("Qualifier") {
                    var model = CreateEventStreamingRequest.Sink.SinkFcParameters.Qualifier()
                    model.fromMap(dict["Qualifier"] as! [String: Any])
                    self.qualifier = model
                }
                if dict.keys.contains("ServiceName") {
                    var model = CreateEventStreamingRequest.Sink.SinkFcParameters.ServiceName()
                    model.fromMap(dict["ServiceName"] as! [String: Any])
                    self.serviceName = model
                }
            }
        }
        public class SinkFnfParameters : Tea.TeaModel {
            public class ExecutionName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class FlowName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Input : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class RoleName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var executionName: CreateEventStreamingRequest.Sink.SinkFnfParameters.ExecutionName?

            public var flowName: CreateEventStreamingRequest.Sink.SinkFnfParameters.FlowName?

            public var input: CreateEventStreamingRequest.Sink.SinkFnfParameters.Input?

            public var roleName: CreateEventStreamingRequest.Sink.SinkFnfParameters.RoleName?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.executionName?.validate()
                try self.flowName?.validate()
                try self.input?.validate()
                try self.roleName?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.executionName != nil {
                    map["ExecutionName"] = self.executionName?.toMap()
                }
                if self.flowName != nil {
                    map["FlowName"] = self.flowName?.toMap()
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.roleName != nil {
                    map["RoleName"] = self.roleName?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ExecutionName") {
                    var model = CreateEventStreamingRequest.Sink.SinkFnfParameters.ExecutionName()
                    model.fromMap(dict["ExecutionName"] as! [String: Any])
                    self.executionName = model
                }
                if dict.keys.contains("FlowName") {
                    var model = CreateEventStreamingRequest.Sink.SinkFnfParameters.FlowName()
                    model.fromMap(dict["FlowName"] as! [String: Any])
                    self.flowName = model
                }
                if dict.keys.contains("Input") {
                    var model = CreateEventStreamingRequest.Sink.SinkFnfParameters.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("RoleName") {
                    var model = CreateEventStreamingRequest.Sink.SinkFnfParameters.RoleName()
                    model.fromMap(dict["RoleName"] as! [String: Any])
                    self.roleName = model
                }
            }
        }
        public class SinkKafkaParameters : Tea.TeaModel {
            public class Acks : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class InstanceId : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Key : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Topic : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Value : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var acks: CreateEventStreamingRequest.Sink.SinkKafkaParameters.Acks?

            public var instanceId: CreateEventStreamingRequest.Sink.SinkKafkaParameters.InstanceId?

            public var key: CreateEventStreamingRequest.Sink.SinkKafkaParameters.Key?

            public var topic: CreateEventStreamingRequest.Sink.SinkKafkaParameters.Topic?

            public var value: CreateEventStreamingRequest.Sink.SinkKafkaParameters.Value?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.acks?.validate()
                try self.instanceId?.validate()
                try self.key?.validate()
                try self.topic?.validate()
                try self.value?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.acks != nil {
                    map["Acks"] = self.acks?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId?.toMap()
                }
                if self.key != nil {
                    map["Key"] = self.key?.toMap()
                }
                if self.topic != nil {
                    map["Topic"] = self.topic?.toMap()
                }
                if self.value != nil {
                    map["Value"] = self.value?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Acks") {
                    var model = CreateEventStreamingRequest.Sink.SinkKafkaParameters.Acks()
                    model.fromMap(dict["Acks"] as! [String: Any])
                    self.acks = model
                }
                if dict.keys.contains("InstanceId") {
                    var model = CreateEventStreamingRequest.Sink.SinkKafkaParameters.InstanceId()
                    model.fromMap(dict["InstanceId"] as! [String: Any])
                    self.instanceId = model
                }
                if dict.keys.contains("Key") {
                    var model = CreateEventStreamingRequest.Sink.SinkKafkaParameters.Key()
                    model.fromMap(dict["Key"] as! [String: Any])
                    self.key = model
                }
                if dict.keys.contains("Topic") {
                    var model = CreateEventStreamingRequest.Sink.SinkKafkaParameters.Topic()
                    model.fromMap(dict["Topic"] as! [String: Any])
                    self.topic = model
                }
                if dict.keys.contains("Value") {
                    var model = CreateEventStreamingRequest.Sink.SinkKafkaParameters.Value()
                    model.fromMap(dict["Value"] as! [String: Any])
                    self.value = model
                }
            }
        }
        public class SinkMNSParameters : Tea.TeaModel {
            public class Body : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class IsBase64Encode : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class QueueName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var body: CreateEventStreamingRequest.Sink.SinkMNSParameters.Body?

            public var isBase64Encode: CreateEventStreamingRequest.Sink.SinkMNSParameters.IsBase64Encode?

            public var queueName: CreateEventStreamingRequest.Sink.SinkMNSParameters.QueueName?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.body?.validate()
                try self.isBase64Encode?.validate()
                try self.queueName?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body?.toMap()
                }
                if self.isBase64Encode != nil {
                    map["IsBase64Encode"] = self.isBase64Encode?.toMap()
                }
                if self.queueName != nil {
                    map["QueueName"] = self.queueName?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") {
                    var model = CreateEventStreamingRequest.Sink.SinkMNSParameters.Body()
                    model.fromMap(dict["Body"] as! [String: Any])
                    self.body = model
                }
                if dict.keys.contains("IsBase64Encode") {
                    var model = CreateEventStreamingRequest.Sink.SinkMNSParameters.IsBase64Encode()
                    model.fromMap(dict["IsBase64Encode"] as! [String: Any])
                    self.isBase64Encode = model
                }
                if dict.keys.contains("QueueName") {
                    var model = CreateEventStreamingRequest.Sink.SinkMNSParameters.QueueName()
                    model.fromMap(dict["QueueName"] as! [String: Any])
                    self.queueName = model
                }
            }
        }
        public class SinkPrometheusParameters : Tea.TeaModel {
            public class AuthorizationType : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Data : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class NetworkType : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Password : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class SecurityGroupId : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class URL : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Username : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class VSwitchId : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class VpcId : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var authorizationType: CreateEventStreamingRequest.Sink.SinkPrometheusParameters.AuthorizationType?

            public var data: CreateEventStreamingRequest.Sink.SinkPrometheusParameters.Data?

            public var networkType: CreateEventStreamingRequest.Sink.SinkPrometheusParameters.NetworkType?

            public var password: CreateEventStreamingRequest.Sink.SinkPrometheusParameters.Password?

            public var securityGroupId: CreateEventStreamingRequest.Sink.SinkPrometheusParameters.SecurityGroupId?

            public var URL: CreateEventStreamingRequest.Sink.SinkPrometheusParameters.URL?

            public var username: CreateEventStreamingRequest.Sink.SinkPrometheusParameters.Username?

            public var vSwitchId: CreateEventStreamingRequest.Sink.SinkPrometheusParameters.VSwitchId?

            public var vpcId: CreateEventStreamingRequest.Sink.SinkPrometheusParameters.VpcId?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.authorizationType?.validate()
                try self.data?.validate()
                try self.networkType?.validate()
                try self.password?.validate()
                try self.securityGroupId?.validate()
                try self.URL?.validate()
                try self.username?.validate()
                try self.vSwitchId?.validate()
                try self.vpcId?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorizationType != nil {
                    map["AuthorizationType"] = self.authorizationType?.toMap()
                }
                if self.data != nil {
                    map["Data"] = self.data?.toMap()
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType?.toMap()
                }
                if self.password != nil {
                    map["Password"] = self.password?.toMap()
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId?.toMap()
                }
                if self.URL != nil {
                    map["URL"] = self.URL?.toMap()
                }
                if self.username != nil {
                    map["Username"] = self.username?.toMap()
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuthorizationType") {
                    var model = CreateEventStreamingRequest.Sink.SinkPrometheusParameters.AuthorizationType()
                    model.fromMap(dict["AuthorizationType"] as! [String: Any])
                    self.authorizationType = model
                }
                if dict.keys.contains("Data") {
                    var model = CreateEventStreamingRequest.Sink.SinkPrometheusParameters.Data()
                    model.fromMap(dict["Data"] as! [String: Any])
                    self.data = model
                }
                if dict.keys.contains("NetworkType") {
                    var model = CreateEventStreamingRequest.Sink.SinkPrometheusParameters.NetworkType()
                    model.fromMap(dict["NetworkType"] as! [String: Any])
                    self.networkType = model
                }
                if dict.keys.contains("Password") {
                    var model = CreateEventStreamingRequest.Sink.SinkPrometheusParameters.Password()
                    model.fromMap(dict["Password"] as! [String: Any])
                    self.password = model
                }
                if dict.keys.contains("SecurityGroupId") {
                    var model = CreateEventStreamingRequest.Sink.SinkPrometheusParameters.SecurityGroupId()
                    model.fromMap(dict["SecurityGroupId"] as! [String: Any])
                    self.securityGroupId = model
                }
                if dict.keys.contains("URL") {
                    var model = CreateEventStreamingRequest.Sink.SinkPrometheusParameters.URL()
                    model.fromMap(dict["URL"] as! [String: Any])
                    self.URL = model
                }
                if dict.keys.contains("Username") {
                    var model = CreateEventStreamingRequest.Sink.SinkPrometheusParameters.Username()
                    model.fromMap(dict["Username"] as! [String: Any])
                    self.username = model
                }
                if dict.keys.contains("VSwitchId") {
                    var model = CreateEventStreamingRequest.Sink.SinkPrometheusParameters.VSwitchId()
                    model.fromMap(dict["VSwitchId"] as! [String: Any])
                    self.vSwitchId = model
                }
                if dict.keys.contains("VpcId") {
                    var model = CreateEventStreamingRequest.Sink.SinkPrometheusParameters.VpcId()
                    model.fromMap(dict["VpcId"] as! [String: Any])
                    self.vpcId = model
                }
            }
        }
        public class SinkRabbitMQParameters : Tea.TeaModel {
            public class Body : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Exchange : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class InstanceId : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class MessageId : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Properties : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class QueueName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class RoutingKey : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class TargetType : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class VirtualHostName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var body: CreateEventStreamingRequest.Sink.SinkRabbitMQParameters.Body?

            public var exchange: CreateEventStreamingRequest.Sink.SinkRabbitMQParameters.Exchange?

            public var instanceId: CreateEventStreamingRequest.Sink.SinkRabbitMQParameters.InstanceId?

            public var messageId: CreateEventStreamingRequest.Sink.SinkRabbitMQParameters.MessageId?

            public var properties: CreateEventStreamingRequest.Sink.SinkRabbitMQParameters.Properties?

            public var queueName: CreateEventStreamingRequest.Sink.SinkRabbitMQParameters.QueueName?

            public var routingKey: CreateEventStreamingRequest.Sink.SinkRabbitMQParameters.RoutingKey?

            public var targetType: CreateEventStreamingRequest.Sink.SinkRabbitMQParameters.TargetType?

            public var virtualHostName: CreateEventStreamingRequest.Sink.SinkRabbitMQParameters.VirtualHostName?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.body?.validate()
                try self.exchange?.validate()
                try self.instanceId?.validate()
                try self.messageId?.validate()
                try self.properties?.validate()
                try self.queueName?.validate()
                try self.routingKey?.validate()
                try self.targetType?.validate()
                try self.virtualHostName?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body?.toMap()
                }
                if self.exchange != nil {
                    map["Exchange"] = self.exchange?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId?.toMap()
                }
                if self.messageId != nil {
                    map["MessageId"] = self.messageId?.toMap()
                }
                if self.properties != nil {
                    map["Properties"] = self.properties?.toMap()
                }
                if self.queueName != nil {
                    map["QueueName"] = self.queueName?.toMap()
                }
                if self.routingKey != nil {
                    map["RoutingKey"] = self.routingKey?.toMap()
                }
                if self.targetType != nil {
                    map["TargetType"] = self.targetType?.toMap()
                }
                if self.virtualHostName != nil {
                    map["VirtualHostName"] = self.virtualHostName?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") {
                    var model = CreateEventStreamingRequest.Sink.SinkRabbitMQParameters.Body()
                    model.fromMap(dict["Body"] as! [String: Any])
                    self.body = model
                }
                if dict.keys.contains("Exchange") {
                    var model = CreateEventStreamingRequest.Sink.SinkRabbitMQParameters.Exchange()
                    model.fromMap(dict["Exchange"] as! [String: Any])
                    self.exchange = model
                }
                if dict.keys.contains("InstanceId") {
                    var model = CreateEventStreamingRequest.Sink.SinkRabbitMQParameters.InstanceId()
                    model.fromMap(dict["InstanceId"] as! [String: Any])
                    self.instanceId = model
                }
                if dict.keys.contains("MessageId") {
                    var model = CreateEventStreamingRequest.Sink.SinkRabbitMQParameters.MessageId()
                    model.fromMap(dict["MessageId"] as! [String: Any])
                    self.messageId = model
                }
                if dict.keys.contains("Properties") {
                    var model = CreateEventStreamingRequest.Sink.SinkRabbitMQParameters.Properties()
                    model.fromMap(dict["Properties"] as! [String: Any])
                    self.properties = model
                }
                if dict.keys.contains("QueueName") {
                    var model = CreateEventStreamingRequest.Sink.SinkRabbitMQParameters.QueueName()
                    model.fromMap(dict["QueueName"] as! [String: Any])
                    self.queueName = model
                }
                if dict.keys.contains("RoutingKey") {
                    var model = CreateEventStreamingRequest.Sink.SinkRabbitMQParameters.RoutingKey()
                    model.fromMap(dict["RoutingKey"] as! [String: Any])
                    self.routingKey = model
                }
                if dict.keys.contains("TargetType") {
                    var model = CreateEventStreamingRequest.Sink.SinkRabbitMQParameters.TargetType()
                    model.fromMap(dict["TargetType"] as! [String: Any])
                    self.targetType = model
                }
                if dict.keys.contains("VirtualHostName") {
                    var model = CreateEventStreamingRequest.Sink.SinkRabbitMQParameters.VirtualHostName()
                    model.fromMap(dict["VirtualHostName"] as! [String: Any])
                    self.virtualHostName = model
                }
            }
        }
        public class SinkRocketMQParameters : Tea.TeaModel {
            public class Body : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class InstanceEndpoint : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class InstanceId : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class InstancePassword : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class InstanceType : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class InstanceUsername : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Keys : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Network : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Properties : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class SecurityGroupId : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Topic : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class VSwitchIds : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class VpcId : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var body: CreateEventStreamingRequest.Sink.SinkRocketMQParameters.Body?

            public var instanceEndpoint: CreateEventStreamingRequest.Sink.SinkRocketMQParameters.InstanceEndpoint?

            public var instanceId: CreateEventStreamingRequest.Sink.SinkRocketMQParameters.InstanceId?

            public var instancePassword: CreateEventStreamingRequest.Sink.SinkRocketMQParameters.InstancePassword?

            public var instanceType: CreateEventStreamingRequest.Sink.SinkRocketMQParameters.InstanceType?

            public var instanceUsername: CreateEventStreamingRequest.Sink.SinkRocketMQParameters.InstanceUsername?

            public var keys: CreateEventStreamingRequest.Sink.SinkRocketMQParameters.Keys?

            public var network: CreateEventStreamingRequest.Sink.SinkRocketMQParameters.Network?

            public var properties: CreateEventStreamingRequest.Sink.SinkRocketMQParameters.Properties?

            public var securityGroupId: CreateEventStreamingRequest.Sink.SinkRocketMQParameters.SecurityGroupId?

            public var tags: CreateEventStreamingRequest.Sink.SinkRocketMQParameters.Tags?

            public var topic: CreateEventStreamingRequest.Sink.SinkRocketMQParameters.Topic?

            public var vSwitchIds: CreateEventStreamingRequest.Sink.SinkRocketMQParameters.VSwitchIds?

            public var vpcId: CreateEventStreamingRequest.Sink.SinkRocketMQParameters.VpcId?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.body?.validate()
                try self.instanceEndpoint?.validate()
                try self.instanceId?.validate()
                try self.instancePassword?.validate()
                try self.instanceType?.validate()
                try self.instanceUsername?.validate()
                try self.keys?.validate()
                try self.network?.validate()
                try self.properties?.validate()
                try self.securityGroupId?.validate()
                try self.tags?.validate()
                try self.topic?.validate()
                try self.vSwitchIds?.validate()
                try self.vpcId?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body?.toMap()
                }
                if self.instanceEndpoint != nil {
                    map["InstanceEndpoint"] = self.instanceEndpoint?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId?.toMap()
                }
                if self.instancePassword != nil {
                    map["InstancePassword"] = self.instancePassword?.toMap()
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType?.toMap()
                }
                if self.instanceUsername != nil {
                    map["InstanceUsername"] = self.instanceUsername?.toMap()
                }
                if self.keys != nil {
                    map["Keys"] = self.keys?.toMap()
                }
                if self.network != nil {
                    map["Network"] = self.network?.toMap()
                }
                if self.properties != nil {
                    map["Properties"] = self.properties?.toMap()
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId?.toMap()
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.topic != nil {
                    map["Topic"] = self.topic?.toMap()
                }
                if self.vSwitchIds != nil {
                    map["VSwitchIds"] = self.vSwitchIds?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") {
                    var model = CreateEventStreamingRequest.Sink.SinkRocketMQParameters.Body()
                    model.fromMap(dict["Body"] as! [String: Any])
                    self.body = model
                }
                if dict.keys.contains("InstanceEndpoint") {
                    var model = CreateEventStreamingRequest.Sink.SinkRocketMQParameters.InstanceEndpoint()
                    model.fromMap(dict["InstanceEndpoint"] as! [String: Any])
                    self.instanceEndpoint = model
                }
                if dict.keys.contains("InstanceId") {
                    var model = CreateEventStreamingRequest.Sink.SinkRocketMQParameters.InstanceId()
                    model.fromMap(dict["InstanceId"] as! [String: Any])
                    self.instanceId = model
                }
                if dict.keys.contains("InstancePassword") {
                    var model = CreateEventStreamingRequest.Sink.SinkRocketMQParameters.InstancePassword()
                    model.fromMap(dict["InstancePassword"] as! [String: Any])
                    self.instancePassword = model
                }
                if dict.keys.contains("InstanceType") {
                    var model = CreateEventStreamingRequest.Sink.SinkRocketMQParameters.InstanceType()
                    model.fromMap(dict["InstanceType"] as! [String: Any])
                    self.instanceType = model
                }
                if dict.keys.contains("InstanceUsername") {
                    var model = CreateEventStreamingRequest.Sink.SinkRocketMQParameters.InstanceUsername()
                    model.fromMap(dict["InstanceUsername"] as! [String: Any])
                    self.instanceUsername = model
                }
                if dict.keys.contains("Keys") {
                    var model = CreateEventStreamingRequest.Sink.SinkRocketMQParameters.Keys()
                    model.fromMap(dict["Keys"] as! [String: Any])
                    self.keys = model
                }
                if dict.keys.contains("Network") {
                    var model = CreateEventStreamingRequest.Sink.SinkRocketMQParameters.Network()
                    model.fromMap(dict["Network"] as! [String: Any])
                    self.network = model
                }
                if dict.keys.contains("Properties") {
                    var model = CreateEventStreamingRequest.Sink.SinkRocketMQParameters.Properties()
                    model.fromMap(dict["Properties"] as! [String: Any])
                    self.properties = model
                }
                if dict.keys.contains("SecurityGroupId") {
                    var model = CreateEventStreamingRequest.Sink.SinkRocketMQParameters.SecurityGroupId()
                    model.fromMap(dict["SecurityGroupId"] as! [String: Any])
                    self.securityGroupId = model
                }
                if dict.keys.contains("Tags") {
                    var model = CreateEventStreamingRequest.Sink.SinkRocketMQParameters.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("Topic") {
                    var model = CreateEventStreamingRequest.Sink.SinkRocketMQParameters.Topic()
                    model.fromMap(dict["Topic"] as! [String: Any])
                    self.topic = model
                }
                if dict.keys.contains("VSwitchIds") {
                    var model = CreateEventStreamingRequest.Sink.SinkRocketMQParameters.VSwitchIds()
                    model.fromMap(dict["VSwitchIds"] as! [String: Any])
                    self.vSwitchIds = model
                }
                if dict.keys.contains("VpcId") {
                    var model = CreateEventStreamingRequest.Sink.SinkRocketMQParameters.VpcId()
                    model.fromMap(dict["VpcId"] as! [String: Any])
                    self.vpcId = model
                }
            }
        }
        public class SinkSLSParameters : Tea.TeaModel {
            public class Body : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class LogStore : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Project : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class RoleName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Topic : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var body: CreateEventStreamingRequest.Sink.SinkSLSParameters.Body?

            public var logStore: CreateEventStreamingRequest.Sink.SinkSLSParameters.LogStore?

            public var project: CreateEventStreamingRequest.Sink.SinkSLSParameters.Project?

            public var roleName: CreateEventStreamingRequest.Sink.SinkSLSParameters.RoleName?

            public var topic: CreateEventStreamingRequest.Sink.SinkSLSParameters.Topic?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.body?.validate()
                try self.logStore?.validate()
                try self.project?.validate()
                try self.roleName?.validate()
                try self.topic?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body?.toMap()
                }
                if self.logStore != nil {
                    map["LogStore"] = self.logStore?.toMap()
                }
                if self.project != nil {
                    map["Project"] = self.project?.toMap()
                }
                if self.roleName != nil {
                    map["RoleName"] = self.roleName?.toMap()
                }
                if self.topic != nil {
                    map["Topic"] = self.topic?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") {
                    var model = CreateEventStreamingRequest.Sink.SinkSLSParameters.Body()
                    model.fromMap(dict["Body"] as! [String: Any])
                    self.body = model
                }
                if dict.keys.contains("LogStore") {
                    var model = CreateEventStreamingRequest.Sink.SinkSLSParameters.LogStore()
                    model.fromMap(dict["LogStore"] as! [String: Any])
                    self.logStore = model
                }
                if dict.keys.contains("Project") {
                    var model = CreateEventStreamingRequest.Sink.SinkSLSParameters.Project()
                    model.fromMap(dict["Project"] as! [String: Any])
                    self.project = model
                }
                if dict.keys.contains("RoleName") {
                    var model = CreateEventStreamingRequest.Sink.SinkSLSParameters.RoleName()
                    model.fromMap(dict["RoleName"] as! [String: Any])
                    self.roleName = model
                }
                if dict.keys.contains("Topic") {
                    var model = CreateEventStreamingRequest.Sink.SinkSLSParameters.Topic()
                    model.fromMap(dict["Topic"] as! [String: Any])
                    self.topic = model
                }
            }
        }
        public var sinkDataHubParameters: CreateEventStreamingRequest.Sink.SinkDataHubParameters?

        public var sinkFcParameters: CreateEventStreamingRequest.Sink.SinkFcParameters?

        public var sinkFnfParameters: CreateEventStreamingRequest.Sink.SinkFnfParameters?

        public var sinkKafkaParameters: CreateEventStreamingRequest.Sink.SinkKafkaParameters?

        public var sinkMNSParameters: CreateEventStreamingRequest.Sink.SinkMNSParameters?

        public var sinkPrometheusParameters: CreateEventStreamingRequest.Sink.SinkPrometheusParameters?

        public var sinkRabbitMQParameters: CreateEventStreamingRequest.Sink.SinkRabbitMQParameters?

        public var sinkRocketMQParameters: CreateEventStreamingRequest.Sink.SinkRocketMQParameters?

        public var sinkSLSParameters: CreateEventStreamingRequest.Sink.SinkSLSParameters?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sinkDataHubParameters?.validate()
            try self.sinkFcParameters?.validate()
            try self.sinkFnfParameters?.validate()
            try self.sinkKafkaParameters?.validate()
            try self.sinkMNSParameters?.validate()
            try self.sinkPrometheusParameters?.validate()
            try self.sinkRabbitMQParameters?.validate()
            try self.sinkRocketMQParameters?.validate()
            try self.sinkSLSParameters?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sinkDataHubParameters != nil {
                map["SinkDataHubParameters"] = self.sinkDataHubParameters?.toMap()
            }
            if self.sinkFcParameters != nil {
                map["SinkFcParameters"] = self.sinkFcParameters?.toMap()
            }
            if self.sinkFnfParameters != nil {
                map["SinkFnfParameters"] = self.sinkFnfParameters?.toMap()
            }
            if self.sinkKafkaParameters != nil {
                map["SinkKafkaParameters"] = self.sinkKafkaParameters?.toMap()
            }
            if self.sinkMNSParameters != nil {
                map["SinkMNSParameters"] = self.sinkMNSParameters?.toMap()
            }
            if self.sinkPrometheusParameters != nil {
                map["SinkPrometheusParameters"] = self.sinkPrometheusParameters?.toMap()
            }
            if self.sinkRabbitMQParameters != nil {
                map["SinkRabbitMQParameters"] = self.sinkRabbitMQParameters?.toMap()
            }
            if self.sinkRocketMQParameters != nil {
                map["SinkRocketMQParameters"] = self.sinkRocketMQParameters?.toMap()
            }
            if self.sinkSLSParameters != nil {
                map["SinkSLSParameters"] = self.sinkSLSParameters?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SinkDataHubParameters") {
                var model = CreateEventStreamingRequest.Sink.SinkDataHubParameters()
                model.fromMap(dict["SinkDataHubParameters"] as! [String: Any])
                self.sinkDataHubParameters = model
            }
            if dict.keys.contains("SinkFcParameters") {
                var model = CreateEventStreamingRequest.Sink.SinkFcParameters()
                model.fromMap(dict["SinkFcParameters"] as! [String: Any])
                self.sinkFcParameters = model
            }
            if dict.keys.contains("SinkFnfParameters") {
                var model = CreateEventStreamingRequest.Sink.SinkFnfParameters()
                model.fromMap(dict["SinkFnfParameters"] as! [String: Any])
                self.sinkFnfParameters = model
            }
            if dict.keys.contains("SinkKafkaParameters") {
                var model = CreateEventStreamingRequest.Sink.SinkKafkaParameters()
                model.fromMap(dict["SinkKafkaParameters"] as! [String: Any])
                self.sinkKafkaParameters = model
            }
            if dict.keys.contains("SinkMNSParameters") {
                var model = CreateEventStreamingRequest.Sink.SinkMNSParameters()
                model.fromMap(dict["SinkMNSParameters"] as! [String: Any])
                self.sinkMNSParameters = model
            }
            if dict.keys.contains("SinkPrometheusParameters") {
                var model = CreateEventStreamingRequest.Sink.SinkPrometheusParameters()
                model.fromMap(dict["SinkPrometheusParameters"] as! [String: Any])
                self.sinkPrometheusParameters = model
            }
            if dict.keys.contains("SinkRabbitMQParameters") {
                var model = CreateEventStreamingRequest.Sink.SinkRabbitMQParameters()
                model.fromMap(dict["SinkRabbitMQParameters"] as! [String: Any])
                self.sinkRabbitMQParameters = model
            }
            if dict.keys.contains("SinkRocketMQParameters") {
                var model = CreateEventStreamingRequest.Sink.SinkRocketMQParameters()
                model.fromMap(dict["SinkRocketMQParameters"] as! [String: Any])
                self.sinkRocketMQParameters = model
            }
            if dict.keys.contains("SinkSLSParameters") {
                var model = CreateEventStreamingRequest.Sink.SinkSLSParameters()
                model.fromMap(dict["SinkSLSParameters"] as! [String: Any])
                self.sinkSLSParameters = model
            }
        }
    }
    public class Source : Tea.TeaModel {
        public class SourceApacheKafkaParameters : Tea.TeaModel {
            public var bootstraps: String?

            public var consumerGroup: String?

            public var networkType: String?

            public var offsetReset: String?

            public var saslMechanism: String?

            public var saslPassword: String?

            public var saslUser: String?

            public var securityGroupId: String?

            public var securityProtocol: String?

            public var topic: String?

            public var vSwitchIds: String?

            public var valueDataType: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bootstraps != nil {
                    map["Bootstraps"] = self.bootstraps!
                }
                if self.consumerGroup != nil {
                    map["ConsumerGroup"] = self.consumerGroup!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.offsetReset != nil {
                    map["OffsetReset"] = self.offsetReset!
                }
                if self.saslMechanism != nil {
                    map["SaslMechanism"] = self.saslMechanism!
                }
                if self.saslPassword != nil {
                    map["SaslPassword"] = self.saslPassword!
                }
                if self.saslUser != nil {
                    map["SaslUser"] = self.saslUser!
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                if self.securityProtocol != nil {
                    map["SecurityProtocol"] = self.securityProtocol!
                }
                if self.topic != nil {
                    map["Topic"] = self.topic!
                }
                if self.vSwitchIds != nil {
                    map["VSwitchIds"] = self.vSwitchIds!
                }
                if self.valueDataType != nil {
                    map["ValueDataType"] = self.valueDataType!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bootstraps") {
                    self.bootstraps = dict["Bootstraps"] as! String
                }
                if dict.keys.contains("ConsumerGroup") {
                    self.consumerGroup = dict["ConsumerGroup"] as! String
                }
                if dict.keys.contains("NetworkType") {
                    self.networkType = dict["NetworkType"] as! String
                }
                if dict.keys.contains("OffsetReset") {
                    self.offsetReset = dict["OffsetReset"] as! String
                }
                if dict.keys.contains("SaslMechanism") {
                    self.saslMechanism = dict["SaslMechanism"] as! String
                }
                if dict.keys.contains("SaslPassword") {
                    self.saslPassword = dict["SaslPassword"] as! String
                }
                if dict.keys.contains("SaslUser") {
                    self.saslUser = dict["SaslUser"] as! String
                }
                if dict.keys.contains("SecurityGroupId") {
                    self.securityGroupId = dict["SecurityGroupId"] as! String
                }
                if dict.keys.contains("SecurityProtocol") {
                    self.securityProtocol = dict["SecurityProtocol"] as! String
                }
                if dict.keys.contains("Topic") {
                    self.topic = dict["Topic"] as! String
                }
                if dict.keys.contains("VSwitchIds") {
                    self.vSwitchIds = dict["VSwitchIds"] as! String
                }
                if dict.keys.contains("ValueDataType") {
                    self.valueDataType = dict["ValueDataType"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public class SourceDTSParameters : Tea.TeaModel {
            public var brokerUrl: String?

            public var initCheckPoint: Int64?

            public var password: String?

            public var sid: String?

            public var taskId: String?

            public var topic: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.brokerUrl != nil {
                    map["BrokerUrl"] = self.brokerUrl!
                }
                if self.initCheckPoint != nil {
                    map["InitCheckPoint"] = self.initCheckPoint!
                }
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.sid != nil {
                    map["Sid"] = self.sid!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.topic != nil {
                    map["Topic"] = self.topic!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BrokerUrl") {
                    self.brokerUrl = dict["BrokerUrl"] as! String
                }
                if dict.keys.contains("InitCheckPoint") {
                    self.initCheckPoint = dict["InitCheckPoint"] as! Int64
                }
                if dict.keys.contains("Password") {
                    self.password = dict["Password"] as! String
                }
                if dict.keys.contains("Sid") {
                    self.sid = dict["Sid"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("Topic") {
                    self.topic = dict["Topic"] as! String
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
            }
        }
        public class SourceKafkaParameters : Tea.TeaModel {
            public var consumerGroup: String?

            public var instanceId: String?

            public var network: String?

            public var offsetReset: String?

            public var regionId: String?

            public var securityGroupId: String?

            public var topic: String?

            public var vSwitchIds: String?

            public var valueDataType: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.consumerGroup != nil {
                    map["ConsumerGroup"] = self.consumerGroup!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.network != nil {
                    map["Network"] = self.network!
                }
                if self.offsetReset != nil {
                    map["OffsetReset"] = self.offsetReset!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                if self.topic != nil {
                    map["Topic"] = self.topic!
                }
                if self.vSwitchIds != nil {
                    map["VSwitchIds"] = self.vSwitchIds!
                }
                if self.valueDataType != nil {
                    map["ValueDataType"] = self.valueDataType!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConsumerGroup") {
                    self.consumerGroup = dict["ConsumerGroup"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Network") {
                    self.network = dict["Network"] as! String
                }
                if dict.keys.contains("OffsetReset") {
                    self.offsetReset = dict["OffsetReset"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SecurityGroupId") {
                    self.securityGroupId = dict["SecurityGroupId"] as! String
                }
                if dict.keys.contains("Topic") {
                    self.topic = dict["Topic"] as! String
                }
                if dict.keys.contains("VSwitchIds") {
                    self.vSwitchIds = dict["VSwitchIds"] as! String
                }
                if dict.keys.contains("ValueDataType") {
                    self.valueDataType = dict["ValueDataType"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public class SourceMNSParameters : Tea.TeaModel {
            public var isBase64Decode: Bool?

            public var queueName: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isBase64Decode != nil {
                    map["IsBase64Decode"] = self.isBase64Decode!
                }
                if self.queueName != nil {
                    map["QueueName"] = self.queueName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IsBase64Decode") {
                    self.isBase64Decode = dict["IsBase64Decode"] as! Bool
                }
                if dict.keys.contains("QueueName") {
                    self.queueName = dict["QueueName"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public class SourceMQTTParameters : Tea.TeaModel {
            public var bodyDataType: String?

            public var instanceId: String?

            public var regionId: String?

            public var topic: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bodyDataType != nil {
                    map["BodyDataType"] = self.bodyDataType!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.topic != nil {
                    map["Topic"] = self.topic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BodyDataType") {
                    self.bodyDataType = dict["BodyDataType"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Topic") {
                    self.topic = dict["Topic"] as! String
                }
            }
        }
        public class SourcePrometheusParameters : Tea.TeaModel {
            public var clusterId: String?

            public var dataType: String?

            public var labels: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.dataType != nil {
                    map["DataType"] = self.dataType!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("DataType") {
                    self.dataType = dict["DataType"] as! String
                }
                if dict.keys.contains("Labels") {
                    self.labels = dict["Labels"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public class SourceRabbitMQParameters : Tea.TeaModel {
            public var instanceId: String?

            public var queueName: String?

            public var regionId: String?

            public var virtualHostName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.queueName != nil {
                    map["QueueName"] = self.queueName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.virtualHostName != nil {
                    map["VirtualHostName"] = self.virtualHostName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("QueueName") {
                    self.queueName = dict["QueueName"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("VirtualHostName") {
                    self.virtualHostName = dict["VirtualHostName"] as! String
                }
            }
        }
        public class SourceRocketMQParameters : Tea.TeaModel {
            public var authType: String?

            public var bodyDataType: String?

            public var filterSql: String?

            public var filterType: String?

            public var groupID: String?

            public var instanceEndpoint: String?

            public var instanceId: String?

            public var instanceNetwork: String?

            public var instancePassword: String?

            public var instanceSecurityGroupId: String?

            public var instanceType: String?

            public var instanceUsername: String?

            public var instanceVSwitchIds: String?

            public var instanceVpcId: String?

            public var network: String?

            public var offset: String?

            public var regionId: String?

            public var securityGroupId: String?

            public var tag: String?

            public var timestamp: Int64?

            public var topic: String?

            public var vSwitchIds: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authType != nil {
                    map["AuthType"] = self.authType!
                }
                if self.bodyDataType != nil {
                    map["BodyDataType"] = self.bodyDataType!
                }
                if self.filterSql != nil {
                    map["FilterSql"] = self.filterSql!
                }
                if self.filterType != nil {
                    map["FilterType"] = self.filterType!
                }
                if self.groupID != nil {
                    map["GroupID"] = self.groupID!
                }
                if self.instanceEndpoint != nil {
                    map["InstanceEndpoint"] = self.instanceEndpoint!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceNetwork != nil {
                    map["InstanceNetwork"] = self.instanceNetwork!
                }
                if self.instancePassword != nil {
                    map["InstancePassword"] = self.instancePassword!
                }
                if self.instanceSecurityGroupId != nil {
                    map["InstanceSecurityGroupId"] = self.instanceSecurityGroupId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.instanceUsername != nil {
                    map["InstanceUsername"] = self.instanceUsername!
                }
                if self.instanceVSwitchIds != nil {
                    map["InstanceVSwitchIds"] = self.instanceVSwitchIds!
                }
                if self.instanceVpcId != nil {
                    map["InstanceVpcId"] = self.instanceVpcId!
                }
                if self.network != nil {
                    map["Network"] = self.network!
                }
                if self.offset != nil {
                    map["Offset"] = self.offset!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.topic != nil {
                    map["Topic"] = self.topic!
                }
                if self.vSwitchIds != nil {
                    map["VSwitchIds"] = self.vSwitchIds!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuthType") {
                    self.authType = dict["AuthType"] as! String
                }
                if dict.keys.contains("BodyDataType") {
                    self.bodyDataType = dict["BodyDataType"] as! String
                }
                if dict.keys.contains("FilterSql") {
                    self.filterSql = dict["FilterSql"] as! String
                }
                if dict.keys.contains("FilterType") {
                    self.filterType = dict["FilterType"] as! String
                }
                if dict.keys.contains("GroupID") {
                    self.groupID = dict["GroupID"] as! String
                }
                if dict.keys.contains("InstanceEndpoint") {
                    self.instanceEndpoint = dict["InstanceEndpoint"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceNetwork") {
                    self.instanceNetwork = dict["InstanceNetwork"] as! String
                }
                if dict.keys.contains("InstancePassword") {
                    self.instancePassword = dict["InstancePassword"] as! String
                }
                if dict.keys.contains("InstanceSecurityGroupId") {
                    self.instanceSecurityGroupId = dict["InstanceSecurityGroupId"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("InstanceUsername") {
                    self.instanceUsername = dict["InstanceUsername"] as! String
                }
                if dict.keys.contains("InstanceVSwitchIds") {
                    self.instanceVSwitchIds = dict["InstanceVSwitchIds"] as! String
                }
                if dict.keys.contains("InstanceVpcId") {
                    self.instanceVpcId = dict["InstanceVpcId"] as! String
                }
                if dict.keys.contains("Network") {
                    self.network = dict["Network"] as! String
                }
                if dict.keys.contains("Offset") {
                    self.offset = dict["Offset"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SecurityGroupId") {
                    self.securityGroupId = dict["SecurityGroupId"] as! String
                }
                if dict.keys.contains("Tag") {
                    self.tag = dict["Tag"] as! String
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
                if dict.keys.contains("Topic") {
                    self.topic = dict["Topic"] as! String
                }
                if dict.keys.contains("VSwitchIds") {
                    self.vSwitchIds = dict["VSwitchIds"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public class SourceSLSParameters : Tea.TeaModel {
            public var consumePosition: String?

            public var logStore: String?

            public var project: String?

            public var roleName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.consumePosition != nil {
                    map["ConsumePosition"] = self.consumePosition!
                }
                if self.logStore != nil {
                    map["LogStore"] = self.logStore!
                }
                if self.project != nil {
                    map["Project"] = self.project!
                }
                if self.roleName != nil {
                    map["RoleName"] = self.roleName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConsumePosition") {
                    self.consumePosition = dict["ConsumePosition"] as! String
                }
                if dict.keys.contains("LogStore") {
                    self.logStore = dict["LogStore"] as! String
                }
                if dict.keys.contains("Project") {
                    self.project = dict["Project"] as! String
                }
                if dict.keys.contains("RoleName") {
                    self.roleName = dict["RoleName"] as! String
                }
            }
        }
        public var sourceApacheKafkaParameters: CreateEventStreamingRequest.Source.SourceApacheKafkaParameters?

        public var sourceDTSParameters: CreateEventStreamingRequest.Source.SourceDTSParameters?

        public var sourceKafkaParameters: CreateEventStreamingRequest.Source.SourceKafkaParameters?

        public var sourceMNSParameters: CreateEventStreamingRequest.Source.SourceMNSParameters?

        public var sourceMQTTParameters: CreateEventStreamingRequest.Source.SourceMQTTParameters?

        public var sourcePrometheusParameters: CreateEventStreamingRequest.Source.SourcePrometheusParameters?

        public var sourceRabbitMQParameters: CreateEventStreamingRequest.Source.SourceRabbitMQParameters?

        public var sourceRocketMQParameters: CreateEventStreamingRequest.Source.SourceRocketMQParameters?

        public var sourceSLSParameters: CreateEventStreamingRequest.Source.SourceSLSParameters?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sourceApacheKafkaParameters?.validate()
            try self.sourceDTSParameters?.validate()
            try self.sourceKafkaParameters?.validate()
            try self.sourceMNSParameters?.validate()
            try self.sourceMQTTParameters?.validate()
            try self.sourcePrometheusParameters?.validate()
            try self.sourceRabbitMQParameters?.validate()
            try self.sourceRocketMQParameters?.validate()
            try self.sourceSLSParameters?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sourceApacheKafkaParameters != nil {
                map["SourceApacheKafkaParameters"] = self.sourceApacheKafkaParameters?.toMap()
            }
            if self.sourceDTSParameters != nil {
                map["SourceDTSParameters"] = self.sourceDTSParameters?.toMap()
            }
            if self.sourceKafkaParameters != nil {
                map["SourceKafkaParameters"] = self.sourceKafkaParameters?.toMap()
            }
            if self.sourceMNSParameters != nil {
                map["SourceMNSParameters"] = self.sourceMNSParameters?.toMap()
            }
            if self.sourceMQTTParameters != nil {
                map["SourceMQTTParameters"] = self.sourceMQTTParameters?.toMap()
            }
            if self.sourcePrometheusParameters != nil {
                map["SourcePrometheusParameters"] = self.sourcePrometheusParameters?.toMap()
            }
            if self.sourceRabbitMQParameters != nil {
                map["SourceRabbitMQParameters"] = self.sourceRabbitMQParameters?.toMap()
            }
            if self.sourceRocketMQParameters != nil {
                map["SourceRocketMQParameters"] = self.sourceRocketMQParameters?.toMap()
            }
            if self.sourceSLSParameters != nil {
                map["SourceSLSParameters"] = self.sourceSLSParameters?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SourceApacheKafkaParameters") {
                var model = CreateEventStreamingRequest.Source.SourceApacheKafkaParameters()
                model.fromMap(dict["SourceApacheKafkaParameters"] as! [String: Any])
                self.sourceApacheKafkaParameters = model
            }
            if dict.keys.contains("SourceDTSParameters") {
                var model = CreateEventStreamingRequest.Source.SourceDTSParameters()
                model.fromMap(dict["SourceDTSParameters"] as! [String: Any])
                self.sourceDTSParameters = model
            }
            if dict.keys.contains("SourceKafkaParameters") {
                var model = CreateEventStreamingRequest.Source.SourceKafkaParameters()
                model.fromMap(dict["SourceKafkaParameters"] as! [String: Any])
                self.sourceKafkaParameters = model
            }
            if dict.keys.contains("SourceMNSParameters") {
                var model = CreateEventStreamingRequest.Source.SourceMNSParameters()
                model.fromMap(dict["SourceMNSParameters"] as! [String: Any])
                self.sourceMNSParameters = model
            }
            if dict.keys.contains("SourceMQTTParameters") {
                var model = CreateEventStreamingRequest.Source.SourceMQTTParameters()
                model.fromMap(dict["SourceMQTTParameters"] as! [String: Any])
                self.sourceMQTTParameters = model
            }
            if dict.keys.contains("SourcePrometheusParameters") {
                var model = CreateEventStreamingRequest.Source.SourcePrometheusParameters()
                model.fromMap(dict["SourcePrometheusParameters"] as! [String: Any])
                self.sourcePrometheusParameters = model
            }
            if dict.keys.contains("SourceRabbitMQParameters") {
                var model = CreateEventStreamingRequest.Source.SourceRabbitMQParameters()
                model.fromMap(dict["SourceRabbitMQParameters"] as! [String: Any])
                self.sourceRabbitMQParameters = model
            }
            if dict.keys.contains("SourceRocketMQParameters") {
                var model = CreateEventStreamingRequest.Source.SourceRocketMQParameters()
                model.fromMap(dict["SourceRocketMQParameters"] as! [String: Any])
                self.sourceRocketMQParameters = model
            }
            if dict.keys.contains("SourceSLSParameters") {
                var model = CreateEventStreamingRequest.Source.SourceSLSParameters()
                model.fromMap(dict["SourceSLSParameters"] as! [String: Any])
                self.sourceSLSParameters = model
            }
        }
    }
    public class Transforms : Tea.TeaModel {
        public var arn: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.arn != nil {
                map["Arn"] = self.arn!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Arn") {
                self.arn = dict["Arn"] as! String
            }
        }
    }
    public var description_: String?

    public var eventStreamingName: String?

    public var filterPattern: String?

    public var runOptions: CreateEventStreamingRequest.RunOptions?

    public var sink: CreateEventStreamingRequest.Sink?

    public var source: CreateEventStreamingRequest.Source?

    public var transforms: [CreateEventStreamingRequest.Transforms]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.runOptions?.validate()
        try self.sink?.validate()
        try self.source?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eventStreamingName != nil {
            map["EventStreamingName"] = self.eventStreamingName!
        }
        if self.filterPattern != nil {
            map["FilterPattern"] = self.filterPattern!
        }
        if self.runOptions != nil {
            map["RunOptions"] = self.runOptions?.toMap()
        }
        if self.sink != nil {
            map["Sink"] = self.sink?.toMap()
        }
        if self.source != nil {
            map["Source"] = self.source?.toMap()
        }
        if self.transforms != nil {
            var tmp : [Any] = []
            for k in self.transforms! {
                tmp.append(k.toMap())
            }
            map["Transforms"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EventStreamingName") {
            self.eventStreamingName = dict["EventStreamingName"] as! String
        }
        if dict.keys.contains("FilterPattern") {
            self.filterPattern = dict["FilterPattern"] as! String
        }
        if dict.keys.contains("RunOptions") {
            var model = CreateEventStreamingRequest.RunOptions()
            model.fromMap(dict["RunOptions"] as! [String: Any])
            self.runOptions = model
        }
        if dict.keys.contains("Sink") {
            var model = CreateEventStreamingRequest.Sink()
            model.fromMap(dict["Sink"] as! [String: Any])
            self.sink = model
        }
        if dict.keys.contains("Source") {
            var model = CreateEventStreamingRequest.Source()
            model.fromMap(dict["Source"] as! [String: Any])
            self.source = model
        }
        if dict.keys.contains("Transforms") {
            var tmp : [CreateEventStreamingRequest.Transforms] = []
            for v in dict["Transforms"] as! [Any] {
                var model = CreateEventStreamingRequest.Transforms()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.transforms = tmp
        }
    }
}

public class CreateEventStreamingShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var eventStreamingName: String?

    public var filterPattern: String?

    public var runOptionsShrink: String?

    public var sinkShrink: String?

    public var sourceShrink: String?

    public var transformsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eventStreamingName != nil {
            map["EventStreamingName"] = self.eventStreamingName!
        }
        if self.filterPattern != nil {
            map["FilterPattern"] = self.filterPattern!
        }
        if self.runOptionsShrink != nil {
            map["RunOptions"] = self.runOptionsShrink!
        }
        if self.sinkShrink != nil {
            map["Sink"] = self.sinkShrink!
        }
        if self.sourceShrink != nil {
            map["Source"] = self.sourceShrink!
        }
        if self.transformsShrink != nil {
            map["Transforms"] = self.transformsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EventStreamingName") {
            self.eventStreamingName = dict["EventStreamingName"] as! String
        }
        if dict.keys.contains("FilterPattern") {
            self.filterPattern = dict["FilterPattern"] as! String
        }
        if dict.keys.contains("RunOptions") {
            self.runOptionsShrink = dict["RunOptions"] as! String
        }
        if dict.keys.contains("Sink") {
            self.sinkShrink = dict["Sink"] as! String
        }
        if dict.keys.contains("Source") {
            self.sourceShrink = dict["Source"] as! String
        }
        if dict.keys.contains("Transforms") {
            self.transformsShrink = dict["Transforms"] as! String
        }
    }
}

public class CreateEventStreamingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var eventStreamingARN: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventStreamingARN != nil {
                map["EventStreamingARN"] = self.eventStreamingARN!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventStreamingARN") {
                self.eventStreamingARN = dict["EventStreamingARN"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateEventStreamingResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateEventStreamingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateEventStreamingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEventStreamingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEventStreamingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRuleRequest : Tea.TeaModel {
    public class EventTargets : Tea.TeaModel {
        public class DeadLetterQueue : Tea.TeaModel {
            public var arn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.arn != nil {
                    map["Arn"] = self.arn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Arn") {
                    self.arn = dict["Arn"] as! String
                }
            }
        }
        public class ParamList : Tea.TeaModel {
            public var form: String?

            public var resourceKey: String?

            public var template: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.form != nil {
                    map["Form"] = self.form!
                }
                if self.resourceKey != nil {
                    map["ResourceKey"] = self.resourceKey!
                }
                if self.template != nil {
                    map["Template"] = self.template!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Form") {
                    self.form = dict["Form"] as! String
                }
                if dict.keys.contains("ResourceKey") {
                    self.resourceKey = dict["ResourceKey"] as! String
                }
                if dict.keys.contains("Template") {
                    self.template = dict["Template"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var deadLetterQueue: CreateRuleRequest.EventTargets.DeadLetterQueue?

        public var endpoint: String?

        public var errorsTolerance: String?

        public var id: String?

        public var paramList: [CreateRuleRequest.EventTargets.ParamList]?

        public var pushRetryStrategy: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.deadLetterQueue?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deadLetterQueue != nil {
                map["DeadLetterQueue"] = self.deadLetterQueue?.toMap()
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.errorsTolerance != nil {
                map["ErrorsTolerance"] = self.errorsTolerance!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.paramList != nil {
                var tmp : [Any] = []
                for k in self.paramList! {
                    tmp.append(k.toMap())
                }
                map["ParamList"] = tmp
            }
            if self.pushRetryStrategy != nil {
                map["PushRetryStrategy"] = self.pushRetryStrategy!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeadLetterQueue") {
                var model = CreateRuleRequest.EventTargets.DeadLetterQueue()
                model.fromMap(dict["DeadLetterQueue"] as! [String: Any])
                self.deadLetterQueue = model
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("ErrorsTolerance") {
                self.errorsTolerance = dict["ErrorsTolerance"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ParamList") {
                var tmp : [CreateRuleRequest.EventTargets.ParamList] = []
                for v in dict["ParamList"] as! [Any] {
                    var model = CreateRuleRequest.EventTargets.ParamList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.paramList = tmp
            }
            if dict.keys.contains("PushRetryStrategy") {
                self.pushRetryStrategy = dict["PushRetryStrategy"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var description_: String?

    public var eventBusName: String?

    public var eventTargets: [CreateRuleRequest.EventTargets]?

    public var filterPattern: String?

    public var ruleName: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.eventTargets != nil {
            var tmp : [Any] = []
            for k in self.eventTargets! {
                tmp.append(k.toMap())
            }
            map["EventTargets"] = tmp
        }
        if self.filterPattern != nil {
            map["FilterPattern"] = self.filterPattern!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("EventTargets") {
            var tmp : [CreateRuleRequest.EventTargets] = []
            for v in dict["EventTargets"] as! [Any] {
                var model = CreateRuleRequest.EventTargets()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.eventTargets = tmp
        }
        if dict.keys.contains("FilterPattern") {
            self.filterPattern = dict["FilterPattern"] as! String
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class CreateRuleShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var eventBusName: String?

    public var eventTargetsShrink: String?

    public var filterPattern: String?

    public var ruleName: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.eventTargetsShrink != nil {
            map["EventTargets"] = self.eventTargetsShrink!
        }
        if self.filterPattern != nil {
            map["FilterPattern"] = self.filterPattern!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("EventTargets") {
            self.eventTargetsShrink = dict["EventTargets"] as! String
        }
        if dict.keys.contains("FilterPattern") {
            self.filterPattern = dict["FilterPattern"] as! String
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class CreateRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var ruleARN: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleARN != nil {
                map["RuleARN"] = self.ruleARN!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RuleARN") {
                self.ruleARN = dict["RuleARN"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateRuleResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateServiceLinkedRoleForProductRequest : Tea.TeaModel {
    public var productName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.productName != nil {
            map["ProductName"] = self.productName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProductName") {
            self.productName = dict["ProductName"] as! String
        }
    }
}

public class CreateServiceLinkedRoleForProductResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateServiceLinkedRoleForProductResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateServiceLinkedRoleForProductResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateServiceLinkedRoleForProductResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteApiDestinationRequest : Tea.TeaModel {
    public var apiDestinationName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiDestinationName != nil {
            map["ApiDestinationName"] = self.apiDestinationName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiDestinationName") {
            self.apiDestinationName = dict["ApiDestinationName"] as! String
        }
    }
}

public class DeleteApiDestinationResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteApiDestinationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApiDestinationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteApiDestinationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteConnectionRequest : Tea.TeaModel {
    public var connectionName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionName != nil {
            map["ConnectionName"] = self.connectionName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConnectionName") {
            self.connectionName = dict["ConnectionName"] as! String
        }
    }
}

public class DeleteConnectionResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEventBusRequest : Tea.TeaModel {
    public var eventBusName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
    }
}

public class DeleteEventBusResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteEventBusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEventBusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEventBusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEventSourceRequest : Tea.TeaModel {
    public var eventBusName: String?

    public var eventSourceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.eventSourceName != nil {
            map["EventSourceName"] = self.eventSourceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("EventSourceName") {
            self.eventSourceName = dict["EventSourceName"] as! String
        }
    }
}

public class DeleteEventSourceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteEventSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEventSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEventSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEventStreamingRequest : Tea.TeaModel {
    public var eventStreamingName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventStreamingName != nil {
            map["EventStreamingName"] = self.eventStreamingName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventStreamingName") {
            self.eventStreamingName = dict["EventStreamingName"] as! String
        }
    }
}

public class DeleteEventStreamingResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteEventStreamingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEventStreamingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEventStreamingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRuleRequest : Tea.TeaModel {
    public var eventBusName: String?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
    }
}

public class DeleteRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTargetsRequest : Tea.TeaModel {
    public var eventBusName: String?

    public var ruleName: String?

    public var targetIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.targetIds != nil {
            map["TargetIds"] = self.targetIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("TargetIds") {
            self.targetIds = dict["TargetIds"] as! [String]
        }
    }
}

public class DeleteTargetsShrinkRequest : Tea.TeaModel {
    public var eventBusName: String?

    public var ruleName: String?

    public var targetIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.targetIdsShrink != nil {
            map["TargetIds"] = self.targetIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("TargetIds") {
            self.targetIdsShrink = dict["TargetIds"] as! String
        }
    }
}

public class DeleteTargetsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ErrorEntries : Tea.TeaModel {
            public var entryId: String?

            public var errorCode: String?

            public var errorMessage: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.entryId != nil {
                    map["EntryId"] = self.entryId!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EntryId") {
                    self.entryId = dict["EntryId"] as! String
                }
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
            }
        }
        public var errorEntries: [DeleteTargetsResponseBody.Data.ErrorEntries]?

        public var errorEntriesCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorEntries != nil {
                var tmp : [Any] = []
                for k in self.errorEntries! {
                    tmp.append(k.toMap())
                }
                map["ErrorEntries"] = tmp
            }
            if self.errorEntriesCount != nil {
                map["ErrorEntriesCount"] = self.errorEntriesCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorEntries") {
                var tmp : [DeleteTargetsResponseBody.Data.ErrorEntries] = []
                for v in dict["ErrorEntries"] as! [Any] {
                    var model = DeleteTargetsResponseBody.Data.ErrorEntries()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.errorEntries = tmp
            }
            if dict.keys.contains("ErrorEntriesCount") {
                self.errorEntriesCount = dict["ErrorEntriesCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: DeleteTargetsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DeleteTargetsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteTargetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTargetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTargetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableRuleRequest : Tea.TeaModel {
    public var eventBusName: String?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
    }
}

public class DisableRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DisableRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableRuleRequest : Tea.TeaModel {
    public var eventBusName: String?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
    }
}

public class EnableRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EnableRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EventCenterCheckEnabledOnDefaultBusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var enabled: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! Bool
            }
        }
    }
    public var code: String?

    public var data: EventCenterCheckEnabledOnDefaultBusResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = EventCenterCheckEnabledOnDefaultBusResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EventCenterCheckEnabledOnDefaultBusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EventCenterCheckEnabledOnDefaultBusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EventCenterCheckEnabledOnDefaultBusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EventCenterDisableOnDefaultBusResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EventCenterDisableOnDefaultBusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EventCenterDisableOnDefaultBusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EventCenterDisableOnDefaultBusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EventCenterEnableOnDefaultBusResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EventCenterEnableOnDefaultBusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EventCenterEnableOnDefaultBusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EventCenterEnableOnDefaultBusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EventCenterQueryEventsRequest : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public class Parameters : Tea.TeaModel {
            public class Calculations : Tea.TeaModel {
                public var column: String?

                public var op: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.column != nil {
                        map["Column"] = self.column!
                    }
                    if self.op != nil {
                        map["Op"] = self.op!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Column") {
                        self.column = dict["Column"] as! String
                    }
                    if dict.keys.contains("Op") {
                        self.op = dict["Op"] as! String
                    }
                }
            }
            public class Filters : Tea.TeaModel {
                public var column: String?

                public var op: String?

                public var values: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.column != nil {
                        map["Column"] = self.column!
                    }
                    if self.op != nil {
                        map["Op"] = self.op!
                    }
                    if self.values != nil {
                        map["Values"] = self.values!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Column") {
                        self.column = dict["Column"] as! String
                    }
                    if dict.keys.contains("Op") {
                        self.op = dict["Op"] as! String
                    }
                    if dict.keys.contains("Values") {
                        self.values = dict["Values"] as! [String]
                    }
                }
            }
            public class Orders : Tea.TeaModel {
                public var column: String?

                public var desc: Bool?

                public var op: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.column != nil {
                        map["Column"] = self.column!
                    }
                    if self.desc != nil {
                        map["Desc"] = self.desc!
                    }
                    if self.op != nil {
                        map["Op"] = self.op!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Column") {
                        self.column = dict["Column"] as! String
                    }
                    if dict.keys.contains("Desc") {
                        self.desc = dict["Desc"] as! Bool
                    }
                    if dict.keys.contains("Op") {
                        self.op = dict["Op"] as! String
                    }
                }
            }
            public var breakdowns: [String]?

            public var calculations: [EventCenterQueryEventsRequest.Body.Parameters.Calculations]?

            public var endTime: Int?

            public var filterCombination: String?

            public var filters: [EventCenterQueryEventsRequest.Body.Parameters.Filters]?

            public var granularity: Int?

            public var limit: Int?

            public var offset: Int?

            public var orders: [EventCenterQueryEventsRequest.Body.Parameters.Orders]?

            public var startTime: Int?

            public var timeRange: Int?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakdowns != nil {
                    map["Breakdowns"] = self.breakdowns!
                }
                if self.calculations != nil {
                    var tmp : [Any] = []
                    for k in self.calculations! {
                        tmp.append(k.toMap())
                    }
                    map["Calculations"] = tmp
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.filterCombination != nil {
                    map["FilterCombination"] = self.filterCombination!
                }
                if self.filters != nil {
                    var tmp : [Any] = []
                    for k in self.filters! {
                        tmp.append(k.toMap())
                    }
                    map["Filters"] = tmp
                }
                if self.granularity != nil {
                    map["Granularity"] = self.granularity!
                }
                if self.limit != nil {
                    map["Limit"] = self.limit!
                }
                if self.offset != nil {
                    map["Offset"] = self.offset!
                }
                if self.orders != nil {
                    var tmp : [Any] = []
                    for k in self.orders! {
                        tmp.append(k.toMap())
                    }
                    map["Orders"] = tmp
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.timeRange != nil {
                    map["TimeRange"] = self.timeRange!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Breakdowns") {
                    self.breakdowns = dict["Breakdowns"] as! [String]
                }
                if dict.keys.contains("Calculations") {
                    var tmp : [EventCenterQueryEventsRequest.Body.Parameters.Calculations] = []
                    for v in dict["Calculations"] as! [Any] {
                        var model = EventCenterQueryEventsRequest.Body.Parameters.Calculations()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.calculations = tmp
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int
                }
                if dict.keys.contains("FilterCombination") {
                    self.filterCombination = dict["FilterCombination"] as! String
                }
                if dict.keys.contains("Filters") {
                    var tmp : [EventCenterQueryEventsRequest.Body.Parameters.Filters] = []
                    for v in dict["Filters"] as! [Any] {
                        var model = EventCenterQueryEventsRequest.Body.Parameters.Filters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.filters = tmp
                }
                if dict.keys.contains("Granularity") {
                    self.granularity = dict["Granularity"] as! Int
                }
                if dict.keys.contains("Limit") {
                    self.limit = dict["Limit"] as! Int
                }
                if dict.keys.contains("Offset") {
                    self.offset = dict["Offset"] as! Int
                }
                if dict.keys.contains("Orders") {
                    var tmp : [EventCenterQueryEventsRequest.Body.Parameters.Orders] = []
                    for v in dict["Orders"] as! [Any] {
                        var model = EventCenterQueryEventsRequest.Body.Parameters.Orders()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.orders = tmp
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int
                }
                if dict.keys.contains("TimeRange") {
                    self.timeRange = dict["TimeRange"] as! Int
                }
            }
        }
        public var parameters: EventCenterQueryEventsRequest.Body.Parameters?

        public var queryType: String?

        public var schemaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.parameters?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.parameters != nil {
                map["Parameters"] = self.parameters?.toMap()
            }
            if self.queryType != nil {
                map["QueryType"] = self.queryType!
            }
            if self.schemaId != nil {
                map["SchemaId"] = self.schemaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Parameters") {
                var model = EventCenterQueryEventsRequest.Body.Parameters()
                model.fromMap(dict["Parameters"] as! [String: Any])
                self.parameters = model
            }
            if dict.keys.contains("QueryType") {
                self.queryType = dict["QueryType"] as! String
            }
            if dict.keys.contains("SchemaId") {
                self.schemaId = dict["SchemaId"] as! String
            }
        }
    }
    public var body: EventCenterQueryEventsRequest.Body?

    public var busName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["Body"] = self.body?.toMap()
        }
        if self.busName != nil {
            map["BusName"] = self.busName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Body") {
            var model = EventCenterQueryEventsRequest.Body()
            model.fromMap(dict["Body"] as! [String: Any])
            self.body = model
        }
        if dict.keys.contains("BusName") {
            self.busName = dict["BusName"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
    }
}

public class EventCenterQueryEventsShrinkRequest : Tea.TeaModel {
    public var bodyShrink: String?

    public var busName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bodyShrink != nil {
            map["Body"] = self.bodyShrink!
        }
        if self.busName != nil {
            map["BusName"] = self.busName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Body") {
            self.bodyShrink = dict["Body"] as! String
        }
        if dict.keys.contains("BusName") {
            self.busName = dict["BusName"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
    }
}

public class EventCenterQueryEventsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Table : Tea.TeaModel {
            public var rowData: [String: Any]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.rowData != nil {
                    map["RowData"] = self.rowData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RowData") {
                    self.rowData = dict["RowData"] as! [String: Any]
                }
            }
        }
        public class TimeSeries : Tea.TeaModel {
            public var rowData: [String: Any]?

            public var time: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.rowData != nil {
                    map["RowData"] = self.rowData!
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RowData") {
                    self.rowData = dict["RowData"] as! [String: Any]
                }
                if dict.keys.contains("Time") {
                    self.time = dict["Time"] as! String
                }
            }
        }
        public var maxResults: Int32?

        public var nextToken: String?

        public var table: [EventCenterQueryEventsResponseBody.Data.Table]?

        public var timeSeries: [EventCenterQueryEventsResponseBody.Data.TimeSeries]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxResults != nil {
                map["MaxResults"] = self.maxResults!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.table != nil {
                var tmp : [Any] = []
                for k in self.table! {
                    tmp.append(k.toMap())
                }
                map["Table"] = tmp
            }
            if self.timeSeries != nil {
                var tmp : [Any] = []
                for k in self.timeSeries! {
                    tmp.append(k.toMap())
                }
                map["TimeSeries"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MaxResults") {
                self.maxResults = dict["MaxResults"] as! Int32
            }
            if dict.keys.contains("NextToken") {
                self.nextToken = dict["NextToken"] as! String
            }
            if dict.keys.contains("Table") {
                var tmp : [EventCenterQueryEventsResponseBody.Data.Table] = []
                for v in dict["Table"] as! [Any] {
                    var model = EventCenterQueryEventsResponseBody.Data.Table()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.table = tmp
            }
            if dict.keys.contains("TimeSeries") {
                var tmp : [EventCenterQueryEventsResponseBody.Data.TimeSeries] = []
                for v in dict["TimeSeries"] as! [Any] {
                    var model = EventCenterQueryEventsResponseBody.Data.TimeSeries()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.timeSeries = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: EventCenterQueryEventsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = EventCenterQueryEventsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EventCenterQueryEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EventCenterQueryEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EventCenterQueryEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetApiDestinationRequest : Tea.TeaModel {
    public var apiDestinationName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiDestinationName != nil {
            map["ApiDestinationName"] = self.apiDestinationName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiDestinationName") {
            self.apiDestinationName = dict["ApiDestinationName"] as! String
        }
    }
}

public class GetApiDestinationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class HttpApiParameters : Tea.TeaModel {
            public var endpoint: String?

            public var method: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Endpoint") {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("Method") {
                    self.method = dict["Method"] as! String
                }
            }
        }
        public var apiDestinationName: String?

        public var connectionName: String?

        public var description_: String?

        public var gmtCreate: Int64?

        public var httpApiParameters: GetApiDestinationResponseBody.Data.HttpApiParameters?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.httpApiParameters?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiDestinationName != nil {
                map["ApiDestinationName"] = self.apiDestinationName!
            }
            if self.connectionName != nil {
                map["ConnectionName"] = self.connectionName!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.httpApiParameters != nil {
                map["HttpApiParameters"] = self.httpApiParameters?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiDestinationName") {
                self.apiDestinationName = dict["ApiDestinationName"] as! String
            }
            if dict.keys.contains("ConnectionName") {
                self.connectionName = dict["ConnectionName"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! Int64
            }
            if dict.keys.contains("HttpApiParameters") {
                var model = GetApiDestinationResponseBody.Data.HttpApiParameters()
                model.fromMap(dict["HttpApiParameters"] as! [String: Any])
                self.httpApiParameters = model
            }
        }
    }
    public var code: String?

    public var data: GetApiDestinationResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetApiDestinationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetApiDestinationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApiDestinationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetApiDestinationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetConnectionRequest : Tea.TeaModel {
    public var connectionName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionName != nil {
            map["ConnectionName"] = self.connectionName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConnectionName") {
            self.connectionName = dict["ConnectionName"] as! String
        }
    }
}

public class GetConnectionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Connections : Tea.TeaModel {
            public class AuthParameters : Tea.TeaModel {
                public class ApiKeyAuthParameters : Tea.TeaModel {
                    public var apiKeyName: String?

                    public var apiKeyValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.apiKeyName != nil {
                            map["ApiKeyName"] = self.apiKeyName!
                        }
                        if self.apiKeyValue != nil {
                            map["ApiKeyValue"] = self.apiKeyValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ApiKeyName") {
                            self.apiKeyName = dict["ApiKeyName"] as! String
                        }
                        if dict.keys.contains("ApiKeyValue") {
                            self.apiKeyValue = dict["ApiKeyValue"] as! String
                        }
                    }
                }
                public class BasicAuthParameters : Tea.TeaModel {
                    public var password: String?

                    public var username: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.password != nil {
                            map["Password"] = self.password!
                        }
                        if self.username != nil {
                            map["Username"] = self.username!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Password") {
                            self.password = dict["Password"] as! String
                        }
                        if dict.keys.contains("Username") {
                            self.username = dict["Username"] as! String
                        }
                    }
                }
                public class OAuthParameters : Tea.TeaModel {
                    public class ClientParameters : Tea.TeaModel {
                        public var clientID: String?

                        public var clientSecret: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.clientID != nil {
                                map["ClientID"] = self.clientID!
                            }
                            if self.clientSecret != nil {
                                map["ClientSecret"] = self.clientSecret!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ClientID") {
                                self.clientID = dict["ClientID"] as! String
                            }
                            if dict.keys.contains("ClientSecret") {
                                self.clientSecret = dict["ClientSecret"] as! String
                            }
                        }
                    }
                    public class OAuthHttpParameters : Tea.TeaModel {
                        public class BodyParameters : Tea.TeaModel {
                            public var isValueSecret: String?

                            public var key: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.isValueSecret != nil {
                                    map["IsValueSecret"] = self.isValueSecret!
                                }
                                if self.key != nil {
                                    map["Key"] = self.key!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("IsValueSecret") {
                                    self.isValueSecret = dict["IsValueSecret"] as! String
                                }
                                if dict.keys.contains("Key") {
                                    self.key = dict["Key"] as! String
                                }
                                if dict.keys.contains("Value") {
                                    self.value = dict["Value"] as! String
                                }
                            }
                        }
                        public class HeaderParameters : Tea.TeaModel {
                            public var isValueSecret: String?

                            public var key: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.isValueSecret != nil {
                                    map["IsValueSecret"] = self.isValueSecret!
                                }
                                if self.key != nil {
                                    map["Key"] = self.key!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("IsValueSecret") {
                                    self.isValueSecret = dict["IsValueSecret"] as! String
                                }
                                if dict.keys.contains("Key") {
                                    self.key = dict["Key"] as! String
                                }
                                if dict.keys.contains("Value") {
                                    self.value = dict["Value"] as! String
                                }
                            }
                        }
                        public class QueryStringParameters : Tea.TeaModel {
                            public var isValueSecret: String?

                            public var key: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.isValueSecret != nil {
                                    map["IsValueSecret"] = self.isValueSecret!
                                }
                                if self.key != nil {
                                    map["Key"] = self.key!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("IsValueSecret") {
                                    self.isValueSecret = dict["IsValueSecret"] as! String
                                }
                                if dict.keys.contains("Key") {
                                    self.key = dict["Key"] as! String
                                }
                                if dict.keys.contains("Value") {
                                    self.value = dict["Value"] as! String
                                }
                            }
                        }
                        public var bodyParameters: [GetConnectionResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters.BodyParameters]?

                        public var headerParameters: [GetConnectionResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters.HeaderParameters]?

                        public var queryStringParameters: [GetConnectionResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters.QueryStringParameters]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bodyParameters != nil {
                                var tmp : [Any] = []
                                for k in self.bodyParameters! {
                                    tmp.append(k.toMap())
                                }
                                map["BodyParameters"] = tmp
                            }
                            if self.headerParameters != nil {
                                var tmp : [Any] = []
                                for k in self.headerParameters! {
                                    tmp.append(k.toMap())
                                }
                                map["HeaderParameters"] = tmp
                            }
                            if self.queryStringParameters != nil {
                                var tmp : [Any] = []
                                for k in self.queryStringParameters! {
                                    tmp.append(k.toMap())
                                }
                                map["QueryStringParameters"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("BodyParameters") {
                                var tmp : [GetConnectionResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters.BodyParameters] = []
                                for v in dict["BodyParameters"] as! [Any] {
                                    var model = GetConnectionResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters.BodyParameters()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.bodyParameters = tmp
                            }
                            if dict.keys.contains("HeaderParameters") {
                                var tmp : [GetConnectionResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters.HeaderParameters] = []
                                for v in dict["HeaderParameters"] as! [Any] {
                                    var model = GetConnectionResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters.HeaderParameters()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.headerParameters = tmp
                            }
                            if dict.keys.contains("QueryStringParameters") {
                                var tmp : [GetConnectionResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters.QueryStringParameters] = []
                                for v in dict["QueryStringParameters"] as! [Any] {
                                    var model = GetConnectionResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters.QueryStringParameters()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.queryStringParameters = tmp
                            }
                        }
                    }
                    public var authorizationEndpoint: String?

                    public var clientParameters: GetConnectionResponseBody.Data.Connections.AuthParameters.OAuthParameters.ClientParameters?

                    public var httpMethod: String?

                    public var OAuthHttpParameters: GetConnectionResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.clientParameters?.validate()
                        try self.OAuthHttpParameters?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.authorizationEndpoint != nil {
                            map["AuthorizationEndpoint"] = self.authorizationEndpoint!
                        }
                        if self.clientParameters != nil {
                            map["ClientParameters"] = self.clientParameters?.toMap()
                        }
                        if self.httpMethod != nil {
                            map["HttpMethod"] = self.httpMethod!
                        }
                        if self.OAuthHttpParameters != nil {
                            map["OAuthHttpParameters"] = self.OAuthHttpParameters?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AuthorizationEndpoint") {
                            self.authorizationEndpoint = dict["AuthorizationEndpoint"] as! String
                        }
                        if dict.keys.contains("ClientParameters") {
                            var model = GetConnectionResponseBody.Data.Connections.AuthParameters.OAuthParameters.ClientParameters()
                            model.fromMap(dict["ClientParameters"] as! [String: Any])
                            self.clientParameters = model
                        }
                        if dict.keys.contains("HttpMethod") {
                            self.httpMethod = dict["HttpMethod"] as! String
                        }
                        if dict.keys.contains("OAuthHttpParameters") {
                            var model = GetConnectionResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters()
                            model.fromMap(dict["OAuthHttpParameters"] as! [String: Any])
                            self.OAuthHttpParameters = model
                        }
                    }
                }
                public var apiKeyAuthParameters: GetConnectionResponseBody.Data.Connections.AuthParameters.ApiKeyAuthParameters?

                public var authorizationType: String?

                public var basicAuthParameters: GetConnectionResponseBody.Data.Connections.AuthParameters.BasicAuthParameters?

                public var OAuthParameters: GetConnectionResponseBody.Data.Connections.AuthParameters.OAuthParameters?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.apiKeyAuthParameters?.validate()
                    try self.basicAuthParameters?.validate()
                    try self.OAuthParameters?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.apiKeyAuthParameters != nil {
                        map["ApiKeyAuthParameters"] = self.apiKeyAuthParameters?.toMap()
                    }
                    if self.authorizationType != nil {
                        map["AuthorizationType"] = self.authorizationType!
                    }
                    if self.basicAuthParameters != nil {
                        map["BasicAuthParameters"] = self.basicAuthParameters?.toMap()
                    }
                    if self.OAuthParameters != nil {
                        map["OAuthParameters"] = self.OAuthParameters?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ApiKeyAuthParameters") {
                        var model = GetConnectionResponseBody.Data.Connections.AuthParameters.ApiKeyAuthParameters()
                        model.fromMap(dict["ApiKeyAuthParameters"] as! [String: Any])
                        self.apiKeyAuthParameters = model
                    }
                    if dict.keys.contains("AuthorizationType") {
                        self.authorizationType = dict["AuthorizationType"] as! String
                    }
                    if dict.keys.contains("BasicAuthParameters") {
                        var model = GetConnectionResponseBody.Data.Connections.AuthParameters.BasicAuthParameters()
                        model.fromMap(dict["BasicAuthParameters"] as! [String: Any])
                        self.basicAuthParameters = model
                    }
                    if dict.keys.contains("OAuthParameters") {
                        var model = GetConnectionResponseBody.Data.Connections.AuthParameters.OAuthParameters()
                        model.fromMap(dict["OAuthParameters"] as! [String: Any])
                        self.OAuthParameters = model
                    }
                }
            }
            public class NetworkParameters : Tea.TeaModel {
                public var networkType: String?

                public var securityGroupId: String?

                public var vpcId: String?

                public var vswitcheId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.networkType != nil {
                        map["NetworkType"] = self.networkType!
                    }
                    if self.securityGroupId != nil {
                        map["SecurityGroupId"] = self.securityGroupId!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    if self.vswitcheId != nil {
                        map["VswitcheId"] = self.vswitcheId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NetworkType") {
                        self.networkType = dict["NetworkType"] as! String
                    }
                    if dict.keys.contains("SecurityGroupId") {
                        self.securityGroupId = dict["SecurityGroupId"] as! String
                    }
                    if dict.keys.contains("VpcId") {
                        self.vpcId = dict["VpcId"] as! String
                    }
                    if dict.keys.contains("VswitcheId") {
                        self.vswitcheId = dict["VswitcheId"] as! String
                    }
                }
            }
            public var authParameters: GetConnectionResponseBody.Data.Connections.AuthParameters?

            public var connectionName: String?

            public var description_: String?

            public var gmtCreate: Int64?

            public var id: Int64?

            public var networkParameters: GetConnectionResponseBody.Data.Connections.NetworkParameters?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.authParameters?.validate()
                try self.networkParameters?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authParameters != nil {
                    map["AuthParameters"] = self.authParameters?.toMap()
                }
                if self.connectionName != nil {
                    map["ConnectionName"] = self.connectionName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.networkParameters != nil {
                    map["NetworkParameters"] = self.networkParameters?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuthParameters") {
                    var model = GetConnectionResponseBody.Data.Connections.AuthParameters()
                    model.fromMap(dict["AuthParameters"] as! [String: Any])
                    self.authParameters = model
                }
                if dict.keys.contains("ConnectionName") {
                    self.connectionName = dict["ConnectionName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("NetworkParameters") {
                    var model = GetConnectionResponseBody.Data.Connections.NetworkParameters()
                    model.fromMap(dict["NetworkParameters"] as! [String: Any])
                    self.networkParameters = model
                }
            }
        }
        public var connections: [GetConnectionResponseBody.Data.Connections]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connections != nil {
                var tmp : [Any] = []
                for k in self.connections! {
                    tmp.append(k.toMap())
                }
                map["Connections"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Connections") {
                var tmp : [GetConnectionResponseBody.Data.Connections] = []
                for v in dict["Connections"] as! [Any] {
                    var model = GetConnectionResponseBody.Data.Connections()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.connections = tmp
            }
        }
    }
    public var code: String?

    public var data: GetConnectionResponseBody.Data?

    public var httpCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetConnectionResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEventBusRequest : Tea.TeaModel {
    public var eventBusName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
    }
}

public class GetEventBusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createTimestamp: Int64?

        public var description_: String?

        public var eventBusARN: String?

        public var eventBusName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.eventBusARN != nil {
                map["EventBusARN"] = self.eventBusARN!
            }
            if self.eventBusName != nil {
                map["EventBusName"] = self.eventBusName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTimestamp") {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EventBusARN") {
                self.eventBusARN = dict["EventBusARN"] as! String
            }
            if dict.keys.contains("EventBusName") {
                self.eventBusName = dict["EventBusName"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetEventBusResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetEventBusResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetEventBusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEventBusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEventBusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEventStreamingRequest : Tea.TeaModel {
    public var eventStreamingName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventStreamingName != nil {
            map["EventStreamingName"] = self.eventStreamingName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventStreamingName") {
            self.eventStreamingName = dict["EventStreamingName"] as! String
        }
    }
}

public class GetEventStreamingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RunOptions : Tea.TeaModel {
            public class BatchWindow : Tea.TeaModel {
                public var countBasedWindow: Int32?

                public var timeBasedWindow: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.countBasedWindow != nil {
                        map["CountBasedWindow"] = self.countBasedWindow!
                    }
                    if self.timeBasedWindow != nil {
                        map["TimeBasedWindow"] = self.timeBasedWindow!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CountBasedWindow") {
                        self.countBasedWindow = dict["CountBasedWindow"] as! Int32
                    }
                    if dict.keys.contains("TimeBasedWindow") {
                        self.timeBasedWindow = dict["TimeBasedWindow"] as! Int32
                    }
                }
            }
            public class DeadLetterQueue : Tea.TeaModel {
                public var arn: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.arn != nil {
                        map["Arn"] = self.arn!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Arn") {
                        self.arn = dict["Arn"] as! String
                    }
                }
            }
            public class RetryStrategy : Tea.TeaModel {
                public var maximumEventAgeInSeconds: Double?

                public var maximumRetryAttempts: Double?

                public var pushRetryStrategy: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maximumEventAgeInSeconds != nil {
                        map["MaximumEventAgeInSeconds"] = self.maximumEventAgeInSeconds!
                    }
                    if self.maximumRetryAttempts != nil {
                        map["MaximumRetryAttempts"] = self.maximumRetryAttempts!
                    }
                    if self.pushRetryStrategy != nil {
                        map["PushRetryStrategy"] = self.pushRetryStrategy!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MaximumEventAgeInSeconds") {
                        self.maximumEventAgeInSeconds = dict["MaximumEventAgeInSeconds"] as! Double
                    }
                    if dict.keys.contains("MaximumRetryAttempts") {
                        self.maximumRetryAttempts = dict["MaximumRetryAttempts"] as! Double
                    }
                    if dict.keys.contains("PushRetryStrategy") {
                        self.pushRetryStrategy = dict["PushRetryStrategy"] as! String
                    }
                }
            }
            public var batchWindow: GetEventStreamingResponseBody.Data.RunOptions.BatchWindow?

            public var deadLetterQueue: GetEventStreamingResponseBody.Data.RunOptions.DeadLetterQueue?

            public var errorsTolerance: String?

            public var maximumTasks: Int32?

            public var retryStrategy: GetEventStreamingResponseBody.Data.RunOptions.RetryStrategy?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.batchWindow?.validate()
                try self.deadLetterQueue?.validate()
                try self.retryStrategy?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.batchWindow != nil {
                    map["BatchWindow"] = self.batchWindow?.toMap()
                }
                if self.deadLetterQueue != nil {
                    map["DeadLetterQueue"] = self.deadLetterQueue?.toMap()
                }
                if self.errorsTolerance != nil {
                    map["ErrorsTolerance"] = self.errorsTolerance!
                }
                if self.maximumTasks != nil {
                    map["MaximumTasks"] = self.maximumTasks!
                }
                if self.retryStrategy != nil {
                    map["RetryStrategy"] = self.retryStrategy?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BatchWindow") {
                    var model = GetEventStreamingResponseBody.Data.RunOptions.BatchWindow()
                    model.fromMap(dict["BatchWindow"] as! [String: Any])
                    self.batchWindow = model
                }
                if dict.keys.contains("DeadLetterQueue") {
                    var model = GetEventStreamingResponseBody.Data.RunOptions.DeadLetterQueue()
                    model.fromMap(dict["DeadLetterQueue"] as! [String: Any])
                    self.deadLetterQueue = model
                }
                if dict.keys.contains("ErrorsTolerance") {
                    self.errorsTolerance = dict["ErrorsTolerance"] as! String
                }
                if dict.keys.contains("MaximumTasks") {
                    self.maximumTasks = dict["MaximumTasks"] as! Int32
                }
                if dict.keys.contains("RetryStrategy") {
                    var model = GetEventStreamingResponseBody.Data.RunOptions.RetryStrategy()
                    model.fromMap(dict["RetryStrategy"] as! [String: Any])
                    self.retryStrategy = model
                }
            }
        }
        public class Sink : Tea.TeaModel {
            public class SinkFcParameters : Tea.TeaModel {
                public class Body : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Concurrency : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class FunctionName : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class InvocationType : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Qualifier : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class ServiceName : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var body: GetEventStreamingResponseBody.Data.Sink.SinkFcParameters.Body?

                public var concurrency: GetEventStreamingResponseBody.Data.Sink.SinkFcParameters.Concurrency?

                public var functionName: GetEventStreamingResponseBody.Data.Sink.SinkFcParameters.FunctionName?

                public var invocationType: GetEventStreamingResponseBody.Data.Sink.SinkFcParameters.InvocationType?

                public var qualifier: GetEventStreamingResponseBody.Data.Sink.SinkFcParameters.Qualifier?

                public var serviceName: GetEventStreamingResponseBody.Data.Sink.SinkFcParameters.ServiceName?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.body?.validate()
                    try self.concurrency?.validate()
                    try self.functionName?.validate()
                    try self.invocationType?.validate()
                    try self.qualifier?.validate()
                    try self.serviceName?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.body != nil {
                        map["Body"] = self.body?.toMap()
                    }
                    if self.concurrency != nil {
                        map["Concurrency"] = self.concurrency?.toMap()
                    }
                    if self.functionName != nil {
                        map["FunctionName"] = self.functionName?.toMap()
                    }
                    if self.invocationType != nil {
                        map["InvocationType"] = self.invocationType?.toMap()
                    }
                    if self.qualifier != nil {
                        map["Qualifier"] = self.qualifier?.toMap()
                    }
                    if self.serviceName != nil {
                        map["ServiceName"] = self.serviceName?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Body") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkFcParameters.Body()
                        model.fromMap(dict["Body"] as! [String: Any])
                        self.body = model
                    }
                    if dict.keys.contains("Concurrency") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkFcParameters.Concurrency()
                        model.fromMap(dict["Concurrency"] as! [String: Any])
                        self.concurrency = model
                    }
                    if dict.keys.contains("FunctionName") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkFcParameters.FunctionName()
                        model.fromMap(dict["FunctionName"] as! [String: Any])
                        self.functionName = model
                    }
                    if dict.keys.contains("InvocationType") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkFcParameters.InvocationType()
                        model.fromMap(dict["InvocationType"] as! [String: Any])
                        self.invocationType = model
                    }
                    if dict.keys.contains("Qualifier") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkFcParameters.Qualifier()
                        model.fromMap(dict["Qualifier"] as! [String: Any])
                        self.qualifier = model
                    }
                    if dict.keys.contains("ServiceName") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkFcParameters.ServiceName()
                        model.fromMap(dict["ServiceName"] as! [String: Any])
                        self.serviceName = model
                    }
                }
            }
            public class SinkFnfParameters : Tea.TeaModel {
                public class ExecutionName : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class FlowName : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Input : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class RoleName : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var executionName: GetEventStreamingResponseBody.Data.Sink.SinkFnfParameters.ExecutionName?

                public var flowName: GetEventStreamingResponseBody.Data.Sink.SinkFnfParameters.FlowName?

                public var input: GetEventStreamingResponseBody.Data.Sink.SinkFnfParameters.Input?

                public var roleName: GetEventStreamingResponseBody.Data.Sink.SinkFnfParameters.RoleName?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.executionName?.validate()
                    try self.flowName?.validate()
                    try self.input?.validate()
                    try self.roleName?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.executionName != nil {
                        map["ExecutionName"] = self.executionName?.toMap()
                    }
                    if self.flowName != nil {
                        map["FlowName"] = self.flowName?.toMap()
                    }
                    if self.input != nil {
                        map["Input"] = self.input?.toMap()
                    }
                    if self.roleName != nil {
                        map["RoleName"] = self.roleName?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ExecutionName") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkFnfParameters.ExecutionName()
                        model.fromMap(dict["ExecutionName"] as! [String: Any])
                        self.executionName = model
                    }
                    if dict.keys.contains("FlowName") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkFnfParameters.FlowName()
                        model.fromMap(dict["FlowName"] as! [String: Any])
                        self.flowName = model
                    }
                    if dict.keys.contains("Input") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkFnfParameters.Input()
                        model.fromMap(dict["Input"] as! [String: Any])
                        self.input = model
                    }
                    if dict.keys.contains("RoleName") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkFnfParameters.RoleName()
                        model.fromMap(dict["RoleName"] as! [String: Any])
                        self.roleName = model
                    }
                }
            }
            public class SinkKafkaParameters : Tea.TeaModel {
                public class Acks : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class InstanceId : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Key : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Topic : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Value : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var acks: GetEventStreamingResponseBody.Data.Sink.SinkKafkaParameters.Acks?

                public var instanceId: GetEventStreamingResponseBody.Data.Sink.SinkKafkaParameters.InstanceId?

                public var key: GetEventStreamingResponseBody.Data.Sink.SinkKafkaParameters.Key?

                public var topic: GetEventStreamingResponseBody.Data.Sink.SinkKafkaParameters.Topic?

                public var value: GetEventStreamingResponseBody.Data.Sink.SinkKafkaParameters.Value?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.acks?.validate()
                    try self.instanceId?.validate()
                    try self.key?.validate()
                    try self.topic?.validate()
                    try self.value?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.acks != nil {
                        map["Acks"] = self.acks?.toMap()
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId?.toMap()
                    }
                    if self.key != nil {
                        map["Key"] = self.key?.toMap()
                    }
                    if self.topic != nil {
                        map["Topic"] = self.topic?.toMap()
                    }
                    if self.value != nil {
                        map["Value"] = self.value?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Acks") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkKafkaParameters.Acks()
                        model.fromMap(dict["Acks"] as! [String: Any])
                        self.acks = model
                    }
                    if dict.keys.contains("InstanceId") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkKafkaParameters.InstanceId()
                        model.fromMap(dict["InstanceId"] as! [String: Any])
                        self.instanceId = model
                    }
                    if dict.keys.contains("Key") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkKafkaParameters.Key()
                        model.fromMap(dict["Key"] as! [String: Any])
                        self.key = model
                    }
                    if dict.keys.contains("Topic") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkKafkaParameters.Topic()
                        model.fromMap(dict["Topic"] as! [String: Any])
                        self.topic = model
                    }
                    if dict.keys.contains("Value") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkKafkaParameters.Value()
                        model.fromMap(dict["Value"] as! [String: Any])
                        self.value = model
                    }
                }
            }
            public class SinkMNSParameters : Tea.TeaModel {
                public class Body : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class IsBase64Encode : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class QueueName : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var body: GetEventStreamingResponseBody.Data.Sink.SinkMNSParameters.Body?

                public var isBase64Encode: GetEventStreamingResponseBody.Data.Sink.SinkMNSParameters.IsBase64Encode?

                public var queueName: GetEventStreamingResponseBody.Data.Sink.SinkMNSParameters.QueueName?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.body?.validate()
                    try self.isBase64Encode?.validate()
                    try self.queueName?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.body != nil {
                        map["Body"] = self.body?.toMap()
                    }
                    if self.isBase64Encode != nil {
                        map["IsBase64Encode"] = self.isBase64Encode?.toMap()
                    }
                    if self.queueName != nil {
                        map["QueueName"] = self.queueName?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Body") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkMNSParameters.Body()
                        model.fromMap(dict["Body"] as! [String: Any])
                        self.body = model
                    }
                    if dict.keys.contains("IsBase64Encode") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkMNSParameters.IsBase64Encode()
                        model.fromMap(dict["IsBase64Encode"] as! [String: Any])
                        self.isBase64Encode = model
                    }
                    if dict.keys.contains("QueueName") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkMNSParameters.QueueName()
                        model.fromMap(dict["QueueName"] as! [String: Any])
                        self.queueName = model
                    }
                }
            }
            public class SinkRabbitMQParameters : Tea.TeaModel {
                public class Body : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Exchange : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class InstanceId : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class MessageId : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Properties : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class QueueName : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class RoutingKey : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class TargetType : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class VirtualHostName : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var body: GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters.Body?

                public var exchange: GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters.Exchange?

                public var instanceId: GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters.InstanceId?

                public var messageId: GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters.MessageId?

                public var properties: GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters.Properties?

                public var queueName: GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters.QueueName?

                public var routingKey: GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters.RoutingKey?

                public var targetType: GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters.TargetType?

                public var virtualHostName: GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters.VirtualHostName?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.body?.validate()
                    try self.exchange?.validate()
                    try self.instanceId?.validate()
                    try self.messageId?.validate()
                    try self.properties?.validate()
                    try self.queueName?.validate()
                    try self.routingKey?.validate()
                    try self.targetType?.validate()
                    try self.virtualHostName?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.body != nil {
                        map["Body"] = self.body?.toMap()
                    }
                    if self.exchange != nil {
                        map["Exchange"] = self.exchange?.toMap()
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId?.toMap()
                    }
                    if self.messageId != nil {
                        map["MessageId"] = self.messageId?.toMap()
                    }
                    if self.properties != nil {
                        map["Properties"] = self.properties?.toMap()
                    }
                    if self.queueName != nil {
                        map["QueueName"] = self.queueName?.toMap()
                    }
                    if self.routingKey != nil {
                        map["RoutingKey"] = self.routingKey?.toMap()
                    }
                    if self.targetType != nil {
                        map["TargetType"] = self.targetType?.toMap()
                    }
                    if self.virtualHostName != nil {
                        map["VirtualHostName"] = self.virtualHostName?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Body") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters.Body()
                        model.fromMap(dict["Body"] as! [String: Any])
                        self.body = model
                    }
                    if dict.keys.contains("Exchange") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters.Exchange()
                        model.fromMap(dict["Exchange"] as! [String: Any])
                        self.exchange = model
                    }
                    if dict.keys.contains("InstanceId") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters.InstanceId()
                        model.fromMap(dict["InstanceId"] as! [String: Any])
                        self.instanceId = model
                    }
                    if dict.keys.contains("MessageId") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters.MessageId()
                        model.fromMap(dict["MessageId"] as! [String: Any])
                        self.messageId = model
                    }
                    if dict.keys.contains("Properties") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters.Properties()
                        model.fromMap(dict["Properties"] as! [String: Any])
                        self.properties = model
                    }
                    if dict.keys.contains("QueueName") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters.QueueName()
                        model.fromMap(dict["QueueName"] as! [String: Any])
                        self.queueName = model
                    }
                    if dict.keys.contains("RoutingKey") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters.RoutingKey()
                        model.fromMap(dict["RoutingKey"] as! [String: Any])
                        self.routingKey = model
                    }
                    if dict.keys.contains("TargetType") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters.TargetType()
                        model.fromMap(dict["TargetType"] as! [String: Any])
                        self.targetType = model
                    }
                    if dict.keys.contains("VirtualHostName") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters.VirtualHostName()
                        model.fromMap(dict["VirtualHostName"] as! [String: Any])
                        self.virtualHostName = model
                    }
                }
            }
            public class SinkRocketMQParameters : Tea.TeaModel {
                public class Body : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class InstanceId : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Keys : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Properties : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Tags : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Topic : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var body: GetEventStreamingResponseBody.Data.Sink.SinkRocketMQParameters.Body?

                public var instanceId: GetEventStreamingResponseBody.Data.Sink.SinkRocketMQParameters.InstanceId?

                public var keys: GetEventStreamingResponseBody.Data.Sink.SinkRocketMQParameters.Keys?

                public var properties: GetEventStreamingResponseBody.Data.Sink.SinkRocketMQParameters.Properties?

                public var tags: GetEventStreamingResponseBody.Data.Sink.SinkRocketMQParameters.Tags?

                public var topic: GetEventStreamingResponseBody.Data.Sink.SinkRocketMQParameters.Topic?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.body?.validate()
                    try self.instanceId?.validate()
                    try self.keys?.validate()
                    try self.properties?.validate()
                    try self.tags?.validate()
                    try self.topic?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.body != nil {
                        map["Body"] = self.body?.toMap()
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId?.toMap()
                    }
                    if self.keys != nil {
                        map["Keys"] = self.keys?.toMap()
                    }
                    if self.properties != nil {
                        map["Properties"] = self.properties?.toMap()
                    }
                    if self.tags != nil {
                        map["Tags"] = self.tags?.toMap()
                    }
                    if self.topic != nil {
                        map["Topic"] = self.topic?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Body") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkRocketMQParameters.Body()
                        model.fromMap(dict["Body"] as! [String: Any])
                        self.body = model
                    }
                    if dict.keys.contains("InstanceId") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkRocketMQParameters.InstanceId()
                        model.fromMap(dict["InstanceId"] as! [String: Any])
                        self.instanceId = model
                    }
                    if dict.keys.contains("Keys") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkRocketMQParameters.Keys()
                        model.fromMap(dict["Keys"] as! [String: Any])
                        self.keys = model
                    }
                    if dict.keys.contains("Properties") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkRocketMQParameters.Properties()
                        model.fromMap(dict["Properties"] as! [String: Any])
                        self.properties = model
                    }
                    if dict.keys.contains("Tags") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkRocketMQParameters.Tags()
                        model.fromMap(dict["Tags"] as! [String: Any])
                        self.tags = model
                    }
                    if dict.keys.contains("Topic") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkRocketMQParameters.Topic()
                        model.fromMap(dict["Topic"] as! [String: Any])
                        self.topic = model
                    }
                }
            }
            public class SinkSLSParameters : Tea.TeaModel {
                public class Body : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class LogStore : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Project : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class RoleName : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Topic : Tea.TeaModel {
                    public var form: String?

                    public var template: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.form != nil {
                            map["Form"] = self.form!
                        }
                        if self.template != nil {
                            map["Template"] = self.template!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Form") {
                            self.form = dict["Form"] as! String
                        }
                        if dict.keys.contains("Template") {
                            self.template = dict["Template"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var body: GetEventStreamingResponseBody.Data.Sink.SinkSLSParameters.Body?

                public var logStore: GetEventStreamingResponseBody.Data.Sink.SinkSLSParameters.LogStore?

                public var project: GetEventStreamingResponseBody.Data.Sink.SinkSLSParameters.Project?

                public var roleName: GetEventStreamingResponseBody.Data.Sink.SinkSLSParameters.RoleName?

                public var topic: GetEventStreamingResponseBody.Data.Sink.SinkSLSParameters.Topic?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.body?.validate()
                    try self.logStore?.validate()
                    try self.project?.validate()
                    try self.roleName?.validate()
                    try self.topic?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.body != nil {
                        map["Body"] = self.body?.toMap()
                    }
                    if self.logStore != nil {
                        map["LogStore"] = self.logStore?.toMap()
                    }
                    if self.project != nil {
                        map["Project"] = self.project?.toMap()
                    }
                    if self.roleName != nil {
                        map["RoleName"] = self.roleName?.toMap()
                    }
                    if self.topic != nil {
                        map["Topic"] = self.topic?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Body") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkSLSParameters.Body()
                        model.fromMap(dict["Body"] as! [String: Any])
                        self.body = model
                    }
                    if dict.keys.contains("LogStore") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkSLSParameters.LogStore()
                        model.fromMap(dict["LogStore"] as! [String: Any])
                        self.logStore = model
                    }
                    if dict.keys.contains("Project") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkSLSParameters.Project()
                        model.fromMap(dict["Project"] as! [String: Any])
                        self.project = model
                    }
                    if dict.keys.contains("RoleName") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkSLSParameters.RoleName()
                        model.fromMap(dict["RoleName"] as! [String: Any])
                        self.roleName = model
                    }
                    if dict.keys.contains("Topic") {
                        var model = GetEventStreamingResponseBody.Data.Sink.SinkSLSParameters.Topic()
                        model.fromMap(dict["Topic"] as! [String: Any])
                        self.topic = model
                    }
                }
            }
            public var sinkFcParameters: GetEventStreamingResponseBody.Data.Sink.SinkFcParameters?

            public var sinkFnfParameters: GetEventStreamingResponseBody.Data.Sink.SinkFnfParameters?

            public var sinkKafkaParameters: GetEventStreamingResponseBody.Data.Sink.SinkKafkaParameters?

            public var sinkMNSParameters: GetEventStreamingResponseBody.Data.Sink.SinkMNSParameters?

            public var sinkRabbitMQParameters: GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters?

            public var sinkRocketMQParameters: GetEventStreamingResponseBody.Data.Sink.SinkRocketMQParameters?

            public var sinkSLSParameters: GetEventStreamingResponseBody.Data.Sink.SinkSLSParameters?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.sinkFcParameters?.validate()
                try self.sinkFnfParameters?.validate()
                try self.sinkKafkaParameters?.validate()
                try self.sinkMNSParameters?.validate()
                try self.sinkRabbitMQParameters?.validate()
                try self.sinkRocketMQParameters?.validate()
                try self.sinkSLSParameters?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sinkFcParameters != nil {
                    map["SinkFcParameters"] = self.sinkFcParameters?.toMap()
                }
                if self.sinkFnfParameters != nil {
                    map["SinkFnfParameters"] = self.sinkFnfParameters?.toMap()
                }
                if self.sinkKafkaParameters != nil {
                    map["SinkKafkaParameters"] = self.sinkKafkaParameters?.toMap()
                }
                if self.sinkMNSParameters != nil {
                    map["SinkMNSParameters"] = self.sinkMNSParameters?.toMap()
                }
                if self.sinkRabbitMQParameters != nil {
                    map["SinkRabbitMQParameters"] = self.sinkRabbitMQParameters?.toMap()
                }
                if self.sinkRocketMQParameters != nil {
                    map["SinkRocketMQParameters"] = self.sinkRocketMQParameters?.toMap()
                }
                if self.sinkSLSParameters != nil {
                    map["SinkSLSParameters"] = self.sinkSLSParameters?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SinkFcParameters") {
                    var model = GetEventStreamingResponseBody.Data.Sink.SinkFcParameters()
                    model.fromMap(dict["SinkFcParameters"] as! [String: Any])
                    self.sinkFcParameters = model
                }
                if dict.keys.contains("SinkFnfParameters") {
                    var model = GetEventStreamingResponseBody.Data.Sink.SinkFnfParameters()
                    model.fromMap(dict["SinkFnfParameters"] as! [String: Any])
                    self.sinkFnfParameters = model
                }
                if dict.keys.contains("SinkKafkaParameters") {
                    var model = GetEventStreamingResponseBody.Data.Sink.SinkKafkaParameters()
                    model.fromMap(dict["SinkKafkaParameters"] as! [String: Any])
                    self.sinkKafkaParameters = model
                }
                if dict.keys.contains("SinkMNSParameters") {
                    var model = GetEventStreamingResponseBody.Data.Sink.SinkMNSParameters()
                    model.fromMap(dict["SinkMNSParameters"] as! [String: Any])
                    self.sinkMNSParameters = model
                }
                if dict.keys.contains("SinkRabbitMQParameters") {
                    var model = GetEventStreamingResponseBody.Data.Sink.SinkRabbitMQParameters()
                    model.fromMap(dict["SinkRabbitMQParameters"] as! [String: Any])
                    self.sinkRabbitMQParameters = model
                }
                if dict.keys.contains("SinkRocketMQParameters") {
                    var model = GetEventStreamingResponseBody.Data.Sink.SinkRocketMQParameters()
                    model.fromMap(dict["SinkRocketMQParameters"] as! [String: Any])
                    self.sinkRocketMQParameters = model
                }
                if dict.keys.contains("SinkSLSParameters") {
                    var model = GetEventStreamingResponseBody.Data.Sink.SinkSLSParameters()
                    model.fromMap(dict["SinkSLSParameters"] as! [String: Any])
                    self.sinkSLSParameters = model
                }
            }
        }
        public class Source : Tea.TeaModel {
            public class SourceApacheKafkaParameters : Tea.TeaModel {
                public var bootstraps: String?

                public var consumerGroup: String?

                public var networkType: String?

                public var offsetReset: String?

                public var saslMechanism: String?

                public var saslPassword: String?

                public var saslUser: String?

                public var securityGroupId: String?

                public var securityProtocol: String?

                public var topic: String?

                public var vSwitchIds: String?

                public var valueDataType: String?

                public var vpcId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bootstraps != nil {
                        map["Bootstraps"] = self.bootstraps!
                    }
                    if self.consumerGroup != nil {
                        map["ConsumerGroup"] = self.consumerGroup!
                    }
                    if self.networkType != nil {
                        map["NetworkType"] = self.networkType!
                    }
                    if self.offsetReset != nil {
                        map["OffsetReset"] = self.offsetReset!
                    }
                    if self.saslMechanism != nil {
                        map["SaslMechanism"] = self.saslMechanism!
                    }
                    if self.saslPassword != nil {
                        map["SaslPassword"] = self.saslPassword!
                    }
                    if self.saslUser != nil {
                        map["SaslUser"] = self.saslUser!
                    }
                    if self.securityGroupId != nil {
                        map["SecurityGroupId"] = self.securityGroupId!
                    }
                    if self.securityProtocol != nil {
                        map["SecurityProtocol"] = self.securityProtocol!
                    }
                    if self.topic != nil {
                        map["Topic"] = self.topic!
                    }
                    if self.vSwitchIds != nil {
                        map["VSwitchIds"] = self.vSwitchIds!
                    }
                    if self.valueDataType != nil {
                        map["ValueDataType"] = self.valueDataType!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bootstraps") {
                        self.bootstraps = dict["Bootstraps"] as! String
                    }
                    if dict.keys.contains("ConsumerGroup") {
                        self.consumerGroup = dict["ConsumerGroup"] as! String
                    }
                    if dict.keys.contains("NetworkType") {
                        self.networkType = dict["NetworkType"] as! String
                    }
                    if dict.keys.contains("OffsetReset") {
                        self.offsetReset = dict["OffsetReset"] as! String
                    }
                    if dict.keys.contains("SaslMechanism") {
                        self.saslMechanism = dict["SaslMechanism"] as! String
                    }
                    if dict.keys.contains("SaslPassword") {
                        self.saslPassword = dict["SaslPassword"] as! String
                    }
                    if dict.keys.contains("SaslUser") {
                        self.saslUser = dict["SaslUser"] as! String
                    }
                    if dict.keys.contains("SecurityGroupId") {
                        self.securityGroupId = dict["SecurityGroupId"] as! String
                    }
                    if dict.keys.contains("SecurityProtocol") {
                        self.securityProtocol = dict["SecurityProtocol"] as! String
                    }
                    if dict.keys.contains("Topic") {
                        self.topic = dict["Topic"] as! String
                    }
                    if dict.keys.contains("VSwitchIds") {
                        self.vSwitchIds = dict["VSwitchIds"] as! String
                    }
                    if dict.keys.contains("ValueDataType") {
                        self.valueDataType = dict["ValueDataType"] as! String
                    }
                    if dict.keys.contains("VpcId") {
                        self.vpcId = dict["VpcId"] as! String
                    }
                }
            }
            public class SourceDTSParameters : Tea.TeaModel {
                public var brokerUrl: String?

                public var initCheckPoint: String?

                public var password: String?

                public var sid: String?

                public var taskId: String?

                public var topic: String?

                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.brokerUrl != nil {
                        map["BrokerUrl"] = self.brokerUrl!
                    }
                    if self.initCheckPoint != nil {
                        map["InitCheckPoint"] = self.initCheckPoint!
                    }
                    if self.password != nil {
                        map["Password"] = self.password!
                    }
                    if self.sid != nil {
                        map["Sid"] = self.sid!
                    }
                    if self.taskId != nil {
                        map["TaskId"] = self.taskId!
                    }
                    if self.topic != nil {
                        map["Topic"] = self.topic!
                    }
                    if self.username != nil {
                        map["Username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BrokerUrl") {
                        self.brokerUrl = dict["BrokerUrl"] as! String
                    }
                    if dict.keys.contains("InitCheckPoint") {
                        self.initCheckPoint = dict["InitCheckPoint"] as! String
                    }
                    if dict.keys.contains("Password") {
                        self.password = dict["Password"] as! String
                    }
                    if dict.keys.contains("Sid") {
                        self.sid = dict["Sid"] as! String
                    }
                    if dict.keys.contains("TaskId") {
                        self.taskId = dict["TaskId"] as! String
                    }
                    if dict.keys.contains("Topic") {
                        self.topic = dict["Topic"] as! String
                    }
                    if dict.keys.contains("Username") {
                        self.username = dict["Username"] as! String
                    }
                }
            }
            public class SourceKafkaParameters : Tea.TeaModel {
                public var consumerGroup: String?

                public var instanceId: String?

                public var network: String?

                public var offsetReset: String?

                public var regionId: String?

                public var securityGroupId: String?

                public var topic: String?

                public var vSwitchIds: String?

                public var valueDataType: String?

                public var vpcId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.consumerGroup != nil {
                        map["ConsumerGroup"] = self.consumerGroup!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.network != nil {
                        map["Network"] = self.network!
                    }
                    if self.offsetReset != nil {
                        map["OffsetReset"] = self.offsetReset!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    if self.securityGroupId != nil {
                        map["SecurityGroupId"] = self.securityGroupId!
                    }
                    if self.topic != nil {
                        map["Topic"] = self.topic!
                    }
                    if self.vSwitchIds != nil {
                        map["VSwitchIds"] = self.vSwitchIds!
                    }
                    if self.valueDataType != nil {
                        map["ValueDataType"] = self.valueDataType!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConsumerGroup") {
                        self.consumerGroup = dict["ConsumerGroup"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("Network") {
                        self.network = dict["Network"] as! String
                    }
                    if dict.keys.contains("OffsetReset") {
                        self.offsetReset = dict["OffsetReset"] as! String
                    }
                    if dict.keys.contains("RegionId") {
                        self.regionId = dict["RegionId"] as! String
                    }
                    if dict.keys.contains("SecurityGroupId") {
                        self.securityGroupId = dict["SecurityGroupId"] as! String
                    }
                    if dict.keys.contains("Topic") {
                        self.topic = dict["Topic"] as! String
                    }
                    if dict.keys.contains("VSwitchIds") {
                        self.vSwitchIds = dict["VSwitchIds"] as! String
                    }
                    if dict.keys.contains("ValueDataType") {
                        self.valueDataType = dict["ValueDataType"] as! String
                    }
                    if dict.keys.contains("VpcId") {
                        self.vpcId = dict["VpcId"] as! String
                    }
                }
            }
            public class SourceMNSParameters : Tea.TeaModel {
                public var isBase64Decode: Bool?

                public var queueName: String?

                public var regionId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.isBase64Decode != nil {
                        map["IsBase64Decode"] = self.isBase64Decode!
                    }
                    if self.queueName != nil {
                        map["QueueName"] = self.queueName!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IsBase64Decode") {
                        self.isBase64Decode = dict["IsBase64Decode"] as! Bool
                    }
                    if dict.keys.contains("QueueName") {
                        self.queueName = dict["QueueName"] as! String
                    }
                    if dict.keys.contains("RegionId") {
                        self.regionId = dict["RegionId"] as! String
                    }
                }
            }
            public class SourceMQTTParameters : Tea.TeaModel {
                public var instanceId: String?

                public var regionId: String?

                public var topic: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    if self.topic != nil {
                        map["Topic"] = self.topic!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("RegionId") {
                        self.regionId = dict["RegionId"] as! String
                    }
                    if dict.keys.contains("Topic") {
                        self.topic = dict["Topic"] as! String
                    }
                }
            }
            public class SourcePrometheusParameters : Tea.TeaModel {
                public var clusterId: String?

                public var dataType: String?

                public var labels: String?

                public var regionId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clusterId != nil {
                        map["ClusterId"] = self.clusterId!
                    }
                    if self.dataType != nil {
                        map["DataType"] = self.dataType!
                    }
                    if self.labels != nil {
                        map["Labels"] = self.labels!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClusterId") {
                        self.clusterId = dict["ClusterId"] as! String
                    }
                    if dict.keys.contains("DataType") {
                        self.dataType = dict["DataType"] as! String
                    }
                    if dict.keys.contains("Labels") {
                        self.labels = dict["Labels"] as! String
                    }
                    if dict.keys.contains("RegionId") {
                        self.regionId = dict["RegionId"] as! String
                    }
                }
            }
            public class SourceRabbitMQParameters : Tea.TeaModel {
                public var instanceId: String?

                public var queueName: String?

                public var regionId: String?

                public var virtualHostName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.queueName != nil {
                        map["QueueName"] = self.queueName!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    if self.virtualHostName != nil {
                        map["VirtualHostName"] = self.virtualHostName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("QueueName") {
                        self.queueName = dict["QueueName"] as! String
                    }
                    if dict.keys.contains("RegionId") {
                        self.regionId = dict["RegionId"] as! String
                    }
                    if dict.keys.contains("VirtualHostName") {
                        self.virtualHostName = dict["VirtualHostName"] as! String
                    }
                }
            }
            public class SourceRocketMQParameters : Tea.TeaModel {
                public var authType: String?

                public var bodyDataType: String?

                public var groupID: String?

                public var instanceEndpoint: String?

                public var instanceId: String?

                public var instanceNetwork: String?

                public var instancePassword: String?

                public var instanceSecurityGroupId: String?

                public var instanceType: String?

                public var instanceUsername: String?

                public var instanceVSwitchIds: String?

                public var instanceVpcId: String?

                public var offset: String?

                public var regionId: String?

                public var tag: String?

                public var timestamp: Int64?

                public var topic: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.authType != nil {
                        map["AuthType"] = self.authType!
                    }
                    if self.bodyDataType != nil {
                        map["BodyDataType"] = self.bodyDataType!
                    }
                    if self.groupID != nil {
                        map["GroupID"] = self.groupID!
                    }
                    if self.instanceEndpoint != nil {
                        map["InstanceEndpoint"] = self.instanceEndpoint!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.instanceNetwork != nil {
                        map["InstanceNetwork"] = self.instanceNetwork!
                    }
                    if self.instancePassword != nil {
                        map["InstancePassword"] = self.instancePassword!
                    }
                    if self.instanceSecurityGroupId != nil {
                        map["InstanceSecurityGroupId"] = self.instanceSecurityGroupId!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.instanceUsername != nil {
                        map["InstanceUsername"] = self.instanceUsername!
                    }
                    if self.instanceVSwitchIds != nil {
                        map["InstanceVSwitchIds"] = self.instanceVSwitchIds!
                    }
                    if self.instanceVpcId != nil {
                        map["InstanceVpcId"] = self.instanceVpcId!
                    }
                    if self.offset != nil {
                        map["Offset"] = self.offset!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    if self.tag != nil {
                        map["Tag"] = self.tag!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.topic != nil {
                        map["Topic"] = self.topic!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AuthType") {
                        self.authType = dict["AuthType"] as! String
                    }
                    if dict.keys.contains("BodyDataType") {
                        self.bodyDataType = dict["BodyDataType"] as! String
                    }
                    if dict.keys.contains("GroupID") {
                        self.groupID = dict["GroupID"] as! String
                    }
                    if dict.keys.contains("InstanceEndpoint") {
                        self.instanceEndpoint = dict["InstanceEndpoint"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("InstanceNetwork") {
                        self.instanceNetwork = dict["InstanceNetwork"] as! String
                    }
                    if dict.keys.contains("InstancePassword") {
                        self.instancePassword = dict["InstancePassword"] as! String
                    }
                    if dict.keys.contains("InstanceSecurityGroupId") {
                        self.instanceSecurityGroupId = dict["InstanceSecurityGroupId"] as! String
                    }
                    if dict.keys.contains("InstanceType") {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                    if dict.keys.contains("InstanceUsername") {
                        self.instanceUsername = dict["InstanceUsername"] as! String
                    }
                    if dict.keys.contains("InstanceVSwitchIds") {
                        self.instanceVSwitchIds = dict["InstanceVSwitchIds"] as! String
                    }
                    if dict.keys.contains("InstanceVpcId") {
                        self.instanceVpcId = dict["InstanceVpcId"] as! String
                    }
                    if dict.keys.contains("Offset") {
                        self.offset = dict["Offset"] as! String
                    }
                    if dict.keys.contains("RegionId") {
                        self.regionId = dict["RegionId"] as! String
                    }
                    if dict.keys.contains("Tag") {
                        self.tag = dict["Tag"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("Topic") {
                        self.topic = dict["Topic"] as! String
                    }
                }
            }
            public class SourceSLSParameters : Tea.TeaModel {
                public var consumePosition: String?

                public var consumerGroup: String?

                public var logStore: String?

                public var project: String?

                public var roleName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.consumePosition != nil {
                        map["ConsumePosition"] = self.consumePosition!
                    }
                    if self.consumerGroup != nil {
                        map["ConsumerGroup"] = self.consumerGroup!
                    }
                    if self.logStore != nil {
                        map["LogStore"] = self.logStore!
                    }
                    if self.project != nil {
                        map["Project"] = self.project!
                    }
                    if self.roleName != nil {
                        map["RoleName"] = self.roleName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConsumePosition") {
                        self.consumePosition = dict["ConsumePosition"] as! String
                    }
                    if dict.keys.contains("ConsumerGroup") {
                        self.consumerGroup = dict["ConsumerGroup"] as! String
                    }
                    if dict.keys.contains("LogStore") {
                        self.logStore = dict["LogStore"] as! String
                    }
                    if dict.keys.contains("Project") {
                        self.project = dict["Project"] as! String
                    }
                    if dict.keys.contains("RoleName") {
                        self.roleName = dict["RoleName"] as! String
                    }
                }
            }
            public var sourceApacheKafkaParameters: GetEventStreamingResponseBody.Data.Source.SourceApacheKafkaParameters?

            public var sourceDTSParameters: GetEventStreamingResponseBody.Data.Source.SourceDTSParameters?

            public var sourceKafkaParameters: GetEventStreamingResponseBody.Data.Source.SourceKafkaParameters?

            public var sourceMNSParameters: GetEventStreamingResponseBody.Data.Source.SourceMNSParameters?

            public var sourceMQTTParameters: GetEventStreamingResponseBody.Data.Source.SourceMQTTParameters?

            public var sourcePrometheusParameters: GetEventStreamingResponseBody.Data.Source.SourcePrometheusParameters?

            public var sourceRabbitMQParameters: GetEventStreamingResponseBody.Data.Source.SourceRabbitMQParameters?

            public var sourceRocketMQParameters: GetEventStreamingResponseBody.Data.Source.SourceRocketMQParameters?

            public var sourceSLSParameters: GetEventStreamingResponseBody.Data.Source.SourceSLSParameters?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.sourceApacheKafkaParameters?.validate()
                try self.sourceDTSParameters?.validate()
                try self.sourceKafkaParameters?.validate()
                try self.sourceMNSParameters?.validate()
                try self.sourceMQTTParameters?.validate()
                try self.sourcePrometheusParameters?.validate()
                try self.sourceRabbitMQParameters?.validate()
                try self.sourceRocketMQParameters?.validate()
                try self.sourceSLSParameters?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sourceApacheKafkaParameters != nil {
                    map["SourceApacheKafkaParameters"] = self.sourceApacheKafkaParameters?.toMap()
                }
                if self.sourceDTSParameters != nil {
                    map["SourceDTSParameters"] = self.sourceDTSParameters?.toMap()
                }
                if self.sourceKafkaParameters != nil {
                    map["SourceKafkaParameters"] = self.sourceKafkaParameters?.toMap()
                }
                if self.sourceMNSParameters != nil {
                    map["SourceMNSParameters"] = self.sourceMNSParameters?.toMap()
                }
                if self.sourceMQTTParameters != nil {
                    map["SourceMQTTParameters"] = self.sourceMQTTParameters?.toMap()
                }
                if self.sourcePrometheusParameters != nil {
                    map["SourcePrometheusParameters"] = self.sourcePrometheusParameters?.toMap()
                }
                if self.sourceRabbitMQParameters != nil {
                    map["SourceRabbitMQParameters"] = self.sourceRabbitMQParameters?.toMap()
                }
                if self.sourceRocketMQParameters != nil {
                    map["SourceRocketMQParameters"] = self.sourceRocketMQParameters?.toMap()
                }
                if self.sourceSLSParameters != nil {
                    map["SourceSLSParameters"] = self.sourceSLSParameters?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SourceApacheKafkaParameters") {
                    var model = GetEventStreamingResponseBody.Data.Source.SourceApacheKafkaParameters()
                    model.fromMap(dict["SourceApacheKafkaParameters"] as! [String: Any])
                    self.sourceApacheKafkaParameters = model
                }
                if dict.keys.contains("SourceDTSParameters") {
                    var model = GetEventStreamingResponseBody.Data.Source.SourceDTSParameters()
                    model.fromMap(dict["SourceDTSParameters"] as! [String: Any])
                    self.sourceDTSParameters = model
                }
                if dict.keys.contains("SourceKafkaParameters") {
                    var model = GetEventStreamingResponseBody.Data.Source.SourceKafkaParameters()
                    model.fromMap(dict["SourceKafkaParameters"] as! [String: Any])
                    self.sourceKafkaParameters = model
                }
                if dict.keys.contains("SourceMNSParameters") {
                    var model = GetEventStreamingResponseBody.Data.Source.SourceMNSParameters()
                    model.fromMap(dict["SourceMNSParameters"] as! [String: Any])
                    self.sourceMNSParameters = model
                }
                if dict.keys.contains("SourceMQTTParameters") {
                    var model = GetEventStreamingResponseBody.Data.Source.SourceMQTTParameters()
                    model.fromMap(dict["SourceMQTTParameters"] as! [String: Any])
                    self.sourceMQTTParameters = model
                }
                if dict.keys.contains("SourcePrometheusParameters") {
                    var model = GetEventStreamingResponseBody.Data.Source.SourcePrometheusParameters()
                    model.fromMap(dict["SourcePrometheusParameters"] as! [String: Any])
                    self.sourcePrometheusParameters = model
                }
                if dict.keys.contains("SourceRabbitMQParameters") {
                    var model = GetEventStreamingResponseBody.Data.Source.SourceRabbitMQParameters()
                    model.fromMap(dict["SourceRabbitMQParameters"] as! [String: Any])
                    self.sourceRabbitMQParameters = model
                }
                if dict.keys.contains("SourceRocketMQParameters") {
                    var model = GetEventStreamingResponseBody.Data.Source.SourceRocketMQParameters()
                    model.fromMap(dict["SourceRocketMQParameters"] as! [String: Any])
                    self.sourceRocketMQParameters = model
                }
                if dict.keys.contains("SourceSLSParameters") {
                    var model = GetEventStreamingResponseBody.Data.Source.SourceSLSParameters()
                    model.fromMap(dict["SourceSLSParameters"] as! [String: Any])
                    self.sourceSLSParameters = model
                }
            }
        }
        public class Transforms : Tea.TeaModel {
            public var arn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.arn != nil {
                    map["Arn"] = self.arn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Arn") {
                    self.arn = dict["Arn"] as! String
                }
            }
        }
        public var description_: String?

        public var eventStreamingName: String?

        public var filterPattern: String?

        public var runOptions: GetEventStreamingResponseBody.Data.RunOptions?

        public var sink: GetEventStreamingResponseBody.Data.Sink?

        public var source: GetEventStreamingResponseBody.Data.Source?

        public var status: String?

        public var transforms: [GetEventStreamingResponseBody.Data.Transforms]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.runOptions?.validate()
            try self.sink?.validate()
            try self.source?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.eventStreamingName != nil {
                map["EventStreamingName"] = self.eventStreamingName!
            }
            if self.filterPattern != nil {
                map["FilterPattern"] = self.filterPattern!
            }
            if self.runOptions != nil {
                map["RunOptions"] = self.runOptions?.toMap()
            }
            if self.sink != nil {
                map["Sink"] = self.sink?.toMap()
            }
            if self.source != nil {
                map["Source"] = self.source?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.transforms != nil {
                var tmp : [Any] = []
                for k in self.transforms! {
                    tmp.append(k.toMap())
                }
                map["Transforms"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EventStreamingName") {
                self.eventStreamingName = dict["EventStreamingName"] as! String
            }
            if dict.keys.contains("FilterPattern") {
                self.filterPattern = dict["FilterPattern"] as! String
            }
            if dict.keys.contains("RunOptions") {
                var model = GetEventStreamingResponseBody.Data.RunOptions()
                model.fromMap(dict["RunOptions"] as! [String: Any])
                self.runOptions = model
            }
            if dict.keys.contains("Sink") {
                var model = GetEventStreamingResponseBody.Data.Sink()
                model.fromMap(dict["Sink"] as! [String: Any])
                self.sink = model
            }
            if dict.keys.contains("Source") {
                var model = GetEventStreamingResponseBody.Data.Source()
                model.fromMap(dict["Source"] as! [String: Any])
                self.source = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Transforms") {
                var tmp : [GetEventStreamingResponseBody.Data.Transforms] = []
                for v in dict["Transforms"] as! [Any] {
                    var model = GetEventStreamingResponseBody.Data.Transforms()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transforms = tmp
            }
        }
    }
    public var code: String?

    public var data: GetEventStreamingResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetEventStreamingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetEventStreamingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEventStreamingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEventStreamingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRuleRequest : Tea.TeaModel {
    public var eventBusName: String?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
    }
}

public class GetRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Targets : Tea.TeaModel {
            public class DeadLetterQueue : Tea.TeaModel {
                public var arn: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.arn != nil {
                        map["Arn"] = self.arn!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Arn") {
                        self.arn = dict["Arn"] as! String
                    }
                }
            }
            public class ParamList : Tea.TeaModel {
                public var form: String?

                public var resourceKey: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.resourceKey != nil {
                        map["ResourceKey"] = self.resourceKey!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("ResourceKey") {
                        self.resourceKey = dict["ResourceKey"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var deadLetterQueue: GetRuleResponseBody.Data.Targets.DeadLetterQueue?

            public var detailMap: [String: Any]?

            public var endpoint: String?

            public var errorsTolerance: String?

            public var id: String?

            public var paramList: [GetRuleResponseBody.Data.Targets.ParamList]?

            public var pushRetryStrategy: String?

            public var pushSelector: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.deadLetterQueue?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deadLetterQueue != nil {
                    map["DeadLetterQueue"] = self.deadLetterQueue?.toMap()
                }
                if self.detailMap != nil {
                    map["DetailMap"] = self.detailMap!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.errorsTolerance != nil {
                    map["ErrorsTolerance"] = self.errorsTolerance!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.paramList != nil {
                    var tmp : [Any] = []
                    for k in self.paramList! {
                        tmp.append(k.toMap())
                    }
                    map["ParamList"] = tmp
                }
                if self.pushRetryStrategy != nil {
                    map["PushRetryStrategy"] = self.pushRetryStrategy!
                }
                if self.pushSelector != nil {
                    map["PushSelector"] = self.pushSelector!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeadLetterQueue") {
                    var model = GetRuleResponseBody.Data.Targets.DeadLetterQueue()
                    model.fromMap(dict["DeadLetterQueue"] as! [String: Any])
                    self.deadLetterQueue = model
                }
                if dict.keys.contains("DetailMap") {
                    self.detailMap = dict["DetailMap"] as! [String: Any]
                }
                if dict.keys.contains("Endpoint") {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("ErrorsTolerance") {
                    self.errorsTolerance = dict["ErrorsTolerance"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("ParamList") {
                    var tmp : [GetRuleResponseBody.Data.Targets.ParamList] = []
                    for v in dict["ParamList"] as! [Any] {
                        var model = GetRuleResponseBody.Data.Targets.ParamList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.paramList = tmp
                }
                if dict.keys.contains("PushRetryStrategy") {
                    self.pushRetryStrategy = dict["PushRetryStrategy"] as! String
                }
                if dict.keys.contains("PushSelector") {
                    self.pushSelector = dict["PushSelector"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var createdTimestamp: Int64?

        public var description_: String?

        public var eventBusName: String?

        public var filterPattern: String?

        public var ruleARN: String?

        public var ruleName: String?

        public var status: String?

        public var targets: [GetRuleResponseBody.Data.Targets]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTimestamp != nil {
                map["CreatedTimestamp"] = self.createdTimestamp!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.eventBusName != nil {
                map["EventBusName"] = self.eventBusName!
            }
            if self.filterPattern != nil {
                map["FilterPattern"] = self.filterPattern!
            }
            if self.ruleARN != nil {
                map["RuleARN"] = self.ruleARN!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.targets != nil {
                var tmp : [Any] = []
                for k in self.targets! {
                    tmp.append(k.toMap())
                }
                map["Targets"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTimestamp") {
                self.createdTimestamp = dict["CreatedTimestamp"] as! Int64
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EventBusName") {
                self.eventBusName = dict["EventBusName"] as! String
            }
            if dict.keys.contains("FilterPattern") {
                self.filterPattern = dict["FilterPattern"] as! String
            }
            if dict.keys.contains("RuleARN") {
                self.ruleARN = dict["RuleARN"] as! String
            }
            if dict.keys.contains("RuleName") {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Targets") {
                var tmp : [GetRuleResponseBody.Data.Targets] = []
                for v in dict["Targets"] as! [Any] {
                    var model = GetRuleResponseBody.Data.Targets()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.targets = tmp
            }
        }
    }
    public var code: String?

    public var data: GetRuleResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAliyunOfficialEventSourcesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EventSourceList : Tea.TeaModel {
            public class EventTypes : Tea.TeaModel {
                public var eventSourceName: String?

                public var groupName: String?

                public var name: String?

                public var shortName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.eventSourceName != nil {
                        map["EventSourceName"] = self.eventSourceName!
                    }
                    if self.groupName != nil {
                        map["GroupName"] = self.groupName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.shortName != nil {
                        map["ShortName"] = self.shortName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EventSourceName") {
                        self.eventSourceName = dict["EventSourceName"] as! String
                    }
                    if dict.keys.contains("GroupName") {
                        self.groupName = dict["GroupName"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ShortName") {
                        self.shortName = dict["ShortName"] as! String
                    }
                }
            }
            public var arn: String?

            public var ctime: Double?

            public var description_: String?

            public var eventBusName: String?

            public var eventTypes: [ListAliyunOfficialEventSourcesResponseBody.Data.EventSourceList.EventTypes]?

            public var fullName: String?

            public var name: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.arn != nil {
                    map["Arn"] = self.arn!
                }
                if self.ctime != nil {
                    map["Ctime"] = self.ctime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.eventBusName != nil {
                    map["EventBusName"] = self.eventBusName!
                }
                if self.eventTypes != nil {
                    var tmp : [Any] = []
                    for k in self.eventTypes! {
                        tmp.append(k.toMap())
                    }
                    map["EventTypes"] = tmp
                }
                if self.fullName != nil {
                    map["FullName"] = self.fullName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Arn") {
                    self.arn = dict["Arn"] as! String
                }
                if dict.keys.contains("Ctime") {
                    self.ctime = dict["Ctime"] as! Double
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EventBusName") {
                    self.eventBusName = dict["EventBusName"] as! String
                }
                if dict.keys.contains("EventTypes") {
                    var tmp : [ListAliyunOfficialEventSourcesResponseBody.Data.EventSourceList.EventTypes] = []
                    for v in dict["EventTypes"] as! [Any] {
                        var model = ListAliyunOfficialEventSourcesResponseBody.Data.EventSourceList.EventTypes()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.eventTypes = tmp
                }
                if dict.keys.contains("FullName") {
                    self.fullName = dict["FullName"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var eventSourceList: [ListAliyunOfficialEventSourcesResponseBody.Data.EventSourceList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventSourceList != nil {
                var tmp : [Any] = []
                for k in self.eventSourceList! {
                    tmp.append(k.toMap())
                }
                map["EventSourceList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventSourceList") {
                var tmp : [ListAliyunOfficialEventSourcesResponseBody.Data.EventSourceList] = []
                for v in dict["EventSourceList"] as! [Any] {
                    var model = ListAliyunOfficialEventSourcesResponseBody.Data.EventSourceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eventSourceList = tmp
            }
        }
    }
    public var code: String?

    public var data: ListAliyunOfficialEventSourcesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListAliyunOfficialEventSourcesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAliyunOfficialEventSourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAliyunOfficialEventSourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAliyunOfficialEventSourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApiDestinationsRequest : Tea.TeaModel {
    public var apiDestinationNamePrefix: String?

    public var connectionName: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiDestinationNamePrefix != nil {
            map["ApiDestinationNamePrefix"] = self.apiDestinationNamePrefix!
        }
        if self.connectionName != nil {
            map["ConnectionName"] = self.connectionName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiDestinationNamePrefix") {
            self.apiDestinationNamePrefix = dict["ApiDestinationNamePrefix"] as! String
        }
        if dict.keys.contains("ConnectionName") {
            self.connectionName = dict["ConnectionName"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
    }
}

public class ListApiDestinationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ApiDestinations : Tea.TeaModel {
            public class HttpApiParameters : Tea.TeaModel {
                public var endpoint: String?

                public var method: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endpoint != nil {
                        map["Endpoint"] = self.endpoint!
                    }
                    if self.method != nil {
                        map["Method"] = self.method!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Endpoint") {
                        self.endpoint = dict["Endpoint"] as! String
                    }
                    if dict.keys.contains("Method") {
                        self.method = dict["Method"] as! String
                    }
                }
            }
            public var apiDestinationName: String?

            public var connectionName: String?

            public var description_: String?

            public var gmtCreate: Int64?

            public var httpApiParameters: ListApiDestinationsResponseBody.Data.ApiDestinations.HttpApiParameters?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.httpApiParameters?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiDestinationName != nil {
                    map["ApiDestinationName"] = self.apiDestinationName!
                }
                if self.connectionName != nil {
                    map["ConnectionName"] = self.connectionName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.httpApiParameters != nil {
                    map["HttpApiParameters"] = self.httpApiParameters?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiDestinationName") {
                    self.apiDestinationName = dict["ApiDestinationName"] as! String
                }
                if dict.keys.contains("ConnectionName") {
                    self.connectionName = dict["ConnectionName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("HttpApiParameters") {
                    var model = ListApiDestinationsResponseBody.Data.ApiDestinations.HttpApiParameters()
                    model.fromMap(dict["HttpApiParameters"] as! [String: Any])
                    self.httpApiParameters = model
                }
            }
        }
        public var apiDestinations: [ListApiDestinationsResponseBody.Data.ApiDestinations]?

        public var maxResults: Double?

        public var nextToken: String?

        public var total: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiDestinations != nil {
                var tmp : [Any] = []
                for k in self.apiDestinations! {
                    tmp.append(k.toMap())
                }
                map["ApiDestinations"] = tmp
            }
            if self.maxResults != nil {
                map["MaxResults"] = self.maxResults!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiDestinations") {
                var tmp : [ListApiDestinationsResponseBody.Data.ApiDestinations] = []
                for v in dict["ApiDestinations"] as! [Any] {
                    var model = ListApiDestinationsResponseBody.Data.ApiDestinations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.apiDestinations = tmp
            }
            if dict.keys.contains("MaxResults") {
                self.maxResults = dict["MaxResults"] as! Double
            }
            if dict.keys.contains("NextToken") {
                self.nextToken = dict["NextToken"] as! String
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Double
            }
        }
    }
    public var code: String?

    public var data: ListApiDestinationsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListApiDestinationsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListApiDestinationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApiDestinationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListApiDestinationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListConnectionsRequest : Tea.TeaModel {
    public var connectionNamePrefix: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionNamePrefix != nil {
            map["ConnectionNamePrefix"] = self.connectionNamePrefix!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConnectionNamePrefix") {
            self.connectionNamePrefix = dict["ConnectionNamePrefix"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
    }
}

public class ListConnectionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Connections : Tea.TeaModel {
            public class AuthParameters : Tea.TeaModel {
                public class ApiKeyAuthParameters : Tea.TeaModel {
                    public var apiKeyName: String?

                    public var apiKeyValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.apiKeyName != nil {
                            map["ApiKeyName"] = self.apiKeyName!
                        }
                        if self.apiKeyValue != nil {
                            map["ApiKeyValue"] = self.apiKeyValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ApiKeyName") {
                            self.apiKeyName = dict["ApiKeyName"] as! String
                        }
                        if dict.keys.contains("ApiKeyValue") {
                            self.apiKeyValue = dict["ApiKeyValue"] as! String
                        }
                    }
                }
                public class BasicAuthParameters : Tea.TeaModel {
                    public var password: String?

                    public var username: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.password != nil {
                            map["Password"] = self.password!
                        }
                        if self.username != nil {
                            map["Username"] = self.username!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Password") {
                            self.password = dict["Password"] as! String
                        }
                        if dict.keys.contains("Username") {
                            self.username = dict["Username"] as! String
                        }
                    }
                }
                public class OAuthParameters : Tea.TeaModel {
                    public class ClientParameters : Tea.TeaModel {
                        public var clientID: String?

                        public var clientSecret: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.clientID != nil {
                                map["ClientID"] = self.clientID!
                            }
                            if self.clientSecret != nil {
                                map["ClientSecret"] = self.clientSecret!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ClientID") {
                                self.clientID = dict["ClientID"] as! String
                            }
                            if dict.keys.contains("ClientSecret") {
                                self.clientSecret = dict["ClientSecret"] as! String
                            }
                        }
                    }
                    public class OAuthHttpParameters : Tea.TeaModel {
                        public class BodyParameters : Tea.TeaModel {
                            public var isValueSecret: String?

                            public var key: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.isValueSecret != nil {
                                    map["IsValueSecret"] = self.isValueSecret!
                                }
                                if self.key != nil {
                                    map["Key"] = self.key!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("IsValueSecret") {
                                    self.isValueSecret = dict["IsValueSecret"] as! String
                                }
                                if dict.keys.contains("Key") {
                                    self.key = dict["Key"] as! String
                                }
                                if dict.keys.contains("Value") {
                                    self.value = dict["Value"] as! String
                                }
                            }
                        }
                        public class HeaderParameters : Tea.TeaModel {
                            public var isValueSecret: String?

                            public var key: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.isValueSecret != nil {
                                    map["IsValueSecret"] = self.isValueSecret!
                                }
                                if self.key != nil {
                                    map["Key"] = self.key!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("IsValueSecret") {
                                    self.isValueSecret = dict["IsValueSecret"] as! String
                                }
                                if dict.keys.contains("Key") {
                                    self.key = dict["Key"] as! String
                                }
                                if dict.keys.contains("Value") {
                                    self.value = dict["Value"] as! String
                                }
                            }
                        }
                        public class QueryStringParameters : Tea.TeaModel {
                            public var isValueSecret: String?

                            public var key: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.isValueSecret != nil {
                                    map["IsValueSecret"] = self.isValueSecret!
                                }
                                if self.key != nil {
                                    map["Key"] = self.key!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("IsValueSecret") {
                                    self.isValueSecret = dict["IsValueSecret"] as! String
                                }
                                if dict.keys.contains("Key") {
                                    self.key = dict["Key"] as! String
                                }
                                if dict.keys.contains("Value") {
                                    self.value = dict["Value"] as! String
                                }
                            }
                        }
                        public var bodyParameters: [ListConnectionsResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters.BodyParameters]?

                        public var headerParameters: [ListConnectionsResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters.HeaderParameters]?

                        public var queryStringParameters: [ListConnectionsResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters.QueryStringParameters]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bodyParameters != nil {
                                var tmp : [Any] = []
                                for k in self.bodyParameters! {
                                    tmp.append(k.toMap())
                                }
                                map["BodyParameters"] = tmp
                            }
                            if self.headerParameters != nil {
                                var tmp : [Any] = []
                                for k in self.headerParameters! {
                                    tmp.append(k.toMap())
                                }
                                map["HeaderParameters"] = tmp
                            }
                            if self.queryStringParameters != nil {
                                var tmp : [Any] = []
                                for k in self.queryStringParameters! {
                                    tmp.append(k.toMap())
                                }
                                map["QueryStringParameters"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("BodyParameters") {
                                var tmp : [ListConnectionsResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters.BodyParameters] = []
                                for v in dict["BodyParameters"] as! [Any] {
                                    var model = ListConnectionsResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters.BodyParameters()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.bodyParameters = tmp
                            }
                            if dict.keys.contains("HeaderParameters") {
                                var tmp : [ListConnectionsResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters.HeaderParameters] = []
                                for v in dict["HeaderParameters"] as! [Any] {
                                    var model = ListConnectionsResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters.HeaderParameters()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.headerParameters = tmp
                            }
                            if dict.keys.contains("QueryStringParameters") {
                                var tmp : [ListConnectionsResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters.QueryStringParameters] = []
                                for v in dict["QueryStringParameters"] as! [Any] {
                                    var model = ListConnectionsResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters.QueryStringParameters()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.queryStringParameters = tmp
                            }
                        }
                    }
                    public var authorizationEndpoint: String?

                    public var clientParameters: ListConnectionsResponseBody.Data.Connections.AuthParameters.OAuthParameters.ClientParameters?

                    public var httpMethod: String?

                    public var OAuthHttpParameters: ListConnectionsResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.clientParameters?.validate()
                        try self.OAuthHttpParameters?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.authorizationEndpoint != nil {
                            map["AuthorizationEndpoint"] = self.authorizationEndpoint!
                        }
                        if self.clientParameters != nil {
                            map["ClientParameters"] = self.clientParameters?.toMap()
                        }
                        if self.httpMethod != nil {
                            map["HttpMethod"] = self.httpMethod!
                        }
                        if self.OAuthHttpParameters != nil {
                            map["OAuthHttpParameters"] = self.OAuthHttpParameters?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AuthorizationEndpoint") {
                            self.authorizationEndpoint = dict["AuthorizationEndpoint"] as! String
                        }
                        if dict.keys.contains("ClientParameters") {
                            var model = ListConnectionsResponseBody.Data.Connections.AuthParameters.OAuthParameters.ClientParameters()
                            model.fromMap(dict["ClientParameters"] as! [String: Any])
                            self.clientParameters = model
                        }
                        if dict.keys.contains("HttpMethod") {
                            self.httpMethod = dict["HttpMethod"] as! String
                        }
                        if dict.keys.contains("OAuthHttpParameters") {
                            var model = ListConnectionsResponseBody.Data.Connections.AuthParameters.OAuthParameters.OAuthHttpParameters()
                            model.fromMap(dict["OAuthHttpParameters"] as! [String: Any])
                            self.OAuthHttpParameters = model
                        }
                    }
                }
                public var apiKeyAuthParameters: ListConnectionsResponseBody.Data.Connections.AuthParameters.ApiKeyAuthParameters?

                public var authorizationType: String?

                public var basicAuthParameters: ListConnectionsResponseBody.Data.Connections.AuthParameters.BasicAuthParameters?

                public var OAuthParameters: ListConnectionsResponseBody.Data.Connections.AuthParameters.OAuthParameters?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.apiKeyAuthParameters?.validate()
                    try self.basicAuthParameters?.validate()
                    try self.OAuthParameters?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.apiKeyAuthParameters != nil {
                        map["ApiKeyAuthParameters"] = self.apiKeyAuthParameters?.toMap()
                    }
                    if self.authorizationType != nil {
                        map["AuthorizationType"] = self.authorizationType!
                    }
                    if self.basicAuthParameters != nil {
                        map["BasicAuthParameters"] = self.basicAuthParameters?.toMap()
                    }
                    if self.OAuthParameters != nil {
                        map["OAuthParameters"] = self.OAuthParameters?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ApiKeyAuthParameters") {
                        var model = ListConnectionsResponseBody.Data.Connections.AuthParameters.ApiKeyAuthParameters()
                        model.fromMap(dict["ApiKeyAuthParameters"] as! [String: Any])
                        self.apiKeyAuthParameters = model
                    }
                    if dict.keys.contains("AuthorizationType") {
                        self.authorizationType = dict["AuthorizationType"] as! String
                    }
                    if dict.keys.contains("BasicAuthParameters") {
                        var model = ListConnectionsResponseBody.Data.Connections.AuthParameters.BasicAuthParameters()
                        model.fromMap(dict["BasicAuthParameters"] as! [String: Any])
                        self.basicAuthParameters = model
                    }
                    if dict.keys.contains("OAuthParameters") {
                        var model = ListConnectionsResponseBody.Data.Connections.AuthParameters.OAuthParameters()
                        model.fromMap(dict["OAuthParameters"] as! [String: Any])
                        self.OAuthParameters = model
                    }
                }
            }
            public class NetworkParameters : Tea.TeaModel {
                public var networkType: String?

                public var securityGroupId: String?

                public var vpcId: String?

                public var vswitcheId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.networkType != nil {
                        map["NetworkType"] = self.networkType!
                    }
                    if self.securityGroupId != nil {
                        map["SecurityGroupId"] = self.securityGroupId!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    if self.vswitcheId != nil {
                        map["VswitcheId"] = self.vswitcheId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NetworkType") {
                        self.networkType = dict["NetworkType"] as! String
                    }
                    if dict.keys.contains("SecurityGroupId") {
                        self.securityGroupId = dict["SecurityGroupId"] as! String
                    }
                    if dict.keys.contains("VpcId") {
                        self.vpcId = dict["VpcId"] as! String
                    }
                    if dict.keys.contains("VswitcheId") {
                        self.vswitcheId = dict["VswitcheId"] as! String
                    }
                }
            }
            public var authParameters: ListConnectionsResponseBody.Data.Connections.AuthParameters?

            public var connectionName: String?

            public var description_: String?

            public var gmtCreate: Int64?

            public var id: Int64?

            public var networkParameters: ListConnectionsResponseBody.Data.Connections.NetworkParameters?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.authParameters?.validate()
                try self.networkParameters?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authParameters != nil {
                    map["AuthParameters"] = self.authParameters?.toMap()
                }
                if self.connectionName != nil {
                    map["ConnectionName"] = self.connectionName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.networkParameters != nil {
                    map["NetworkParameters"] = self.networkParameters?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuthParameters") {
                    var model = ListConnectionsResponseBody.Data.Connections.AuthParameters()
                    model.fromMap(dict["AuthParameters"] as! [String: Any])
                    self.authParameters = model
                }
                if dict.keys.contains("ConnectionName") {
                    self.connectionName = dict["ConnectionName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("NetworkParameters") {
                    var model = ListConnectionsResponseBody.Data.Connections.NetworkParameters()
                    model.fromMap(dict["NetworkParameters"] as! [String: Any])
                    self.networkParameters = model
                }
            }
        }
        public var connections: [ListConnectionsResponseBody.Data.Connections]?

        public var maxResults: Double?

        public var nextToken: String?

        public var total: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connections != nil {
                var tmp : [Any] = []
                for k in self.connections! {
                    tmp.append(k.toMap())
                }
                map["Connections"] = tmp
            }
            if self.maxResults != nil {
                map["MaxResults"] = self.maxResults!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Connections") {
                var tmp : [ListConnectionsResponseBody.Data.Connections] = []
                for v in dict["Connections"] as! [Any] {
                    var model = ListConnectionsResponseBody.Data.Connections()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.connections = tmp
            }
            if dict.keys.contains("MaxResults") {
                self.maxResults = dict["MaxResults"] as! Double
            }
            if dict.keys.contains("NextToken") {
                self.nextToken = dict["NextToken"] as! String
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Double
            }
        }
    }
    public var code: String?

    public var data: ListConnectionsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListConnectionsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListConnectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConnectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListConnectionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEventBusesRequest : Tea.TeaModel {
    public var limit: Int32?

    public var namePrefix: String?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.namePrefix != nil {
            map["NamePrefix"] = self.namePrefix!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! Int32
        }
        if dict.keys.contains("NamePrefix") {
            self.namePrefix = dict["NamePrefix"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
    }
}

public class ListEventBusesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EventBuses : Tea.TeaModel {
            public var createTimestamp: Int64?

            public var description_: String?

            public var eventBusARN: String?

            public var eventBusName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.eventBusARN != nil {
                    map["EventBusARN"] = self.eventBusARN!
                }
                if self.eventBusName != nil {
                    map["EventBusName"] = self.eventBusName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EventBusARN") {
                    self.eventBusARN = dict["EventBusARN"] as! String
                }
                if dict.keys.contains("EventBusName") {
                    self.eventBusName = dict["EventBusName"] as! String
                }
            }
        }
        public var eventBuses: [ListEventBusesResponseBody.Data.EventBuses]?

        public var nextToken: String?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventBuses != nil {
                var tmp : [Any] = []
                for k in self.eventBuses! {
                    tmp.append(k.toMap())
                }
                map["EventBuses"] = tmp
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventBuses") {
                var tmp : [ListEventBusesResponseBody.Data.EventBuses] = []
                for v in dict["EventBuses"] as! [Any] {
                    var model = ListEventBusesResponseBody.Data.EventBuses()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eventBuses = tmp
            }
            if dict.keys.contains("NextToken") {
                self.nextToken = dict["NextToken"] as! String
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListEventBusesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListEventBusesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListEventBusesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEventBusesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEventBusesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEventStreamingsRequest : Tea.TeaModel {
    public var limit: Int32?

    public var namePrefix: String?

    public var nextToken: String?

    public var sinkArn: String?

    public var sourceArn: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.namePrefix != nil {
            map["NamePrefix"] = self.namePrefix!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.sinkArn != nil {
            map["SinkArn"] = self.sinkArn!
        }
        if self.sourceArn != nil {
            map["SourceArn"] = self.sourceArn!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! Int32
        }
        if dict.keys.contains("NamePrefix") {
            self.namePrefix = dict["NamePrefix"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SinkArn") {
            self.sinkArn = dict["SinkArn"] as! String
        }
        if dict.keys.contains("SourceArn") {
            self.sourceArn = dict["SourceArn"] as! String
        }
    }
}

public class ListEventStreamingsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EventStreamings : Tea.TeaModel {
            public class RunOptions : Tea.TeaModel {
                public class BatchWindow : Tea.TeaModel {
                    public var countBasedWindow: Int32?

                    public var timeBasedWindow: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.countBasedWindow != nil {
                            map["CountBasedWindow"] = self.countBasedWindow!
                        }
                        if self.timeBasedWindow != nil {
                            map["TimeBasedWindow"] = self.timeBasedWindow!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CountBasedWindow") {
                            self.countBasedWindow = dict["CountBasedWindow"] as! Int32
                        }
                        if dict.keys.contains("TimeBasedWindow") {
                            self.timeBasedWindow = dict["TimeBasedWindow"] as! Int32
                        }
                    }
                }
                public class DeadLetterQueue : Tea.TeaModel {
                    public var arn: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.arn != nil {
                            map["Arn"] = self.arn!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Arn") {
                            self.arn = dict["Arn"] as! String
                        }
                    }
                }
                public class RetryStrategy : Tea.TeaModel {
                    public var maximumEventAgeInSeconds: Double?

                    public var maximumRetryAttempts: Double?

                    public var pushRetryStrategy: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.maximumEventAgeInSeconds != nil {
                            map["MaximumEventAgeInSeconds"] = self.maximumEventAgeInSeconds!
                        }
                        if self.maximumRetryAttempts != nil {
                            map["MaximumRetryAttempts"] = self.maximumRetryAttempts!
                        }
                        if self.pushRetryStrategy != nil {
                            map["PushRetryStrategy"] = self.pushRetryStrategy!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("MaximumEventAgeInSeconds") {
                            self.maximumEventAgeInSeconds = dict["MaximumEventAgeInSeconds"] as! Double
                        }
                        if dict.keys.contains("MaximumRetryAttempts") {
                            self.maximumRetryAttempts = dict["MaximumRetryAttempts"] as! Double
                        }
                        if dict.keys.contains("PushRetryStrategy") {
                            self.pushRetryStrategy = dict["PushRetryStrategy"] as! String
                        }
                    }
                }
                public var batchWindow: ListEventStreamingsResponseBody.Data.EventStreamings.RunOptions.BatchWindow?

                public var deadLetterQueue: ListEventStreamingsResponseBody.Data.EventStreamings.RunOptions.DeadLetterQueue?

                public var errorsTolerance: String?

                public var maximumTasks: Int32?

                public var retryStrategy: ListEventStreamingsResponseBody.Data.EventStreamings.RunOptions.RetryStrategy?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.batchWindow?.validate()
                    try self.deadLetterQueue?.validate()
                    try self.retryStrategy?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.batchWindow != nil {
                        map["BatchWindow"] = self.batchWindow?.toMap()
                    }
                    if self.deadLetterQueue != nil {
                        map["DeadLetterQueue"] = self.deadLetterQueue?.toMap()
                    }
                    if self.errorsTolerance != nil {
                        map["ErrorsTolerance"] = self.errorsTolerance!
                    }
                    if self.maximumTasks != nil {
                        map["MaximumTasks"] = self.maximumTasks!
                    }
                    if self.retryStrategy != nil {
                        map["RetryStrategy"] = self.retryStrategy?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BatchWindow") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.RunOptions.BatchWindow()
                        model.fromMap(dict["BatchWindow"] as! [String: Any])
                        self.batchWindow = model
                    }
                    if dict.keys.contains("DeadLetterQueue") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.RunOptions.DeadLetterQueue()
                        model.fromMap(dict["DeadLetterQueue"] as! [String: Any])
                        self.deadLetterQueue = model
                    }
                    if dict.keys.contains("ErrorsTolerance") {
                        self.errorsTolerance = dict["ErrorsTolerance"] as! String
                    }
                    if dict.keys.contains("MaximumTasks") {
                        self.maximumTasks = dict["MaximumTasks"] as! Int32
                    }
                    if dict.keys.contains("RetryStrategy") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.RunOptions.RetryStrategy()
                        model.fromMap(dict["RetryStrategy"] as! [String: Any])
                        self.retryStrategy = model
                    }
                }
            }
            public class Sink : Tea.TeaModel {
                public class SinkFcParameters : Tea.TeaModel {
                    public class Body : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class Concurrency : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class FunctionName : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class InvocationType : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class Qualifier : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class ServiceName : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public var body: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFcParameters.Body?

                    public var concurrency: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFcParameters.Concurrency?

                    public var functionName: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFcParameters.FunctionName?

                    public var invocationType: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFcParameters.InvocationType?

                    public var qualifier: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFcParameters.Qualifier?

                    public var serviceName: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFcParameters.ServiceName?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.body?.validate()
                        try self.concurrency?.validate()
                        try self.functionName?.validate()
                        try self.invocationType?.validate()
                        try self.qualifier?.validate()
                        try self.serviceName?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.body != nil {
                            map["Body"] = self.body?.toMap()
                        }
                        if self.concurrency != nil {
                            map["Concurrency"] = self.concurrency?.toMap()
                        }
                        if self.functionName != nil {
                            map["FunctionName"] = self.functionName?.toMap()
                        }
                        if self.invocationType != nil {
                            map["InvocationType"] = self.invocationType?.toMap()
                        }
                        if self.qualifier != nil {
                            map["Qualifier"] = self.qualifier?.toMap()
                        }
                        if self.serviceName != nil {
                            map["ServiceName"] = self.serviceName?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Body") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFcParameters.Body()
                            model.fromMap(dict["Body"] as! [String: Any])
                            self.body = model
                        }
                        if dict.keys.contains("Concurrency") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFcParameters.Concurrency()
                            model.fromMap(dict["Concurrency"] as! [String: Any])
                            self.concurrency = model
                        }
                        if dict.keys.contains("FunctionName") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFcParameters.FunctionName()
                            model.fromMap(dict["FunctionName"] as! [String: Any])
                            self.functionName = model
                        }
                        if dict.keys.contains("InvocationType") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFcParameters.InvocationType()
                            model.fromMap(dict["InvocationType"] as! [String: Any])
                            self.invocationType = model
                        }
                        if dict.keys.contains("Qualifier") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFcParameters.Qualifier()
                            model.fromMap(dict["Qualifier"] as! [String: Any])
                            self.qualifier = model
                        }
                        if dict.keys.contains("ServiceName") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFcParameters.ServiceName()
                            model.fromMap(dict["ServiceName"] as! [String: Any])
                            self.serviceName = model
                        }
                    }
                }
                public class SinkFnfParameters : Tea.TeaModel {
                    public class ExecutionName : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class FlowName : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class Input : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class RoleName : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public var executionName: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFnfParameters.ExecutionName?

                    public var flowName: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFnfParameters.FlowName?

                    public var input: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFnfParameters.Input?

                    public var roleName: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFnfParameters.RoleName?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.executionName?.validate()
                        try self.flowName?.validate()
                        try self.input?.validate()
                        try self.roleName?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.executionName != nil {
                            map["ExecutionName"] = self.executionName?.toMap()
                        }
                        if self.flowName != nil {
                            map["FlowName"] = self.flowName?.toMap()
                        }
                        if self.input != nil {
                            map["Input"] = self.input?.toMap()
                        }
                        if self.roleName != nil {
                            map["RoleName"] = self.roleName?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ExecutionName") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFnfParameters.ExecutionName()
                            model.fromMap(dict["ExecutionName"] as! [String: Any])
                            self.executionName = model
                        }
                        if dict.keys.contains("FlowName") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFnfParameters.FlowName()
                            model.fromMap(dict["FlowName"] as! [String: Any])
                            self.flowName = model
                        }
                        if dict.keys.contains("Input") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFnfParameters.Input()
                            model.fromMap(dict["Input"] as! [String: Any])
                            self.input = model
                        }
                        if dict.keys.contains("RoleName") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFnfParameters.RoleName()
                            model.fromMap(dict["RoleName"] as! [String: Any])
                            self.roleName = model
                        }
                    }
                }
                public class SinkKafkaParameters : Tea.TeaModel {
                    public class Acks : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class InstanceId : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class Key : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class Topic : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class Value : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public var acks: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkKafkaParameters.Acks?

                    public var instanceId: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkKafkaParameters.InstanceId?

                    public var key: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkKafkaParameters.Key?

                    public var topic: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkKafkaParameters.Topic?

                    public var value: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkKafkaParameters.Value?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.acks?.validate()
                        try self.instanceId?.validate()
                        try self.key?.validate()
                        try self.topic?.validate()
                        try self.value?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.acks != nil {
                            map["Acks"] = self.acks?.toMap()
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId?.toMap()
                        }
                        if self.key != nil {
                            map["Key"] = self.key?.toMap()
                        }
                        if self.topic != nil {
                            map["Topic"] = self.topic?.toMap()
                        }
                        if self.value != nil {
                            map["Value"] = self.value?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Acks") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkKafkaParameters.Acks()
                            model.fromMap(dict["Acks"] as! [String: Any])
                            self.acks = model
                        }
                        if dict.keys.contains("InstanceId") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkKafkaParameters.InstanceId()
                            model.fromMap(dict["InstanceId"] as! [String: Any])
                            self.instanceId = model
                        }
                        if dict.keys.contains("Key") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkKafkaParameters.Key()
                            model.fromMap(dict["Key"] as! [String: Any])
                            self.key = model
                        }
                        if dict.keys.contains("Topic") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkKafkaParameters.Topic()
                            model.fromMap(dict["Topic"] as! [String: Any])
                            self.topic = model
                        }
                        if dict.keys.contains("Value") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkKafkaParameters.Value()
                            model.fromMap(dict["Value"] as! [String: Any])
                            self.value = model
                        }
                    }
                }
                public class SinkMNSParameters : Tea.TeaModel {
                    public class Body : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class IsBase64Encode : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class QueueName : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public var body: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkMNSParameters.Body?

                    public var isBase64Encode: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkMNSParameters.IsBase64Encode?

                    public var queueName: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkMNSParameters.QueueName?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.body?.validate()
                        try self.isBase64Encode?.validate()
                        try self.queueName?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.body != nil {
                            map["Body"] = self.body?.toMap()
                        }
                        if self.isBase64Encode != nil {
                            map["IsBase64Encode"] = self.isBase64Encode?.toMap()
                        }
                        if self.queueName != nil {
                            map["QueueName"] = self.queueName?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Body") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkMNSParameters.Body()
                            model.fromMap(dict["Body"] as! [String: Any])
                            self.body = model
                        }
                        if dict.keys.contains("IsBase64Encode") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkMNSParameters.IsBase64Encode()
                            model.fromMap(dict["IsBase64Encode"] as! [String: Any])
                            self.isBase64Encode = model
                        }
                        if dict.keys.contains("QueueName") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkMNSParameters.QueueName()
                            model.fromMap(dict["QueueName"] as! [String: Any])
                            self.queueName = model
                        }
                    }
                }
                public class SinkRabbitMQParameters : Tea.TeaModel {
                    public class Body : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class Exchange : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class InstanceId : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class MessageId : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class Properties : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class QueueName : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class RoutingKey : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class TargetType : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class VirtualHostName : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public var body: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters.Body?

                    public var exchange: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters.Exchange?

                    public var instanceId: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters.InstanceId?

                    public var messageId: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters.MessageId?

                    public var properties: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters.Properties?

                    public var queueName: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters.QueueName?

                    public var routingKey: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters.RoutingKey?

                    public var targetType: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters.TargetType?

                    public var virtualHostName: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters.VirtualHostName?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.body?.validate()
                        try self.exchange?.validate()
                        try self.instanceId?.validate()
                        try self.messageId?.validate()
                        try self.properties?.validate()
                        try self.queueName?.validate()
                        try self.routingKey?.validate()
                        try self.targetType?.validate()
                        try self.virtualHostName?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.body != nil {
                            map["Body"] = self.body?.toMap()
                        }
                        if self.exchange != nil {
                            map["Exchange"] = self.exchange?.toMap()
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId?.toMap()
                        }
                        if self.messageId != nil {
                            map["MessageId"] = self.messageId?.toMap()
                        }
                        if self.properties != nil {
                            map["Properties"] = self.properties?.toMap()
                        }
                        if self.queueName != nil {
                            map["QueueName"] = self.queueName?.toMap()
                        }
                        if self.routingKey != nil {
                            map["RoutingKey"] = self.routingKey?.toMap()
                        }
                        if self.targetType != nil {
                            map["TargetType"] = self.targetType?.toMap()
                        }
                        if self.virtualHostName != nil {
                            map["VirtualHostName"] = self.virtualHostName?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Body") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters.Body()
                            model.fromMap(dict["Body"] as! [String: Any])
                            self.body = model
                        }
                        if dict.keys.contains("Exchange") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters.Exchange()
                            model.fromMap(dict["Exchange"] as! [String: Any])
                            self.exchange = model
                        }
                        if dict.keys.contains("InstanceId") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters.InstanceId()
                            model.fromMap(dict["InstanceId"] as! [String: Any])
                            self.instanceId = model
                        }
                        if dict.keys.contains("MessageId") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters.MessageId()
                            model.fromMap(dict["MessageId"] as! [String: Any])
                            self.messageId = model
                        }
                        if dict.keys.contains("Properties") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters.Properties()
                            model.fromMap(dict["Properties"] as! [String: Any])
                            self.properties = model
                        }
                        if dict.keys.contains("QueueName") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters.QueueName()
                            model.fromMap(dict["QueueName"] as! [String: Any])
                            self.queueName = model
                        }
                        if dict.keys.contains("RoutingKey") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters.RoutingKey()
                            model.fromMap(dict["RoutingKey"] as! [String: Any])
                            self.routingKey = model
                        }
                        if dict.keys.contains("TargetType") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters.TargetType()
                            model.fromMap(dict["TargetType"] as! [String: Any])
                            self.targetType = model
                        }
                        if dict.keys.contains("VirtualHostName") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters.VirtualHostName()
                            model.fromMap(dict["VirtualHostName"] as! [String: Any])
                            self.virtualHostName = model
                        }
                    }
                }
                public class SinkRocketMQParameters : Tea.TeaModel {
                    public class Body : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class InstanceId : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class Keys : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class Properties : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class Tags : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class Topic : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public var body: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRocketMQParameters.Body?

                    public var instanceId: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRocketMQParameters.InstanceId?

                    public var keys: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRocketMQParameters.Keys?

                    public var properties: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRocketMQParameters.Properties?

                    public var tags: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRocketMQParameters.Tags?

                    public var topic: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRocketMQParameters.Topic?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.body?.validate()
                        try self.instanceId?.validate()
                        try self.keys?.validate()
                        try self.properties?.validate()
                        try self.tags?.validate()
                        try self.topic?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.body != nil {
                            map["Body"] = self.body?.toMap()
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId?.toMap()
                        }
                        if self.keys != nil {
                            map["Keys"] = self.keys?.toMap()
                        }
                        if self.properties != nil {
                            map["Properties"] = self.properties?.toMap()
                        }
                        if self.tags != nil {
                            map["Tags"] = self.tags?.toMap()
                        }
                        if self.topic != nil {
                            map["Topic"] = self.topic?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Body") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRocketMQParameters.Body()
                            model.fromMap(dict["Body"] as! [String: Any])
                            self.body = model
                        }
                        if dict.keys.contains("InstanceId") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRocketMQParameters.InstanceId()
                            model.fromMap(dict["InstanceId"] as! [String: Any])
                            self.instanceId = model
                        }
                        if dict.keys.contains("Keys") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRocketMQParameters.Keys()
                            model.fromMap(dict["Keys"] as! [String: Any])
                            self.keys = model
                        }
                        if dict.keys.contains("Properties") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRocketMQParameters.Properties()
                            model.fromMap(dict["Properties"] as! [String: Any])
                            self.properties = model
                        }
                        if dict.keys.contains("Tags") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRocketMQParameters.Tags()
                            model.fromMap(dict["Tags"] as! [String: Any])
                            self.tags = model
                        }
                        if dict.keys.contains("Topic") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRocketMQParameters.Topic()
                            model.fromMap(dict["Topic"] as! [String: Any])
                            self.topic = model
                        }
                    }
                }
                public class SinkSLSParameters : Tea.TeaModel {
                    public class Body : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class LogStore : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class Project : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class RoleName : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class Topic : Tea.TeaModel {
                        public var form: String?

                        public var template: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.form != nil {
                                map["Form"] = self.form!
                            }
                            if self.template != nil {
                                map["Template"] = self.template!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Form") {
                                self.form = dict["Form"] as! String
                            }
                            if dict.keys.contains("Template") {
                                self.template = dict["Template"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public var body: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkSLSParameters.Body?

                    public var logStore: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkSLSParameters.LogStore?

                    public var project: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkSLSParameters.Project?

                    public var roleName: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkSLSParameters.RoleName?

                    public var topic: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkSLSParameters.Topic?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.body?.validate()
                        try self.logStore?.validate()
                        try self.project?.validate()
                        try self.roleName?.validate()
                        try self.topic?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.body != nil {
                            map["Body"] = self.body?.toMap()
                        }
                        if self.logStore != nil {
                            map["LogStore"] = self.logStore?.toMap()
                        }
                        if self.project != nil {
                            map["Project"] = self.project?.toMap()
                        }
                        if self.roleName != nil {
                            map["RoleName"] = self.roleName?.toMap()
                        }
                        if self.topic != nil {
                            map["Topic"] = self.topic?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Body") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkSLSParameters.Body()
                            model.fromMap(dict["Body"] as! [String: Any])
                            self.body = model
                        }
                        if dict.keys.contains("LogStore") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkSLSParameters.LogStore()
                            model.fromMap(dict["LogStore"] as! [String: Any])
                            self.logStore = model
                        }
                        if dict.keys.contains("Project") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkSLSParameters.Project()
                            model.fromMap(dict["Project"] as! [String: Any])
                            self.project = model
                        }
                        if dict.keys.contains("RoleName") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkSLSParameters.RoleName()
                            model.fromMap(dict["RoleName"] as! [String: Any])
                            self.roleName = model
                        }
                        if dict.keys.contains("Topic") {
                            var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkSLSParameters.Topic()
                            model.fromMap(dict["Topic"] as! [String: Any])
                            self.topic = model
                        }
                    }
                }
                public var sinkFcParameters: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFcParameters?

                public var sinkFnfParameters: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFnfParameters?

                public var sinkKafkaParameters: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkKafkaParameters?

                public var sinkMNSParameters: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkMNSParameters?

                public var sinkRabbitMQParameters: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters?

                public var sinkRocketMQParameters: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRocketMQParameters?

                public var sinkSLSParameters: ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkSLSParameters?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.sinkFcParameters?.validate()
                    try self.sinkFnfParameters?.validate()
                    try self.sinkKafkaParameters?.validate()
                    try self.sinkMNSParameters?.validate()
                    try self.sinkRabbitMQParameters?.validate()
                    try self.sinkRocketMQParameters?.validate()
                    try self.sinkSLSParameters?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.sinkFcParameters != nil {
                        map["SinkFcParameters"] = self.sinkFcParameters?.toMap()
                    }
                    if self.sinkFnfParameters != nil {
                        map["SinkFnfParameters"] = self.sinkFnfParameters?.toMap()
                    }
                    if self.sinkKafkaParameters != nil {
                        map["SinkKafkaParameters"] = self.sinkKafkaParameters?.toMap()
                    }
                    if self.sinkMNSParameters != nil {
                        map["SinkMNSParameters"] = self.sinkMNSParameters?.toMap()
                    }
                    if self.sinkRabbitMQParameters != nil {
                        map["SinkRabbitMQParameters"] = self.sinkRabbitMQParameters?.toMap()
                    }
                    if self.sinkRocketMQParameters != nil {
                        map["SinkRocketMQParameters"] = self.sinkRocketMQParameters?.toMap()
                    }
                    if self.sinkSLSParameters != nil {
                        map["SinkSLSParameters"] = self.sinkSLSParameters?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SinkFcParameters") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFcParameters()
                        model.fromMap(dict["SinkFcParameters"] as! [String: Any])
                        self.sinkFcParameters = model
                    }
                    if dict.keys.contains("SinkFnfParameters") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkFnfParameters()
                        model.fromMap(dict["SinkFnfParameters"] as! [String: Any])
                        self.sinkFnfParameters = model
                    }
                    if dict.keys.contains("SinkKafkaParameters") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkKafkaParameters()
                        model.fromMap(dict["SinkKafkaParameters"] as! [String: Any])
                        self.sinkKafkaParameters = model
                    }
                    if dict.keys.contains("SinkMNSParameters") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkMNSParameters()
                        model.fromMap(dict["SinkMNSParameters"] as! [String: Any])
                        self.sinkMNSParameters = model
                    }
                    if dict.keys.contains("SinkRabbitMQParameters") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRabbitMQParameters()
                        model.fromMap(dict["SinkRabbitMQParameters"] as! [String: Any])
                        self.sinkRabbitMQParameters = model
                    }
                    if dict.keys.contains("SinkRocketMQParameters") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkRocketMQParameters()
                        model.fromMap(dict["SinkRocketMQParameters"] as! [String: Any])
                        self.sinkRocketMQParameters = model
                    }
                    if dict.keys.contains("SinkSLSParameters") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink.SinkSLSParameters()
                        model.fromMap(dict["SinkSLSParameters"] as! [String: Any])
                        self.sinkSLSParameters = model
                    }
                }
            }
            public class Source : Tea.TeaModel {
                public class SourceApacheKafkaParameters : Tea.TeaModel {
                    public var bootstraps: String?

                    public var consumerGroup: String?

                    public var networkType: String?

                    public var offsetReset: String?

                    public var saslMechanism: String?

                    public var saslPassword: String?

                    public var saslUser: String?

                    public var securityGroupId: String?

                    public var securityProtocol: String?

                    public var topic: String?

                    public var vSwitchIds: String?

                    public var valueDataType: String?

                    public var vpcId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bootstraps != nil {
                            map["Bootstraps"] = self.bootstraps!
                        }
                        if self.consumerGroup != nil {
                            map["ConsumerGroup"] = self.consumerGroup!
                        }
                        if self.networkType != nil {
                            map["NetworkType"] = self.networkType!
                        }
                        if self.offsetReset != nil {
                            map["OffsetReset"] = self.offsetReset!
                        }
                        if self.saslMechanism != nil {
                            map["SaslMechanism"] = self.saslMechanism!
                        }
                        if self.saslPassword != nil {
                            map["SaslPassword"] = self.saslPassword!
                        }
                        if self.saslUser != nil {
                            map["SaslUser"] = self.saslUser!
                        }
                        if self.securityGroupId != nil {
                            map["SecurityGroupId"] = self.securityGroupId!
                        }
                        if self.securityProtocol != nil {
                            map["SecurityProtocol"] = self.securityProtocol!
                        }
                        if self.topic != nil {
                            map["Topic"] = self.topic!
                        }
                        if self.vSwitchIds != nil {
                            map["VSwitchIds"] = self.vSwitchIds!
                        }
                        if self.valueDataType != nil {
                            map["ValueDataType"] = self.valueDataType!
                        }
                        if self.vpcId != nil {
                            map["VpcId"] = self.vpcId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bootstraps") {
                            self.bootstraps = dict["Bootstraps"] as! String
                        }
                        if dict.keys.contains("ConsumerGroup") {
                            self.consumerGroup = dict["ConsumerGroup"] as! String
                        }
                        if dict.keys.contains("NetworkType") {
                            self.networkType = dict["NetworkType"] as! String
                        }
                        if dict.keys.contains("OffsetReset") {
                            self.offsetReset = dict["OffsetReset"] as! String
                        }
                        if dict.keys.contains("SaslMechanism") {
                            self.saslMechanism = dict["SaslMechanism"] as! String
                        }
                        if dict.keys.contains("SaslPassword") {
                            self.saslPassword = dict["SaslPassword"] as! String
                        }
                        if dict.keys.contains("SaslUser") {
                            self.saslUser = dict["SaslUser"] as! String
                        }
                        if dict.keys.contains("SecurityGroupId") {
                            self.securityGroupId = dict["SecurityGroupId"] as! String
                        }
                        if dict.keys.contains("SecurityProtocol") {
                            self.securityProtocol = dict["SecurityProtocol"] as! String
                        }
                        if dict.keys.contains("Topic") {
                            self.topic = dict["Topic"] as! String
                        }
                        if dict.keys.contains("VSwitchIds") {
                            self.vSwitchIds = dict["VSwitchIds"] as! String
                        }
                        if dict.keys.contains("ValueDataType") {
                            self.valueDataType = dict["ValueDataType"] as! String
                        }
                        if dict.keys.contains("VpcId") {
                            self.vpcId = dict["VpcId"] as! String
                        }
                    }
                }
                public class SourceDTSParameters : Tea.TeaModel {
                    public var brokerUrl: String?

                    public var initCheckPoint: String?

                    public var password: String?

                    public var sid: String?

                    public var taskId: String?

                    public var topic: String?

                    public var username: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.brokerUrl != nil {
                            map["BrokerUrl"] = self.brokerUrl!
                        }
                        if self.initCheckPoint != nil {
                            map["InitCheckPoint"] = self.initCheckPoint!
                        }
                        if self.password != nil {
                            map["Password"] = self.password!
                        }
                        if self.sid != nil {
                            map["Sid"] = self.sid!
                        }
                        if self.taskId != nil {
                            map["TaskId"] = self.taskId!
                        }
                        if self.topic != nil {
                            map["Topic"] = self.topic!
                        }
                        if self.username != nil {
                            map["Username"] = self.username!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("BrokerUrl") {
                            self.brokerUrl = dict["BrokerUrl"] as! String
                        }
                        if dict.keys.contains("InitCheckPoint") {
                            self.initCheckPoint = dict["InitCheckPoint"] as! String
                        }
                        if dict.keys.contains("Password") {
                            self.password = dict["Password"] as! String
                        }
                        if dict.keys.contains("Sid") {
                            self.sid = dict["Sid"] as! String
                        }
                        if dict.keys.contains("TaskId") {
                            self.taskId = dict["TaskId"] as! String
                        }
                        if dict.keys.contains("Topic") {
                            self.topic = dict["Topic"] as! String
                        }
                        if dict.keys.contains("Username") {
                            self.username = dict["Username"] as! String
                        }
                    }
                }
                public class SourceKafkaParameters : Tea.TeaModel {
                    public var consumerGroup: String?

                    public var instanceId: String?

                    public var network: String?

                    public var offsetReset: String?

                    public var regionId: String?

                    public var securityGroupId: String?

                    public var topic: String?

                    public var vSwitchIds: String?

                    public var vpcId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.consumerGroup != nil {
                            map["ConsumerGroup"] = self.consumerGroup!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.network != nil {
                            map["Network"] = self.network!
                        }
                        if self.offsetReset != nil {
                            map["OffsetReset"] = self.offsetReset!
                        }
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        if self.securityGroupId != nil {
                            map["SecurityGroupId"] = self.securityGroupId!
                        }
                        if self.topic != nil {
                            map["Topic"] = self.topic!
                        }
                        if self.vSwitchIds != nil {
                            map["VSwitchIds"] = self.vSwitchIds!
                        }
                        if self.vpcId != nil {
                            map["VpcId"] = self.vpcId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ConsumerGroup") {
                            self.consumerGroup = dict["ConsumerGroup"] as! String
                        }
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("Network") {
                            self.network = dict["Network"] as! String
                        }
                        if dict.keys.contains("OffsetReset") {
                            self.offsetReset = dict["OffsetReset"] as! String
                        }
                        if dict.keys.contains("RegionId") {
                            self.regionId = dict["RegionId"] as! String
                        }
                        if dict.keys.contains("SecurityGroupId") {
                            self.securityGroupId = dict["SecurityGroupId"] as! String
                        }
                        if dict.keys.contains("Topic") {
                            self.topic = dict["Topic"] as! String
                        }
                        if dict.keys.contains("VSwitchIds") {
                            self.vSwitchIds = dict["VSwitchIds"] as! String
                        }
                        if dict.keys.contains("VpcId") {
                            self.vpcId = dict["VpcId"] as! String
                        }
                    }
                }
                public class SourceMNSParameters : Tea.TeaModel {
                    public var isBase64Decode: Bool?

                    public var queueName: String?

                    public var regionId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.isBase64Decode != nil {
                            map["IsBase64Decode"] = self.isBase64Decode!
                        }
                        if self.queueName != nil {
                            map["QueueName"] = self.queueName!
                        }
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IsBase64Decode") {
                            self.isBase64Decode = dict["IsBase64Decode"] as! Bool
                        }
                        if dict.keys.contains("QueueName") {
                            self.queueName = dict["QueueName"] as! String
                        }
                        if dict.keys.contains("RegionId") {
                            self.regionId = dict["RegionId"] as! String
                        }
                    }
                }
                public class SourceMQTTParameters : Tea.TeaModel {
                    public var instanceId: String?

                    public var regionId: String?

                    public var topic: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        if self.topic != nil {
                            map["Topic"] = self.topic!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("RegionId") {
                            self.regionId = dict["RegionId"] as! String
                        }
                        if dict.keys.contains("Topic") {
                            self.topic = dict["Topic"] as! String
                        }
                    }
                }
                public class SourcePrometheusParameters : Tea.TeaModel {
                    public var clusterId: String?

                    public var dataType: String?

                    public var labels: String?

                    public var regionId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.clusterId != nil {
                            map["ClusterId"] = self.clusterId!
                        }
                        if self.dataType != nil {
                            map["DataType"] = self.dataType!
                        }
                        if self.labels != nil {
                            map["Labels"] = self.labels!
                        }
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ClusterId") {
                            self.clusterId = dict["ClusterId"] as! String
                        }
                        if dict.keys.contains("DataType") {
                            self.dataType = dict["DataType"] as! String
                        }
                        if dict.keys.contains("Labels") {
                            self.labels = dict["Labels"] as! String
                        }
                        if dict.keys.contains("RegionId") {
                            self.regionId = dict["RegionId"] as! String
                        }
                    }
                }
                public class SourceRabbitMQParameters : Tea.TeaModel {
                    public var instanceId: String?

                    public var queueName: String?

                    public var regionId: String?

                    public var virtualHostName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.queueName != nil {
                            map["QueueName"] = self.queueName!
                        }
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        if self.virtualHostName != nil {
                            map["VirtualHostName"] = self.virtualHostName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("QueueName") {
                            self.queueName = dict["QueueName"] as! String
                        }
                        if dict.keys.contains("RegionId") {
                            self.regionId = dict["RegionId"] as! String
                        }
                        if dict.keys.contains("VirtualHostName") {
                            self.virtualHostName = dict["VirtualHostName"] as! String
                        }
                    }
                }
                public class SourceRocketMQParameters : Tea.TeaModel {
                    public var authType: String?

                    public var bodyDataType: String?

                    public var groupID: String?

                    public var instanceEndpoint: String?

                    public var instanceId: String?

                    public var instanceNetwork: String?

                    public var instancePassword: String?

                    public var instanceSecurityGroupId: String?

                    public var instanceType: String?

                    public var instanceUsername: String?

                    public var instanceVSwitchIds: String?

                    public var instanceVpcId: String?

                    public var offset: String?

                    public var regionId: String?

                    public var tag: String?

                    public var timestamp: Int64?

                    public var topic: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.authType != nil {
                            map["AuthType"] = self.authType!
                        }
                        if self.bodyDataType != nil {
                            map["BodyDataType"] = self.bodyDataType!
                        }
                        if self.groupID != nil {
                            map["GroupID"] = self.groupID!
                        }
                        if self.instanceEndpoint != nil {
                            map["InstanceEndpoint"] = self.instanceEndpoint!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.instanceNetwork != nil {
                            map["InstanceNetwork"] = self.instanceNetwork!
                        }
                        if self.instancePassword != nil {
                            map["InstancePassword"] = self.instancePassword!
                        }
                        if self.instanceSecurityGroupId != nil {
                            map["InstanceSecurityGroupId"] = self.instanceSecurityGroupId!
                        }
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.instanceUsername != nil {
                            map["InstanceUsername"] = self.instanceUsername!
                        }
                        if self.instanceVSwitchIds != nil {
                            map["InstanceVSwitchIds"] = self.instanceVSwitchIds!
                        }
                        if self.instanceVpcId != nil {
                            map["InstanceVpcId"] = self.instanceVpcId!
                        }
                        if self.offset != nil {
                            map["Offset"] = self.offset!
                        }
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        if self.tag != nil {
                            map["Tag"] = self.tag!
                        }
                        if self.timestamp != nil {
                            map["Timestamp"] = self.timestamp!
                        }
                        if self.topic != nil {
                            map["Topic"] = self.topic!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AuthType") {
                            self.authType = dict["AuthType"] as! String
                        }
                        if dict.keys.contains("BodyDataType") {
                            self.bodyDataType = dict["BodyDataType"] as! String
                        }
                        if dict.keys.contains("GroupID") {
                            self.groupID = dict["GroupID"] as! String
                        }
                        if dict.keys.contains("InstanceEndpoint") {
                            self.instanceEndpoint = dict["InstanceEndpoint"] as! String
                        }
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("InstanceNetwork") {
                            self.instanceNetwork = dict["InstanceNetwork"] as! String
                        }
                        if dict.keys.contains("InstancePassword") {
                            self.instancePassword = dict["InstancePassword"] as! String
                        }
                        if dict.keys.contains("InstanceSecurityGroupId") {
                            self.instanceSecurityGroupId = dict["InstanceSecurityGroupId"] as! String
                        }
                        if dict.keys.contains("InstanceType") {
                            self.instanceType = dict["InstanceType"] as! String
                        }
                        if dict.keys.contains("InstanceUsername") {
                            self.instanceUsername = dict["InstanceUsername"] as! String
                        }
                        if dict.keys.contains("InstanceVSwitchIds") {
                            self.instanceVSwitchIds = dict["InstanceVSwitchIds"] as! String
                        }
                        if dict.keys.contains("InstanceVpcId") {
                            self.instanceVpcId = dict["InstanceVpcId"] as! String
                        }
                        if dict.keys.contains("Offset") {
                            self.offset = dict["Offset"] as! String
                        }
                        if dict.keys.contains("RegionId") {
                            self.regionId = dict["RegionId"] as! String
                        }
                        if dict.keys.contains("Tag") {
                            self.tag = dict["Tag"] as! String
                        }
                        if dict.keys.contains("Timestamp") {
                            self.timestamp = dict["Timestamp"] as! Int64
                        }
                        if dict.keys.contains("Topic") {
                            self.topic = dict["Topic"] as! String
                        }
                    }
                }
                public class SourceSLSParameters : Tea.TeaModel {
                    public var consumePosition: String?

                    public var consumerGroup: String?

                    public var logStore: String?

                    public var project: String?

                    public var roleName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.consumePosition != nil {
                            map["ConsumePosition"] = self.consumePosition!
                        }
                        if self.consumerGroup != nil {
                            map["ConsumerGroup"] = self.consumerGroup!
                        }
                        if self.logStore != nil {
                            map["LogStore"] = self.logStore!
                        }
                        if self.project != nil {
                            map["Project"] = self.project!
                        }
                        if self.roleName != nil {
                            map["RoleName"] = self.roleName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ConsumePosition") {
                            self.consumePosition = dict["ConsumePosition"] as! String
                        }
                        if dict.keys.contains("ConsumerGroup") {
                            self.consumerGroup = dict["ConsumerGroup"] as! String
                        }
                        if dict.keys.contains("LogStore") {
                            self.logStore = dict["LogStore"] as! String
                        }
                        if dict.keys.contains("Project") {
                            self.project = dict["Project"] as! String
                        }
                        if dict.keys.contains("RoleName") {
                            self.roleName = dict["RoleName"] as! String
                        }
                    }
                }
                public var sourceApacheKafkaParameters: ListEventStreamingsResponseBody.Data.EventStreamings.Source.SourceApacheKafkaParameters?

                public var sourceDTSParameters: ListEventStreamingsResponseBody.Data.EventStreamings.Source.SourceDTSParameters?

                public var sourceKafkaParameters: ListEventStreamingsResponseBody.Data.EventStreamings.Source.SourceKafkaParameters?

                public var sourceMNSParameters: ListEventStreamingsResponseBody.Data.EventStreamings.Source.SourceMNSParameters?

                public var sourceMQTTParameters: ListEventStreamingsResponseBody.Data.EventStreamings.Source.SourceMQTTParameters?

                public var sourcePrometheusParameters: ListEventStreamingsResponseBody.Data.EventStreamings.Source.SourcePrometheusParameters?

                public var sourceRabbitMQParameters: ListEventStreamingsResponseBody.Data.EventStreamings.Source.SourceRabbitMQParameters?

                public var sourceRocketMQParameters: ListEventStreamingsResponseBody.Data.EventStreamings.Source.SourceRocketMQParameters?

                public var sourceSLSParameters: ListEventStreamingsResponseBody.Data.EventStreamings.Source.SourceSLSParameters?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.sourceApacheKafkaParameters?.validate()
                    try self.sourceDTSParameters?.validate()
                    try self.sourceKafkaParameters?.validate()
                    try self.sourceMNSParameters?.validate()
                    try self.sourceMQTTParameters?.validate()
                    try self.sourcePrometheusParameters?.validate()
                    try self.sourceRabbitMQParameters?.validate()
                    try self.sourceRocketMQParameters?.validate()
                    try self.sourceSLSParameters?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.sourceApacheKafkaParameters != nil {
                        map["SourceApacheKafkaParameters"] = self.sourceApacheKafkaParameters?.toMap()
                    }
                    if self.sourceDTSParameters != nil {
                        map["SourceDTSParameters"] = self.sourceDTSParameters?.toMap()
                    }
                    if self.sourceKafkaParameters != nil {
                        map["SourceKafkaParameters"] = self.sourceKafkaParameters?.toMap()
                    }
                    if self.sourceMNSParameters != nil {
                        map["SourceMNSParameters"] = self.sourceMNSParameters?.toMap()
                    }
                    if self.sourceMQTTParameters != nil {
                        map["SourceMQTTParameters"] = self.sourceMQTTParameters?.toMap()
                    }
                    if self.sourcePrometheusParameters != nil {
                        map["SourcePrometheusParameters"] = self.sourcePrometheusParameters?.toMap()
                    }
                    if self.sourceRabbitMQParameters != nil {
                        map["SourceRabbitMQParameters"] = self.sourceRabbitMQParameters?.toMap()
                    }
                    if self.sourceRocketMQParameters != nil {
                        map["SourceRocketMQParameters"] = self.sourceRocketMQParameters?.toMap()
                    }
                    if self.sourceSLSParameters != nil {
                        map["SourceSLSParameters"] = self.sourceSLSParameters?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SourceApacheKafkaParameters") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.Source.SourceApacheKafkaParameters()
                        model.fromMap(dict["SourceApacheKafkaParameters"] as! [String: Any])
                        self.sourceApacheKafkaParameters = model
                    }
                    if dict.keys.contains("SourceDTSParameters") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.Source.SourceDTSParameters()
                        model.fromMap(dict["SourceDTSParameters"] as! [String: Any])
                        self.sourceDTSParameters = model
                    }
                    if dict.keys.contains("SourceKafkaParameters") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.Source.SourceKafkaParameters()
                        model.fromMap(dict["SourceKafkaParameters"] as! [String: Any])
                        self.sourceKafkaParameters = model
                    }
                    if dict.keys.contains("SourceMNSParameters") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.Source.SourceMNSParameters()
                        model.fromMap(dict["SourceMNSParameters"] as! [String: Any])
                        self.sourceMNSParameters = model
                    }
                    if dict.keys.contains("SourceMQTTParameters") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.Source.SourceMQTTParameters()
                        model.fromMap(dict["SourceMQTTParameters"] as! [String: Any])
                        self.sourceMQTTParameters = model
                    }
                    if dict.keys.contains("SourcePrometheusParameters") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.Source.SourcePrometheusParameters()
                        model.fromMap(dict["SourcePrometheusParameters"] as! [String: Any])
                        self.sourcePrometheusParameters = model
                    }
                    if dict.keys.contains("SourceRabbitMQParameters") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.Source.SourceRabbitMQParameters()
                        model.fromMap(dict["SourceRabbitMQParameters"] as! [String: Any])
                        self.sourceRabbitMQParameters = model
                    }
                    if dict.keys.contains("SourceRocketMQParameters") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.Source.SourceRocketMQParameters()
                        model.fromMap(dict["SourceRocketMQParameters"] as! [String: Any])
                        self.sourceRocketMQParameters = model
                    }
                    if dict.keys.contains("SourceSLSParameters") {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.Source.SourceSLSParameters()
                        model.fromMap(dict["SourceSLSParameters"] as! [String: Any])
                        self.sourceSLSParameters = model
                    }
                }
            }
            public class Transforms : Tea.TeaModel {
                public var arn: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.arn != nil {
                        map["Arn"] = self.arn!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Arn") {
                        self.arn = dict["Arn"] as! String
                    }
                }
            }
            public var description_: String?

            public var eventStreamingName: String?

            public var filterPattern: String?

            public var runOptions: ListEventStreamingsResponseBody.Data.EventStreamings.RunOptions?

            public var sink: ListEventStreamingsResponseBody.Data.EventStreamings.Sink?

            public var source: ListEventStreamingsResponseBody.Data.EventStreamings.Source?

            public var status: String?

            public var transforms: [ListEventStreamingsResponseBody.Data.EventStreamings.Transforms]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.runOptions?.validate()
                try self.sink?.validate()
                try self.source?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.eventStreamingName != nil {
                    map["EventStreamingName"] = self.eventStreamingName!
                }
                if self.filterPattern != nil {
                    map["FilterPattern"] = self.filterPattern!
                }
                if self.runOptions != nil {
                    map["RunOptions"] = self.runOptions?.toMap()
                }
                if self.sink != nil {
                    map["Sink"] = self.sink?.toMap()
                }
                if self.source != nil {
                    map["Source"] = self.source?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.transforms != nil {
                    var tmp : [Any] = []
                    for k in self.transforms! {
                        tmp.append(k.toMap())
                    }
                    map["Transforms"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EventStreamingName") {
                    self.eventStreamingName = dict["EventStreamingName"] as! String
                }
                if dict.keys.contains("FilterPattern") {
                    self.filterPattern = dict["FilterPattern"] as! String
                }
                if dict.keys.contains("RunOptions") {
                    var model = ListEventStreamingsResponseBody.Data.EventStreamings.RunOptions()
                    model.fromMap(dict["RunOptions"] as! [String: Any])
                    self.runOptions = model
                }
                if dict.keys.contains("Sink") {
                    var model = ListEventStreamingsResponseBody.Data.EventStreamings.Sink()
                    model.fromMap(dict["Sink"] as! [String: Any])
                    self.sink = model
                }
                if dict.keys.contains("Source") {
                    var model = ListEventStreamingsResponseBody.Data.EventStreamings.Source()
                    model.fromMap(dict["Source"] as! [String: Any])
                    self.source = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Transforms") {
                    var tmp : [ListEventStreamingsResponseBody.Data.EventStreamings.Transforms] = []
                    for v in dict["Transforms"] as! [Any] {
                        var model = ListEventStreamingsResponseBody.Data.EventStreamings.Transforms()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.transforms = tmp
                }
            }
        }
        public var eventStreamings: [ListEventStreamingsResponseBody.Data.EventStreamings]?

        public var nextToken: String?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventStreamings != nil {
                var tmp : [Any] = []
                for k in self.eventStreamings! {
                    tmp.append(k.toMap())
                }
                map["EventStreamings"] = tmp
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventStreamings") {
                var tmp : [ListEventStreamingsResponseBody.Data.EventStreamings] = []
                for v in dict["EventStreamings"] as! [Any] {
                    var model = ListEventStreamingsResponseBody.Data.EventStreamings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eventStreamings = tmp
            }
            if dict.keys.contains("NextToken") {
                self.nextToken = dict["NextToken"] as! String
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListEventStreamingsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListEventStreamingsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListEventStreamingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEventStreamingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEventStreamingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRulesRequest : Tea.TeaModel {
    public var eventBusName: String?

    public var limit: Int32?

    public var nextToken: String?

    public var ruleNamePrefix: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ruleNamePrefix != nil {
            map["RuleNamePrefix"] = self.ruleNamePrefix!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RuleNamePrefix") {
            self.ruleNamePrefix = dict["RuleNamePrefix"] as! String
        }
    }
}

public class ListRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Rules : Tea.TeaModel {
            public class Targets : Tea.TeaModel {
                public var endpoint: String?

                public var errorsTolerance: String?

                public var id: String?

                public var pushSelector: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endpoint != nil {
                        map["Endpoint"] = self.endpoint!
                    }
                    if self.errorsTolerance != nil {
                        map["ErrorsTolerance"] = self.errorsTolerance!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.pushSelector != nil {
                        map["PushSelector"] = self.pushSelector!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Endpoint") {
                        self.endpoint = dict["Endpoint"] as! String
                    }
                    if dict.keys.contains("ErrorsTolerance") {
                        self.errorsTolerance = dict["ErrorsTolerance"] as! String
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("PushSelector") {
                        self.pushSelector = dict["PushSelector"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var createdTimestamp: Int64?

            public var description_: String?

            public var detailMap: [String: Any]?

            public var eventBusName: String?

            public var filterPattern: String?

            public var ruleARN: String?

            public var ruleName: String?

            public var status: String?

            public var targets: [ListRulesResponseBody.Data.Rules.Targets]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createdTimestamp != nil {
                    map["CreatedTimestamp"] = self.createdTimestamp!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.detailMap != nil {
                    map["DetailMap"] = self.detailMap!
                }
                if self.eventBusName != nil {
                    map["EventBusName"] = self.eventBusName!
                }
                if self.filterPattern != nil {
                    map["FilterPattern"] = self.filterPattern!
                }
                if self.ruleARN != nil {
                    map["RuleARN"] = self.ruleARN!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.targets != nil {
                    var tmp : [Any] = []
                    for k in self.targets! {
                        tmp.append(k.toMap())
                    }
                    map["Targets"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatedTimestamp") {
                    self.createdTimestamp = dict["CreatedTimestamp"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DetailMap") {
                    self.detailMap = dict["DetailMap"] as! [String: Any]
                }
                if dict.keys.contains("EventBusName") {
                    self.eventBusName = dict["EventBusName"] as! String
                }
                if dict.keys.contains("FilterPattern") {
                    self.filterPattern = dict["FilterPattern"] as! String
                }
                if dict.keys.contains("RuleARN") {
                    self.ruleARN = dict["RuleARN"] as! String
                }
                if dict.keys.contains("RuleName") {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Targets") {
                    var tmp : [ListRulesResponseBody.Data.Rules.Targets] = []
                    for v in dict["Targets"] as! [Any] {
                        var model = ListRulesResponseBody.Data.Rules.Targets()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.targets = tmp
                }
            }
        }
        public var nextToken: String?

        public var rules: [ListRulesResponseBody.Data.Rules]?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.rules != nil {
                var tmp : [Any] = []
                for k in self.rules! {
                    tmp.append(k.toMap())
                }
                map["Rules"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NextToken") {
                self.nextToken = dict["NextToken"] as! String
            }
            if dict.keys.contains("Rules") {
                var tmp : [ListRulesResponseBody.Data.Rules] = []
                for v in dict["Rules"] as! [Any] {
                    var model = ListRulesResponseBody.Data.Rules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.rules = tmp
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListRulesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListRulesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTargetsRequest : Tea.TeaModel {
    public var arn: String?

    public var eventBusName: String?

    public var limit: Int32?

    public var nextToken: String?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arn != nil {
            map["Arn"] = self.arn!
        }
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Arn") {
            self.arn = dict["Arn"] as! String
        }
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
    }
}

public class ListTargetsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Targets : Tea.TeaModel {
            public class ParamList : Tea.TeaModel {
                public var form: String?

                public var resourceKey: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.resourceKey != nil {
                        map["ResourceKey"] = self.resourceKey!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("ResourceKey") {
                        self.resourceKey = dict["ResourceKey"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var endpoint: String?

            public var errorsTolerance: String?

            public var eventBusName: String?

            public var id: String?

            public var paramList: [ListTargetsResponseBody.Data.Targets.ParamList]?

            public var ruleName: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.errorsTolerance != nil {
                    map["ErrorsTolerance"] = self.errorsTolerance!
                }
                if self.eventBusName != nil {
                    map["EventBusName"] = self.eventBusName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.paramList != nil {
                    var tmp : [Any] = []
                    for k in self.paramList! {
                        tmp.append(k.toMap())
                    }
                    map["ParamList"] = tmp
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Endpoint") {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("ErrorsTolerance") {
                    self.errorsTolerance = dict["ErrorsTolerance"] as! String
                }
                if dict.keys.contains("EventBusName") {
                    self.eventBusName = dict["EventBusName"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("ParamList") {
                    var tmp : [ListTargetsResponseBody.Data.Targets.ParamList] = []
                    for v in dict["ParamList"] as! [Any] {
                        var model = ListTargetsResponseBody.Data.Targets.ParamList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.paramList = tmp
                }
                if dict.keys.contains("RuleName") {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var nextToken: String?

        public var targets: [ListTargetsResponseBody.Data.Targets]?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.targets != nil {
                var tmp : [Any] = []
                for k in self.targets! {
                    tmp.append(k.toMap())
                }
                map["Targets"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NextToken") {
                self.nextToken = dict["NextToken"] as! String
            }
            if dict.keys.contains("Targets") {
                var tmp : [ListTargetsResponseBody.Data.Targets] = []
                for v in dict["Targets"] as! [Any] {
                    var model = ListTargetsResponseBody.Data.Targets()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.targets = tmp
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListTargetsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListTargetsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListTargetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTargetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTargetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUserDefinedEventSourcesRequest : Tea.TeaModel {
    public var eventBusName: String?

    public var limit: Int32?

    public var namePrefix: String?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.namePrefix != nil {
            map["NamePrefix"] = self.namePrefix!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! Int32
        }
        if dict.keys.contains("NamePrefix") {
            self.namePrefix = dict["NamePrefix"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
    }
}

public class ListUserDefinedEventSourcesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EventSourceList : Tea.TeaModel {
            public class SourceHttpEventParameters : Tea.TeaModel {
                public var ip: [String]?

                public var method: [String]?

                public var publicWebHookUrl: [String]?

                public var referer: [String]?

                public var securityConfig: String?

                public var type: String?

                public var vpcWebHookUrl: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    if self.method != nil {
                        map["Method"] = self.method!
                    }
                    if self.publicWebHookUrl != nil {
                        map["PublicWebHookUrl"] = self.publicWebHookUrl!
                    }
                    if self.referer != nil {
                        map["Referer"] = self.referer!
                    }
                    if self.securityConfig != nil {
                        map["SecurityConfig"] = self.securityConfig!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.vpcWebHookUrl != nil {
                        map["VpcWebHookUrl"] = self.vpcWebHookUrl!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ip") {
                        self.ip = dict["Ip"] as! [String]
                    }
                    if dict.keys.contains("Method") {
                        self.method = dict["Method"] as! [String]
                    }
                    if dict.keys.contains("PublicWebHookUrl") {
                        self.publicWebHookUrl = dict["PublicWebHookUrl"] as! [String]
                    }
                    if dict.keys.contains("Referer") {
                        self.referer = dict["Referer"] as! [String]
                    }
                    if dict.keys.contains("SecurityConfig") {
                        self.securityConfig = dict["SecurityConfig"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("VpcWebHookUrl") {
                        self.vpcWebHookUrl = dict["VpcWebHookUrl"] as! [String]
                    }
                }
            }
            public class SourceKafkaParameters : Tea.TeaModel {
                public var consumerGroup: String?

                public var instanceId: String?

                public var maximumTasks: Int32?

                public var network: String?

                public var offsetReset: String?

                public var regionId: String?

                public var securityGroupId: String?

                public var topic: String?

                public var vSwitchIds: String?

                public var vpcId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.consumerGroup != nil {
                        map["ConsumerGroup"] = self.consumerGroup!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.maximumTasks != nil {
                        map["MaximumTasks"] = self.maximumTasks!
                    }
                    if self.network != nil {
                        map["Network"] = self.network!
                    }
                    if self.offsetReset != nil {
                        map["OffsetReset"] = self.offsetReset!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    if self.securityGroupId != nil {
                        map["SecurityGroupId"] = self.securityGroupId!
                    }
                    if self.topic != nil {
                        map["Topic"] = self.topic!
                    }
                    if self.vSwitchIds != nil {
                        map["VSwitchIds"] = self.vSwitchIds!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConsumerGroup") {
                        self.consumerGroup = dict["ConsumerGroup"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("MaximumTasks") {
                        self.maximumTasks = dict["MaximumTasks"] as! Int32
                    }
                    if dict.keys.contains("Network") {
                        self.network = dict["Network"] as! String
                    }
                    if dict.keys.contains("OffsetReset") {
                        self.offsetReset = dict["OffsetReset"] as! String
                    }
                    if dict.keys.contains("RegionId") {
                        self.regionId = dict["RegionId"] as! String
                    }
                    if dict.keys.contains("SecurityGroupId") {
                        self.securityGroupId = dict["SecurityGroupId"] as! String
                    }
                    if dict.keys.contains("Topic") {
                        self.topic = dict["Topic"] as! String
                    }
                    if dict.keys.contains("VSwitchIds") {
                        self.vSwitchIds = dict["VSwitchIds"] as! String
                    }
                    if dict.keys.contains("VpcId") {
                        self.vpcId = dict["VpcId"] as! String
                    }
                }
            }
            public class SourceMNSParameters : Tea.TeaModel {
                public var isBase64Decode: Bool?

                public var queueName: String?

                public var regionId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.isBase64Decode != nil {
                        map["IsBase64Decode"] = self.isBase64Decode!
                    }
                    if self.queueName != nil {
                        map["QueueName"] = self.queueName!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IsBase64Decode") {
                        self.isBase64Decode = dict["IsBase64Decode"] as! Bool
                    }
                    if dict.keys.contains("QueueName") {
                        self.queueName = dict["QueueName"] as! String
                    }
                    if dict.keys.contains("RegionId") {
                        self.regionId = dict["RegionId"] as! String
                    }
                }
            }
            public class SourceRabbitMQParameters : Tea.TeaModel {
                public var instanceId: String?

                public var queueName: String?

                public var regionId: String?

                public var virtualHostName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.queueName != nil {
                        map["QueueName"] = self.queueName!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    if self.virtualHostName != nil {
                        map["VirtualHostName"] = self.virtualHostName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("QueueName") {
                        self.queueName = dict["QueueName"] as! String
                    }
                    if dict.keys.contains("RegionId") {
                        self.regionId = dict["RegionId"] as! String
                    }
                    if dict.keys.contains("VirtualHostName") {
                        self.virtualHostName = dict["VirtualHostName"] as! String
                    }
                }
            }
            public class SourceRocketMQParameters : Tea.TeaModel {
                public var authType: String?

                public var groupId: String?

                public var instanceEndpoint: String?

                public var instanceId: String?

                public var instanceNetwork: String?

                public var instancePassword: String?

                public var instanceSecurityGroupId: String?

                public var instanceType: String?

                public var instanceUsername: String?

                public var instanceVSwitchIds: String?

                public var instanceVpcId: String?

                public var offset: String?

                public var regionId: String?

                public var tag: String?

                public var timestamp: Double?

                public var topic: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.authType != nil {
                        map["AuthType"] = self.authType!
                    }
                    if self.groupId != nil {
                        map["GroupId"] = self.groupId!
                    }
                    if self.instanceEndpoint != nil {
                        map["InstanceEndpoint"] = self.instanceEndpoint!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.instanceNetwork != nil {
                        map["InstanceNetwork"] = self.instanceNetwork!
                    }
                    if self.instancePassword != nil {
                        map["InstancePassword"] = self.instancePassword!
                    }
                    if self.instanceSecurityGroupId != nil {
                        map["InstanceSecurityGroupId"] = self.instanceSecurityGroupId!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.instanceUsername != nil {
                        map["InstanceUsername"] = self.instanceUsername!
                    }
                    if self.instanceVSwitchIds != nil {
                        map["InstanceVSwitchIds"] = self.instanceVSwitchIds!
                    }
                    if self.instanceVpcId != nil {
                        map["InstanceVpcId"] = self.instanceVpcId!
                    }
                    if self.offset != nil {
                        map["Offset"] = self.offset!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    if self.tag != nil {
                        map["Tag"] = self.tag!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.topic != nil {
                        map["Topic"] = self.topic!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AuthType") {
                        self.authType = dict["AuthType"] as! String
                    }
                    if dict.keys.contains("GroupId") {
                        self.groupId = dict["GroupId"] as! String
                    }
                    if dict.keys.contains("InstanceEndpoint") {
                        self.instanceEndpoint = dict["InstanceEndpoint"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("InstanceNetwork") {
                        self.instanceNetwork = dict["InstanceNetwork"] as! String
                    }
                    if dict.keys.contains("InstancePassword") {
                        self.instancePassword = dict["InstancePassword"] as! String
                    }
                    if dict.keys.contains("InstanceSecurityGroupId") {
                        self.instanceSecurityGroupId = dict["InstanceSecurityGroupId"] as! String
                    }
                    if dict.keys.contains("InstanceType") {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                    if dict.keys.contains("InstanceUsername") {
                        self.instanceUsername = dict["InstanceUsername"] as! String
                    }
                    if dict.keys.contains("InstanceVSwitchIds") {
                        self.instanceVSwitchIds = dict["InstanceVSwitchIds"] as! String
                    }
                    if dict.keys.contains("InstanceVpcId") {
                        self.instanceVpcId = dict["InstanceVpcId"] as! String
                    }
                    if dict.keys.contains("Offset") {
                        self.offset = dict["Offset"] as! String
                    }
                    if dict.keys.contains("RegionId") {
                        self.regionId = dict["RegionId"] as! String
                    }
                    if dict.keys.contains("Tag") {
                        self.tag = dict["Tag"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Double
                    }
                    if dict.keys.contains("Topic") {
                        self.topic = dict["Topic"] as! String
                    }
                }
            }
            public class SourceSLSParameters : Tea.TeaModel {
                public var consumePosition: String?

                public var logStore: String?

                public var project: String?

                public var roleName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.consumePosition != nil {
                        map["ConsumePosition"] = self.consumePosition!
                    }
                    if self.logStore != nil {
                        map["LogStore"] = self.logStore!
                    }
                    if self.project != nil {
                        map["Project"] = self.project!
                    }
                    if self.roleName != nil {
                        map["RoleName"] = self.roleName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConsumePosition") {
                        self.consumePosition = dict["ConsumePosition"] as! String
                    }
                    if dict.keys.contains("LogStore") {
                        self.logStore = dict["LogStore"] as! String
                    }
                    if dict.keys.contains("Project") {
                        self.project = dict["Project"] as! String
                    }
                    if dict.keys.contains("RoleName") {
                        self.roleName = dict["RoleName"] as! String
                    }
                }
            }
            public class SourceScheduledEventParameters : Tea.TeaModel {
                public var schedule: String?

                public var timeZone: String?

                public var userData: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.schedule != nil {
                        map["Schedule"] = self.schedule!
                    }
                    if self.timeZone != nil {
                        map["TimeZone"] = self.timeZone!
                    }
                    if self.userData != nil {
                        map["UserData"] = self.userData!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Schedule") {
                        self.schedule = dict["Schedule"] as! String
                    }
                    if dict.keys.contains("TimeZone") {
                        self.timeZone = dict["TimeZone"] as! String
                    }
                    if dict.keys.contains("UserData") {
                        self.userData = dict["UserData"] as! String
                    }
                }
            }
            public var arn: String?

            public var ctime: Double?

            public var eventBusName: String?

            public var externalSourceType: String?

            public var name: String?

            public var sourceHttpEventParameters: ListUserDefinedEventSourcesResponseBody.Data.EventSourceList.SourceHttpEventParameters?

            public var sourceKafkaParameters: ListUserDefinedEventSourcesResponseBody.Data.EventSourceList.SourceKafkaParameters?

            public var sourceMNSParameters: ListUserDefinedEventSourcesResponseBody.Data.EventSourceList.SourceMNSParameters?

            public var sourceRabbitMQParameters: ListUserDefinedEventSourcesResponseBody.Data.EventSourceList.SourceRabbitMQParameters?

            public var sourceRocketMQParameters: ListUserDefinedEventSourcesResponseBody.Data.EventSourceList.SourceRocketMQParameters?

            public var sourceSLSParameters: ListUserDefinedEventSourcesResponseBody.Data.EventSourceList.SourceSLSParameters?

            public var sourceScheduledEventParameters: ListUserDefinedEventSourcesResponseBody.Data.EventSourceList.SourceScheduledEventParameters?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.sourceHttpEventParameters?.validate()
                try self.sourceKafkaParameters?.validate()
                try self.sourceMNSParameters?.validate()
                try self.sourceRabbitMQParameters?.validate()
                try self.sourceRocketMQParameters?.validate()
                try self.sourceSLSParameters?.validate()
                try self.sourceScheduledEventParameters?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.arn != nil {
                    map["Arn"] = self.arn!
                }
                if self.ctime != nil {
                    map["Ctime"] = self.ctime!
                }
                if self.eventBusName != nil {
                    map["EventBusName"] = self.eventBusName!
                }
                if self.externalSourceType != nil {
                    map["ExternalSourceType"] = self.externalSourceType!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.sourceHttpEventParameters != nil {
                    map["SourceHttpEventParameters"] = self.sourceHttpEventParameters?.toMap()
                }
                if self.sourceKafkaParameters != nil {
                    map["SourceKafkaParameters"] = self.sourceKafkaParameters?.toMap()
                }
                if self.sourceMNSParameters != nil {
                    map["SourceMNSParameters"] = self.sourceMNSParameters?.toMap()
                }
                if self.sourceRabbitMQParameters != nil {
                    map["SourceRabbitMQParameters"] = self.sourceRabbitMQParameters?.toMap()
                }
                if self.sourceRocketMQParameters != nil {
                    map["SourceRocketMQParameters"] = self.sourceRocketMQParameters?.toMap()
                }
                if self.sourceSLSParameters != nil {
                    map["SourceSLSParameters"] = self.sourceSLSParameters?.toMap()
                }
                if self.sourceScheduledEventParameters != nil {
                    map["SourceScheduledEventParameters"] = self.sourceScheduledEventParameters?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Arn") {
                    self.arn = dict["Arn"] as! String
                }
                if dict.keys.contains("Ctime") {
                    self.ctime = dict["Ctime"] as! Double
                }
                if dict.keys.contains("EventBusName") {
                    self.eventBusName = dict["EventBusName"] as! String
                }
                if dict.keys.contains("ExternalSourceType") {
                    self.externalSourceType = dict["ExternalSourceType"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SourceHttpEventParameters") {
                    var model = ListUserDefinedEventSourcesResponseBody.Data.EventSourceList.SourceHttpEventParameters()
                    model.fromMap(dict["SourceHttpEventParameters"] as! [String: Any])
                    self.sourceHttpEventParameters = model
                }
                if dict.keys.contains("SourceKafkaParameters") {
                    var model = ListUserDefinedEventSourcesResponseBody.Data.EventSourceList.SourceKafkaParameters()
                    model.fromMap(dict["SourceKafkaParameters"] as! [String: Any])
                    self.sourceKafkaParameters = model
                }
                if dict.keys.contains("SourceMNSParameters") {
                    var model = ListUserDefinedEventSourcesResponseBody.Data.EventSourceList.SourceMNSParameters()
                    model.fromMap(dict["SourceMNSParameters"] as! [String: Any])
                    self.sourceMNSParameters = model
                }
                if dict.keys.contains("SourceRabbitMQParameters") {
                    var model = ListUserDefinedEventSourcesResponseBody.Data.EventSourceList.SourceRabbitMQParameters()
                    model.fromMap(dict["SourceRabbitMQParameters"] as! [String: Any])
                    self.sourceRabbitMQParameters = model
                }
                if dict.keys.contains("SourceRocketMQParameters") {
                    var model = ListUserDefinedEventSourcesResponseBody.Data.EventSourceList.SourceRocketMQParameters()
                    model.fromMap(dict["SourceRocketMQParameters"] as! [String: Any])
                    self.sourceRocketMQParameters = model
                }
                if dict.keys.contains("SourceSLSParameters") {
                    var model = ListUserDefinedEventSourcesResponseBody.Data.EventSourceList.SourceSLSParameters()
                    model.fromMap(dict["SourceSLSParameters"] as! [String: Any])
                    self.sourceSLSParameters = model
                }
                if dict.keys.contains("SourceScheduledEventParameters") {
                    var model = ListUserDefinedEventSourcesResponseBody.Data.EventSourceList.SourceScheduledEventParameters()
                    model.fromMap(dict["SourceScheduledEventParameters"] as! [String: Any])
                    self.sourceScheduledEventParameters = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var eventSourceList: [ListUserDefinedEventSourcesResponseBody.Data.EventSourceList]?

        public var nextToken: String?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventSourceList != nil {
                var tmp : [Any] = []
                for k in self.eventSourceList! {
                    tmp.append(k.toMap())
                }
                map["EventSourceList"] = tmp
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventSourceList") {
                var tmp : [ListUserDefinedEventSourcesResponseBody.Data.EventSourceList] = []
                for v in dict["EventSourceList"] as! [Any] {
                    var model = ListUserDefinedEventSourcesResponseBody.Data.EventSourceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eventSourceList = tmp
            }
            if dict.keys.contains("NextToken") {
                self.nextToken = dict["NextToken"] as! String
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListUserDefinedEventSourcesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListUserDefinedEventSourcesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListUserDefinedEventSourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserDefinedEventSourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListUserDefinedEventSourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PauseEventStreamingRequest : Tea.TeaModel {
    public var eventStreamingName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventStreamingName != nil {
            map["EventStreamingName"] = self.eventStreamingName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventStreamingName") {
            self.eventStreamingName = dict["EventStreamingName"] as! String
        }
    }
}

public class PauseEventStreamingResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PauseEventStreamingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PauseEventStreamingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PauseEventStreamingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutTargetsRequest : Tea.TeaModel {
    public class Targets : Tea.TeaModel {
        public class DeadLetterQueue : Tea.TeaModel {
            public var arn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.arn != nil {
                    map["Arn"] = self.arn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Arn") {
                    self.arn = dict["Arn"] as! String
                }
            }
        }
        public class ParamList : Tea.TeaModel {
            public var form: String?

            public var resourceKey: String?

            public var template: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.form != nil {
                    map["Form"] = self.form!
                }
                if self.resourceKey != nil {
                    map["ResourceKey"] = self.resourceKey!
                }
                if self.template != nil {
                    map["Template"] = self.template!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Form") {
                    self.form = dict["Form"] as! String
                }
                if dict.keys.contains("ResourceKey") {
                    self.resourceKey = dict["ResourceKey"] as! String
                }
                if dict.keys.contains("Template") {
                    self.template = dict["Template"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var deadLetterQueue: PutTargetsRequest.Targets.DeadLetterQueue?

        public var endpoint: String?

        public var errorsTolerance: String?

        public var id: String?

        public var paramList: [PutTargetsRequest.Targets.ParamList]?

        public var pushRetryStrategy: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.deadLetterQueue?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deadLetterQueue != nil {
                map["DeadLetterQueue"] = self.deadLetterQueue?.toMap()
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.errorsTolerance != nil {
                map["ErrorsTolerance"] = self.errorsTolerance!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.paramList != nil {
                var tmp : [Any] = []
                for k in self.paramList! {
                    tmp.append(k.toMap())
                }
                map["ParamList"] = tmp
            }
            if self.pushRetryStrategy != nil {
                map["PushRetryStrategy"] = self.pushRetryStrategy!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeadLetterQueue") {
                var model = PutTargetsRequest.Targets.DeadLetterQueue()
                model.fromMap(dict["DeadLetterQueue"] as! [String: Any])
                self.deadLetterQueue = model
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("ErrorsTolerance") {
                self.errorsTolerance = dict["ErrorsTolerance"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ParamList") {
                var tmp : [PutTargetsRequest.Targets.ParamList] = []
                for v in dict["ParamList"] as! [Any] {
                    var model = PutTargetsRequest.Targets.ParamList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.paramList = tmp
            }
            if dict.keys.contains("PushRetryStrategy") {
                self.pushRetryStrategy = dict["PushRetryStrategy"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var eventBusName: String?

    public var ruleName: String?

    public var targets: [PutTargetsRequest.Targets]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.targets != nil {
            var tmp : [Any] = []
            for k in self.targets! {
                tmp.append(k.toMap())
            }
            map["Targets"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("Targets") {
            var tmp : [PutTargetsRequest.Targets] = []
            for v in dict["Targets"] as! [Any] {
                var model = PutTargetsRequest.Targets()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.targets = tmp
        }
    }
}

public class PutTargetsShrinkRequest : Tea.TeaModel {
    public var eventBusName: String?

    public var ruleName: String?

    public var targetsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.targetsShrink != nil {
            map["Targets"] = self.targetsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("Targets") {
            self.targetsShrink = dict["Targets"] as! String
        }
    }
}

public class PutTargetsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ErrorEntries : Tea.TeaModel {
            public var entryId: String?

            public var errorCode: String?

            public var errorMessage: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.entryId != nil {
                    map["EntryId"] = self.entryId!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EntryId") {
                    self.entryId = dict["EntryId"] as! String
                }
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
            }
        }
        public var errorEntries: [PutTargetsResponseBody.Data.ErrorEntries]?

        public var errorEntriesCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorEntries != nil {
                var tmp : [Any] = []
                for k in self.errorEntries! {
                    tmp.append(k.toMap())
                }
                map["ErrorEntries"] = tmp
            }
            if self.errorEntriesCount != nil {
                map["ErrorEntriesCount"] = self.errorEntriesCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorEntries") {
                var tmp : [PutTargetsResponseBody.Data.ErrorEntries] = []
                for v in dict["ErrorEntries"] as! [Any] {
                    var model = PutTargetsResponseBody.Data.ErrorEntries()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.errorEntries = tmp
            }
            if dict.keys.contains("ErrorEntriesCount") {
                self.errorEntriesCount = dict["ErrorEntriesCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: PutTargetsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = PutTargetsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PutTargetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutTargetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PutTargetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryEventRequest : Tea.TeaModel {
    public var eventBusName: String?

    public var eventId: String?

    public var eventSource: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.eventSource != nil {
            map["EventSource"] = self.eventSource!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("EventSource") {
            self.eventSource = dict["EventSource"] as! String
        }
    }
}

public class QueryEventResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: [String: Any]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [String: Any]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryEventTracesRequest : Tea.TeaModel {
    public var eventBusName: String?

    public var eventId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
    }
}

public class QueryEventTracesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var action: String?

        public var actionTime: Int64?

        public var endpoint: String?

        public var eventBusName: String?

        public var eventId: String?

        public var eventSource: String?

        public var notifyLatency: String?

        public var notifyStatus: String?

        public var notifyTime: Int64?

        public var receivedTime: Int64?

        public var ruleMatchingTime: String?

        public var ruleName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.actionTime != nil {
                map["ActionTime"] = self.actionTime!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.eventBusName != nil {
                map["EventBusName"] = self.eventBusName!
            }
            if self.eventId != nil {
                map["EventId"] = self.eventId!
            }
            if self.eventSource != nil {
                map["EventSource"] = self.eventSource!
            }
            if self.notifyLatency != nil {
                map["NotifyLatency"] = self.notifyLatency!
            }
            if self.notifyStatus != nil {
                map["NotifyStatus"] = self.notifyStatus!
            }
            if self.notifyTime != nil {
                map["NotifyTime"] = self.notifyTime!
            }
            if self.receivedTime != nil {
                map["ReceivedTime"] = self.receivedTime!
            }
            if self.ruleMatchingTime != nil {
                map["RuleMatchingTime"] = self.ruleMatchingTime!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("ActionTime") {
                self.actionTime = dict["ActionTime"] as! Int64
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("EventBusName") {
                self.eventBusName = dict["EventBusName"] as! String
            }
            if dict.keys.contains("EventId") {
                self.eventId = dict["EventId"] as! String
            }
            if dict.keys.contains("EventSource") {
                self.eventSource = dict["EventSource"] as! String
            }
            if dict.keys.contains("NotifyLatency") {
                self.notifyLatency = dict["NotifyLatency"] as! String
            }
            if dict.keys.contains("NotifyStatus") {
                self.notifyStatus = dict["NotifyStatus"] as! String
            }
            if dict.keys.contains("NotifyTime") {
                self.notifyTime = dict["NotifyTime"] as! Int64
            }
            if dict.keys.contains("ReceivedTime") {
                self.receivedTime = dict["ReceivedTime"] as! Int64
            }
            if dict.keys.contains("RuleMatchingTime") {
                self.ruleMatchingTime = dict["RuleMatchingTime"] as! String
            }
            if dict.keys.contains("RuleName") {
                self.ruleName = dict["RuleName"] as! String
            }
        }
    }
    public var code: String?

    public var data: [QueryEventTracesResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [QueryEventTracesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryEventTracesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryEventTracesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryEventTracesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryEventTracesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTracedEventByEventIdRequest : Tea.TeaModel {
    public var eventBusName: String?

    public var eventId: String?

    public var eventSource: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.eventSource != nil {
            map["EventSource"] = self.eventSource!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("EventSource") {
            self.eventSource = dict["EventSource"] as! String
        }
    }
}

public class QueryTracedEventByEventIdResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Events : Tea.TeaModel {
            public var eventBusName: String?

            public var eventId: String?

            public var eventReceivedTime: Int64?

            public var eventSource: String?

            public var eventType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventBusName != nil {
                    map["EventBusName"] = self.eventBusName!
                }
                if self.eventId != nil {
                    map["EventId"] = self.eventId!
                }
                if self.eventReceivedTime != nil {
                    map["EventReceivedTime"] = self.eventReceivedTime!
                }
                if self.eventSource != nil {
                    map["EventSource"] = self.eventSource!
                }
                if self.eventType != nil {
                    map["EventType"] = self.eventType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EventBusName") {
                    self.eventBusName = dict["EventBusName"] as! String
                }
                if dict.keys.contains("EventId") {
                    self.eventId = dict["EventId"] as! String
                }
                if dict.keys.contains("EventReceivedTime") {
                    self.eventReceivedTime = dict["EventReceivedTime"] as! Int64
                }
                if dict.keys.contains("EventSource") {
                    self.eventSource = dict["EventSource"] as! String
                }
                if dict.keys.contains("EventType") {
                    self.eventType = dict["EventType"] as! String
                }
            }
        }
        public var events: [QueryTracedEventByEventIdResponseBody.Data.Events]?

        public var nextToken: String?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.events != nil {
                var tmp : [Any] = []
                for k in self.events! {
                    tmp.append(k.toMap())
                }
                map["Events"] = tmp
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Events") {
                var tmp : [QueryTracedEventByEventIdResponseBody.Data.Events] = []
                for v in dict["Events"] as! [Any] {
                    var model = QueryTracedEventByEventIdResponseBody.Data.Events()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.events = tmp
            }
            if dict.keys.contains("NextToken") {
                self.nextToken = dict["NextToken"] as! String
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: [QueryTracedEventByEventIdResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [QueryTracedEventByEventIdResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryTracedEventByEventIdResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryTracedEventByEventIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTracedEventByEventIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryTracedEventByEventIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTracedEventsRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var eventBusName: String?

    public var eventSource: String?

    public var eventType: String?

    public var limit: Int32?

    public var matchedRule: String?

    public var nextToken: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.eventSource != nil {
            map["EventSource"] = self.eventSource!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.matchedRule != nil {
            map["MatchedRule"] = self.matchedRule!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("EventSource") {
            self.eventSource = dict["EventSource"] as! String
        }
        if dict.keys.contains("EventType") {
            self.eventType = dict["EventType"] as! String
        }
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! Int32
        }
        if dict.keys.contains("MatchedRule") {
            self.matchedRule = dict["MatchedRule"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class QueryTracedEventsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Events : Tea.TeaModel {
            public var eventBusName: String?

            public var eventId: String?

            public var eventReceivedTime: Int64?

            public var eventSource: String?

            public var eventType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventBusName != nil {
                    map["EventBusName"] = self.eventBusName!
                }
                if self.eventId != nil {
                    map["EventId"] = self.eventId!
                }
                if self.eventReceivedTime != nil {
                    map["EventReceivedTime"] = self.eventReceivedTime!
                }
                if self.eventSource != nil {
                    map["EventSource"] = self.eventSource!
                }
                if self.eventType != nil {
                    map["EventType"] = self.eventType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EventBusName") {
                    self.eventBusName = dict["EventBusName"] as! String
                }
                if dict.keys.contains("EventId") {
                    self.eventId = dict["EventId"] as! String
                }
                if dict.keys.contains("EventReceivedTime") {
                    self.eventReceivedTime = dict["EventReceivedTime"] as! Int64
                }
                if dict.keys.contains("EventSource") {
                    self.eventSource = dict["EventSource"] as! String
                }
                if dict.keys.contains("EventType") {
                    self.eventType = dict["EventType"] as! String
                }
            }
        }
        public var events: [QueryTracedEventsResponseBody.Data.Events]?

        public var nextToken: String?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.events != nil {
                var tmp : [Any] = []
                for k in self.events! {
                    tmp.append(k.toMap())
                }
                map["Events"] = tmp
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Events") {
                var tmp : [QueryTracedEventsResponseBody.Data.Events] = []
                for v in dict["Events"] as! [Any] {
                    var model = QueryTracedEventsResponseBody.Data.Events()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.events = tmp
            }
            if dict.keys.contains("NextToken") {
                self.nextToken = dict["NextToken"] as! String
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: QueryTracedEventsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = QueryTracedEventsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryTracedEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTracedEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryTracedEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartEventStreamingRequest : Tea.TeaModel {
    public var eventStreamingName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventStreamingName != nil {
            map["EventStreamingName"] = self.eventStreamingName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventStreamingName") {
            self.eventStreamingName = dict["EventStreamingName"] as! String
        }
    }
}

public class StartEventStreamingResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StartEventStreamingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartEventStreamingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartEventStreamingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TestEventPatternRequest : Tea.TeaModel {
    public var event: String?

    public var eventPattern: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.event != nil {
            map["Event"] = self.event!
        }
        if self.eventPattern != nil {
            map["EventPattern"] = self.eventPattern!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Event") {
            self.event = dict["Event"] as! String
        }
        if dict.keys.contains("EventPattern") {
            self.eventPattern = dict["EventPattern"] as! String
        }
    }
}

public class TestEventPatternResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["Result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! Bool
            }
        }
    }
    public var code: String?

    public var data: TestEventPatternResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = TestEventPatternResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class TestEventPatternResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TestEventPatternResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TestEventPatternResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateApiDestinationRequest : Tea.TeaModel {
    public class HttpApiParameters : Tea.TeaModel {
        public var endpoint: String?

        public var method: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.method != nil {
                map["Method"] = self.method!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("Method") {
                self.method = dict["Method"] as! String
            }
        }
    }
    public var apiDestinationName: String?

    public var connectionName: String?

    public var description_: String?

    public var httpApiParameters: UpdateApiDestinationRequest.HttpApiParameters?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.httpApiParameters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiDestinationName != nil {
            map["ApiDestinationName"] = self.apiDestinationName!
        }
        if self.connectionName != nil {
            map["ConnectionName"] = self.connectionName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.httpApiParameters != nil {
            map["HttpApiParameters"] = self.httpApiParameters?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiDestinationName") {
            self.apiDestinationName = dict["ApiDestinationName"] as! String
        }
        if dict.keys.contains("ConnectionName") {
            self.connectionName = dict["ConnectionName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("HttpApiParameters") {
            var model = UpdateApiDestinationRequest.HttpApiParameters()
            model.fromMap(dict["HttpApiParameters"] as! [String: Any])
            self.httpApiParameters = model
        }
    }
}

public class UpdateApiDestinationShrinkRequest : Tea.TeaModel {
    public var apiDestinationName: String?

    public var connectionName: String?

    public var description_: String?

    public var httpApiParametersShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiDestinationName != nil {
            map["ApiDestinationName"] = self.apiDestinationName!
        }
        if self.connectionName != nil {
            map["ConnectionName"] = self.connectionName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.httpApiParametersShrink != nil {
            map["HttpApiParameters"] = self.httpApiParametersShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiDestinationName") {
            self.apiDestinationName = dict["ApiDestinationName"] as! String
        }
        if dict.keys.contains("ConnectionName") {
            self.connectionName = dict["ConnectionName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("HttpApiParameters") {
            self.httpApiParametersShrink = dict["HttpApiParameters"] as! String
        }
    }
}

public class UpdateApiDestinationResponseBody : Tea.TeaModel {
    public var apiDestinationName: String?

    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiDestinationName != nil {
            map["ApiDestinationName"] = self.apiDestinationName!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiDestinationName") {
            self.apiDestinationName = dict["ApiDestinationName"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateApiDestinationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApiDestinationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateApiDestinationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateConnectionRequest : Tea.TeaModel {
    public class AuthParameters : Tea.TeaModel {
        public class ApiKeyAuthParameters : Tea.TeaModel {
            public var apiKeyName: String?

            public var apiKeyValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiKeyName != nil {
                    map["ApiKeyName"] = self.apiKeyName!
                }
                if self.apiKeyValue != nil {
                    map["ApiKeyValue"] = self.apiKeyValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiKeyName") {
                    self.apiKeyName = dict["ApiKeyName"] as! String
                }
                if dict.keys.contains("ApiKeyValue") {
                    self.apiKeyValue = dict["ApiKeyValue"] as! String
                }
            }
        }
        public class BasicAuthParameters : Tea.TeaModel {
            public var password: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Password") {
                    self.password = dict["Password"] as! String
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
            }
        }
        public class OAuthParameters : Tea.TeaModel {
            public class ClientParameters : Tea.TeaModel {
                public var clientID: String?

                public var clientSecret: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clientID != nil {
                        map["ClientID"] = self.clientID!
                    }
                    if self.clientSecret != nil {
                        map["ClientSecret"] = self.clientSecret!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClientID") {
                        self.clientID = dict["ClientID"] as! String
                    }
                    if dict.keys.contains("ClientSecret") {
                        self.clientSecret = dict["ClientSecret"] as! String
                    }
                }
            }
            public class OAuthHttpParameters : Tea.TeaModel {
                public class BodyParameters : Tea.TeaModel {
                    public var isValueSecret: String?

                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.isValueSecret != nil {
                            map["IsValueSecret"] = self.isValueSecret!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IsValueSecret") {
                            self.isValueSecret = dict["IsValueSecret"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class HeaderParameters : Tea.TeaModel {
                    public var isValueSecret: String?

                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.isValueSecret != nil {
                            map["IsValueSecret"] = self.isValueSecret!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IsValueSecret") {
                            self.isValueSecret = dict["IsValueSecret"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class QueryStringParameters : Tea.TeaModel {
                    public var isValueSecret: String?

                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.isValueSecret != nil {
                            map["IsValueSecret"] = self.isValueSecret!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IsValueSecret") {
                            self.isValueSecret = dict["IsValueSecret"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var bodyParameters: [UpdateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters.BodyParameters]?

                public var headerParameters: [UpdateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters.HeaderParameters]?

                public var queryStringParameters: [UpdateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters.QueryStringParameters]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bodyParameters != nil {
                        var tmp : [Any] = []
                        for k in self.bodyParameters! {
                            tmp.append(k.toMap())
                        }
                        map["BodyParameters"] = tmp
                    }
                    if self.headerParameters != nil {
                        var tmp : [Any] = []
                        for k in self.headerParameters! {
                            tmp.append(k.toMap())
                        }
                        map["HeaderParameters"] = tmp
                    }
                    if self.queryStringParameters != nil {
                        var tmp : [Any] = []
                        for k in self.queryStringParameters! {
                            tmp.append(k.toMap())
                        }
                        map["QueryStringParameters"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BodyParameters") {
                        var tmp : [UpdateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters.BodyParameters] = []
                        for v in dict["BodyParameters"] as! [Any] {
                            var model = UpdateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters.BodyParameters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.bodyParameters = tmp
                    }
                    if dict.keys.contains("HeaderParameters") {
                        var tmp : [UpdateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters.HeaderParameters] = []
                        for v in dict["HeaderParameters"] as! [Any] {
                            var model = UpdateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters.HeaderParameters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.headerParameters = tmp
                    }
                    if dict.keys.contains("QueryStringParameters") {
                        var tmp : [UpdateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters.QueryStringParameters] = []
                        for v in dict["QueryStringParameters"] as! [Any] {
                            var model = UpdateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters.QueryStringParameters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.queryStringParameters = tmp
                    }
                }
            }
            public var authorizationEndpoint: String?

            public var clientParameters: UpdateConnectionRequest.AuthParameters.OAuthParameters.ClientParameters?

            public var httpMethod: String?

            public var OAuthHttpParameters: UpdateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.clientParameters?.validate()
                try self.OAuthHttpParameters?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorizationEndpoint != nil {
                    map["AuthorizationEndpoint"] = self.authorizationEndpoint!
                }
                if self.clientParameters != nil {
                    map["ClientParameters"] = self.clientParameters?.toMap()
                }
                if self.httpMethod != nil {
                    map["HttpMethod"] = self.httpMethod!
                }
                if self.OAuthHttpParameters != nil {
                    map["OAuthHttpParameters"] = self.OAuthHttpParameters?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuthorizationEndpoint") {
                    self.authorizationEndpoint = dict["AuthorizationEndpoint"] as! String
                }
                if dict.keys.contains("ClientParameters") {
                    var model = UpdateConnectionRequest.AuthParameters.OAuthParameters.ClientParameters()
                    model.fromMap(dict["ClientParameters"] as! [String: Any])
                    self.clientParameters = model
                }
                if dict.keys.contains("HttpMethod") {
                    self.httpMethod = dict["HttpMethod"] as! String
                }
                if dict.keys.contains("OAuthHttpParameters") {
                    var model = UpdateConnectionRequest.AuthParameters.OAuthParameters.OAuthHttpParameters()
                    model.fromMap(dict["OAuthHttpParameters"] as! [String: Any])
                    self.OAuthHttpParameters = model
                }
            }
        }
        public var apiKeyAuthParameters: UpdateConnectionRequest.AuthParameters.ApiKeyAuthParameters?

        public var authorizationType: String?

        public var basicAuthParameters: UpdateConnectionRequest.AuthParameters.BasicAuthParameters?

        public var OAuthParameters: UpdateConnectionRequest.AuthParameters.OAuthParameters?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.apiKeyAuthParameters?.validate()
            try self.basicAuthParameters?.validate()
            try self.OAuthParameters?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiKeyAuthParameters != nil {
                map["ApiKeyAuthParameters"] = self.apiKeyAuthParameters?.toMap()
            }
            if self.authorizationType != nil {
                map["AuthorizationType"] = self.authorizationType!
            }
            if self.basicAuthParameters != nil {
                map["BasicAuthParameters"] = self.basicAuthParameters?.toMap()
            }
            if self.OAuthParameters != nil {
                map["OAuthParameters"] = self.OAuthParameters?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiKeyAuthParameters") {
                var model = UpdateConnectionRequest.AuthParameters.ApiKeyAuthParameters()
                model.fromMap(dict["ApiKeyAuthParameters"] as! [String: Any])
                self.apiKeyAuthParameters = model
            }
            if dict.keys.contains("AuthorizationType") {
                self.authorizationType = dict["AuthorizationType"] as! String
            }
            if dict.keys.contains("BasicAuthParameters") {
                var model = UpdateConnectionRequest.AuthParameters.BasicAuthParameters()
                model.fromMap(dict["BasicAuthParameters"] as! [String: Any])
                self.basicAuthParameters = model
            }
            if dict.keys.contains("OAuthParameters") {
                var model = UpdateConnectionRequest.AuthParameters.OAuthParameters()
                model.fromMap(dict["OAuthParameters"] as! [String: Any])
                self.OAuthParameters = model
            }
        }
    }
    public class NetworkParameters : Tea.TeaModel {
        public var networkType: String?

        public var securityGroupId: String?

        public var vpcId: String?

        public var vswitcheId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkType != nil {
                map["NetworkType"] = self.networkType!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.vswitcheId != nil {
                map["VswitcheId"] = self.vswitcheId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetworkType") {
                self.networkType = dict["NetworkType"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
            if dict.keys.contains("VswitcheId") {
                self.vswitcheId = dict["VswitcheId"] as! String
            }
        }
    }
    public var authParameters: UpdateConnectionRequest.AuthParameters?

    public var connectionName: String?

    public var description_: String?

    public var networkParameters: UpdateConnectionRequest.NetworkParameters?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authParameters?.validate()
        try self.networkParameters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authParameters != nil {
            map["AuthParameters"] = self.authParameters?.toMap()
        }
        if self.connectionName != nil {
            map["ConnectionName"] = self.connectionName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.networkParameters != nil {
            map["NetworkParameters"] = self.networkParameters?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthParameters") {
            var model = UpdateConnectionRequest.AuthParameters()
            model.fromMap(dict["AuthParameters"] as! [String: Any])
            self.authParameters = model
        }
        if dict.keys.contains("ConnectionName") {
            self.connectionName = dict["ConnectionName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("NetworkParameters") {
            var model = UpdateConnectionRequest.NetworkParameters()
            model.fromMap(dict["NetworkParameters"] as! [String: Any])
            self.networkParameters = model
        }
    }
}

public class UpdateConnectionShrinkRequest : Tea.TeaModel {
    public var authParametersShrink: String?

    public var connectionName: String?

    public var description_: String?

    public var networkParametersShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authParametersShrink != nil {
            map["AuthParameters"] = self.authParametersShrink!
        }
        if self.connectionName != nil {
            map["ConnectionName"] = self.connectionName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.networkParametersShrink != nil {
            map["NetworkParameters"] = self.networkParametersShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthParameters") {
            self.authParametersShrink = dict["AuthParameters"] as! String
        }
        if dict.keys.contains("ConnectionName") {
            self.connectionName = dict["ConnectionName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("NetworkParameters") {
            self.networkParametersShrink = dict["NetworkParameters"] as! String
        }
    }
}

public class UpdateConnectionResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEventBusRequest : Tea.TeaModel {
    public var description_: String?

    public var eventBusName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
    }
}

public class UpdateEventBusResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateEventBusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEventBusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateEventBusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEventSourceRequest : Tea.TeaModel {
    public class SourceHttpEventParameters : Tea.TeaModel {
        public var ip: [String]?

        public var method: [String]?

        public var referer: [String]?

        public var securityConfig: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.method != nil {
                map["Method"] = self.method!
            }
            if self.referer != nil {
                map["Referer"] = self.referer!
            }
            if self.securityConfig != nil {
                map["SecurityConfig"] = self.securityConfig!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! [String]
            }
            if dict.keys.contains("Method") {
                self.method = dict["Method"] as! [String]
            }
            if dict.keys.contains("Referer") {
                self.referer = dict["Referer"] as! [String]
            }
            if dict.keys.contains("SecurityConfig") {
                self.securityConfig = dict["SecurityConfig"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class SourceKafkaParameters : Tea.TeaModel {
        public var consumerGroup: String?

        public var instanceId: String?

        public var maximumTasks: Int32?

        public var network: String?

        public var offsetReset: String?

        public var regionId: String?

        public var securityGroupId: String?

        public var topic: String?

        public var vSwitchIds: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consumerGroup != nil {
                map["ConsumerGroup"] = self.consumerGroup!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.maximumTasks != nil {
                map["MaximumTasks"] = self.maximumTasks!
            }
            if self.network != nil {
                map["Network"] = self.network!
            }
            if self.offsetReset != nil {
                map["OffsetReset"] = self.offsetReset!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.topic != nil {
                map["Topic"] = self.topic!
            }
            if self.vSwitchIds != nil {
                map["VSwitchIds"] = self.vSwitchIds!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsumerGroup") {
                self.consumerGroup = dict["ConsumerGroup"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("MaximumTasks") {
                self.maximumTasks = dict["MaximumTasks"] as! Int32
            }
            if dict.keys.contains("Network") {
                self.network = dict["Network"] as! String
            }
            if dict.keys.contains("OffsetReset") {
                self.offsetReset = dict["OffsetReset"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("Topic") {
                self.topic = dict["Topic"] as! String
            }
            if dict.keys.contains("VSwitchIds") {
                self.vSwitchIds = dict["VSwitchIds"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public class SourceMNSParameters : Tea.TeaModel {
        public var isBase64Decode: Bool?

        public var queueName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.isBase64Decode != nil {
                map["IsBase64Decode"] = self.isBase64Decode!
            }
            if self.queueName != nil {
                map["QueueName"] = self.queueName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IsBase64Decode") {
                self.isBase64Decode = dict["IsBase64Decode"] as! Bool
            }
            if dict.keys.contains("QueueName") {
                self.queueName = dict["QueueName"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public class SourceRabbitMQParameters : Tea.TeaModel {
        public var instanceId: String?

        public var queueName: String?

        public var regionId: String?

        public var virtualHostName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.queueName != nil {
                map["QueueName"] = self.queueName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.virtualHostName != nil {
                map["VirtualHostName"] = self.virtualHostName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("QueueName") {
                self.queueName = dict["QueueName"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("VirtualHostName") {
                self.virtualHostName = dict["VirtualHostName"] as! String
            }
        }
    }
    public class SourceRocketMQParameters : Tea.TeaModel {
        public var authType: String?

        public var groupID: String?

        public var instanceEndpoint: String?

        public var instanceId: String?

        public var instanceNetwork: String?

        public var instancePassword: String?

        public var instanceSecurityGroupId: String?

        public var instanceType: String?

        public var instanceUsername: String?

        public var instanceVSwitchIds: String?

        public var instanceVpcId: String?

        public var offset: String?

        public var regionId: String?

        public var tag: String?

        public var timestamp: Int64?

        public var topic: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authType != nil {
                map["AuthType"] = self.authType!
            }
            if self.groupID != nil {
                map["GroupID"] = self.groupID!
            }
            if self.instanceEndpoint != nil {
                map["InstanceEndpoint"] = self.instanceEndpoint!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceNetwork != nil {
                map["InstanceNetwork"] = self.instanceNetwork!
            }
            if self.instancePassword != nil {
                map["InstancePassword"] = self.instancePassword!
            }
            if self.instanceSecurityGroupId != nil {
                map["InstanceSecurityGroupId"] = self.instanceSecurityGroupId!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.instanceUsername != nil {
                map["InstanceUsername"] = self.instanceUsername!
            }
            if self.instanceVSwitchIds != nil {
                map["InstanceVSwitchIds"] = self.instanceVSwitchIds!
            }
            if self.instanceVpcId != nil {
                map["InstanceVpcId"] = self.instanceVpcId!
            }
            if self.offset != nil {
                map["Offset"] = self.offset!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.topic != nil {
                map["Topic"] = self.topic!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthType") {
                self.authType = dict["AuthType"] as! String
            }
            if dict.keys.contains("GroupID") {
                self.groupID = dict["GroupID"] as! String
            }
            if dict.keys.contains("InstanceEndpoint") {
                self.instanceEndpoint = dict["InstanceEndpoint"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceNetwork") {
                self.instanceNetwork = dict["InstanceNetwork"] as! String
            }
            if dict.keys.contains("InstancePassword") {
                self.instancePassword = dict["InstancePassword"] as! String
            }
            if dict.keys.contains("InstanceSecurityGroupId") {
                self.instanceSecurityGroupId = dict["InstanceSecurityGroupId"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("InstanceUsername") {
                self.instanceUsername = dict["InstanceUsername"] as! String
            }
            if dict.keys.contains("InstanceVSwitchIds") {
                self.instanceVSwitchIds = dict["InstanceVSwitchIds"] as! String
            }
            if dict.keys.contains("InstanceVpcId") {
                self.instanceVpcId = dict["InstanceVpcId"] as! String
            }
            if dict.keys.contains("Offset") {
                self.offset = dict["Offset"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Tag") {
                self.tag = dict["Tag"] as! String
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("Topic") {
                self.topic = dict["Topic"] as! String
            }
        }
    }
    public class SourceSLSParameters : Tea.TeaModel {
        public var consumePosition: String?

        public var logStore: String?

        public var project: String?

        public var roleName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consumePosition != nil {
                map["ConsumePosition"] = self.consumePosition!
            }
            if self.logStore != nil {
                map["LogStore"] = self.logStore!
            }
            if self.project != nil {
                map["Project"] = self.project!
            }
            if self.roleName != nil {
                map["RoleName"] = self.roleName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsumePosition") {
                self.consumePosition = dict["ConsumePosition"] as! String
            }
            if dict.keys.contains("LogStore") {
                self.logStore = dict["LogStore"] as! String
            }
            if dict.keys.contains("Project") {
                self.project = dict["Project"] as! String
            }
            if dict.keys.contains("RoleName") {
                self.roleName = dict["RoleName"] as! String
            }
        }
    }
    public class SourceScheduledEventParameters : Tea.TeaModel {
        public var schedule: String?

        public var timeZone: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.schedule != nil {
                map["Schedule"] = self.schedule!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Schedule") {
                self.schedule = dict["Schedule"] as! String
            }
            if dict.keys.contains("TimeZone") {
                self.timeZone = dict["TimeZone"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var description_: String?

    public var eventBusName: String?

    public var eventSourceName: String?

    public var sourceHttpEventParameters: UpdateEventSourceRequest.SourceHttpEventParameters?

    public var sourceKafkaParameters: UpdateEventSourceRequest.SourceKafkaParameters?

    public var sourceMNSParameters: UpdateEventSourceRequest.SourceMNSParameters?

    public var sourceRabbitMQParameters: UpdateEventSourceRequest.SourceRabbitMQParameters?

    public var sourceRocketMQParameters: UpdateEventSourceRequest.SourceRocketMQParameters?

    public var sourceSLSParameters: UpdateEventSourceRequest.SourceSLSParameters?

    public var sourceScheduledEventParameters: UpdateEventSourceRequest.SourceScheduledEventParameters?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sourceHttpEventParameters?.validate()
        try self.sourceKafkaParameters?.validate()
        try self.sourceMNSParameters?.validate()
        try self.sourceRabbitMQParameters?.validate()
        try self.sourceRocketMQParameters?.validate()
        try self.sourceSLSParameters?.validate()
        try self.sourceScheduledEventParameters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.eventSourceName != nil {
            map["EventSourceName"] = self.eventSourceName!
        }
        if self.sourceHttpEventParameters != nil {
            map["SourceHttpEventParameters"] = self.sourceHttpEventParameters?.toMap()
        }
        if self.sourceKafkaParameters != nil {
            map["SourceKafkaParameters"] = self.sourceKafkaParameters?.toMap()
        }
        if self.sourceMNSParameters != nil {
            map["SourceMNSParameters"] = self.sourceMNSParameters?.toMap()
        }
        if self.sourceRabbitMQParameters != nil {
            map["SourceRabbitMQParameters"] = self.sourceRabbitMQParameters?.toMap()
        }
        if self.sourceRocketMQParameters != nil {
            map["SourceRocketMQParameters"] = self.sourceRocketMQParameters?.toMap()
        }
        if self.sourceSLSParameters != nil {
            map["SourceSLSParameters"] = self.sourceSLSParameters?.toMap()
        }
        if self.sourceScheduledEventParameters != nil {
            map["SourceScheduledEventParameters"] = self.sourceScheduledEventParameters?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("EventSourceName") {
            self.eventSourceName = dict["EventSourceName"] as! String
        }
        if dict.keys.contains("SourceHttpEventParameters") {
            var model = UpdateEventSourceRequest.SourceHttpEventParameters()
            model.fromMap(dict["SourceHttpEventParameters"] as! [String: Any])
            self.sourceHttpEventParameters = model
        }
        if dict.keys.contains("SourceKafkaParameters") {
            var model = UpdateEventSourceRequest.SourceKafkaParameters()
            model.fromMap(dict["SourceKafkaParameters"] as! [String: Any])
            self.sourceKafkaParameters = model
        }
        if dict.keys.contains("SourceMNSParameters") {
            var model = UpdateEventSourceRequest.SourceMNSParameters()
            model.fromMap(dict["SourceMNSParameters"] as! [String: Any])
            self.sourceMNSParameters = model
        }
        if dict.keys.contains("SourceRabbitMQParameters") {
            var model = UpdateEventSourceRequest.SourceRabbitMQParameters()
            model.fromMap(dict["SourceRabbitMQParameters"] as! [String: Any])
            self.sourceRabbitMQParameters = model
        }
        if dict.keys.contains("SourceRocketMQParameters") {
            var model = UpdateEventSourceRequest.SourceRocketMQParameters()
            model.fromMap(dict["SourceRocketMQParameters"] as! [String: Any])
            self.sourceRocketMQParameters = model
        }
        if dict.keys.contains("SourceSLSParameters") {
            var model = UpdateEventSourceRequest.SourceSLSParameters()
            model.fromMap(dict["SourceSLSParameters"] as! [String: Any])
            self.sourceSLSParameters = model
        }
        if dict.keys.contains("SourceScheduledEventParameters") {
            var model = UpdateEventSourceRequest.SourceScheduledEventParameters()
            model.fromMap(dict["SourceScheduledEventParameters"] as! [String: Any])
            self.sourceScheduledEventParameters = model
        }
    }
}

public class UpdateEventSourceShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var eventBusName: String?

    public var eventSourceName: String?

    public var sourceHttpEventParametersShrink: String?

    public var sourceKafkaParametersShrink: String?

    public var sourceMNSParametersShrink: String?

    public var sourceRabbitMQParametersShrink: String?

    public var sourceRocketMQParametersShrink: String?

    public var sourceSLSParametersShrink: String?

    public var sourceScheduledEventParametersShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.eventSourceName != nil {
            map["EventSourceName"] = self.eventSourceName!
        }
        if self.sourceHttpEventParametersShrink != nil {
            map["SourceHttpEventParameters"] = self.sourceHttpEventParametersShrink!
        }
        if self.sourceKafkaParametersShrink != nil {
            map["SourceKafkaParameters"] = self.sourceKafkaParametersShrink!
        }
        if self.sourceMNSParametersShrink != nil {
            map["SourceMNSParameters"] = self.sourceMNSParametersShrink!
        }
        if self.sourceRabbitMQParametersShrink != nil {
            map["SourceRabbitMQParameters"] = self.sourceRabbitMQParametersShrink!
        }
        if self.sourceRocketMQParametersShrink != nil {
            map["SourceRocketMQParameters"] = self.sourceRocketMQParametersShrink!
        }
        if self.sourceSLSParametersShrink != nil {
            map["SourceSLSParameters"] = self.sourceSLSParametersShrink!
        }
        if self.sourceScheduledEventParametersShrink != nil {
            map["SourceScheduledEventParameters"] = self.sourceScheduledEventParametersShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("EventSourceName") {
            self.eventSourceName = dict["EventSourceName"] as! String
        }
        if dict.keys.contains("SourceHttpEventParameters") {
            self.sourceHttpEventParametersShrink = dict["SourceHttpEventParameters"] as! String
        }
        if dict.keys.contains("SourceKafkaParameters") {
            self.sourceKafkaParametersShrink = dict["SourceKafkaParameters"] as! String
        }
        if dict.keys.contains("SourceMNSParameters") {
            self.sourceMNSParametersShrink = dict["SourceMNSParameters"] as! String
        }
        if dict.keys.contains("SourceRabbitMQParameters") {
            self.sourceRabbitMQParametersShrink = dict["SourceRabbitMQParameters"] as! String
        }
        if dict.keys.contains("SourceRocketMQParameters") {
            self.sourceRocketMQParametersShrink = dict["SourceRocketMQParameters"] as! String
        }
        if dict.keys.contains("SourceSLSParameters") {
            self.sourceSLSParametersShrink = dict["SourceSLSParameters"] as! String
        }
        if dict.keys.contains("SourceScheduledEventParameters") {
            self.sourceScheduledEventParametersShrink = dict["SourceScheduledEventParameters"] as! String
        }
    }
}

public class UpdateEventSourceResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateEventSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEventSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateEventSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEventStreamingRequest : Tea.TeaModel {
    public class RunOptions : Tea.TeaModel {
        public class BatchWindow : Tea.TeaModel {
            public var countBasedWindow: Int32?

            public var timeBasedWindow: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.countBasedWindow != nil {
                    map["CountBasedWindow"] = self.countBasedWindow!
                }
                if self.timeBasedWindow != nil {
                    map["TimeBasedWindow"] = self.timeBasedWindow!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CountBasedWindow") {
                    self.countBasedWindow = dict["CountBasedWindow"] as! Int32
                }
                if dict.keys.contains("TimeBasedWindow") {
                    self.timeBasedWindow = dict["TimeBasedWindow"] as! Int32
                }
            }
        }
        public class DeadLetterQueue : Tea.TeaModel {
            public var arn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.arn != nil {
                    map["Arn"] = self.arn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Arn") {
                    self.arn = dict["Arn"] as! String
                }
            }
        }
        public class RetryStrategy : Tea.TeaModel {
            public var maximumEventAgeInSeconds: Int64?

            public var maximumRetryAttempts: Int64?

            public var pushRetryStrategy: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maximumEventAgeInSeconds != nil {
                    map["MaximumEventAgeInSeconds"] = self.maximumEventAgeInSeconds!
                }
                if self.maximumRetryAttempts != nil {
                    map["MaximumRetryAttempts"] = self.maximumRetryAttempts!
                }
                if self.pushRetryStrategy != nil {
                    map["PushRetryStrategy"] = self.pushRetryStrategy!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaximumEventAgeInSeconds") {
                    self.maximumEventAgeInSeconds = dict["MaximumEventAgeInSeconds"] as! Int64
                }
                if dict.keys.contains("MaximumRetryAttempts") {
                    self.maximumRetryAttempts = dict["MaximumRetryAttempts"] as! Int64
                }
                if dict.keys.contains("PushRetryStrategy") {
                    self.pushRetryStrategy = dict["PushRetryStrategy"] as! String
                }
            }
        }
        public var batchWindow: UpdateEventStreamingRequest.RunOptions.BatchWindow?

        public var deadLetterQueue: UpdateEventStreamingRequest.RunOptions.DeadLetterQueue?

        public var errorsTolerance: String?

        public var maximumTasks: Int64?

        public var retryStrategy: UpdateEventStreamingRequest.RunOptions.RetryStrategy?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.batchWindow?.validate()
            try self.deadLetterQueue?.validate()
            try self.retryStrategy?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.batchWindow != nil {
                map["BatchWindow"] = self.batchWindow?.toMap()
            }
            if self.deadLetterQueue != nil {
                map["DeadLetterQueue"] = self.deadLetterQueue?.toMap()
            }
            if self.errorsTolerance != nil {
                map["ErrorsTolerance"] = self.errorsTolerance!
            }
            if self.maximumTasks != nil {
                map["MaximumTasks"] = self.maximumTasks!
            }
            if self.retryStrategy != nil {
                map["RetryStrategy"] = self.retryStrategy?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BatchWindow") {
                var model = UpdateEventStreamingRequest.RunOptions.BatchWindow()
                model.fromMap(dict["BatchWindow"] as! [String: Any])
                self.batchWindow = model
            }
            if dict.keys.contains("DeadLetterQueue") {
                var model = UpdateEventStreamingRequest.RunOptions.DeadLetterQueue()
                model.fromMap(dict["DeadLetterQueue"] as! [String: Any])
                self.deadLetterQueue = model
            }
            if dict.keys.contains("ErrorsTolerance") {
                self.errorsTolerance = dict["ErrorsTolerance"] as! String
            }
            if dict.keys.contains("MaximumTasks") {
                self.maximumTasks = dict["MaximumTasks"] as! Int64
            }
            if dict.keys.contains("RetryStrategy") {
                var model = UpdateEventStreamingRequest.RunOptions.RetryStrategy()
                model.fromMap(dict["RetryStrategy"] as! [String: Any])
                self.retryStrategy = model
            }
        }
    }
    public class Sink : Tea.TeaModel {
        public class SinkFcParameters : Tea.TeaModel {
            public class Body : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Concurrency : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class FunctionName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class InvocationType : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Qualifier : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class ServiceName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var body: UpdateEventStreamingRequest.Sink.SinkFcParameters.Body?

            public var concurrency: UpdateEventStreamingRequest.Sink.SinkFcParameters.Concurrency?

            public var functionName: UpdateEventStreamingRequest.Sink.SinkFcParameters.FunctionName?

            public var invocationType: UpdateEventStreamingRequest.Sink.SinkFcParameters.InvocationType?

            public var qualifier: UpdateEventStreamingRequest.Sink.SinkFcParameters.Qualifier?

            public var serviceName: UpdateEventStreamingRequest.Sink.SinkFcParameters.ServiceName?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.body?.validate()
                try self.concurrency?.validate()
                try self.functionName?.validate()
                try self.invocationType?.validate()
                try self.qualifier?.validate()
                try self.serviceName?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body?.toMap()
                }
                if self.concurrency != nil {
                    map["Concurrency"] = self.concurrency?.toMap()
                }
                if self.functionName != nil {
                    map["FunctionName"] = self.functionName?.toMap()
                }
                if self.invocationType != nil {
                    map["InvocationType"] = self.invocationType?.toMap()
                }
                if self.qualifier != nil {
                    map["Qualifier"] = self.qualifier?.toMap()
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") {
                    var model = UpdateEventStreamingRequest.Sink.SinkFcParameters.Body()
                    model.fromMap(dict["Body"] as! [String: Any])
                    self.body = model
                }
                if dict.keys.contains("Concurrency") {
                    var model = UpdateEventStreamingRequest.Sink.SinkFcParameters.Concurrency()
                    model.fromMap(dict["Concurrency"] as! [String: Any])
                    self.concurrency = model
                }
                if dict.keys.contains("FunctionName") {
                    var model = UpdateEventStreamingRequest.Sink.SinkFcParameters.FunctionName()
                    model.fromMap(dict["FunctionName"] as! [String: Any])
                    self.functionName = model
                }
                if dict.keys.contains("InvocationType") {
                    var model = UpdateEventStreamingRequest.Sink.SinkFcParameters.InvocationType()
                    model.fromMap(dict["InvocationType"] as! [String: Any])
                    self.invocationType = model
                }
                if dict.keys.contains("Qualifier") {
                    var model = UpdateEventStreamingRequest.Sink.SinkFcParameters.Qualifier()
                    model.fromMap(dict["Qualifier"] as! [String: Any])
                    self.qualifier = model
                }
                if dict.keys.contains("ServiceName") {
                    var model = UpdateEventStreamingRequest.Sink.SinkFcParameters.ServiceName()
                    model.fromMap(dict["ServiceName"] as! [String: Any])
                    self.serviceName = model
                }
            }
        }
        public class SinkFnfParameters : Tea.TeaModel {
            public class ExecutionName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class FlowName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Input : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class RoleName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var executionName: UpdateEventStreamingRequest.Sink.SinkFnfParameters.ExecutionName?

            public var flowName: UpdateEventStreamingRequest.Sink.SinkFnfParameters.FlowName?

            public var input: UpdateEventStreamingRequest.Sink.SinkFnfParameters.Input?

            public var roleName: UpdateEventStreamingRequest.Sink.SinkFnfParameters.RoleName?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.executionName?.validate()
                try self.flowName?.validate()
                try self.input?.validate()
                try self.roleName?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.executionName != nil {
                    map["ExecutionName"] = self.executionName?.toMap()
                }
                if self.flowName != nil {
                    map["FlowName"] = self.flowName?.toMap()
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.roleName != nil {
                    map["RoleName"] = self.roleName?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ExecutionName") {
                    var model = UpdateEventStreamingRequest.Sink.SinkFnfParameters.ExecutionName()
                    model.fromMap(dict["ExecutionName"] as! [String: Any])
                    self.executionName = model
                }
                if dict.keys.contains("FlowName") {
                    var model = UpdateEventStreamingRequest.Sink.SinkFnfParameters.FlowName()
                    model.fromMap(dict["FlowName"] as! [String: Any])
                    self.flowName = model
                }
                if dict.keys.contains("Input") {
                    var model = UpdateEventStreamingRequest.Sink.SinkFnfParameters.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("RoleName") {
                    var model = UpdateEventStreamingRequest.Sink.SinkFnfParameters.RoleName()
                    model.fromMap(dict["RoleName"] as! [String: Any])
                    self.roleName = model
                }
            }
        }
        public class SinkKafkaParameters : Tea.TeaModel {
            public class Acks : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class InstanceId : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Key : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Topic : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Value : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var acks: UpdateEventStreamingRequest.Sink.SinkKafkaParameters.Acks?

            public var instanceId: UpdateEventStreamingRequest.Sink.SinkKafkaParameters.InstanceId?

            public var key: UpdateEventStreamingRequest.Sink.SinkKafkaParameters.Key?

            public var topic: UpdateEventStreamingRequest.Sink.SinkKafkaParameters.Topic?

            public var value: UpdateEventStreamingRequest.Sink.SinkKafkaParameters.Value?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.acks?.validate()
                try self.instanceId?.validate()
                try self.key?.validate()
                try self.topic?.validate()
                try self.value?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.acks != nil {
                    map["Acks"] = self.acks?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId?.toMap()
                }
                if self.key != nil {
                    map["Key"] = self.key?.toMap()
                }
                if self.topic != nil {
                    map["Topic"] = self.topic?.toMap()
                }
                if self.value != nil {
                    map["Value"] = self.value?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Acks") {
                    var model = UpdateEventStreamingRequest.Sink.SinkKafkaParameters.Acks()
                    model.fromMap(dict["Acks"] as! [String: Any])
                    self.acks = model
                }
                if dict.keys.contains("InstanceId") {
                    var model = UpdateEventStreamingRequest.Sink.SinkKafkaParameters.InstanceId()
                    model.fromMap(dict["InstanceId"] as! [String: Any])
                    self.instanceId = model
                }
                if dict.keys.contains("Key") {
                    var model = UpdateEventStreamingRequest.Sink.SinkKafkaParameters.Key()
                    model.fromMap(dict["Key"] as! [String: Any])
                    self.key = model
                }
                if dict.keys.contains("Topic") {
                    var model = UpdateEventStreamingRequest.Sink.SinkKafkaParameters.Topic()
                    model.fromMap(dict["Topic"] as! [String: Any])
                    self.topic = model
                }
                if dict.keys.contains("Value") {
                    var model = UpdateEventStreamingRequest.Sink.SinkKafkaParameters.Value()
                    model.fromMap(dict["Value"] as! [String: Any])
                    self.value = model
                }
            }
        }
        public class SinkMNSParameters : Tea.TeaModel {
            public class Body : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class IsBase64Encode : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class QueueName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var body: UpdateEventStreamingRequest.Sink.SinkMNSParameters.Body?

            public var isBase64Encode: UpdateEventStreamingRequest.Sink.SinkMNSParameters.IsBase64Encode?

            public var queueName: UpdateEventStreamingRequest.Sink.SinkMNSParameters.QueueName?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.body?.validate()
                try self.isBase64Encode?.validate()
                try self.queueName?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body?.toMap()
                }
                if self.isBase64Encode != nil {
                    map["IsBase64Encode"] = self.isBase64Encode?.toMap()
                }
                if self.queueName != nil {
                    map["QueueName"] = self.queueName?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") {
                    var model = UpdateEventStreamingRequest.Sink.SinkMNSParameters.Body()
                    model.fromMap(dict["Body"] as! [String: Any])
                    self.body = model
                }
                if dict.keys.contains("IsBase64Encode") {
                    var model = UpdateEventStreamingRequest.Sink.SinkMNSParameters.IsBase64Encode()
                    model.fromMap(dict["IsBase64Encode"] as! [String: Any])
                    self.isBase64Encode = model
                }
                if dict.keys.contains("QueueName") {
                    var model = UpdateEventStreamingRequest.Sink.SinkMNSParameters.QueueName()
                    model.fromMap(dict["QueueName"] as! [String: Any])
                    self.queueName = model
                }
            }
        }
        public class SinkPrometheusParameters : Tea.TeaModel {
            public class AuthorizationType : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Data : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class NetworkType : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Password : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class SecurityGroupId : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class URL : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Username : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class VSwitchId : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class VpcId : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var authorizationType: UpdateEventStreamingRequest.Sink.SinkPrometheusParameters.AuthorizationType?

            public var data: UpdateEventStreamingRequest.Sink.SinkPrometheusParameters.Data?

            public var networkType: UpdateEventStreamingRequest.Sink.SinkPrometheusParameters.NetworkType?

            public var password: UpdateEventStreamingRequest.Sink.SinkPrometheusParameters.Password?

            public var securityGroupId: UpdateEventStreamingRequest.Sink.SinkPrometheusParameters.SecurityGroupId?

            public var URL: UpdateEventStreamingRequest.Sink.SinkPrometheusParameters.URL?

            public var username: UpdateEventStreamingRequest.Sink.SinkPrometheusParameters.Username?

            public var vSwitchId: UpdateEventStreamingRequest.Sink.SinkPrometheusParameters.VSwitchId?

            public var vpcId: UpdateEventStreamingRequest.Sink.SinkPrometheusParameters.VpcId?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.authorizationType?.validate()
                try self.data?.validate()
                try self.networkType?.validate()
                try self.password?.validate()
                try self.securityGroupId?.validate()
                try self.URL?.validate()
                try self.username?.validate()
                try self.vSwitchId?.validate()
                try self.vpcId?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorizationType != nil {
                    map["AuthorizationType"] = self.authorizationType?.toMap()
                }
                if self.data != nil {
                    map["Data"] = self.data?.toMap()
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType?.toMap()
                }
                if self.password != nil {
                    map["Password"] = self.password?.toMap()
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId?.toMap()
                }
                if self.URL != nil {
                    map["URL"] = self.URL?.toMap()
                }
                if self.username != nil {
                    map["Username"] = self.username?.toMap()
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuthorizationType") {
                    var model = UpdateEventStreamingRequest.Sink.SinkPrometheusParameters.AuthorizationType()
                    model.fromMap(dict["AuthorizationType"] as! [String: Any])
                    self.authorizationType = model
                }
                if dict.keys.contains("Data") {
                    var model = UpdateEventStreamingRequest.Sink.SinkPrometheusParameters.Data()
                    model.fromMap(dict["Data"] as! [String: Any])
                    self.data = model
                }
                if dict.keys.contains("NetworkType") {
                    var model = UpdateEventStreamingRequest.Sink.SinkPrometheusParameters.NetworkType()
                    model.fromMap(dict["NetworkType"] as! [String: Any])
                    self.networkType = model
                }
                if dict.keys.contains("Password") {
                    var model = UpdateEventStreamingRequest.Sink.SinkPrometheusParameters.Password()
                    model.fromMap(dict["Password"] as! [String: Any])
                    self.password = model
                }
                if dict.keys.contains("SecurityGroupId") {
                    var model = UpdateEventStreamingRequest.Sink.SinkPrometheusParameters.SecurityGroupId()
                    model.fromMap(dict["SecurityGroupId"] as! [String: Any])
                    self.securityGroupId = model
                }
                if dict.keys.contains("URL") {
                    var model = UpdateEventStreamingRequest.Sink.SinkPrometheusParameters.URL()
                    model.fromMap(dict["URL"] as! [String: Any])
                    self.URL = model
                }
                if dict.keys.contains("Username") {
                    var model = UpdateEventStreamingRequest.Sink.SinkPrometheusParameters.Username()
                    model.fromMap(dict["Username"] as! [String: Any])
                    self.username = model
                }
                if dict.keys.contains("VSwitchId") {
                    var model = UpdateEventStreamingRequest.Sink.SinkPrometheusParameters.VSwitchId()
                    model.fromMap(dict["VSwitchId"] as! [String: Any])
                    self.vSwitchId = model
                }
                if dict.keys.contains("VpcId") {
                    var model = UpdateEventStreamingRequest.Sink.SinkPrometheusParameters.VpcId()
                    model.fromMap(dict["VpcId"] as! [String: Any])
                    self.vpcId = model
                }
            }
        }
        public class SinkRabbitMQParameters : Tea.TeaModel {
            public class Body : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Exchange : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class InstanceId : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class MessageId : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Properties : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class QueueName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class RoutingKey : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class TargetType : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class VirtualHostName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var body: UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters.Body?

            public var exchange: UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters.Exchange?

            public var instanceId: UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters.InstanceId?

            public var messageId: UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters.MessageId?

            public var properties: UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters.Properties?

            public var queueName: UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters.QueueName?

            public var routingKey: UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters.RoutingKey?

            public var targetType: UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters.TargetType?

            public var virtualHostName: UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters.VirtualHostName?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.body?.validate()
                try self.exchange?.validate()
                try self.instanceId?.validate()
                try self.messageId?.validate()
                try self.properties?.validate()
                try self.queueName?.validate()
                try self.routingKey?.validate()
                try self.targetType?.validate()
                try self.virtualHostName?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body?.toMap()
                }
                if self.exchange != nil {
                    map["Exchange"] = self.exchange?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId?.toMap()
                }
                if self.messageId != nil {
                    map["MessageId"] = self.messageId?.toMap()
                }
                if self.properties != nil {
                    map["Properties"] = self.properties?.toMap()
                }
                if self.queueName != nil {
                    map["QueueName"] = self.queueName?.toMap()
                }
                if self.routingKey != nil {
                    map["RoutingKey"] = self.routingKey?.toMap()
                }
                if self.targetType != nil {
                    map["TargetType"] = self.targetType?.toMap()
                }
                if self.virtualHostName != nil {
                    map["VirtualHostName"] = self.virtualHostName?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") {
                    var model = UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters.Body()
                    model.fromMap(dict["Body"] as! [String: Any])
                    self.body = model
                }
                if dict.keys.contains("Exchange") {
                    var model = UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters.Exchange()
                    model.fromMap(dict["Exchange"] as! [String: Any])
                    self.exchange = model
                }
                if dict.keys.contains("InstanceId") {
                    var model = UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters.InstanceId()
                    model.fromMap(dict["InstanceId"] as! [String: Any])
                    self.instanceId = model
                }
                if dict.keys.contains("MessageId") {
                    var model = UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters.MessageId()
                    model.fromMap(dict["MessageId"] as! [String: Any])
                    self.messageId = model
                }
                if dict.keys.contains("Properties") {
                    var model = UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters.Properties()
                    model.fromMap(dict["Properties"] as! [String: Any])
                    self.properties = model
                }
                if dict.keys.contains("QueueName") {
                    var model = UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters.QueueName()
                    model.fromMap(dict["QueueName"] as! [String: Any])
                    self.queueName = model
                }
                if dict.keys.contains("RoutingKey") {
                    var model = UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters.RoutingKey()
                    model.fromMap(dict["RoutingKey"] as! [String: Any])
                    self.routingKey = model
                }
                if dict.keys.contains("TargetType") {
                    var model = UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters.TargetType()
                    model.fromMap(dict["TargetType"] as! [String: Any])
                    self.targetType = model
                }
                if dict.keys.contains("VirtualHostName") {
                    var model = UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters.VirtualHostName()
                    model.fromMap(dict["VirtualHostName"] as! [String: Any])
                    self.virtualHostName = model
                }
            }
        }
        public class SinkRocketMQParameters : Tea.TeaModel {
            public class Body : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class InstanceId : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Keys : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Properties : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Topic : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var body: UpdateEventStreamingRequest.Sink.SinkRocketMQParameters.Body?

            public var instanceId: UpdateEventStreamingRequest.Sink.SinkRocketMQParameters.InstanceId?

            public var keys: UpdateEventStreamingRequest.Sink.SinkRocketMQParameters.Keys?

            public var properties: UpdateEventStreamingRequest.Sink.SinkRocketMQParameters.Properties?

            public var tags: UpdateEventStreamingRequest.Sink.SinkRocketMQParameters.Tags?

            public var topic: UpdateEventStreamingRequest.Sink.SinkRocketMQParameters.Topic?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.body?.validate()
                try self.instanceId?.validate()
                try self.keys?.validate()
                try self.properties?.validate()
                try self.tags?.validate()
                try self.topic?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId?.toMap()
                }
                if self.keys != nil {
                    map["Keys"] = self.keys?.toMap()
                }
                if self.properties != nil {
                    map["Properties"] = self.properties?.toMap()
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.topic != nil {
                    map["Topic"] = self.topic?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") {
                    var model = UpdateEventStreamingRequest.Sink.SinkRocketMQParameters.Body()
                    model.fromMap(dict["Body"] as! [String: Any])
                    self.body = model
                }
                if dict.keys.contains("InstanceId") {
                    var model = UpdateEventStreamingRequest.Sink.SinkRocketMQParameters.InstanceId()
                    model.fromMap(dict["InstanceId"] as! [String: Any])
                    self.instanceId = model
                }
                if dict.keys.contains("Keys") {
                    var model = UpdateEventStreamingRequest.Sink.SinkRocketMQParameters.Keys()
                    model.fromMap(dict["Keys"] as! [String: Any])
                    self.keys = model
                }
                if dict.keys.contains("Properties") {
                    var model = UpdateEventStreamingRequest.Sink.SinkRocketMQParameters.Properties()
                    model.fromMap(dict["Properties"] as! [String: Any])
                    self.properties = model
                }
                if dict.keys.contains("Tags") {
                    var model = UpdateEventStreamingRequest.Sink.SinkRocketMQParameters.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("Topic") {
                    var model = UpdateEventStreamingRequest.Sink.SinkRocketMQParameters.Topic()
                    model.fromMap(dict["Topic"] as! [String: Any])
                    self.topic = model
                }
            }
        }
        public class SinkSLSParameters : Tea.TeaModel {
            public class Body : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class LogStore : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Project : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class RoleName : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Topic : Tea.TeaModel {
                public var form: String?

                public var template: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.form != nil {
                        map["Form"] = self.form!
                    }
                    if self.template != nil {
                        map["Template"] = self.template!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Form") {
                        self.form = dict["Form"] as! String
                    }
                    if dict.keys.contains("Template") {
                        self.template = dict["Template"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var body: UpdateEventStreamingRequest.Sink.SinkSLSParameters.Body?

            public var logStore: UpdateEventStreamingRequest.Sink.SinkSLSParameters.LogStore?

            public var project: UpdateEventStreamingRequest.Sink.SinkSLSParameters.Project?

            public var roleName: UpdateEventStreamingRequest.Sink.SinkSLSParameters.RoleName?

            public var topic: UpdateEventStreamingRequest.Sink.SinkSLSParameters.Topic?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.body?.validate()
                try self.logStore?.validate()
                try self.project?.validate()
                try self.roleName?.validate()
                try self.topic?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body?.toMap()
                }
                if self.logStore != nil {
                    map["LogStore"] = self.logStore?.toMap()
                }
                if self.project != nil {
                    map["Project"] = self.project?.toMap()
                }
                if self.roleName != nil {
                    map["RoleName"] = self.roleName?.toMap()
                }
                if self.topic != nil {
                    map["Topic"] = self.topic?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") {
                    var model = UpdateEventStreamingRequest.Sink.SinkSLSParameters.Body()
                    model.fromMap(dict["Body"] as! [String: Any])
                    self.body = model
                }
                if dict.keys.contains("LogStore") {
                    var model = UpdateEventStreamingRequest.Sink.SinkSLSParameters.LogStore()
                    model.fromMap(dict["LogStore"] as! [String: Any])
                    self.logStore = model
                }
                if dict.keys.contains("Project") {
                    var model = UpdateEventStreamingRequest.Sink.SinkSLSParameters.Project()
                    model.fromMap(dict["Project"] as! [String: Any])
                    self.project = model
                }
                if dict.keys.contains("RoleName") {
                    var model = UpdateEventStreamingRequest.Sink.SinkSLSParameters.RoleName()
                    model.fromMap(dict["RoleName"] as! [String: Any])
                    self.roleName = model
                }
                if dict.keys.contains("Topic") {
                    var model = UpdateEventStreamingRequest.Sink.SinkSLSParameters.Topic()
                    model.fromMap(dict["Topic"] as! [String: Any])
                    self.topic = model
                }
            }
        }
        public var sinkFcParameters: UpdateEventStreamingRequest.Sink.SinkFcParameters?

        public var sinkFnfParameters: UpdateEventStreamingRequest.Sink.SinkFnfParameters?

        public var sinkKafkaParameters: UpdateEventStreamingRequest.Sink.SinkKafkaParameters?

        public var sinkMNSParameters: UpdateEventStreamingRequest.Sink.SinkMNSParameters?

        public var sinkPrometheusParameters: UpdateEventStreamingRequest.Sink.SinkPrometheusParameters?

        public var sinkRabbitMQParameters: UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters?

        public var sinkRocketMQParameters: UpdateEventStreamingRequest.Sink.SinkRocketMQParameters?

        public var sinkSLSParameters: UpdateEventStreamingRequest.Sink.SinkSLSParameters?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sinkFcParameters?.validate()
            try self.sinkFnfParameters?.validate()
            try self.sinkKafkaParameters?.validate()
            try self.sinkMNSParameters?.validate()
            try self.sinkPrometheusParameters?.validate()
            try self.sinkRabbitMQParameters?.validate()
            try self.sinkRocketMQParameters?.validate()
            try self.sinkSLSParameters?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sinkFcParameters != nil {
                map["SinkFcParameters"] = self.sinkFcParameters?.toMap()
            }
            if self.sinkFnfParameters != nil {
                map["SinkFnfParameters"] = self.sinkFnfParameters?.toMap()
            }
            if self.sinkKafkaParameters != nil {
                map["SinkKafkaParameters"] = self.sinkKafkaParameters?.toMap()
            }
            if self.sinkMNSParameters != nil {
                map["SinkMNSParameters"] = self.sinkMNSParameters?.toMap()
            }
            if self.sinkPrometheusParameters != nil {
                map["SinkPrometheusParameters"] = self.sinkPrometheusParameters?.toMap()
            }
            if self.sinkRabbitMQParameters != nil {
                map["SinkRabbitMQParameters"] = self.sinkRabbitMQParameters?.toMap()
            }
            if self.sinkRocketMQParameters != nil {
                map["SinkRocketMQParameters"] = self.sinkRocketMQParameters?.toMap()
            }
            if self.sinkSLSParameters != nil {
                map["SinkSLSParameters"] = self.sinkSLSParameters?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SinkFcParameters") {
                var model = UpdateEventStreamingRequest.Sink.SinkFcParameters()
                model.fromMap(dict["SinkFcParameters"] as! [String: Any])
                self.sinkFcParameters = model
            }
            if dict.keys.contains("SinkFnfParameters") {
                var model = UpdateEventStreamingRequest.Sink.SinkFnfParameters()
                model.fromMap(dict["SinkFnfParameters"] as! [String: Any])
                self.sinkFnfParameters = model
            }
            if dict.keys.contains("SinkKafkaParameters") {
                var model = UpdateEventStreamingRequest.Sink.SinkKafkaParameters()
                model.fromMap(dict["SinkKafkaParameters"] as! [String: Any])
                self.sinkKafkaParameters = model
            }
            if dict.keys.contains("SinkMNSParameters") {
                var model = UpdateEventStreamingRequest.Sink.SinkMNSParameters()
                model.fromMap(dict["SinkMNSParameters"] as! [String: Any])
                self.sinkMNSParameters = model
            }
            if dict.keys.contains("SinkPrometheusParameters") {
                var model = UpdateEventStreamingRequest.Sink.SinkPrometheusParameters()
                model.fromMap(dict["SinkPrometheusParameters"] as! [String: Any])
                self.sinkPrometheusParameters = model
            }
            if dict.keys.contains("SinkRabbitMQParameters") {
                var model = UpdateEventStreamingRequest.Sink.SinkRabbitMQParameters()
                model.fromMap(dict["SinkRabbitMQParameters"] as! [String: Any])
                self.sinkRabbitMQParameters = model
            }
            if dict.keys.contains("SinkRocketMQParameters") {
                var model = UpdateEventStreamingRequest.Sink.SinkRocketMQParameters()
                model.fromMap(dict["SinkRocketMQParameters"] as! [String: Any])
                self.sinkRocketMQParameters = model
            }
            if dict.keys.contains("SinkSLSParameters") {
                var model = UpdateEventStreamingRequest.Sink.SinkSLSParameters()
                model.fromMap(dict["SinkSLSParameters"] as! [String: Any])
                self.sinkSLSParameters = model
            }
        }
    }
    public class Source : Tea.TeaModel {
        public class SourceApacheKafkaParameters : Tea.TeaModel {
            public var bootstraps: String?

            public var consumerGroup: String?

            public var networkType: String?

            public var offsetReset: String?

            public var saslMechanism: String?

            public var saslPassword: String?

            public var saslUser: String?

            public var securityGroupId: String?

            public var securityProtocol: String?

            public var topic: String?

            public var vSwitchIds: String?

            public var valueDataType: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bootstraps != nil {
                    map["Bootstraps"] = self.bootstraps!
                }
                if self.consumerGroup != nil {
                    map["ConsumerGroup"] = self.consumerGroup!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.offsetReset != nil {
                    map["OffsetReset"] = self.offsetReset!
                }
                if self.saslMechanism != nil {
                    map["SaslMechanism"] = self.saslMechanism!
                }
                if self.saslPassword != nil {
                    map["SaslPassword"] = self.saslPassword!
                }
                if self.saslUser != nil {
                    map["SaslUser"] = self.saslUser!
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                if self.securityProtocol != nil {
                    map["SecurityProtocol"] = self.securityProtocol!
                }
                if self.topic != nil {
                    map["Topic"] = self.topic!
                }
                if self.vSwitchIds != nil {
                    map["VSwitchIds"] = self.vSwitchIds!
                }
                if self.valueDataType != nil {
                    map["ValueDataType"] = self.valueDataType!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bootstraps") {
                    self.bootstraps = dict["Bootstraps"] as! String
                }
                if dict.keys.contains("ConsumerGroup") {
                    self.consumerGroup = dict["ConsumerGroup"] as! String
                }
                if dict.keys.contains("NetworkType") {
                    self.networkType = dict["NetworkType"] as! String
                }
                if dict.keys.contains("OffsetReset") {
                    self.offsetReset = dict["OffsetReset"] as! String
                }
                if dict.keys.contains("SaslMechanism") {
                    self.saslMechanism = dict["SaslMechanism"] as! String
                }
                if dict.keys.contains("SaslPassword") {
                    self.saslPassword = dict["SaslPassword"] as! String
                }
                if dict.keys.contains("SaslUser") {
                    self.saslUser = dict["SaslUser"] as! String
                }
                if dict.keys.contains("SecurityGroupId") {
                    self.securityGroupId = dict["SecurityGroupId"] as! String
                }
                if dict.keys.contains("SecurityProtocol") {
                    self.securityProtocol = dict["SecurityProtocol"] as! String
                }
                if dict.keys.contains("Topic") {
                    self.topic = dict["Topic"] as! String
                }
                if dict.keys.contains("VSwitchIds") {
                    self.vSwitchIds = dict["VSwitchIds"] as! String
                }
                if dict.keys.contains("ValueDataType") {
                    self.valueDataType = dict["ValueDataType"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public class SourceDTSParameters : Tea.TeaModel {
            public var brokerUrl: String?

            public var initCheckPoint: Int64?

            public var password: String?

            public var sid: String?

            public var taskId: String?

            public var topic: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.brokerUrl != nil {
                    map["BrokerUrl"] = self.brokerUrl!
                }
                if self.initCheckPoint != nil {
                    map["InitCheckPoint"] = self.initCheckPoint!
                }
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.sid != nil {
                    map["Sid"] = self.sid!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.topic != nil {
                    map["Topic"] = self.topic!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BrokerUrl") {
                    self.brokerUrl = dict["BrokerUrl"] as! String
                }
                if dict.keys.contains("InitCheckPoint") {
                    self.initCheckPoint = dict["InitCheckPoint"] as! Int64
                }
                if dict.keys.contains("Password") {
                    self.password = dict["Password"] as! String
                }
                if dict.keys.contains("Sid") {
                    self.sid = dict["Sid"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("Topic") {
                    self.topic = dict["Topic"] as! String
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
            }
        }
        public class SourceKafkaParameters : Tea.TeaModel {
            public var consumerGroup: String?

            public var instanceId: String?

            public var network: String?

            public var offsetReset: String?

            public var regionId: String?

            public var securityGroupId: String?

            public var topic: String?

            public var vSwitchIds: String?

            public var valueDataType: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.consumerGroup != nil {
                    map["ConsumerGroup"] = self.consumerGroup!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.network != nil {
                    map["Network"] = self.network!
                }
                if self.offsetReset != nil {
                    map["OffsetReset"] = self.offsetReset!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                if self.topic != nil {
                    map["Topic"] = self.topic!
                }
                if self.vSwitchIds != nil {
                    map["VSwitchIds"] = self.vSwitchIds!
                }
                if self.valueDataType != nil {
                    map["ValueDataType"] = self.valueDataType!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConsumerGroup") {
                    self.consumerGroup = dict["ConsumerGroup"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Network") {
                    self.network = dict["Network"] as! String
                }
                if dict.keys.contains("OffsetReset") {
                    self.offsetReset = dict["OffsetReset"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SecurityGroupId") {
                    self.securityGroupId = dict["SecurityGroupId"] as! String
                }
                if dict.keys.contains("Topic") {
                    self.topic = dict["Topic"] as! String
                }
                if dict.keys.contains("VSwitchIds") {
                    self.vSwitchIds = dict["VSwitchIds"] as! String
                }
                if dict.keys.contains("ValueDataType") {
                    self.valueDataType = dict["ValueDataType"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public class SourceMNSParameters : Tea.TeaModel {
            public var isBase64Decode: Bool?

            public var queueName: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isBase64Decode != nil {
                    map["IsBase64Decode"] = self.isBase64Decode!
                }
                if self.queueName != nil {
                    map["QueueName"] = self.queueName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IsBase64Decode") {
                    self.isBase64Decode = dict["IsBase64Decode"] as! Bool
                }
                if dict.keys.contains("QueueName") {
                    self.queueName = dict["QueueName"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public class SourceMQTTParameters : Tea.TeaModel {
            public var instanceId: String?

            public var regionId: String?

            public var topic: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.topic != nil {
                    map["Topic"] = self.topic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Topic") {
                    self.topic = dict["Topic"] as! String
                }
            }
        }
        public class SourcePrometheusParameters : Tea.TeaModel {
            public var clusterId: String?

            public var dataType: String?

            public var labels: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.dataType != nil {
                    map["DataType"] = self.dataType!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("DataType") {
                    self.dataType = dict["DataType"] as! String
                }
                if dict.keys.contains("Labels") {
                    self.labels = dict["Labels"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public class SourceRabbitMQParameters : Tea.TeaModel {
            public var instanceId: String?

            public var queueName: String?

            public var regionId: String?

            public var virtualHostName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.queueName != nil {
                    map["QueueName"] = self.queueName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.virtualHostName != nil {
                    map["VirtualHostName"] = self.virtualHostName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("QueueName") {
                    self.queueName = dict["QueueName"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("VirtualHostName") {
                    self.virtualHostName = dict["VirtualHostName"] as! String
                }
            }
        }
        public class SourceRocketMQParameters : Tea.TeaModel {
            public var authType: String?

            public var bodyDataType: String?

            public var groupID: String?

            public var instanceEndpoint: String?

            public var instanceId: String?

            public var instanceNetwork: String?

            public var instancePassword: String?

            public var instanceSecurityGroupId: String?

            public var instanceType: String?

            public var instanceUsername: String?

            public var instanceVSwitchIds: String?

            public var instanceVpcId: String?

            public var offset: String?

            public var regionId: String?

            public var tag: String?

            public var timestamp: Int64?

            public var topic: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authType != nil {
                    map["AuthType"] = self.authType!
                }
                if self.bodyDataType != nil {
                    map["BodyDataType"] = self.bodyDataType!
                }
                if self.groupID != nil {
                    map["GroupID"] = self.groupID!
                }
                if self.instanceEndpoint != nil {
                    map["InstanceEndpoint"] = self.instanceEndpoint!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceNetwork != nil {
                    map["InstanceNetwork"] = self.instanceNetwork!
                }
                if self.instancePassword != nil {
                    map["InstancePassword"] = self.instancePassword!
                }
                if self.instanceSecurityGroupId != nil {
                    map["InstanceSecurityGroupId"] = self.instanceSecurityGroupId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.instanceUsername != nil {
                    map["InstanceUsername"] = self.instanceUsername!
                }
                if self.instanceVSwitchIds != nil {
                    map["InstanceVSwitchIds"] = self.instanceVSwitchIds!
                }
                if self.instanceVpcId != nil {
                    map["InstanceVpcId"] = self.instanceVpcId!
                }
                if self.offset != nil {
                    map["Offset"] = self.offset!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.topic != nil {
                    map["Topic"] = self.topic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuthType") {
                    self.authType = dict["AuthType"] as! String
                }
                if dict.keys.contains("BodyDataType") {
                    self.bodyDataType = dict["BodyDataType"] as! String
                }
                if dict.keys.contains("GroupID") {
                    self.groupID = dict["GroupID"] as! String
                }
                if dict.keys.contains("InstanceEndpoint") {
                    self.instanceEndpoint = dict["InstanceEndpoint"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceNetwork") {
                    self.instanceNetwork = dict["InstanceNetwork"] as! String
                }
                if dict.keys.contains("InstancePassword") {
                    self.instancePassword = dict["InstancePassword"] as! String
                }
                if dict.keys.contains("InstanceSecurityGroupId") {
                    self.instanceSecurityGroupId = dict["InstanceSecurityGroupId"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("InstanceUsername") {
                    self.instanceUsername = dict["InstanceUsername"] as! String
                }
                if dict.keys.contains("InstanceVSwitchIds") {
                    self.instanceVSwitchIds = dict["InstanceVSwitchIds"] as! String
                }
                if dict.keys.contains("InstanceVpcId") {
                    self.instanceVpcId = dict["InstanceVpcId"] as! String
                }
                if dict.keys.contains("Offset") {
                    self.offset = dict["Offset"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Tag") {
                    self.tag = dict["Tag"] as! String
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
                if dict.keys.contains("Topic") {
                    self.topic = dict["Topic"] as! String
                }
            }
        }
        public class SourceSLSParameters : Tea.TeaModel {
            public var roleName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.roleName != nil {
                    map["RoleName"] = self.roleName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RoleName") {
                    self.roleName = dict["RoleName"] as! String
                }
            }
        }
        public var sourceApacheKafkaParameters: UpdateEventStreamingRequest.Source.SourceApacheKafkaParameters?

        public var sourceDTSParameters: UpdateEventStreamingRequest.Source.SourceDTSParameters?

        public var sourceKafkaParameters: UpdateEventStreamingRequest.Source.SourceKafkaParameters?

        public var sourceMNSParameters: UpdateEventStreamingRequest.Source.SourceMNSParameters?

        public var sourceMQTTParameters: UpdateEventStreamingRequest.Source.SourceMQTTParameters?

        public var sourcePrometheusParameters: UpdateEventStreamingRequest.Source.SourcePrometheusParameters?

        public var sourceRabbitMQParameters: UpdateEventStreamingRequest.Source.SourceRabbitMQParameters?

        public var sourceRocketMQParameters: UpdateEventStreamingRequest.Source.SourceRocketMQParameters?

        public var sourceSLSParameters: UpdateEventStreamingRequest.Source.SourceSLSParameters?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sourceApacheKafkaParameters?.validate()
            try self.sourceDTSParameters?.validate()
            try self.sourceKafkaParameters?.validate()
            try self.sourceMNSParameters?.validate()
            try self.sourceMQTTParameters?.validate()
            try self.sourcePrometheusParameters?.validate()
            try self.sourceRabbitMQParameters?.validate()
            try self.sourceRocketMQParameters?.validate()
            try self.sourceSLSParameters?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sourceApacheKafkaParameters != nil {
                map["SourceApacheKafkaParameters"] = self.sourceApacheKafkaParameters?.toMap()
            }
            if self.sourceDTSParameters != nil {
                map["SourceDTSParameters"] = self.sourceDTSParameters?.toMap()
            }
            if self.sourceKafkaParameters != nil {
                map["SourceKafkaParameters"] = self.sourceKafkaParameters?.toMap()
            }
            if self.sourceMNSParameters != nil {
                map["SourceMNSParameters"] = self.sourceMNSParameters?.toMap()
            }
            if self.sourceMQTTParameters != nil {
                map["SourceMQTTParameters"] = self.sourceMQTTParameters?.toMap()
            }
            if self.sourcePrometheusParameters != nil {
                map["SourcePrometheusParameters"] = self.sourcePrometheusParameters?.toMap()
            }
            if self.sourceRabbitMQParameters != nil {
                map["SourceRabbitMQParameters"] = self.sourceRabbitMQParameters?.toMap()
            }
            if self.sourceRocketMQParameters != nil {
                map["SourceRocketMQParameters"] = self.sourceRocketMQParameters?.toMap()
            }
            if self.sourceSLSParameters != nil {
                map["SourceSLSParameters"] = self.sourceSLSParameters?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SourceApacheKafkaParameters") {
                var model = UpdateEventStreamingRequest.Source.SourceApacheKafkaParameters()
                model.fromMap(dict["SourceApacheKafkaParameters"] as! [String: Any])
                self.sourceApacheKafkaParameters = model
            }
            if dict.keys.contains("SourceDTSParameters") {
                var model = UpdateEventStreamingRequest.Source.SourceDTSParameters()
                model.fromMap(dict["SourceDTSParameters"] as! [String: Any])
                self.sourceDTSParameters = model
            }
            if dict.keys.contains("SourceKafkaParameters") {
                var model = UpdateEventStreamingRequest.Source.SourceKafkaParameters()
                model.fromMap(dict["SourceKafkaParameters"] as! [String: Any])
                self.sourceKafkaParameters = model
            }
            if dict.keys.contains("SourceMNSParameters") {
                var model = UpdateEventStreamingRequest.Source.SourceMNSParameters()
                model.fromMap(dict["SourceMNSParameters"] as! [String: Any])
                self.sourceMNSParameters = model
            }
            if dict.keys.contains("SourceMQTTParameters") {
                var model = UpdateEventStreamingRequest.Source.SourceMQTTParameters()
                model.fromMap(dict["SourceMQTTParameters"] as! [String: Any])
                self.sourceMQTTParameters = model
            }
            if dict.keys.contains("SourcePrometheusParameters") {
                var model = UpdateEventStreamingRequest.Source.SourcePrometheusParameters()
                model.fromMap(dict["SourcePrometheusParameters"] as! [String: Any])
                self.sourcePrometheusParameters = model
            }
            if dict.keys.contains("SourceRabbitMQParameters") {
                var model = UpdateEventStreamingRequest.Source.SourceRabbitMQParameters()
                model.fromMap(dict["SourceRabbitMQParameters"] as! [String: Any])
                self.sourceRabbitMQParameters = model
            }
            if dict.keys.contains("SourceRocketMQParameters") {
                var model = UpdateEventStreamingRequest.Source.SourceRocketMQParameters()
                model.fromMap(dict["SourceRocketMQParameters"] as! [String: Any])
                self.sourceRocketMQParameters = model
            }
            if dict.keys.contains("SourceSLSParameters") {
                var model = UpdateEventStreamingRequest.Source.SourceSLSParameters()
                model.fromMap(dict["SourceSLSParameters"] as! [String: Any])
                self.sourceSLSParameters = model
            }
        }
    }
    public class Transforms : Tea.TeaModel {
        public var arn: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.arn != nil {
                map["Arn"] = self.arn!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Arn") {
                self.arn = dict["Arn"] as! String
            }
        }
    }
    public var description_: String?

    public var eventStreamingName: String?

    public var filterPattern: String?

    public var runOptions: UpdateEventStreamingRequest.RunOptions?

    public var sink: UpdateEventStreamingRequest.Sink?

    public var source: UpdateEventStreamingRequest.Source?

    public var transforms: [UpdateEventStreamingRequest.Transforms]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.runOptions?.validate()
        try self.sink?.validate()
        try self.source?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eventStreamingName != nil {
            map["EventStreamingName"] = self.eventStreamingName!
        }
        if self.filterPattern != nil {
            map["FilterPattern"] = self.filterPattern!
        }
        if self.runOptions != nil {
            map["RunOptions"] = self.runOptions?.toMap()
        }
        if self.sink != nil {
            map["Sink"] = self.sink?.toMap()
        }
        if self.source != nil {
            map["Source"] = self.source?.toMap()
        }
        if self.transforms != nil {
            var tmp : [Any] = []
            for k in self.transforms! {
                tmp.append(k.toMap())
            }
            map["Transforms"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EventStreamingName") {
            self.eventStreamingName = dict["EventStreamingName"] as! String
        }
        if dict.keys.contains("FilterPattern") {
            self.filterPattern = dict["FilterPattern"] as! String
        }
        if dict.keys.contains("RunOptions") {
            var model = UpdateEventStreamingRequest.RunOptions()
            model.fromMap(dict["RunOptions"] as! [String: Any])
            self.runOptions = model
        }
        if dict.keys.contains("Sink") {
            var model = UpdateEventStreamingRequest.Sink()
            model.fromMap(dict["Sink"] as! [String: Any])
            self.sink = model
        }
        if dict.keys.contains("Source") {
            var model = UpdateEventStreamingRequest.Source()
            model.fromMap(dict["Source"] as! [String: Any])
            self.source = model
        }
        if dict.keys.contains("Transforms") {
            var tmp : [UpdateEventStreamingRequest.Transforms] = []
            for v in dict["Transforms"] as! [Any] {
                var model = UpdateEventStreamingRequest.Transforms()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.transforms = tmp
        }
    }
}

public class UpdateEventStreamingShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var eventStreamingName: String?

    public var filterPattern: String?

    public var runOptionsShrink: String?

    public var sinkShrink: String?

    public var sourceShrink: String?

    public var transformsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eventStreamingName != nil {
            map["EventStreamingName"] = self.eventStreamingName!
        }
        if self.filterPattern != nil {
            map["FilterPattern"] = self.filterPattern!
        }
        if self.runOptionsShrink != nil {
            map["RunOptions"] = self.runOptionsShrink!
        }
        if self.sinkShrink != nil {
            map["Sink"] = self.sinkShrink!
        }
        if self.sourceShrink != nil {
            map["Source"] = self.sourceShrink!
        }
        if self.transformsShrink != nil {
            map["Transforms"] = self.transformsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EventStreamingName") {
            self.eventStreamingName = dict["EventStreamingName"] as! String
        }
        if dict.keys.contains("FilterPattern") {
            self.filterPattern = dict["FilterPattern"] as! String
        }
        if dict.keys.contains("RunOptions") {
            self.runOptionsShrink = dict["RunOptions"] as! String
        }
        if dict.keys.contains("Sink") {
            self.sinkShrink = dict["Sink"] as! String
        }
        if dict.keys.contains("Source") {
            self.sourceShrink = dict["Source"] as! String
        }
        if dict.keys.contains("Transforms") {
            self.transformsShrink = dict["Transforms"] as! String
        }
    }
}

public class UpdateEventStreamingResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateEventStreamingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEventStreamingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateEventStreamingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateRuleRequest : Tea.TeaModel {
    public var description_: String?

    public var eventBusName: String?

    public var filterPattern: String?

    public var ruleName: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.filterPattern != nil {
            map["FilterPattern"] = self.filterPattern!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("FilterPattern") {
            self.filterPattern = dict["FilterPattern"] as! String
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class UpdateRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
