import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class BindVariableRequest : Tea.TeaModel {
    public var lang: String?

    public var apiRegionId: String?

    public var apiType: String?

    public var createType: String?

    public var defineId: String?

    public var defineIds: String?

    public var description_: String?

    public var eventCode: String?

    public var exceptionValue: String?

    public var id: Int64?

    public var outputField: String?

    public var outputType: String?

    public var params: String?

    public var paramsList: String?

    public var regId: String?

    public var sourceType: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.apiRegionId != nil {
            map["apiRegionId"] = self.apiRegionId!
        }
        if self.apiType != nil {
            map["apiType"] = self.apiType!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.defineId != nil {
            map["defineId"] = self.defineId!
        }
        if self.defineIds != nil {
            map["defineIds"] = self.defineIds!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.exceptionValue != nil {
            map["exceptionValue"] = self.exceptionValue!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.outputField != nil {
            map["outputField"] = self.outputField!
        }
        if self.outputType != nil {
            map["outputType"] = self.outputType!
        }
        if self.params != nil {
            map["params"] = self.params!
        }
        if self.paramsList != nil {
            map["paramsList"] = self.paramsList!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.sourceType != nil {
            map["sourceType"] = self.sourceType!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("apiRegionId") {
            self.apiRegionId = dict["apiRegionId"] as! String
        }
        if dict.keys.contains("apiType") {
            self.apiType = dict["apiType"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("defineId") {
            self.defineId = dict["defineId"] as! String
        }
        if dict.keys.contains("defineIds") {
            self.defineIds = dict["defineIds"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("exceptionValue") {
            self.exceptionValue = dict["exceptionValue"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("outputField") {
            self.outputField = dict["outputField"] as! String
        }
        if dict.keys.contains("outputType") {
            self.outputType = dict["outputType"] as! String
        }
        if dict.keys.contains("params") {
            self.params = dict["params"] as! String
        }
        if dict.keys.contains("paramsList") {
            self.paramsList = dict["paramsList"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("sourceType") {
            self.sourceType = dict["sourceType"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
    }
}

public class BindVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class BindVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BindVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckCustVariableLimitRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class CheckCustVariableLimitResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CheckCustVariableLimitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckCustVariableLimitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CheckCustVariableLimitResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckExpressionVariableLimitRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class CheckExpressionVariableLimitResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CheckExpressionVariableLimitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckExpressionVariableLimitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CheckExpressionVariableLimitResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckFieldLimitRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("source") {
            self.source = dict["source"] as! String
        }
    }
}

public class CheckFieldLimitResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CheckFieldLimitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckFieldLimitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CheckFieldLimitResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckPermissionRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class CheckPermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CheckPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CheckPermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckUsageVariableRequest : Tea.TeaModel {
    public var lang: String?

    public var id: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class CheckUsageVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CheckUsageVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckUsageVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CheckUsageVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ClearNameListRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var variableId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.variableId != nil {
            map["variableId"] = self.variableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("variableId") {
            self.variableId = dict["variableId"] as! Int64
        }
    }
}

public class ClearNameListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class ClearNameListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ClearNameListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ClearNameListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAnalysisConditionFavoriteRequest : Tea.TeaModel {
    public var lang: String?

    public var condition: String?

    public var eventBeginTime: Int64?

    public var eventCodes: String?

    public var eventEndTime: Int64?

    public var fieldName: String?

    public var fieldValue: String?

    public var name: String?

    public var regId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.condition != nil {
            map["condition"] = self.condition!
        }
        if self.eventBeginTime != nil {
            map["eventBeginTime"] = self.eventBeginTime!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.eventEndTime != nil {
            map["eventEndTime"] = self.eventEndTime!
        }
        if self.fieldName != nil {
            map["fieldName"] = self.fieldName!
        }
        if self.fieldValue != nil {
            map["fieldValue"] = self.fieldValue!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("condition") {
            self.condition = dict["condition"] as! String
        }
        if dict.keys.contains("eventBeginTime") {
            self.eventBeginTime = dict["eventBeginTime"] as! Int64
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("eventEndTime") {
            self.eventEndTime = dict["eventEndTime"] as! Int64
        }
        if dict.keys.contains("fieldName") {
            self.fieldName = dict["fieldName"] as! String
        }
        if dict.keys.contains("fieldValue") {
            self.fieldValue = dict["fieldValue"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class CreateAnalysisConditionFavoriteResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CreateAnalysisConditionFavoriteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAnalysisConditionFavoriteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAnalysisConditionFavoriteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAnalysisExportTaskRequest : Tea.TeaModel {
    public var lang: String?

    public var columns: String?

    public var conditions: String?

    public var eventBeginTime: Int64?

    public var eventCodes: String?

    public var eventEndTime: Int64?

    public var fieldName: String?

    public var fieldValue: String?

    public var fileFormat: String?

    public var regId: String?

    public var scope: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.columns != nil {
            map["columns"] = self.columns!
        }
        if self.conditions != nil {
            map["conditions"] = self.conditions!
        }
        if self.eventBeginTime != nil {
            map["eventBeginTime"] = self.eventBeginTime!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.eventEndTime != nil {
            map["eventEndTime"] = self.eventEndTime!
        }
        if self.fieldName != nil {
            map["fieldName"] = self.fieldName!
        }
        if self.fieldValue != nil {
            map["fieldValue"] = self.fieldValue!
        }
        if self.fileFormat != nil {
            map["fileFormat"] = self.fileFormat!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("columns") {
            self.columns = dict["columns"] as! String
        }
        if dict.keys.contains("conditions") {
            self.conditions = dict["conditions"] as! String
        }
        if dict.keys.contains("eventBeginTime") {
            self.eventBeginTime = dict["eventBeginTime"] as! Int64
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("eventEndTime") {
            self.eventEndTime = dict["eventEndTime"] as! Int64
        }
        if dict.keys.contains("fieldName") {
            self.fieldName = dict["fieldName"] as! String
        }
        if dict.keys.contains("fieldValue") {
            self.fieldValue = dict["fieldValue"] as! String
        }
        if dict.keys.contains("fileFormat") {
            self.fileFormat = dict["fileFormat"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("scope") {
            self.scope = dict["scope"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class CreateAnalysisExportTaskResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var columns: String?

        public var conditions: String?

        public var eventBeginTime: Int64?

        public var eventCodes: String?

        public var eventEndTime: Int64?

        public var fileFormat: String?

        public var ossKey: String?

        public var scope: String?

        public var status: String?

        public var type: String?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columns != nil {
                map["columns"] = self.columns!
            }
            if self.conditions != nil {
                map["conditions"] = self.conditions!
            }
            if self.eventBeginTime != nil {
                map["eventBeginTime"] = self.eventBeginTime!
            }
            if self.eventCodes != nil {
                map["eventCodes"] = self.eventCodes!
            }
            if self.eventEndTime != nil {
                map["eventEndTime"] = self.eventEndTime!
            }
            if self.fileFormat != nil {
                map["fileFormat"] = self.fileFormat!
            }
            if self.ossKey != nil {
                map["ossKey"] = self.ossKey!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("columns") {
                self.columns = dict["columns"] as! String
            }
            if dict.keys.contains("conditions") {
                self.conditions = dict["conditions"] as! String
            }
            if dict.keys.contains("eventBeginTime") {
                self.eventBeginTime = dict["eventBeginTime"] as! Int64
            }
            if dict.keys.contains("eventCodes") {
                self.eventCodes = dict["eventCodes"] as! String
            }
            if dict.keys.contains("eventEndTime") {
                self.eventEndTime = dict["eventEndTime"] as! Int64
            }
            if dict.keys.contains("fileFormat") {
                self.fileFormat = dict["fileFormat"] as! String
            }
            if dict.keys.contains("ossKey") {
                self.ossKey = dict["ossKey"] as! String
            }
            if dict.keys.contains("scope") {
                self.scope = dict["scope"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("userId") {
                self.userId = dict["userId"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var resultObject: CreateAnalysisExportTaskResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = CreateAnalysisExportTaskResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class CreateAnalysisExportTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAnalysisExportTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAnalysisExportTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAppKeyRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class CreateAppKeyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var data: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! Bool
        }
    }
}

public class CreateAppKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAppKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAppKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAuthorizationUserRequest : Tea.TeaModel {
    public var lang: String?

    public var bindId: Int64?

    public var createType: String?

    public var eventTemplateId: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.bindId != nil {
            map["bindId"] = self.bindId!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.eventTemplateId != nil {
            map["eventTemplateId"] = self.eventTemplateId!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("bindId") {
            self.bindId = dict["bindId"] as! Int64
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("eventTemplateId") {
            self.eventTemplateId = dict["eventTemplateId"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class CreateAuthorizationUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CreateAuthorizationUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAuthorizationUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAuthorizationUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCustVariableRequest : Tea.TeaModel {
    public var lang: String?

    public var condition: String?

    public var createType: String?

    public var description_: String?

    public var eventCodes: String?

    public var historyValueType: String?

    public var object: String?

    public var outputs: String?

    public var regId: String?

    public var subject: String?

    public var timeType: String?

    public var title: String?

    public var twCount: Int32?

    public var velocityFC: String?

    public var velocityTW: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.condition != nil {
            map["condition"] = self.condition!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.historyValueType != nil {
            map["historyValueType"] = self.historyValueType!
        }
        if self.object != nil {
            map["object"] = self.object!
        }
        if self.outputs != nil {
            map["outputs"] = self.outputs!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        if self.timeType != nil {
            map["timeType"] = self.timeType!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.twCount != nil {
            map["twCount"] = self.twCount!
        }
        if self.velocityFC != nil {
            map["velocityFC"] = self.velocityFC!
        }
        if self.velocityTW != nil {
            map["velocityTW"] = self.velocityTW!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("condition") {
            self.condition = dict["condition"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("historyValueType") {
            self.historyValueType = dict["historyValueType"] as! String
        }
        if dict.keys.contains("object") {
            self.object = dict["object"] as! String
        }
        if dict.keys.contains("outputs") {
            self.outputs = dict["outputs"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("subject") {
            self.subject = dict["subject"] as! String
        }
        if dict.keys.contains("timeType") {
            self.timeType = dict["timeType"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("twCount") {
            self.twCount = dict["twCount"] as! Int32
        }
        if dict.keys.contains("velocityFC") {
            self.velocityFC = dict["velocityFC"] as! String
        }
        if dict.keys.contains("velocityTW") {
            self.velocityTW = dict["velocityTW"] as! String
        }
    }
}

public class CreateCustVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CreateCustVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCustVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataSourceRequest : Tea.TeaModel {
    public var lang: String?

    public var description_: String?

    public var name: String?

    public var ossKey: String?

    public var regId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.ossKey != nil {
            map["ossKey"] = self.ossKey!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("ossKey") {
            self.ossKey = dict["ossKey"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class CreateDataSourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CreateDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEventRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var eventName: String?

    public var inputFieldsStr: String?

    public var memo: String?

    public var regId: String?

    public var templateCode: String?

    public var templateName: String?

    public var templateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.eventName != nil {
            map["eventName"] = self.eventName!
        }
        if self.inputFieldsStr != nil {
            map["inputFieldsStr"] = self.inputFieldsStr!
        }
        if self.memo != nil {
            map["memo"] = self.memo!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.templateCode != nil {
            map["templateCode"] = self.templateCode!
        }
        if self.templateName != nil {
            map["templateName"] = self.templateName!
        }
        if self.templateType != nil {
            map["templateType"] = self.templateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("eventName") {
            self.eventName = dict["eventName"] as! String
        }
        if dict.keys.contains("inputFieldsStr") {
            self.inputFieldsStr = dict["inputFieldsStr"] as! String
        }
        if dict.keys.contains("memo") {
            self.memo = dict["memo"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("templateCode") {
            self.templateCode = dict["templateCode"] as! String
        }
        if dict.keys.contains("templateName") {
            self.templateName = dict["templateName"] as! String
        }
        if dict.keys.contains("templateType") {
            self.templateType = dict["templateType"] as! String
        }
    }
}

public class CreateEventResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") {
            self.data = dict["data"] as! Bool
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateExpressionVariableRequest : Tea.TeaModel {
    public var lang: String?

    public var description_: String?

    public var eventCode: String?

    public var expression: String?

    public var expressionTitle: String?

    public var expressionVariable: String?

    public var outlier: String?

    public var outputs: String?

    public var regId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.expression != nil {
            map["expression"] = self.expression!
        }
        if self.expressionTitle != nil {
            map["expressionTitle"] = self.expressionTitle!
        }
        if self.expressionVariable != nil {
            map["expressionVariable"] = self.expressionVariable!
        }
        if self.outlier != nil {
            map["outlier"] = self.outlier!
        }
        if self.outputs != nil {
            map["outputs"] = self.outputs!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("expression") {
            self.expression = dict["expression"] as! String
        }
        if dict.keys.contains("expressionTitle") {
            self.expressionTitle = dict["expressionTitle"] as! String
        }
        if dict.keys.contains("expressionVariable") {
            self.expressionVariable = dict["expressionVariable"] as! String
        }
        if dict.keys.contains("outlier") {
            self.outlier = dict["outlier"] as! String
        }
        if dict.keys.contains("outputs") {
            self.outputs = dict["outputs"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
    }
}

public class CreateExpressionVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CreateExpressionVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateExpressionVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateExpressionVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFieldRequest : Tea.TeaModel {
    public var lang: String?

    public var classify: String?

    public var description_: String?

    public var enumData: String?

    public var name: String?

    public var regId: String?

    public var source: String?

    public var title: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.classify != nil {
            map["classify"] = self.classify!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.enumData != nil {
            map["enumData"] = self.enumData!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("classify") {
            self.classify = dict["classify"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("enumData") {
            self.enumData = dict["enumData"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("source") {
            self.source = dict["source"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class CreateFieldResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CreateFieldResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFieldResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateFieldResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateGroupSignRequest : Tea.TeaModel {
    public var lang: String?

    public var signList: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.signList != nil {
            map["SignList"] = self.signList!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SignList") {
            self.signList = dict["SignList"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class CreateGroupSignResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var data: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! Bool
        }
    }
}

public class CreateGroupSignResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateGroupSignResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateGroupSignResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMonitorTaskRequest : Tea.TeaModel {
    public var lang: String?

    public var bizType: String?

    public var cycleType: String?

    public var endTime: Int64?

    public var filePath: String?

    public var listdayStr: String?

    public var regId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.bizType != nil {
            map["bizType"] = self.bizType!
        }
        if self.cycleType != nil {
            map["cycleType"] = self.cycleType!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.filePath != nil {
            map["filePath"] = self.filePath!
        }
        if self.listdayStr != nil {
            map["listdayStr"] = self.listdayStr!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("bizType") {
            self.bizType = dict["bizType"] as! String
        }
        if dict.keys.contains("cycleType") {
            self.cycleType = dict["cycleType"] as! String
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("filePath") {
            self.filePath = dict["filePath"] as! String
        }
        if dict.keys.contains("listdayStr") {
            self.listdayStr = dict["listdayStr"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! Int64
        }
    }
}

public class CreateMonitorTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CreateMonitorTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMonitorTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMonitorTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePocRequest : Tea.TeaModel {
    public var lang: String?

    public var configStr: String?

    public var fileName: String?

    public var fileType: String?

    public var fileUrl: String?

    public var regId: String?

    public var serviceCode: String?

    public var serviceName: String?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.configStr != nil {
            map["configStr"] = self.configStr!
        }
        if self.fileName != nil {
            map["fileName"] = self.fileName!
        }
        if self.fileType != nil {
            map["fileType"] = self.fileType!
        }
        if self.fileUrl != nil {
            map["fileUrl"] = self.fileUrl!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.serviceCode != nil {
            map["serviceCode"] = self.serviceCode!
        }
        if self.serviceName != nil {
            map["serviceName"] = self.serviceName!
        }
        if self.taskName != nil {
            map["taskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("configStr") {
            self.configStr = dict["configStr"] as! String
        }
        if dict.keys.contains("fileName") {
            self.fileName = dict["fileName"] as! String
        }
        if dict.keys.contains("fileType") {
            self.fileType = dict["fileType"] as! String
        }
        if dict.keys.contains("fileUrl") {
            self.fileUrl = dict["fileUrl"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("serviceCode") {
            self.serviceCode = dict["serviceCode"] as! String
        }
        if dict.keys.contains("serviceName") {
            self.serviceName = dict["serviceName"] as! String
        }
        if dict.keys.contains("taskName") {
            self.taskName = dict["taskName"] as! String
        }
    }
}

public class CreatePocResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CreatePocResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePocResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePocResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePocEvRequest : Tea.TeaModel {
    public var dateFormat: String?

    public var fileName: String?

    public var fileType: String?

    public var fileUrl: String?

    public var lang: String?

    public var regId: String?

    public var serviceCode: String?

    public var serviceName: String?

    public var tab: String?

    public var taskName: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dateFormat != nil {
            map["DateFormat"] = self.dateFormat!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileType != nil {
            map["FileType"] = self.fileType!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["RegId"] = self.regId!
        }
        if self.serviceCode != nil {
            map["ServiceCode"] = self.serviceCode!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.tab != nil {
            map["Tab"] = self.tab!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DateFormat") {
            self.dateFormat = dict["DateFormat"] as! String
        }
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileType") {
            self.fileType = dict["FileType"] as! String
        }
        if dict.keys.contains("FileUrl") {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RegId") {
            self.regId = dict["RegId"] as! String
        }
        if dict.keys.contains("ServiceCode") {
            self.serviceCode = dict["ServiceCode"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("Tab") {
            self.tab = dict["Tab"] as! String
        }
        if dict.keys.contains("TaskName") {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreatePocEvResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["ResultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultObject") {
            self.resultObject = dict["ResultObject"] as! String
        }
    }
}

public class CreatePocEvResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePocEvResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePocEvResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateQueryVariableRequest : Tea.TeaModel {
    public var lang: String?

    public var dataSourceCode: String?

    public var description_: String?

    public var eventCode: String?

    public var expression: String?

    public var expressionTitle: String?

    public var expressionVariable: String?

    public var outlier: String?

    public var outputs: String?

    public var regId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.dataSourceCode != nil {
            map["dataSourceCode"] = self.dataSourceCode!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.expression != nil {
            map["expression"] = self.expression!
        }
        if self.expressionTitle != nil {
            map["expressionTitle"] = self.expressionTitle!
        }
        if self.expressionVariable != nil {
            map["expressionVariable"] = self.expressionVariable!
        }
        if self.outlier != nil {
            map["outlier"] = self.outlier!
        }
        if self.outputs != nil {
            map["outputs"] = self.outputs!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("dataSourceCode") {
            self.dataSourceCode = dict["dataSourceCode"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("expression") {
            self.expression = dict["expression"] as! String
        }
        if dict.keys.contains("expressionTitle") {
            self.expressionTitle = dict["expressionTitle"] as! String
        }
        if dict.keys.contains("expressionVariable") {
            self.expressionVariable = dict["expressionVariable"] as! String
        }
        if dict.keys.contains("outlier") {
            self.outlier = dict["outlier"] as! String
        }
        if dict.keys.contains("outputs") {
            self.outputs = dict["outputs"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
    }
}

public class CreateQueryVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CreateQueryVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateQueryVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateQueryVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRecommendEventRuleRequest : Tea.TeaModel {
    public var lang: String?

    public var eventCode: String?

    public var eventName: String?

    public var recommendRuleIdsStr: String?

    public var regId: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.eventName != nil {
            map["eventName"] = self.eventName!
        }
        if self.recommendRuleIdsStr != nil {
            map["recommendRuleIdsStr"] = self.recommendRuleIdsStr!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("eventName") {
            self.eventName = dict["eventName"] as! String
        }
        if dict.keys.contains("recommendRuleIdsStr") {
            self.recommendRuleIdsStr = dict["recommendRuleIdsStr"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! Int64
        }
    }
}

public class CreateRecommendEventRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CreateRecommendEventRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRecommendEventRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRecommendEventRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRecommendTaskRequest : Tea.TeaModel {
    public var lang: String?

    public var name: String?

    public var regId: String?

    public var sampleId: Int64?

    public var variablesStr: String?

    public var velocitiesStr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.sampleId != nil {
            map["sampleId"] = self.sampleId!
        }
        if self.variablesStr != nil {
            map["variablesStr"] = self.variablesStr!
        }
        if self.velocitiesStr != nil {
            map["velocitiesStr"] = self.velocitiesStr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("sampleId") {
            self.sampleId = dict["sampleId"] as! Int64
        }
        if dict.keys.contains("variablesStr") {
            self.variablesStr = dict["variablesStr"] as! String
        }
        if dict.keys.contains("velocitiesStr") {
            self.velocitiesStr = dict["velocitiesStr"] as! String
        }
    }
}

public class CreateRecommendTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CreateRecommendTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRecommendTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRecommendTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateReplenishTaskRequest : Tea.TeaModel {
    public var clientFileName: String?

    public var clientPath: String?

    public var lang: String?

    public var taskId: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientFileName != nil {
            map["ClientFileName"] = self.clientFileName!
        }
        if self.clientPath != nil {
            map["ClientPath"] = self.clientPath!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientFileName") {
            self.clientFileName = dict["ClientFileName"] as! String
        }
        if dict.keys.contains("ClientPath") {
            self.clientPath = dict["ClientPath"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class CreateReplenishTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var data: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! Bool
        }
    }
}

public class CreateReplenishTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateReplenishTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateReplenishTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRuleRequest : Tea.TeaModel {
    public var lang: String?

    public var consoleRuleId: Int64?

    public var createType: String?

    public var eventCode: String?

    public var eventName: String?

    public var logicExpression: String?

    public var memo: String?

    public var regId: String?

    public var ruleActions: String?

    public var ruleExpressions: String?

    public var ruleName: String?

    public var ruleStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.consoleRuleId != nil {
            map["consoleRuleId"] = self.consoleRuleId!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.eventName != nil {
            map["eventName"] = self.eventName!
        }
        if self.logicExpression != nil {
            map["logicExpression"] = self.logicExpression!
        }
        if self.memo != nil {
            map["memo"] = self.memo!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleActions != nil {
            map["ruleActions"] = self.ruleActions!
        }
        if self.ruleExpressions != nil {
            map["ruleExpressions"] = self.ruleExpressions!
        }
        if self.ruleName != nil {
            map["ruleName"] = self.ruleName!
        }
        if self.ruleStatus != nil {
            map["ruleStatus"] = self.ruleStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("consoleRuleId") {
            self.consoleRuleId = dict["consoleRuleId"] as! Int64
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("eventName") {
            self.eventName = dict["eventName"] as! String
        }
        if dict.keys.contains("logicExpression") {
            self.logicExpression = dict["logicExpression"] as! String
        }
        if dict.keys.contains("memo") {
            self.memo = dict["memo"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleActions") {
            self.ruleActions = dict["ruleActions"] as! String
        }
        if dict.keys.contains("ruleExpressions") {
            self.ruleExpressions = dict["ruleExpressions"] as! String
        }
        if dict.keys.contains("ruleName") {
            self.ruleName = dict["ruleName"] as! String
        }
        if dict.keys.contains("ruleStatus") {
            self.ruleStatus = dict["ruleStatus"] as! String
        }
    }
}

public class CreateRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CreateRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSampleRequest : Tea.TeaModel {
    public var lang: String?

    public var clientFileName: String?

    public var clientPath: String?

    public var fileType: String?

    public var regId: String?

    public var sampleTag: String?

    public var sampleType: String?

    public var sampleValues: String?

    public var uploadType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.clientFileName != nil {
            map["clientFileName"] = self.clientFileName!
        }
        if self.clientPath != nil {
            map["clientPath"] = self.clientPath!
        }
        if self.fileType != nil {
            map["fileType"] = self.fileType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.sampleTag != nil {
            map["sampleTag"] = self.sampleTag!
        }
        if self.sampleType != nil {
            map["sampleType"] = self.sampleType!
        }
        if self.sampleValues != nil {
            map["sampleValues"] = self.sampleValues!
        }
        if self.uploadType != nil {
            map["uploadType"] = self.uploadType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("clientFileName") {
            self.clientFileName = dict["clientFileName"] as! String
        }
        if dict.keys.contains("clientPath") {
            self.clientPath = dict["clientPath"] as! String
        }
        if dict.keys.contains("fileType") {
            self.fileType = dict["fileType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("sampleTag") {
            self.sampleTag = dict["sampleTag"] as! String
        }
        if dict.keys.contains("sampleType") {
            self.sampleType = dict["sampleType"] as! String
        }
        if dict.keys.contains("sampleValues") {
            self.sampleValues = dict["sampleValues"] as! String
        }
        if dict.keys.contains("uploadType") {
            self.uploadType = dict["uploadType"] as! String
        }
    }
}

public class CreateSampleResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var communityCount: Int32?

        public var failCount: Int32?

        public var recallProbability: String?

        public var riskDensity: String?

        public var sampleCount: Int32?

        public var successCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.communityCount != nil {
                map["communityCount"] = self.communityCount!
            }
            if self.failCount != nil {
                map["failCount"] = self.failCount!
            }
            if self.recallProbability != nil {
                map["recallProbability"] = self.recallProbability!
            }
            if self.riskDensity != nil {
                map["riskDensity"] = self.riskDensity!
            }
            if self.sampleCount != nil {
                map["sampleCount"] = self.sampleCount!
            }
            if self.successCount != nil {
                map["successCount"] = self.successCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("communityCount") {
                self.communityCount = dict["communityCount"] as! Int32
            }
            if dict.keys.contains("failCount") {
                self.failCount = dict["failCount"] as! Int32
            }
            if dict.keys.contains("recallProbability") {
                self.recallProbability = dict["recallProbability"] as! String
            }
            if dict.keys.contains("riskDensity") {
                self.riskDensity = dict["riskDensity"] as! String
            }
            if dict.keys.contains("sampleCount") {
                self.sampleCount = dict["sampleCount"] as! Int32
            }
            if dict.keys.contains("successCount") {
                self.successCount = dict["successCount"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var resultObject: CreateSampleResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = CreateSampleResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class CreateSampleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSampleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSampleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSampleApiRequest : Tea.TeaModel {
    public var dataType: String?

    public var dataValue: String?

    public var lang: String?

    public var regId: String?

    public var sampleBatchType: String?

    public var serviceList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataType != nil {
            map["DataType"] = self.dataType!
        }
        if self.dataValue != nil {
            map["DataValue"] = self.dataValue!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["RegId"] = self.regId!
        }
        if self.sampleBatchType != nil {
            map["SampleBatchType"] = self.sampleBatchType!
        }
        if self.serviceList != nil {
            map["ServiceList"] = self.serviceList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataType") {
            self.dataType = dict["DataType"] as! String
        }
        if dict.keys.contains("DataValue") {
            self.dataValue = dict["DataValue"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RegId") {
            self.regId = dict["RegId"] as! String
        }
        if dict.keys.contains("SampleBatchType") {
            self.sampleBatchType = dict["SampleBatchType"] as! String
        }
        if dict.keys.contains("ServiceList") {
            self.serviceList = dict["ServiceList"] as! String
        }
    }
}

public class CreateSampleApiResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateSampleApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSampleApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSampleApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSampleDataRequest : Tea.TeaModel {
    public var lang: String?

    public var description_: String?

    public var encryptType: String?

    public var name: String?

    public var regId: String?

    public var riskValue: String?

    public var scene: String?

    public var storePath: String?

    public var storeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.encryptType != nil {
            map["encryptType"] = self.encryptType!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.riskValue != nil {
            map["riskValue"] = self.riskValue!
        }
        if self.scene != nil {
            map["scene"] = self.scene!
        }
        if self.storePath != nil {
            map["storePath"] = self.storePath!
        }
        if self.storeType != nil {
            map["storeType"] = self.storeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("encryptType") {
            self.encryptType = dict["encryptType"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("riskValue") {
            self.riskValue = dict["riskValue"] as! String
        }
        if dict.keys.contains("scene") {
            self.scene = dict["scene"] as! String
        }
        if dict.keys.contains("storePath") {
            self.storePath = dict["storePath"] as! String
        }
        if dict.keys.contains("storeType") {
            self.storeType = dict["storeType"] as! String
        }
    }
}

public class CreateSampleDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CreateSampleDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSampleDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSampleDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSimulationTaskRequest : Tea.TeaModel {
    public var lang: String?

    public var dataSourceConfig: String?

    public var dataSourceType: String?

    public var endTime: Int64?

    public var eventCode: String?

    public var filtersStr: String?

    public var regId: String?

    public var rulesStr: String?

    public var runTask: Bool?

    public var startTime: Int64?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.dataSourceConfig != nil {
            map["dataSourceConfig"] = self.dataSourceConfig!
        }
        if self.dataSourceType != nil {
            map["dataSourceType"] = self.dataSourceType!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.filtersStr != nil {
            map["filtersStr"] = self.filtersStr!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.rulesStr != nil {
            map["rulesStr"] = self.rulesStr!
        }
        if self.runTask != nil {
            map["runTask"] = self.runTask!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.taskName != nil {
            map["taskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("dataSourceConfig") {
            self.dataSourceConfig = dict["dataSourceConfig"] as! String
        }
        if dict.keys.contains("dataSourceType") {
            self.dataSourceType = dict["dataSourceType"] as! String
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("filtersStr") {
            self.filtersStr = dict["filtersStr"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("rulesStr") {
            self.rulesStr = dict["rulesStr"] as! String
        }
        if dict.keys.contains("runTask") {
            self.runTask = dict["runTask"] as! Bool
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("taskName") {
            self.taskName = dict["taskName"] as! String
        }
    }
}

public class CreateSimulationTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CreateSimulationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSimulationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSimulationTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTaskRequest : Tea.TeaModel {
    public var clientFileName: String?

    public var clientPath: String?

    public var describe: String?

    public var lang: String?

    public var sceneName: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientFileName != nil {
            map["ClientFileName"] = self.clientFileName!
        }
        if self.clientPath != nil {
            map["ClientPath"] = self.clientPath!
        }
        if self.describe != nil {
            map["Describe"] = self.describe!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sceneName != nil {
            map["SceneName"] = self.sceneName!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientFileName") {
            self.clientFileName = dict["ClientFileName"] as! String
        }
        if dict.keys.contains("ClientPath") {
            self.clientPath = dict["ClientPath"] as! String
        }
        if dict.keys.contains("Describe") {
            self.describe = dict["Describe"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SceneName") {
            self.sceneName = dict["SceneName"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class CreateTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var data: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! Bool
        }
    }
}

public class CreateTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTemplateRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var eventCode: String?

    public var eventName: String?

    public var logicExpression: String?

    public var memo: String?

    public var regId: String?

    public var ruleActions: String?

    public var ruleExpressions: String?

    public var ruleName: String?

    public var ruleStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.eventName != nil {
            map["eventName"] = self.eventName!
        }
        if self.logicExpression != nil {
            map["logicExpression"] = self.logicExpression!
        }
        if self.memo != nil {
            map["memo"] = self.memo!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleActions != nil {
            map["ruleActions"] = self.ruleActions!
        }
        if self.ruleExpressions != nil {
            map["ruleExpressions"] = self.ruleExpressions!
        }
        if self.ruleName != nil {
            map["ruleName"] = self.ruleName!
        }
        if self.ruleStatus != nil {
            map["ruleStatus"] = self.ruleStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("eventName") {
            self.eventName = dict["eventName"] as! String
        }
        if dict.keys.contains("logicExpression") {
            self.logicExpression = dict["logicExpression"] as! String
        }
        if dict.keys.contains("memo") {
            self.memo = dict["memo"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleActions") {
            self.ruleActions = dict["ruleActions"] as! String
        }
        if dict.keys.contains("ruleExpressions") {
            self.ruleExpressions = dict["ruleExpressions"] as! String
        }
        if dict.keys.contains("ruleName") {
            self.ruleName = dict["ruleName"] as! String
        }
        if dict.keys.contains("ruleStatus") {
            self.ruleStatus = dict["ruleStatus"] as! String
        }
    }
}

public class CreateTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class CreateTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAnalysisConditionFavoriteRequest : Tea.TeaModel {
    public var lang: String?

    public var id: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DeleteAnalysisConditionFavoriteResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DeleteAnalysisConditionFavoriteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAnalysisConditionFavoriteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAnalysisConditionFavoriteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAuthUserRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var eventCode: String?

    public var id: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DeleteAuthUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DeleteAuthUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAuthUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAuthUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteByPassShuntEventRequest : Tea.TeaModel {
    public var lang: String?

    public var eventId: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventId != nil {
            map["eventId"] = self.eventId!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventId") {
            self.eventId = dict["eventId"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DeleteByPassShuntEventResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteByPassShuntEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteByPassShuntEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteByPassShuntEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustVariableRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var dataVersion: Int64?

    public var regId: String?

    public var variableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.dataVersion != nil {
            map["dataVersion"] = self.dataVersion!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.variableId != nil {
            map["variableId"] = self.variableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("dataVersion") {
            self.dataVersion = dict["dataVersion"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("variableId") {
            self.variableId = dict["variableId"] as! String
        }
    }
}

public class DeleteCustVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DeleteCustVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCustVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDataSourceRequest : Tea.TeaModel {
    public var lang: String?

    public var id: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DeleteDataSourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DeleteDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteExpressionVariableRequest : Tea.TeaModel {
    public var lang: String?

    public var dataVersion: Int64?

    public var id: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.dataVersion != nil {
            map["dataVersion"] = self.dataVersion!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("dataVersion") {
            self.dataVersion = dict["dataVersion"] as! Int64
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DeleteExpressionVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DeleteExpressionVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteExpressionVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteExpressionVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFieldRequest : Tea.TeaModel {
    public var lang: String?

    public var id: Int64?

    public var name: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DeleteFieldResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DeleteFieldResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFieldResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteFieldResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNameListRequest : Tea.TeaModel {
    public var lang: String?

    public var ids: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.ids != nil {
            map["ids"] = self.ids!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ids") {
            self.ids = dict["ids"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DeleteNameListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DeleteNameListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNameListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNameListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNameListDataRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var variableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.variableId != nil {
            map["variableId"] = self.variableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("variableId") {
            self.variableId = dict["variableId"] as! String
        }
    }
}

public class DeleteNameListDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DeleteNameListDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNameListDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNameListDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteQueryVariableRequest : Tea.TeaModel {
    public var lang: String?

    public var id: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DeleteQueryVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DeleteQueryVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteQueryVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteQueryVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRuleRequest : Tea.TeaModel {
    public var lang: String?

    public var consoleRuleId: Int64?

    public var regId: String?

    public var ruleId: String?

    public var ruleVersionId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.consoleRuleId != nil {
            map["consoleRuleId"] = self.consoleRuleId!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleId != nil {
            map["ruleId"] = self.ruleId!
        }
        if self.ruleVersionId != nil {
            map["ruleVersionId"] = self.ruleVersionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("consoleRuleId") {
            self.consoleRuleId = dict["consoleRuleId"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleId") {
            self.ruleId = dict["ruleId"] as! String
        }
        if dict.keys.contains("ruleVersionId") {
            self.ruleVersionId = dict["ruleVersionId"] as! Int64
        }
    }
}

public class DeleteRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DeleteRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSampleBatchRequest : Tea.TeaModel {
    public var lang: String?

    public var ids: String?

    public var regId: String?

    public var versions: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.ids != nil {
            map["ids"] = self.ids!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.versions != nil {
            map["versions"] = self.versions!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ids") {
            self.ids = dict["ids"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("versions") {
            self.versions = dict["versions"] as! String
        }
    }
}

public class DeleteSampleBatchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var data: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! Bool
        }
    }
}

public class DeleteSampleBatchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSampleBatchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSampleBatchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSampleDataRequest : Tea.TeaModel {
    public var lang: String?

    public var id: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DeleteSampleDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DeleteSampleDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSampleDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSampleDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTaskRequest : Tea.TeaModel {
    public var lang: String?

    public var taskId: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DeleteTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var data: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! Bool
        }
    }
}

public class DeleteTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAdvanceSearchLeftVariableListRequest : Tea.TeaModel {
    public var lang: String?

    public var eventCodes: String?

    public var regId: String?

    public var scene: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.scene != nil {
            map["scene"] = self.scene!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("scene") {
            self.scene = dict["scene"] as! String
        }
    }
}

public class DescribeAdvanceSearchLeftVariableListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var code: String?

        public var description_: String?

        public var displayType: String?

        public var fieldRank: Int64?

        public var fieldType: String?

        public var id: Int64?

        public var name: String?

        public var parentName: String?

        public var sourceType: String?

        public var title: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["code"] = self.code!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.displayType != nil {
                map["displayType"] = self.displayType!
            }
            if self.fieldRank != nil {
                map["fieldRank"] = self.fieldRank!
            }
            if self.fieldType != nil {
                map["fieldType"] = self.fieldType!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.parentName != nil {
                map["parentName"] = self.parentName!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("code") {
                self.code = dict["code"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("displayType") {
                self.displayType = dict["displayType"] as! String
            }
            if dict.keys.contains("fieldRank") {
                self.fieldRank = dict["fieldRank"] as! Int64
            }
            if dict.keys.contains("fieldType") {
                self.fieldType = dict["fieldType"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("parentName") {
                self.parentName = dict["parentName"] as! String
            }
            if dict.keys.contains("sourceType") {
                self.sourceType = dict["sourceType"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeAdvanceSearchLeftVariableListResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeAdvanceSearchLeftVariableListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeAdvanceSearchLeftVariableListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeAdvanceSearchLeftVariableListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAdvanceSearchLeftVariableListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAdvanceSearchLeftVariableListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAdvanceSearchPageListRequest : Tea.TeaModel {
    public var lang: String?

    public var condition: String?

    public var currentPage: Int64?

    public var eventBeginTime: Int64?

    public var eventCodes: String?

    public var eventEndTime: Int64?

    public var fieldName: String?

    public var fieldValue: String?

    public var pageSize: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.condition != nil {
            map["condition"] = self.condition!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.eventBeginTime != nil {
            map["eventBeginTime"] = self.eventBeginTime!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.eventEndTime != nil {
            map["eventEndTime"] = self.eventEndTime!
        }
        if self.fieldName != nil {
            map["fieldName"] = self.fieldName!
        }
        if self.fieldValue != nil {
            map["fieldValue"] = self.fieldValue!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("condition") {
            self.condition = dict["condition"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int64
        }
        if dict.keys.contains("eventBeginTime") {
            self.eventBeginTime = dict["eventBeginTime"] as! Int64
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("eventEndTime") {
            self.eventEndTime = dict["eventEndTime"] as! Int64
        }
        if dict.keys.contains("fieldName") {
            self.fieldName = dict["fieldName"] as! String
        }
        if dict.keys.contains("fieldValue") {
            self.fieldValue = dict["fieldValue"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeAdvanceSearchPageListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Header : Tea.TeaModel {
            public var fieldName: String?

            public var fieldTitle: String?

            public var isDefault: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldName != nil {
                    map["fieldName"] = self.fieldName!
                }
                if self.fieldTitle != nil {
                    map["fieldTitle"] = self.fieldTitle!
                }
                if self.isDefault != nil {
                    map["isDefault"] = self.isDefault!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("fieldName") {
                    self.fieldName = dict["fieldName"] as! String
                }
                if dict.keys.contains("fieldTitle") {
                    self.fieldTitle = dict["fieldTitle"] as! String
                }
                if dict.keys.contains("isDefault") {
                    self.isDefault = dict["isDefault"] as! Bool
                }
            }
        }
        public var currentPage: Int64?

        public var data: [[String: Any]]?

        public var header: [DescribeAdvanceSearchPageListResponseBody.ResultObject.Header]?

        public var pageSize: Int64?

        public var totalItem: Int64?

        public var totalPage: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["currentPage"] = self.currentPage!
            }
            if self.data != nil {
                map["data"] = self.data!
            }
            if self.header != nil {
                var tmp : [Any] = []
                for k in self.header! {
                    tmp.append(k.toMap())
                }
                map["header"] = tmp
            }
            if self.pageSize != nil {
                map["pageSize"] = self.pageSize!
            }
            if self.totalItem != nil {
                map["totalItem"] = self.totalItem!
            }
            if self.totalPage != nil {
                map["totalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("currentPage") {
                self.currentPage = dict["currentPage"] as! Int64
            }
            if dict.keys.contains("data") {
                self.data = dict["data"] as! [[String: Any]]
            }
            if dict.keys.contains("header") {
                var tmp : [DescribeAdvanceSearchPageListResponseBody.ResultObject.Header] = []
                for v in dict["header"] as! [Any] {
                    var model = DescribeAdvanceSearchPageListResponseBody.ResultObject.Header()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.header = tmp
            }
            if dict.keys.contains("pageSize") {
                self.pageSize = dict["pageSize"] as! Int64
            }
            if dict.keys.contains("totalItem") {
                self.totalItem = dict["totalItem"] as! Int64
            }
            if dict.keys.contains("totalPage") {
                self.totalPage = dict["totalPage"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeAdvanceSearchPageListResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeAdvanceSearchPageListResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeAdvanceSearchPageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAdvanceSearchPageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAdvanceSearchPageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAllDataSourceRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeAllDataSourceResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var eventCode: String?

        public var eventName: String?

        public var id: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeAllDataSourceResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeAllDataSourceResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeAllDataSourceResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeAllDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAllDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAllDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAllEventNameAndCodeRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeAllEventNameAndCodeResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Children : Tea.TeaModel {
            public var createType: String?

            public var eventCode: String?

            public var eventName: String?

            public var eventType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createType != nil {
                    map["createType"] = self.createType!
                }
                if self.eventCode != nil {
                    map["eventCode"] = self.eventCode!
                }
                if self.eventName != nil {
                    map["eventName"] = self.eventName!
                }
                if self.eventType != nil {
                    map["eventType"] = self.eventType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("createType") {
                    self.createType = dict["createType"] as! String
                }
                if dict.keys.contains("eventCode") {
                    self.eventCode = dict["eventCode"] as! String
                }
                if dict.keys.contains("eventName") {
                    self.eventName = dict["eventName"] as! String
                }
                if dict.keys.contains("eventType") {
                    self.eventType = dict["eventType"] as! String
                }
            }
        }
        public var children: [DescribeAllEventNameAndCodeResponseBody.ResultObject.Children]?

        public var createType: String?

        public var eventCode: String?

        public var eventName: String?

        public var eventType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.children != nil {
                var tmp : [Any] = []
                for k in self.children! {
                    tmp.append(k.toMap())
                }
                map["children"] = tmp
            }
            if self.createType != nil {
                map["createType"] = self.createType!
            }
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.eventType != nil {
                map["eventType"] = self.eventType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("children") {
                var tmp : [DescribeAllEventNameAndCodeResponseBody.ResultObject.Children] = []
                for v in dict["children"] as! [Any] {
                    var model = DescribeAllEventNameAndCodeResponseBody.ResultObject.Children()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.children = tmp
            }
            if dict.keys.contains("createType") {
                self.createType = dict["createType"] as! String
            }
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("eventType") {
                self.eventType = dict["eventType"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: [DescribeAllEventNameAndCodeResponseBody.ResultObject]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeAllEventNameAndCodeResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeAllEventNameAndCodeResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeAllEventNameAndCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAllEventNameAndCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAllEventNameAndCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAllRootVariableRequest : Tea.TeaModel {
    public var lang: String?

    public var sourceIp: String?

    public var deviceVariableIds: String?

    public var eventCode: String?

    public var expressionVariableIds: String?

    public var id: Int64?

    public var nativeVariableIds: String?

    public var queryVariableIds: String?

    public var regId: String?

    public var velocityVariableIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.deviceVariableIds != nil {
            map["deviceVariableIds"] = self.deviceVariableIds!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.expressionVariableIds != nil {
            map["expressionVariableIds"] = self.expressionVariableIds!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.nativeVariableIds != nil {
            map["nativeVariableIds"] = self.nativeVariableIds!
        }
        if self.queryVariableIds != nil {
            map["queryVariableIds"] = self.queryVariableIds!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.velocityVariableIds != nil {
            map["velocityVariableIds"] = self.velocityVariableIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("deviceVariableIds") {
            self.deviceVariableIds = dict["deviceVariableIds"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("expressionVariableIds") {
            self.expressionVariableIds = dict["expressionVariableIds"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("nativeVariableIds") {
            self.nativeVariableIds = dict["nativeVariableIds"] as! String
        }
        if dict.keys.contains("queryVariableIds") {
            self.queryVariableIds = dict["queryVariableIds"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("velocityVariableIds") {
            self.velocityVariableIds = dict["velocityVariableIds"] as! String
        }
    }
}

public class DescribeAllRootVariableResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class OutputThreshold : Tea.TeaModel {
            public var maxValue: Double?

            public var minValue: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxValue != nil {
                    map["maxValue"] = self.maxValue!
                }
                if self.minValue != nil {
                    map["minValue"] = self.minValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("maxValue") {
                    self.maxValue = dict["maxValue"] as! Double
                }
                if dict.keys.contains("minValue") {
                    self.minValue = dict["minValue"] as! Double
                }
            }
        }
        public var code: String?

        public var description_: String?

        public var displayType: String?

        public var favoriteFlag: Bool?

        public var fieldRank: Int64?

        public var fieldType: String?

        public var id: Int64?

        public var inputFieldType: String?

        public var inputs: String?

        public var name: String?

        public var outputThreshold: DescribeAllRootVariableResponseBody.ResultObject.OutputThreshold?

        public var sourceType: String?

        public var title: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.outputThreshold?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["code"] = self.code!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.displayType != nil {
                map["displayType"] = self.displayType!
            }
            if self.favoriteFlag != nil {
                map["favoriteFlag"] = self.favoriteFlag!
            }
            if self.fieldRank != nil {
                map["fieldRank"] = self.fieldRank!
            }
            if self.fieldType != nil {
                map["fieldType"] = self.fieldType!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.inputFieldType != nil {
                map["inputFieldType"] = self.inputFieldType!
            }
            if self.inputs != nil {
                map["inputs"] = self.inputs!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.outputThreshold != nil {
                map["outputThreshold"] = self.outputThreshold?.toMap()
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("code") {
                self.code = dict["code"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("displayType") {
                self.displayType = dict["displayType"] as! String
            }
            if dict.keys.contains("favoriteFlag") {
                self.favoriteFlag = dict["favoriteFlag"] as! Bool
            }
            if dict.keys.contains("fieldRank") {
                self.fieldRank = dict["fieldRank"] as! Int64
            }
            if dict.keys.contains("fieldType") {
                self.fieldType = dict["fieldType"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("inputFieldType") {
                self.inputFieldType = dict["inputFieldType"] as! String
            }
            if dict.keys.contains("inputs") {
                self.inputs = dict["inputs"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("outputThreshold") {
                var model = DescribeAllRootVariableResponseBody.ResultObject.OutputThreshold()
                model.fromMap(dict["outputThreshold"] as! [String: Any])
                self.outputThreshold = model
            }
            if dict.keys.contains("sourceType") {
                self.sourceType = dict["sourceType"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeAllRootVariableResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeAllRootVariableResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeAllRootVariableResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeAllRootVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAllRootVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAllRootVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAnalysisColumnFieldListRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeAnalysisColumnFieldListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeAnalysisColumnFieldListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAnalysisColumnFieldListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAnalysisColumnFieldListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAnalysisColumnListRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeAnalysisColumnListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var eventCode: String?

        public var eventName: String?

        public var isDefault: Bool?

        public var variableName: String?

        public var variableTitle: String?

        public var variableType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.isDefault != nil {
                map["isDefault"] = self.isDefault!
            }
            if self.variableName != nil {
                map["variableName"] = self.variableName!
            }
            if self.variableTitle != nil {
                map["variableTitle"] = self.variableTitle!
            }
            if self.variableType != nil {
                map["variableType"] = self.variableType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("isDefault") {
                self.isDefault = dict["isDefault"] as! Bool
            }
            if dict.keys.contains("variableName") {
                self.variableName = dict["variableName"] as! String
            }
            if dict.keys.contains("variableTitle") {
                self.variableTitle = dict["variableTitle"] as! String
            }
            if dict.keys.contains("variableType") {
                self.variableType = dict["variableType"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeAnalysisColumnListResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeAnalysisColumnListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeAnalysisColumnListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeAnalysisColumnListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAnalysisColumnListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAnalysisColumnListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAnalysisConditionFavoriteListRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeAnalysisConditionFavoriteListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var condition: String?

        public var eventBeginTime: Int64?

        public var eventCodes: String?

        public var eventEndTime: Int64?

        public var fieldName: String?

        public var fieldValue: String?

        public var id: Int64?

        public var name: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["condition"] = self.condition!
            }
            if self.eventBeginTime != nil {
                map["eventBeginTime"] = self.eventBeginTime!
            }
            if self.eventCodes != nil {
                map["eventCodes"] = self.eventCodes!
            }
            if self.eventEndTime != nil {
                map["eventEndTime"] = self.eventEndTime!
            }
            if self.fieldName != nil {
                map["fieldName"] = self.fieldName!
            }
            if self.fieldValue != nil {
                map["fieldValue"] = self.fieldValue!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("condition") {
                self.condition = dict["condition"] as! String
            }
            if dict.keys.contains("eventBeginTime") {
                self.eventBeginTime = dict["eventBeginTime"] as! Int64
            }
            if dict.keys.contains("eventCodes") {
                self.eventCodes = dict["eventCodes"] as! String
            }
            if dict.keys.contains("eventEndTime") {
                self.eventEndTime = dict["eventEndTime"] as! Int64
            }
            if dict.keys.contains("fieldName") {
                self.fieldName = dict["fieldName"] as! String
            }
            if dict.keys.contains("fieldValue") {
                self.fieldValue = dict["fieldValue"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeAnalysisConditionFavoriteListResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeAnalysisConditionFavoriteListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeAnalysisConditionFavoriteListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeAnalysisConditionFavoriteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAnalysisConditionFavoriteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAnalysisConditionFavoriteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAnalysisExportTaskDownloadUrlRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeAnalysisExportTaskDownloadUrlResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var downloadFileUrl: String?

        public var executeTime: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadFileUrl != nil {
                map["downloadFileUrl"] = self.downloadFileUrl!
            }
            if self.executeTime != nil {
                map["executeTime"] = self.executeTime!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("downloadFileUrl") {
                self.downloadFileUrl = dict["downloadFileUrl"] as! String
            }
            if dict.keys.contains("executeTime") {
                self.executeTime = dict["executeTime"] as! Int64
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeAnalysisExportTaskDownloadUrlResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeAnalysisExportTaskDownloadUrlResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeAnalysisExportTaskDownloadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAnalysisExportTaskDownloadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAnalysisExportTaskDownloadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiRequest : Tea.TeaModel {
    public var lang: String?

    public var apiId: String?

    public var apiRegionId: String?

    public var apiType: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.apiId != nil {
            map["apiId"] = self.apiId!
        }
        if self.apiRegionId != nil {
            map["apiRegionId"] = self.apiRegionId!
        }
        if self.apiType != nil {
            map["apiType"] = self.apiType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("apiId") {
            self.apiId = dict["apiId"] as! String
        }
        if dict.keys.contains("apiRegionId") {
            self.apiRegionId = dict["apiRegionId"] as! String
        }
        if dict.keys.contains("apiType") {
            self.apiType = dict["apiType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeApiResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiGroupsRequest : Tea.TeaModel {
    public var lang: String?

    public var apiRegionId: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.apiRegionId != nil {
            map["apiRegionId"] = self.apiRegionId!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("apiRegionId") {
            self.apiRegionId = dict["apiRegionId"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeApiGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeApiGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiLimitRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeApiLimitResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var limit: Bool?

        public var maxTotalItem: Int64?

        public var totalItem: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.limit != nil {
                map["limit"] = self.limit!
            }
            if self.maxTotalItem != nil {
                map["maxTotalItem"] = self.maxTotalItem!
            }
            if self.totalItem != nil {
                map["totalItem"] = self.totalItem!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("limit") {
                self.limit = dict["limit"] as! Bool
            }
            if dict.keys.contains("maxTotalItem") {
                self.maxTotalItem = dict["maxTotalItem"] as! Int64
            }
            if dict.keys.contains("totalItem") {
                self.totalItem = dict["totalItem"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeApiLimitResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeApiLimitResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeApiLimitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiLimitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiLimitResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiNameListRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeApiNameListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var apiId: String?

        public var apiName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiId != nil {
                map["apiId"] = self.apiId!
            }
            if self.apiName != nil {
                map["apiName"] = self.apiName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("apiId") {
                self.apiId = dict["apiId"] as! String
            }
            if dict.keys.contains("apiName") {
                self.apiName = dict["apiName"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeApiNameListResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeApiNameListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeApiNameListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeApiNameListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiNameListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiNameListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiVariableRequest : Tea.TeaModel {
    public var lang: String?

    public var id: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeApiVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeApiVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApisRequest : Tea.TeaModel {
    public var lang: String?

    public var apiGroupId: String?

    public var apiRegionId: String?

    public var apiType: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.apiGroupId != nil {
            map["apiGroupId"] = self.apiGroupId!
        }
        if self.apiRegionId != nil {
            map["apiRegionId"] = self.apiRegionId!
        }
        if self.apiType != nil {
            map["apiType"] = self.apiType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("apiGroupId") {
            self.apiGroupId = dict["apiGroupId"] as! String
        }
        if dict.keys.contains("apiRegionId") {
            self.apiRegionId = dict["apiRegionId"] as! String
        }
        if dict.keys.contains("apiType") {
            self.apiType = dict["apiType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeApisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAppKeyPageRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: String?

    public var pageSize: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeAppKeyPageResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var androidSdkUrl: String?

        public var androidSdkVersion: String?

        public var appKey: String?

        public var gmtCreate: Int64?

        public var iosSdkUrl: String?

        public var iosSdkVersion: String?

        public var memo: String?

        public var sdkItems: String?

        public var used: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.androidSdkUrl != nil {
                map["androidSdkUrl"] = self.androidSdkUrl!
            }
            if self.androidSdkVersion != nil {
                map["androidSdkVersion"] = self.androidSdkVersion!
            }
            if self.appKey != nil {
                map["appKey"] = self.appKey!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.iosSdkUrl != nil {
                map["iosSdkUrl"] = self.iosSdkUrl!
            }
            if self.iosSdkVersion != nil {
                map["iosSdkVersion"] = self.iosSdkVersion!
            }
            if self.memo != nil {
                map["memo"] = self.memo!
            }
            if self.sdkItems != nil {
                map["sdkItems"] = self.sdkItems!
            }
            if self.used != nil {
                map["used"] = self.used!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("androidSdkUrl") {
                self.androidSdkUrl = dict["androidSdkUrl"] as! String
            }
            if dict.keys.contains("androidSdkVersion") {
                self.androidSdkVersion = dict["androidSdkVersion"] as! String
            }
            if dict.keys.contains("appKey") {
                self.appKey = dict["appKey"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("iosSdkUrl") {
                self.iosSdkUrl = dict["iosSdkUrl"] as! String
            }
            if dict.keys.contains("iosSdkVersion") {
                self.iosSdkVersion = dict["iosSdkVersion"] as! String
            }
            if dict.keys.contains("memo") {
                self.memo = dict["memo"] as! String
            }
            if dict.keys.contains("sdkItems") {
                self.sdkItems = dict["sdkItems"] as! String
            }
            if dict.keys.contains("used") {
                self.used = dict["used"] as! String
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeAppKeyPageResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeAppKeyPageResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeAppKeyPageResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeAppKeyPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAppKeyPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAppKeyPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAuditConfigRequest : Tea.TeaModel {
    public var lang: String?

    public var auditRelationType: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.auditRelationType != nil {
            map["auditRelationType"] = self.auditRelationType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("auditRelationType") {
            self.auditRelationType = dict["auditRelationType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeAuditConfigResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var resultObject: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeAuditConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAuditConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAuditConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAuditDetailsRequest : Tea.TeaModel {
    public var lang: String?

    public var id: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeAuditDetailsResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var resultObject: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeAuditDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAuditDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAuditDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAuditPageListRequest : Tea.TeaModel {
    public var lang: String?

    public var auditStatus: String?

    public var currentPage: String?

    public var eventCode: String?

    public var pageSize: String?

    public var regId: String?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.auditStatus != nil {
            map["auditStatus"] = self.auditStatus!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleName != nil {
            map["ruleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("auditStatus") {
            self.auditStatus = dict["auditStatus"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleName") {
            self.ruleName = dict["ruleName"] as! String
        }
    }
}

public class DescribeAuditPageListResponseBody : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var resultObject: Bool?

    public var totalItem: Int32?

    public var totalPage: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int64
        }
    }
}

public class DescribeAuditPageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAuditPageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAuditPageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAuthEventNameListRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeAuthEventNameListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeAuthEventNameListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAuthEventNameListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAuthEventNameListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAuthRulePageListRequest : Tea.TeaModel {
    public var lang: String?

    public var eventCode: String?

    public var regId: String?

    public var ruleName: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleName != nil {
            map["ruleName"] = self.ruleName!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleName") {
            self.ruleName = dict["ruleName"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
    }
}

public class DescribeAuthRulePageListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var consoleRuleId: Int64?

        public var createType: String?

        public var gmtModified: Int64?

        public var id: Int64?

        public var memo: String?

        public var ruleId: String?

        public var ruleName: String?

        public var ruleVersionId: Int64?

        public var status: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consoleRuleId != nil {
                map["consoleRuleId"] = self.consoleRuleId!
            }
            if self.createType != nil {
                map["createType"] = self.createType!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.memo != nil {
                map["memo"] = self.memo!
            }
            if self.ruleId != nil {
                map["ruleId"] = self.ruleId!
            }
            if self.ruleName != nil {
                map["ruleName"] = self.ruleName!
            }
            if self.ruleVersionId != nil {
                map["ruleVersionId"] = self.ruleVersionId!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("consoleRuleId") {
                self.consoleRuleId = dict["consoleRuleId"] as! Int64
            }
            if dict.keys.contains("createType") {
                self.createType = dict["createType"] as! String
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("memo") {
                self.memo = dict["memo"] as! String
            }
            if dict.keys.contains("ruleId") {
                self.ruleId = dict["ruleId"] as! String
            }
            if dict.keys.contains("ruleName") {
                self.ruleName = dict["ruleName"] as! String
            }
            if dict.keys.contains("ruleVersionId") {
                self.ruleVersionId = dict["ruleVersionId"] as! Int64
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int64?

    public var pageSize: Int64?

    public var resultObject: [DescribeAuthRulePageListResponseBody.ResultObject]?

    public var totalItem: Int64?

    public var totalPage: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int64
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeAuthRulePageListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeAuthRulePageListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int64
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int64
        }
    }
}

public class DescribeAuthRulePageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAuthRulePageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAuthRulePageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAuthSceneListRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeAuthSceneListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var serviceCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceCode != nil {
                map["serviceCode"] = self.serviceCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("serviceCode") {
                self.serviceCode = dict["serviceCode"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeAuthSceneListResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeAuthSceneListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeAuthSceneListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeAuthSceneListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAuthSceneListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAuthSceneListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAuthScenePageListRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var sceneName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.sceneName != nil {
            map["sceneName"] = self.sceneName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("sceneName") {
            self.sceneName = dict["sceneName"] as! String
        }
    }
}

public class DescribeAuthScenePageListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var commonRuleCount: Int64?

        public var customRuleCount: Int64?

        public var eventCode: String?

        public var sceneName: String?

        public var serverName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commonRuleCount != nil {
                map["commonRuleCount"] = self.commonRuleCount!
            }
            if self.customRuleCount != nil {
                map["customRuleCount"] = self.customRuleCount!
            }
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.sceneName != nil {
                map["sceneName"] = self.sceneName!
            }
            if self.serverName != nil {
                map["serverName"] = self.serverName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("commonRuleCount") {
                self.commonRuleCount = dict["commonRuleCount"] as! Int64
            }
            if dict.keys.contains("customRuleCount") {
                self.customRuleCount = dict["customRuleCount"] as! Int64
            }
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("sceneName") {
                self.sceneName = dict["sceneName"] as! String
            }
            if dict.keys.contains("serverName") {
                self.serverName = dict["serverName"] as! String
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int64?

    public var pageSize: Int64?

    public var resultObject: [DescribeAuthScenePageListResponseBody.ResultObject]?

    public var totalItem: Int64?

    public var totalPage: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int64
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeAuthScenePageListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeAuthScenePageListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int64
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int64
        }
    }
}

public class DescribeAuthScenePageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAuthScenePageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAuthScenePageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAuthStatusRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeAuthStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeAuthStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAuthStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAuthStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAvgExecuteCostReportRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeAvgExecuteCostReportResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var ratio: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ratio != nil {
                map["ratio"] = self.ratio!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ratio") {
                self.ratio = dict["ratio"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: [DescribeAvgExecuteCostReportResponseBody.ResultObject]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeAvgExecuteCostReportResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeAvgExecuteCostReportResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeAvgExecuteCostReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAvgExecuteCostReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAvgExecuteCostReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBasicSearchPageListRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: Int64?

    public var eventBeginTime: Int64?

    public var eventCodes: String?

    public var eventEndTime: Int64?

    public var fieldName: String?

    public var fieldValue: String?

    public var pageSize: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.eventBeginTime != nil {
            map["eventBeginTime"] = self.eventBeginTime!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.eventEndTime != nil {
            map["eventEndTime"] = self.eventEndTime!
        }
        if self.fieldName != nil {
            map["fieldName"] = self.fieldName!
        }
        if self.fieldValue != nil {
            map["fieldValue"] = self.fieldValue!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int64
        }
        if dict.keys.contains("eventBeginTime") {
            self.eventBeginTime = dict["eventBeginTime"] as! Int64
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("eventEndTime") {
            self.eventEndTime = dict["eventEndTime"] as! Int64
        }
        if dict.keys.contains("fieldName") {
            self.fieldName = dict["fieldName"] as! String
        }
        if dict.keys.contains("fieldValue") {
            self.fieldValue = dict["fieldValue"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeBasicSearchPageListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Header : Tea.TeaModel {
            public var fieldName: String?

            public var fieldTitle: String?

            public var isDefault: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldName != nil {
                    map["fieldName"] = self.fieldName!
                }
                if self.fieldTitle != nil {
                    map["fieldTitle"] = self.fieldTitle!
                }
                if self.isDefault != nil {
                    map["isDefault"] = self.isDefault!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("fieldName") {
                    self.fieldName = dict["fieldName"] as! String
                }
                if dict.keys.contains("fieldTitle") {
                    self.fieldTitle = dict["fieldTitle"] as! String
                }
                if dict.keys.contains("isDefault") {
                    self.isDefault = dict["isDefault"] as! Bool
                }
            }
        }
        public var currentPage: Int64?

        public var data: [[String: Any]]?

        public var header: [DescribeBasicSearchPageListResponseBody.ResultObject.Header]?

        public var pageSize: Int64?

        public var totalItem: Int64?

        public var totalPage: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["currentPage"] = self.currentPage!
            }
            if self.data != nil {
                map["data"] = self.data!
            }
            if self.header != nil {
                var tmp : [Any] = []
                for k in self.header! {
                    tmp.append(k.toMap())
                }
                map["header"] = tmp
            }
            if self.pageSize != nil {
                map["pageSize"] = self.pageSize!
            }
            if self.totalItem != nil {
                map["totalItem"] = self.totalItem!
            }
            if self.totalPage != nil {
                map["totalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("currentPage") {
                self.currentPage = dict["currentPage"] as! Int64
            }
            if dict.keys.contains("data") {
                self.data = dict["data"] as! [[String: Any]]
            }
            if dict.keys.contains("header") {
                var tmp : [DescribeBasicSearchPageListResponseBody.ResultObject.Header] = []
                for v in dict["header"] as! [Any] {
                    var model = DescribeBasicSearchPageListResponseBody.ResultObject.Header()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.header = tmp
            }
            if dict.keys.contains("pageSize") {
                self.pageSize = dict["pageSize"] as! Int64
            }
            if dict.keys.contains("totalItem") {
                self.totalItem = dict["totalItem"] as! Int64
            }
            if dict.keys.contains("totalPage") {
                self.totalPage = dict["totalPage"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeBasicSearchPageListResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeBasicSearchPageListResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeBasicSearchPageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBasicSearchPageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBasicSearchPageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBasicStartRequest : Tea.TeaModel {
    public var appKey: String?

    public var endDs: String?

    public var regId: String?

    public var service: String?

    public var startDs: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKey != nil {
            map["appKey"] = self.appKey!
        }
        if self.endDs != nil {
            map["endDs"] = self.endDs!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.service != nil {
            map["service"] = self.service!
        }
        if self.startDs != nil {
            map["startDs"] = self.startDs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("appKey") {
            self.appKey = dict["appKey"] as! String
        }
        if dict.keys.contains("endDs") {
            self.endDs = dict["endDs"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("service") {
            self.service = dict["service"] as! String
        }
        if dict.keys.contains("startDs") {
            self.startDs = dict["startDs"] as! String
        }
    }
}

public class DescribeBasicStartResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeBasicStartResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBasicStartResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBasicStartResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeByPassShuntEventRequest : Tea.TeaModel {
    public var lang: String?

    public var eventId: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventId != nil {
            map["eventId"] = self.eventId!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventId") {
            self.eventId = dict["eventId"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeByPassShuntEventResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var eventName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: DescribeByPassShuntEventResponseBody.ResultObject?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeByPassShuntEventResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeByPassShuntEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeByPassShuntEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeByPassShuntEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustVariableConfigListRequest : Tea.TeaModel {
    public var lang: String?

    public var bizType: String?

    public var regId: String?

    public var timeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.bizType != nil {
            map["bizType"] = self.bizType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.timeType != nil {
            map["timeType"] = self.timeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("bizType") {
            self.bizType = dict["bizType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("timeType") {
            self.timeType = dict["timeType"] as! String
        }
    }
}

public class DescribeCustVariableConfigListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var configKey: String?

        public var configValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configKey != nil {
                map["configKey"] = self.configKey!
            }
            if self.configValue != nil {
                map["configValue"] = self.configValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("configKey") {
                self.configKey = dict["configKey"] as! String
            }
            if dict.keys.contains("configValue") {
                self.configValue = dict["configValue"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeCustVariableConfigListResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeCustVariableConfigListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeCustVariableConfigListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeCustVariableConfigListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustVariableConfigListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCustVariableConfigListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustVariableDetailRequest : Tea.TeaModel {
    public var lang: String?

    public var id: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeCustVariableDetailResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var condition: String?

        public var dataVersion: Int64?

        public var description_: String?

        public var eventCodes: String?

        public var historyValueType: String?

        public var id: Int64?

        public var object: String?

        public var outputs: String?

        public var subject: String?

        public var timeType: String?

        public var title: String?

        public var twCount: String?

        public var velocityFC: String?

        public var velocityTW: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["condition"] = self.condition!
            }
            if self.dataVersion != nil {
                map["dataVersion"] = self.dataVersion!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.eventCodes != nil {
                map["eventCodes"] = self.eventCodes!
            }
            if self.historyValueType != nil {
                map["historyValueType"] = self.historyValueType!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.object != nil {
                map["object"] = self.object!
            }
            if self.outputs != nil {
                map["outputs"] = self.outputs!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.timeType != nil {
                map["timeType"] = self.timeType!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.twCount != nil {
                map["twCount"] = self.twCount!
            }
            if self.velocityFC != nil {
                map["velocityFC"] = self.velocityFC!
            }
            if self.velocityTW != nil {
                map["velocityTW"] = self.velocityTW!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("condition") {
                self.condition = dict["condition"] as! String
            }
            if dict.keys.contains("dataVersion") {
                self.dataVersion = dict["dataVersion"] as! Int64
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("eventCodes") {
                self.eventCodes = dict["eventCodes"] as! String
            }
            if dict.keys.contains("historyValueType") {
                self.historyValueType = dict["historyValueType"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("object") {
                self.object = dict["object"] as! String
            }
            if dict.keys.contains("outputs") {
                self.outputs = dict["outputs"] as! String
            }
            if dict.keys.contains("subject") {
                self.subject = dict["subject"] as! String
            }
            if dict.keys.contains("timeType") {
                self.timeType = dict["timeType"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
            if dict.keys.contains("twCount") {
                self.twCount = dict["twCount"] as! String
            }
            if dict.keys.contains("velocityFC") {
                self.velocityFC = dict["velocityFC"] as! String
            }
            if dict.keys.contains("velocityTW") {
                self.velocityTW = dict["velocityTW"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeCustVariableDetailResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeCustVariableDetailResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeCustVariableDetailResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeCustVariableDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustVariableDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCustVariableDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustVariablePageRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var currentPage: Int32?

    public var description_: String?

    public var eventCode: String?

    public var pageSize: Int32?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeCustVariablePageResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var dataVersion: Int64?

        public var description_: String?

        public var gmtModified: Int64?

        public var id: Int64?

        public var name: String?

        public var status: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataVersion != nil {
                map["dataVersion"] = self.dataVersion!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("dataVersion") {
                self.dataVersion = dict["dataVersion"] as! Int64
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeCustVariablePageResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeCustVariablePageResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeCustVariablePageResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeCustVariablePageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustVariablePageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCustVariablePageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDataSourceDataDownloadUrlRequest : Tea.TeaModel {
    public var lang: String?

    public var dataSourceId: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.dataSourceId != nil {
            map["dataSourceId"] = self.dataSourceId!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("dataSourceId") {
            self.dataSourceId = dict["dataSourceId"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeDataSourceDataDownloadUrlResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var downloadFileUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadFileUrl != nil {
                map["downloadFileUrl"] = self.downloadFileUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("downloadFileUrl") {
                self.downloadFileUrl = dict["downloadFileUrl"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeDataSourceDataDownloadUrlResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeDataSourceDataDownloadUrlResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeDataSourceDataDownloadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDataSourceDataDownloadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDataSourceDataDownloadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDataSourceFieldsRequest : Tea.TeaModel {
    public var lang: String?

    public var dataSourceCode: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.dataSourceCode != nil {
            map["dataSourceCode"] = self.dataSourceCode!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("dataSourceCode") {
            self.dataSourceCode = dict["dataSourceCode"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeDataSourceFieldsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeDataSourceFieldsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDataSourceFieldsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDataSourceFieldsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDataSourcePageListRequest : Tea.TeaModel {
    public var lang: String?

    public var sourceIp: String?

    public var currentPage: Int64?

    public var name: String?

    public var pageSize: Int64?

    public var regId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int64
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class DescribeDataSourcePageListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var creator: String?

        public var description_: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var modifier: String?

        public var name: String?

        public var total: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.total != nil {
                map["total"] = self.total!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! String
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("modifier") {
                self.modifier = dict["modifier"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("total") {
                self.total = dict["total"] as! Int64
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeDataSourcePageListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeDataSourcePageListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeDataSourcePageListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeDataSourcePageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDataSourcePageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDataSourcePageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDecisionResultFluctuationRequest : Tea.TeaModel {
    public var lang: String?

    public var eventCodes: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeDecisionResultFluctuationResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var status: String?

        public var todayNum: Int64?

        public var withinSevenDayNum: String?

        public var withinThirtyDayNum: String?

        public var withinThreeDayNum: String?

        public var yesterdayNum: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.todayNum != nil {
                map["todayNum"] = self.todayNum!
            }
            if self.withinSevenDayNum != nil {
                map["withinSevenDayNum"] = self.withinSevenDayNum!
            }
            if self.withinThirtyDayNum != nil {
                map["withinThirtyDayNum"] = self.withinThirtyDayNum!
            }
            if self.withinThreeDayNum != nil {
                map["withinThreeDayNum"] = self.withinThreeDayNum!
            }
            if self.yesterdayNum != nil {
                map["yesterdayNum"] = self.yesterdayNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("todayNum") {
                self.todayNum = dict["todayNum"] as! Int64
            }
            if dict.keys.contains("withinSevenDayNum") {
                self.withinSevenDayNum = dict["withinSevenDayNum"] as! String
            }
            if dict.keys.contains("withinThirtyDayNum") {
                self.withinThirtyDayNum = dict["withinThirtyDayNum"] as! String
            }
            if dict.keys.contains("withinThreeDayNum") {
                self.withinThreeDayNum = dict["withinThreeDayNum"] as! String
            }
            if dict.keys.contains("yesterdayNum") {
                self.yesterdayNum = dict["yesterdayNum"] as! Int64
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: [DescribeDecisionResultFluctuationResponseBody.ResultObject]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeDecisionResultFluctuationResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeDecisionResultFluctuationResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeDecisionResultFluctuationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDecisionResultFluctuationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDecisionResultFluctuationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDecisionResultTrendRequest : Tea.TeaModel {
    public var lang: String?

    public var beginTime: Int64?

    public var endTime: Int64?

    public var eventCodes: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! Int64
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeDecisionResultTrendResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Series : Tea.TeaModel {
            public class Data : Tea.TeaModel {
                public var num: Int64?

                public var scale: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.num != nil {
                        map["num"] = self.num!
                    }
                    if self.scale != nil {
                        map["scale"] = self.scale!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("num") {
                        self.num = dict["num"] as! Int64
                    }
                    if dict.keys.contains("scale") {
                        self.scale = dict["scale"] as! String
                    }
                }
            }
            public var data: [DescribeDecisionResultTrendResponseBody.ResultObject.Series.Data]?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    var tmp : [Any] = []
                    for k in self.data! {
                        tmp.append(k.toMap())
                    }
                    map["data"] = tmp
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    var tmp : [DescribeDecisionResultTrendResponseBody.ResultObject.Series.Data] = []
                    for v in dict["data"] as! [Any] {
                        var model = DescribeDecisionResultTrendResponseBody.ResultObject.Series.Data()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.data = tmp
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public class Xaxis : Tea.TeaModel {
            public var data: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    self.data = dict["data"] as! [String]
                }
            }
        }
        public var series: [DescribeDecisionResultTrendResponseBody.ResultObject.Series]?

        public var xaxis: DescribeDecisionResultTrendResponseBody.ResultObject.Xaxis?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.xaxis?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.series != nil {
                var tmp : [Any] = []
                for k in self.series! {
                    tmp.append(k.toMap())
                }
                map["series"] = tmp
            }
            if self.xaxis != nil {
                map["xaxis"] = self.xaxis?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("series") {
                var tmp : [DescribeDecisionResultTrendResponseBody.ResultObject.Series] = []
                for v in dict["series"] as! [Any] {
                    var model = DescribeDecisionResultTrendResponseBody.ResultObject.Series()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.series = tmp
            }
            if dict.keys.contains("xaxis") {
                var model = DescribeDecisionResultTrendResponseBody.ResultObject.Xaxis()
                model.fromMap(dict["xaxis"] as! [String: Any])
                self.xaxis = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: DescribeDecisionResultTrendResponseBody.ResultObject?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeDecisionResultTrendResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeDecisionResultTrendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDecisionResultTrendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDecisionResultTrendResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDetailStartRequest : Tea.TeaModel {
    public var appKey: String?

    public var endDs: String?

    public var regId: String?

    public var service: String?

    public var startDs: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKey != nil {
            map["appKey"] = self.appKey!
        }
        if self.endDs != nil {
            map["endDs"] = self.endDs!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.service != nil {
            map["service"] = self.service!
        }
        if self.startDs != nil {
            map["startDs"] = self.startDs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("appKey") {
            self.appKey = dict["appKey"] as! String
        }
        if dict.keys.contains("endDs") {
            self.endDs = dict["endDs"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("service") {
            self.service = dict["service"] as! String
        }
        if dict.keys.contains("startDs") {
            self.startDs = dict["startDs"] as! String
        }
    }
}

public class DescribeDetailStartResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeDetailStartResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDetailStartResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDetailStartResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDownloadUrlRequest : Tea.TeaModel {
    public var fileType: String?

    public var lang: String?

    public var regId: String?

    public var taskId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileType != nil {
            map["FileType"] = self.fileType!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["RegId"] = self.regId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileType") {
            self.fileType = dict["FileType"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RegId") {
            self.regId = dict["RegId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeDownloadUrlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! String
        }
    }
}

public class DescribeDownloadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDownloadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDownloadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventBaseInfoByEventCodeRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var eventCode: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeEventBaseInfoByEventCodeResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class InputFields : Tea.TeaModel {
            public var description_: String?

            public var fieldCode: String?

            public var fieldRank: String?

            public var fieldSource: String?

            public var fieldType: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.fieldCode != nil {
                    map["fieldCode"] = self.fieldCode!
                }
                if self.fieldRank != nil {
                    map["fieldRank"] = self.fieldRank!
                }
                if self.fieldSource != nil {
                    map["fieldSource"] = self.fieldSource!
                }
                if self.fieldType != nil {
                    map["fieldType"] = self.fieldType!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("fieldCode") {
                    self.fieldCode = dict["fieldCode"] as! String
                }
                if dict.keys.contains("fieldRank") {
                    self.fieldRank = dict["fieldRank"] as! String
                }
                if dict.keys.contains("fieldSource") {
                    self.fieldSource = dict["fieldSource"] as! String
                }
                if dict.keys.contains("fieldType") {
                    self.fieldType = dict["fieldType"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public class RuleDetails : Tea.TeaModel {
            public var logicExpression: String?

            public var memo: String?

            public var ruleActions: String?

            public var ruleAuthType: String?

            public var ruleExpressions: String?

            public var ruleId: String?

            public var ruleName: String?

            public var ruleStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logicExpression != nil {
                    map["logicExpression"] = self.logicExpression!
                }
                if self.memo != nil {
                    map["memo"] = self.memo!
                }
                if self.ruleActions != nil {
                    map["ruleActions"] = self.ruleActions!
                }
                if self.ruleAuthType != nil {
                    map["ruleAuthType"] = self.ruleAuthType!
                }
                if self.ruleExpressions != nil {
                    map["ruleExpressions"] = self.ruleExpressions!
                }
                if self.ruleId != nil {
                    map["ruleId"] = self.ruleId!
                }
                if self.ruleName != nil {
                    map["ruleName"] = self.ruleName!
                }
                if self.ruleStatus != nil {
                    map["ruleStatus"] = self.ruleStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("logicExpression") {
                    self.logicExpression = dict["logicExpression"] as! String
                }
                if dict.keys.contains("memo") {
                    self.memo = dict["memo"] as! String
                }
                if dict.keys.contains("ruleActions") {
                    self.ruleActions = dict["ruleActions"] as! String
                }
                if dict.keys.contains("ruleAuthType") {
                    self.ruleAuthType = dict["ruleAuthType"] as! String
                }
                if dict.keys.contains("ruleExpressions") {
                    self.ruleExpressions = dict["ruleExpressions"] as! String
                }
                if dict.keys.contains("ruleId") {
                    self.ruleId = dict["ruleId"] as! String
                }
                if dict.keys.contains("ruleName") {
                    self.ruleName = dict["ruleName"] as! String
                }
                if dict.keys.contains("ruleStatus") {
                    self.ruleStatus = dict["ruleStatus"] as! String
                }
            }
        }
        public var bizVersion: Int32?

        public var eventCode: String?

        public var eventName: String?

        public var eventStauts: String?

        public var inputFields: [DescribeEventBaseInfoByEventCodeResponseBody.ResultObject.InputFields]?

        public var memo: String?

        public var ruleDetails: [DescribeEventBaseInfoByEventCodeResponseBody.ResultObject.RuleDetails]?

        public var templateCode: String?

        public var templateName: String?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizVersion != nil {
                map["bizVersion"] = self.bizVersion!
            }
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.eventStauts != nil {
                map["eventStauts"] = self.eventStauts!
            }
            if self.inputFields != nil {
                var tmp : [Any] = []
                for k in self.inputFields! {
                    tmp.append(k.toMap())
                }
                map["inputFields"] = tmp
            }
            if self.memo != nil {
                map["memo"] = self.memo!
            }
            if self.ruleDetails != nil {
                var tmp : [Any] = []
                for k in self.ruleDetails! {
                    tmp.append(k.toMap())
                }
                map["ruleDetails"] = tmp
            }
            if self.templateCode != nil {
                map["templateCode"] = self.templateCode!
            }
            if self.templateName != nil {
                map["templateName"] = self.templateName!
            }
            if self.templateType != nil {
                map["templateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("bizVersion") {
                self.bizVersion = dict["bizVersion"] as! Int32
            }
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("eventStauts") {
                self.eventStauts = dict["eventStauts"] as! String
            }
            if dict.keys.contains("inputFields") {
                var tmp : [DescribeEventBaseInfoByEventCodeResponseBody.ResultObject.InputFields] = []
                for v in dict["inputFields"] as! [Any] {
                    var model = DescribeEventBaseInfoByEventCodeResponseBody.ResultObject.InputFields()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inputFields = tmp
            }
            if dict.keys.contains("memo") {
                self.memo = dict["memo"] as! String
            }
            if dict.keys.contains("ruleDetails") {
                var tmp : [DescribeEventBaseInfoByEventCodeResponseBody.ResultObject.RuleDetails] = []
                for v in dict["ruleDetails"] as! [Any] {
                    var model = DescribeEventBaseInfoByEventCodeResponseBody.ResultObject.RuleDetails()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ruleDetails = tmp
            }
            if dict.keys.contains("templateCode") {
                self.templateCode = dict["templateCode"] as! String
            }
            if dict.keys.contains("templateName") {
                self.templateName = dict["templateName"] as! String
            }
            if dict.keys.contains("templateType") {
                self.templateType = dict["templateType"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeEventBaseInfoByEventCodeResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeEventBaseInfoByEventCodeResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeEventBaseInfoByEventCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventBaseInfoByEventCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEventBaseInfoByEventCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventCountRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeEventCountResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var limit: Bool?

        public var maxTotalItem: Int32?

        public var totalItem: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.limit != nil {
                map["limit"] = self.limit!
            }
            if self.maxTotalItem != nil {
                map["maxTotalItem"] = self.maxTotalItem!
            }
            if self.totalItem != nil {
                map["totalItem"] = self.totalItem!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("limit") {
                self.limit = dict["limit"] as! Bool
            }
            if dict.keys.contains("maxTotalItem") {
                self.maxTotalItem = dict["maxTotalItem"] as! Int32
            }
            if dict.keys.contains("totalItem") {
                self.totalItem = dict["totalItem"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: DescribeEventCountResponseBody.ResultObject?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeEventCountResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeEventCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEventCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventDetailByRequestIdRequest : Tea.TeaModel {
    public var lang: String?

    public var eventCode: String?

    public var eventTime: Int64?

    public var regId: String?

    public var sRequestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.eventTime != nil {
            map["eventTime"] = self.eventTime!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.sRequestId != nil {
            map["sRequestId"] = self.sRequestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("eventTime") {
            self.eventTime = dict["eventTime"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("sRequestId") {
            self.sRequestId = dict["sRequestId"] as! String
        }
    }
}

public class DescribeEventDetailByRequestIdResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeEventDetailByRequestIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventDetailByRequestIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEventDetailByRequestIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventLogDetailRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var reqIdByLog: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.reqIdByLog != nil {
            map["reqIdByLog"] = self.reqIdByLog!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("reqIdByLog") {
            self.reqIdByLog = dict["reqIdByLog"] as! String
        }
    }
}

public class DescribeEventLogDetailResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeEventLogDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventLogDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEventLogDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventLogPageRequest : Tea.TeaModel {
    public var lang: String?

    public var accountIdPRP: String?

    public var beginTime: Int64?

    public var condition1AL: String?

    public var condition2AL: String?

    public var condition3AL: String?

    public var currentPage: Int32?

    public var deviceTypeLRP: String?

    public var emailPRP: String?

    public var endTime: Int64?

    public var failReasonLRP: String?

    public var ipPRP: String?

    public var loginResultARP: String?

    public var loginTypeLRP: String?

    public var macPRP: String?

    public var mobilePRP: String?

    public var nickNamePRP: String?

    public var operateSourceLRP: String?

    public var pageSize: Int32?

    public var referPRP: String?

    public var regId: String?

    public var registerIpPRP: String?

    public var reqIdPBS: String?

    public var scoreEBS: Int32?

    public var scoreSBS: Int32?

    public var serviceABS: String?

    public var tagsLBS: String?

    public var umidPDI: String?

    public var userAgentPRP: String?

    public var userNameTypeLRP: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.accountIdPRP != nil {
            map["accountIdPRP"] = self.accountIdPRP!
        }
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.condition1AL != nil {
            map["condition1AL"] = self.condition1AL!
        }
        if self.condition2AL != nil {
            map["condition2AL"] = self.condition2AL!
        }
        if self.condition3AL != nil {
            map["condition3AL"] = self.condition3AL!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.deviceTypeLRP != nil {
            map["deviceTypeLRP"] = self.deviceTypeLRP!
        }
        if self.emailPRP != nil {
            map["emailPRP"] = self.emailPRP!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.failReasonLRP != nil {
            map["failReasonLRP"] = self.failReasonLRP!
        }
        if self.ipPRP != nil {
            map["ipPRP"] = self.ipPRP!
        }
        if self.loginResultARP != nil {
            map["loginResultARP"] = self.loginResultARP!
        }
        if self.loginTypeLRP != nil {
            map["loginTypeLRP"] = self.loginTypeLRP!
        }
        if self.macPRP != nil {
            map["macPRP"] = self.macPRP!
        }
        if self.mobilePRP != nil {
            map["mobilePRP"] = self.mobilePRP!
        }
        if self.nickNamePRP != nil {
            map["nickNamePRP"] = self.nickNamePRP!
        }
        if self.operateSourceLRP != nil {
            map["operateSourceLRP"] = self.operateSourceLRP!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.referPRP != nil {
            map["referPRP"] = self.referPRP!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.registerIpPRP != nil {
            map["registerIpPRP"] = self.registerIpPRP!
        }
        if self.reqIdPBS != nil {
            map["reqIdPBS"] = self.reqIdPBS!
        }
        if self.scoreEBS != nil {
            map["scoreEBS"] = self.scoreEBS!
        }
        if self.scoreSBS != nil {
            map["scoreSBS"] = self.scoreSBS!
        }
        if self.serviceABS != nil {
            map["serviceABS"] = self.serviceABS!
        }
        if self.tagsLBS != nil {
            map["tagsLBS"] = self.tagsLBS!
        }
        if self.umidPDI != nil {
            map["umidPDI"] = self.umidPDI!
        }
        if self.userAgentPRP != nil {
            map["userAgentPRP"] = self.userAgentPRP!
        }
        if self.userNameTypeLRP != nil {
            map["userNameTypeLRP"] = self.userNameTypeLRP!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("accountIdPRP") {
            self.accountIdPRP = dict["accountIdPRP"] as! String
        }
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! Int64
        }
        if dict.keys.contains("condition1AL") {
            self.condition1AL = dict["condition1AL"] as! String
        }
        if dict.keys.contains("condition2AL") {
            self.condition2AL = dict["condition2AL"] as! String
        }
        if dict.keys.contains("condition3AL") {
            self.condition3AL = dict["condition3AL"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("deviceTypeLRP") {
            self.deviceTypeLRP = dict["deviceTypeLRP"] as! String
        }
        if dict.keys.contains("emailPRP") {
            self.emailPRP = dict["emailPRP"] as! String
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("failReasonLRP") {
            self.failReasonLRP = dict["failReasonLRP"] as! String
        }
        if dict.keys.contains("ipPRP") {
            self.ipPRP = dict["ipPRP"] as! String
        }
        if dict.keys.contains("loginResultARP") {
            self.loginResultARP = dict["loginResultARP"] as! String
        }
        if dict.keys.contains("loginTypeLRP") {
            self.loginTypeLRP = dict["loginTypeLRP"] as! String
        }
        if dict.keys.contains("macPRP") {
            self.macPRP = dict["macPRP"] as! String
        }
        if dict.keys.contains("mobilePRP") {
            self.mobilePRP = dict["mobilePRP"] as! String
        }
        if dict.keys.contains("nickNamePRP") {
            self.nickNamePRP = dict["nickNamePRP"] as! String
        }
        if dict.keys.contains("operateSourceLRP") {
            self.operateSourceLRP = dict["operateSourceLRP"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("referPRP") {
            self.referPRP = dict["referPRP"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("registerIpPRP") {
            self.registerIpPRP = dict["registerIpPRP"] as! String
        }
        if dict.keys.contains("reqIdPBS") {
            self.reqIdPBS = dict["reqIdPBS"] as! String
        }
        if dict.keys.contains("scoreEBS") {
            self.scoreEBS = dict["scoreEBS"] as! Int32
        }
        if dict.keys.contains("scoreSBS") {
            self.scoreSBS = dict["scoreSBS"] as! Int32
        }
        if dict.keys.contains("serviceABS") {
            self.serviceABS = dict["serviceABS"] as! String
        }
        if dict.keys.contains("tagsLBS") {
            self.tagsLBS = dict["tagsLBS"] as! String
        }
        if dict.keys.contains("umidPDI") {
            self.umidPDI = dict["umidPDI"] as! String
        }
        if dict.keys.contains("userAgentPRP") {
            self.userAgentPRP = dict["userAgentPRP"] as! String
        }
        if dict.keys.contains("userNameTypeLRP") {
            self.userNameTypeLRP = dict["userNameTypeLRP"] as! String
        }
    }
}

public class DescribeEventLogPageResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var accountId: String?

        public var email: String?

        public var ip: String?

        public var mobile: String?

        public var nickName: String?

        public var requestId: String?

        public var score: String?

        public var service: String?

        public var tags: String?

        public var timestamp: String?

        public var umid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.ip != nil {
                map["ip"] = self.ip!
            }
            if self.mobile != nil {
                map["mobile"] = self.mobile!
            }
            if self.nickName != nil {
                map["nickName"] = self.nickName!
            }
            if self.requestId != nil {
                map["requestId"] = self.requestId!
            }
            if self.score != nil {
                map["score"] = self.score!
            }
            if self.service != nil {
                map["service"] = self.service!
            }
            if self.tags != nil {
                map["tags"] = self.tags!
            }
            if self.timestamp != nil {
                map["timestamp"] = self.timestamp!
            }
            if self.umid != nil {
                map["umid"] = self.umid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
            if dict.keys.contains("email") {
                self.email = dict["email"] as! String
            }
            if dict.keys.contains("ip") {
                self.ip = dict["ip"] as! String
            }
            if dict.keys.contains("mobile") {
                self.mobile = dict["mobile"] as! String
            }
            if dict.keys.contains("nickName") {
                self.nickName = dict["nickName"] as! String
            }
            if dict.keys.contains("requestId") {
                self.requestId = dict["requestId"] as! String
            }
            if dict.keys.contains("score") {
                self.score = dict["score"] as! String
            }
            if dict.keys.contains("service") {
                self.service = dict["service"] as! String
            }
            if dict.keys.contains("tags") {
                self.tags = dict["tags"] as! String
            }
            if dict.keys.contains("timestamp") {
                self.timestamp = dict["timestamp"] as! String
            }
            if dict.keys.contains("umid") {
                self.umid = dict["umid"] as! String
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeEventLogPageResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeEventLogPageResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeEventLogPageResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeEventLogPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventLogPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEventLogPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventPageListRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var currentPage: Int32?

    public var eventCode: String?

    public var eventName: String?

    public var eventStatus: String?

    public var pageSize: Int32?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.eventName != nil {
            map["eventName"] = self.eventName!
        }
        if self.eventStatus != nil {
            map["eventStatus"] = self.eventStatus!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("eventName") {
            self.eventName = dict["eventName"] as! String
        }
        if dict.keys.contains("eventStatus") {
            self.eventStatus = dict["eventStatus"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeEventPageListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Children : Tea.TeaModel {
            public var eventCode: String?

            public var eventName: String?

            public var eventStatus: String?

            public var eventType: String?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var id: Int64?

            public var ruleCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventCode != nil {
                    map["eventCode"] = self.eventCode!
                }
                if self.eventName != nil {
                    map["eventName"] = self.eventName!
                }
                if self.eventStatus != nil {
                    map["eventStatus"] = self.eventStatus!
                }
                if self.eventType != nil {
                    map["eventType"] = self.eventType!
                }
                if self.gmtCreate != nil {
                    map["gmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["gmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.ruleCount != nil {
                    map["ruleCount"] = self.ruleCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("eventCode") {
                    self.eventCode = dict["eventCode"] as! String
                }
                if dict.keys.contains("eventName") {
                    self.eventName = dict["eventName"] as! String
                }
                if dict.keys.contains("eventStatus") {
                    self.eventStatus = dict["eventStatus"] as! String
                }
                if dict.keys.contains("eventType") {
                    self.eventType = dict["eventType"] as! String
                }
                if dict.keys.contains("gmtCreate") {
                    self.gmtCreate = dict["gmtCreate"] as! Int64
                }
                if dict.keys.contains("gmtModified") {
                    self.gmtModified = dict["gmtModified"] as! Int64
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("ruleCount") {
                    self.ruleCount = dict["ruleCount"] as! Int64
                }
            }
        }
        public var children: [DescribeEventPageListResponseBody.ResultObject.Children]?

        public var eventCode: String?

        public var eventName: String?

        public var eventStatus: String?

        public var eventType: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var ruleCount: Int32?

        public var templateCode: String?

        public var templateName: String?

        public var templateType: String?

        public var userCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.children != nil {
                var tmp : [Any] = []
                for k in self.children! {
                    tmp.append(k.toMap())
                }
                map["children"] = tmp
            }
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.eventStatus != nil {
                map["eventStatus"] = self.eventStatus!
            }
            if self.eventType != nil {
                map["eventType"] = self.eventType!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.ruleCount != nil {
                map["ruleCount"] = self.ruleCount!
            }
            if self.templateCode != nil {
                map["templateCode"] = self.templateCode!
            }
            if self.templateName != nil {
                map["templateName"] = self.templateName!
            }
            if self.templateType != nil {
                map["templateType"] = self.templateType!
            }
            if self.userCount != nil {
                map["userCount"] = self.userCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("children") {
                var tmp : [DescribeEventPageListResponseBody.ResultObject.Children] = []
                for v in dict["children"] as! [Any] {
                    var model = DescribeEventPageListResponseBody.ResultObject.Children()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.children = tmp
            }
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("eventStatus") {
                self.eventStatus = dict["eventStatus"] as! String
            }
            if dict.keys.contains("eventType") {
                self.eventType = dict["eventType"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("ruleCount") {
                self.ruleCount = dict["ruleCount"] as! Int32
            }
            if dict.keys.contains("templateCode") {
                self.templateCode = dict["templateCode"] as! String
            }
            if dict.keys.contains("templateName") {
                self.templateName = dict["templateName"] as! String
            }
            if dict.keys.contains("templateType") {
                self.templateType = dict["templateType"] as! String
            }
            if dict.keys.contains("userCount") {
                self.userCount = dict["userCount"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeEventPageListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeEventPageListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeEventPageListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeEventPageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventPageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEventPageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventResultBarChartRequest : Tea.TeaModel {
    public var lang: String?

    public var beginTime: Int64?

    public var endTime: Int64?

    public var eventCodes: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! Int64
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeEventResultBarChartResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Series : Tea.TeaModel {
            public class Data : Tea.TeaModel {
                public var num: Int64?

                public var scale: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.num != nil {
                        map["num"] = self.num!
                    }
                    if self.scale != nil {
                        map["scale"] = self.scale!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("num") {
                        self.num = dict["num"] as! Int64
                    }
                    if dict.keys.contains("scale") {
                        self.scale = dict["scale"] as! String
                    }
                }
            }
            public var data: [DescribeEventResultBarChartResponseBody.ResultObject.Series.Data]?

            public var name: String?

            public var stack: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    var tmp : [Any] = []
                    for k in self.data! {
                        tmp.append(k.toMap())
                    }
                    map["data"] = tmp
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.stack != nil {
                    map["stack"] = self.stack!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    var tmp : [DescribeEventResultBarChartResponseBody.ResultObject.Series.Data] = []
                    for v in dict["data"] as! [Any] {
                        var model = DescribeEventResultBarChartResponseBody.ResultObject.Series.Data()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.data = tmp
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("stack") {
                    self.stack = dict["stack"] as! String
                }
            }
        }
        public class Xaxis : Tea.TeaModel {
            public var data: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    self.data = dict["data"] as! [String]
                }
            }
        }
        public var series: [DescribeEventResultBarChartResponseBody.ResultObject.Series]?

        public var xaxis: DescribeEventResultBarChartResponseBody.ResultObject.Xaxis?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.xaxis?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.series != nil {
                var tmp : [Any] = []
                for k in self.series! {
                    tmp.append(k.toMap())
                }
                map["series"] = tmp
            }
            if self.xaxis != nil {
                map["xaxis"] = self.xaxis?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("series") {
                var tmp : [DescribeEventResultBarChartResponseBody.ResultObject.Series] = []
                for v in dict["series"] as! [Any] {
                    var model = DescribeEventResultBarChartResponseBody.ResultObject.Series()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.series = tmp
            }
            if dict.keys.contains("xaxis") {
                var model = DescribeEventResultBarChartResponseBody.ResultObject.Xaxis()
                model.fromMap(dict["xaxis"] as! [String: Any])
                self.xaxis = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: DescribeEventResultBarChartResponseBody.ResultObject?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeEventResultBarChartResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeEventResultBarChartResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventResultBarChartResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEventResultBarChartResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventResultListRequest : Tea.TeaModel {
    public var lang: String?

    public var beginTime: Int64?

    public var currentPage: Int64?

    public var endTime: Int64?

    public var pageSize: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! Int64
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int64
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeEventResultListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var eventCode: String?

        public var eventName: String?

        public var passNum: Int64?

        public var pendingNum: Int64?

        public var rejectNum: Int64?

        public var totalNum: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.passNum != nil {
                map["passNum"] = self.passNum!
            }
            if self.pendingNum != nil {
                map["pendingNum"] = self.pendingNum!
            }
            if self.rejectNum != nil {
                map["rejectNum"] = self.rejectNum!
            }
            if self.totalNum != nil {
                map["totalNum"] = self.totalNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("passNum") {
                self.passNum = dict["passNum"] as! Int64
            }
            if dict.keys.contains("pendingNum") {
                self.pendingNum = dict["pendingNum"] as! Int64
            }
            if dict.keys.contains("rejectNum") {
                self.rejectNum = dict["rejectNum"] as! Int64
            }
            if dict.keys.contains("totalNum") {
                self.totalNum = dict["totalNum"] as! Int64
            }
        }
    }
    public var code: String?

    public var currentPage: Int64?

    public var httpStatusCode: String?

    public var message: String?

    public var pageSize: Int64?

    public var requestId: String?

    public var resultObject: [DescribeEventResultListResponseBody.ResultObject]?

    public var success: Bool?

    public var totalItem: Int64?

    public var totalPage: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int64
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeEventResultListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeEventResultListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int64
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int64
        }
    }
}

public class DescribeEventResultListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventResultListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEventResultListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventTaskHistoryRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeEventTaskHistoryResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var taskCode: String?

        public var taskName: String?

        public var taskStatus: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskCode != nil {
                map["taskCode"] = self.taskCode!
            }
            if self.taskName != nil {
                map["taskName"] = self.taskName!
            }
            if self.taskStatus != nil {
                map["taskStatus"] = self.taskStatus!
            }
            if self.url != nil {
                map["url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("taskCode") {
                self.taskCode = dict["taskCode"] as! String
            }
            if dict.keys.contains("taskName") {
                self.taskName = dict["taskName"] as! String
            }
            if dict.keys.contains("taskStatus") {
                self.taskStatus = dict["taskStatus"] as! String
            }
            if dict.keys.contains("url") {
                self.url = dict["url"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeEventTaskHistoryResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeEventTaskHistoryResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeEventTaskHistoryResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeEventTaskHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventTaskHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEventTaskHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventTotalCountReportRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeEventTotalCountReportResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var ratio: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ratio != nil {
                map["ratio"] = self.ratio!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ratio") {
                self.ratio = dict["ratio"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: DescribeEventTotalCountReportResponseBody.ResultObject?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeEventTotalCountReportResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeEventTotalCountReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventTotalCountReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEventTotalCountReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventUploadPolicyRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeEventUploadPolicyResponseBody : Tea.TeaModel {
    public var accessId: String?

    public var host: String?

    public var key: String?

    public var policy: String?

    public var requestId: String?

    public var signature: String?

    public var stsToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessId != nil {
            map["AccessId"] = self.accessId!
        }
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.signature != nil {
            map["Signature"] = self.signature!
        }
        if self.stsToken != nil {
            map["StsToken"] = self.stsToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessId") {
            self.accessId = dict["AccessId"] as! String
        }
        if dict.keys.contains("Host") {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Signature") {
            self.signature = dict["Signature"] as! String
        }
        if dict.keys.contains("StsToken") {
            self.stsToken = dict["StsToken"] as! String
        }
    }
}

public class DescribeEventUploadPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventUploadPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEventUploadPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventVariableListRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var filterDTO: String?

    public var refObjId: String?

    public var refObjType: String?

    public var regId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.filterDTO != nil {
            map["filterDTO"] = self.filterDTO!
        }
        if self.refObjId != nil {
            map["refObjId"] = self.refObjId!
        }
        if self.refObjType != nil {
            map["refObjType"] = self.refObjType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("filterDTO") {
            self.filterDTO = dict["filterDTO"] as! String
        }
        if dict.keys.contains("refObjId") {
            self.refObjId = dict["refObjId"] as! String
        }
        if dict.keys.contains("refObjType") {
            self.refObjType = dict["refObjType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class DescribeEventVariableListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Actions : Tea.TeaModel {
            public class OutputThreshold : Tea.TeaModel {
                public var maxValue: Double?

                public var minValue: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxValue != nil {
                        map["maxValue"] = self.maxValue!
                    }
                    if self.minValue != nil {
                        map["minValue"] = self.minValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxValue") {
                        self.maxValue = dict["maxValue"] as! Double
                    }
                    if dict.keys.contains("minValue") {
                        self.minValue = dict["minValue"] as! Double
                    }
                }
            }
            public class VariableVelocity : Tea.TeaModel {
                public var iv: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.iv != nil {
                        map["iv"] = self.iv!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("iv") {
                        self.iv = dict["iv"] as! String
                    }
                }
            }
            public var code: String?

            public var dataDisplay: String?

            public var defineId: String?

            public var description_: String?

            public var displayType: String?

            public var expressionTitle: String?

            public var favoriteFlag: Bool?

            public var fieldDetail: String?

            public var fieldRank: Int32?

            public var fieldSource: String?

            public var fieldType: String?

            public var id: Int64?

            public var inputFieldType: String?

            public var inputRequired: String?

            public var inputs: String?

            public var name: String?

            public var outlier: String?

            public var outputThreshold: DescribeEventVariableListResponseBody.ResultObject.Actions.OutputThreshold?

            public var parentName: String?

            public var sourceType: String?

            public var title: String?

            public var type: String?

            public var variableVelocity: DescribeEventVariableListResponseBody.ResultObject.Actions.VariableVelocity?

            public var xLabel: String?

            public var yLabel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputThreshold?.validate()
                try self.variableVelocity?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.dataDisplay != nil {
                    map["dataDisplay"] = self.dataDisplay!
                }
                if self.defineId != nil {
                    map["defineId"] = self.defineId!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.displayType != nil {
                    map["displayType"] = self.displayType!
                }
                if self.expressionTitle != nil {
                    map["expressionTitle"] = self.expressionTitle!
                }
                if self.favoriteFlag != nil {
                    map["favoriteFlag"] = self.favoriteFlag!
                }
                if self.fieldDetail != nil {
                    map["fieldDetail"] = self.fieldDetail!
                }
                if self.fieldRank != nil {
                    map["fieldRank"] = self.fieldRank!
                }
                if self.fieldSource != nil {
                    map["fieldSource"] = self.fieldSource!
                }
                if self.fieldType != nil {
                    map["fieldType"] = self.fieldType!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.inputFieldType != nil {
                    map["inputFieldType"] = self.inputFieldType!
                }
                if self.inputRequired != nil {
                    map["inputRequired"] = self.inputRequired!
                }
                if self.inputs != nil {
                    map["inputs"] = self.inputs!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.outlier != nil {
                    map["outlier"] = self.outlier!
                }
                if self.outputThreshold != nil {
                    map["outputThreshold"] = self.outputThreshold?.toMap()
                }
                if self.parentName != nil {
                    map["parentName"] = self.parentName!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.variableVelocity != nil {
                    map["variableVelocity"] = self.variableVelocity?.toMap()
                }
                if self.xLabel != nil {
                    map["xLabel"] = self.xLabel!
                }
                if self.yLabel != nil {
                    map["yLabel"] = self.yLabel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("dataDisplay") {
                    self.dataDisplay = dict["dataDisplay"] as! String
                }
                if dict.keys.contains("defineId") {
                    self.defineId = dict["defineId"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("displayType") {
                    self.displayType = dict["displayType"] as! String
                }
                if dict.keys.contains("expressionTitle") {
                    self.expressionTitle = dict["expressionTitle"] as! String
                }
                if dict.keys.contains("favoriteFlag") {
                    self.favoriteFlag = dict["favoriteFlag"] as! Bool
                }
                if dict.keys.contains("fieldDetail") {
                    self.fieldDetail = dict["fieldDetail"] as! String
                }
                if dict.keys.contains("fieldRank") {
                    self.fieldRank = dict["fieldRank"] as! Int32
                }
                if dict.keys.contains("fieldSource") {
                    self.fieldSource = dict["fieldSource"] as! String
                }
                if dict.keys.contains("fieldType") {
                    self.fieldType = dict["fieldType"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("inputFieldType") {
                    self.inputFieldType = dict["inputFieldType"] as! String
                }
                if dict.keys.contains("inputRequired") {
                    self.inputRequired = dict["inputRequired"] as! String
                }
                if dict.keys.contains("inputs") {
                    self.inputs = dict["inputs"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("outlier") {
                    self.outlier = dict["outlier"] as! String
                }
                if dict.keys.contains("outputThreshold") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.Actions.OutputThreshold()
                    model.fromMap(dict["outputThreshold"] as! [String: Any])
                    self.outputThreshold = model
                }
                if dict.keys.contains("parentName") {
                    self.parentName = dict["parentName"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("variableVelocity") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.Actions.VariableVelocity()
                    model.fromMap(dict["variableVelocity"] as! [String: Any])
                    self.variableVelocity = model
                }
                if dict.keys.contains("xLabel") {
                    self.xLabel = dict["xLabel"] as! String
                }
                if dict.keys.contains("yLabel") {
                    self.yLabel = dict["yLabel"] as! String
                }
            }
        }
        public class DeviceVariables : Tea.TeaModel {
            public class OutputThreshold : Tea.TeaModel {
                public var maxValue: Double?

                public var minValue: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxValue != nil {
                        map["maxValue"] = self.maxValue!
                    }
                    if self.minValue != nil {
                        map["minValue"] = self.minValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxValue") {
                        self.maxValue = dict["maxValue"] as! Double
                    }
                    if dict.keys.contains("minValue") {
                        self.minValue = dict["minValue"] as! Double
                    }
                }
            }
            public class VariableVelocity : Tea.TeaModel {
                public var iv: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.iv != nil {
                        map["iv"] = self.iv!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("iv") {
                        self.iv = dict["iv"] as! String
                    }
                }
            }
            public var code: String?

            public var dataDisplay: String?

            public var defineId: String?

            public var description_: String?

            public var displayType: String?

            public var expressionTitle: String?

            public var favoriteFlag: Bool?

            public var fieldDetail: String?

            public var fieldRank: Int32?

            public var fieldSource: String?

            public var fieldType: String?

            public var id: Int64?

            public var inputFieldType: String?

            public var inputRequired: String?

            public var inputs: String?

            public var name: String?

            public var outlier: String?

            public var outputThreshold: DescribeEventVariableListResponseBody.ResultObject.DeviceVariables.OutputThreshold?

            public var parentName: String?

            public var sourceType: String?

            public var title: String?

            public var type: String?

            public var variableVelocity: DescribeEventVariableListResponseBody.ResultObject.DeviceVariables.VariableVelocity?

            public var xLabel: String?

            public var yLabel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputThreshold?.validate()
                try self.variableVelocity?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.dataDisplay != nil {
                    map["dataDisplay"] = self.dataDisplay!
                }
                if self.defineId != nil {
                    map["defineId"] = self.defineId!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.displayType != nil {
                    map["displayType"] = self.displayType!
                }
                if self.expressionTitle != nil {
                    map["expressionTitle"] = self.expressionTitle!
                }
                if self.favoriteFlag != nil {
                    map["favoriteFlag"] = self.favoriteFlag!
                }
                if self.fieldDetail != nil {
                    map["fieldDetail"] = self.fieldDetail!
                }
                if self.fieldRank != nil {
                    map["fieldRank"] = self.fieldRank!
                }
                if self.fieldSource != nil {
                    map["fieldSource"] = self.fieldSource!
                }
                if self.fieldType != nil {
                    map["fieldType"] = self.fieldType!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.inputFieldType != nil {
                    map["inputFieldType"] = self.inputFieldType!
                }
                if self.inputRequired != nil {
                    map["inputRequired"] = self.inputRequired!
                }
                if self.inputs != nil {
                    map["inputs"] = self.inputs!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.outlier != nil {
                    map["outlier"] = self.outlier!
                }
                if self.outputThreshold != nil {
                    map["outputThreshold"] = self.outputThreshold?.toMap()
                }
                if self.parentName != nil {
                    map["parentName"] = self.parentName!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.variableVelocity != nil {
                    map["variableVelocity"] = self.variableVelocity?.toMap()
                }
                if self.xLabel != nil {
                    map["xLabel"] = self.xLabel!
                }
                if self.yLabel != nil {
                    map["yLabel"] = self.yLabel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("dataDisplay") {
                    self.dataDisplay = dict["dataDisplay"] as! String
                }
                if dict.keys.contains("defineId") {
                    self.defineId = dict["defineId"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("displayType") {
                    self.displayType = dict["displayType"] as! String
                }
                if dict.keys.contains("expressionTitle") {
                    self.expressionTitle = dict["expressionTitle"] as! String
                }
                if dict.keys.contains("favoriteFlag") {
                    self.favoriteFlag = dict["favoriteFlag"] as! Bool
                }
                if dict.keys.contains("fieldDetail") {
                    self.fieldDetail = dict["fieldDetail"] as! String
                }
                if dict.keys.contains("fieldRank") {
                    self.fieldRank = dict["fieldRank"] as! Int32
                }
                if dict.keys.contains("fieldSource") {
                    self.fieldSource = dict["fieldSource"] as! String
                }
                if dict.keys.contains("fieldType") {
                    self.fieldType = dict["fieldType"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("inputFieldType") {
                    self.inputFieldType = dict["inputFieldType"] as! String
                }
                if dict.keys.contains("inputRequired") {
                    self.inputRequired = dict["inputRequired"] as! String
                }
                if dict.keys.contains("inputs") {
                    self.inputs = dict["inputs"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("outlier") {
                    self.outlier = dict["outlier"] as! String
                }
                if dict.keys.contains("outputThreshold") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.DeviceVariables.OutputThreshold()
                    model.fromMap(dict["outputThreshold"] as! [String: Any])
                    self.outputThreshold = model
                }
                if dict.keys.contains("parentName") {
                    self.parentName = dict["parentName"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("variableVelocity") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.DeviceVariables.VariableVelocity()
                    model.fromMap(dict["variableVelocity"] as! [String: Any])
                    self.variableVelocity = model
                }
                if dict.keys.contains("xLabel") {
                    self.xLabel = dict["xLabel"] as! String
                }
                if dict.keys.contains("yLabel") {
                    self.yLabel = dict["yLabel"] as! String
                }
            }
        }
        public class ExpressionVariables : Tea.TeaModel {
            public class OutputThreshold : Tea.TeaModel {
                public var maxValue: Double?

                public var minValue: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxValue != nil {
                        map["maxValue"] = self.maxValue!
                    }
                    if self.minValue != nil {
                        map["minValue"] = self.minValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxValue") {
                        self.maxValue = dict["maxValue"] as! Double
                    }
                    if dict.keys.contains("minValue") {
                        self.minValue = dict["minValue"] as! Double
                    }
                }
            }
            public class VariableVelocity : Tea.TeaModel {
                public var iv: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.iv != nil {
                        map["iv"] = self.iv!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("iv") {
                        self.iv = dict["iv"] as! String
                    }
                }
            }
            public var code: String?

            public var dataDisplay: String?

            public var defineId: String?

            public var description_: String?

            public var displayType: String?

            public var expressionTitle: String?

            public var favoriteFlag: Bool?

            public var fieldDetail: String?

            public var fieldRank: Int32?

            public var fieldSource: String?

            public var fieldType: String?

            public var id: Int64?

            public var inputFieldType: String?

            public var inputRequired: String?

            public var inputs: String?

            public var name: String?

            public var outlier: String?

            public var outputThreshold: DescribeEventVariableListResponseBody.ResultObject.ExpressionVariables.OutputThreshold?

            public var parentName: String?

            public var sourceType: String?

            public var title: String?

            public var type: String?

            public var variableVelocity: DescribeEventVariableListResponseBody.ResultObject.ExpressionVariables.VariableVelocity?

            public var xLabel: String?

            public var yLabel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputThreshold?.validate()
                try self.variableVelocity?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.dataDisplay != nil {
                    map["dataDisplay"] = self.dataDisplay!
                }
                if self.defineId != nil {
                    map["defineId"] = self.defineId!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.displayType != nil {
                    map["displayType"] = self.displayType!
                }
                if self.expressionTitle != nil {
                    map["expressionTitle"] = self.expressionTitle!
                }
                if self.favoriteFlag != nil {
                    map["favoriteFlag"] = self.favoriteFlag!
                }
                if self.fieldDetail != nil {
                    map["fieldDetail"] = self.fieldDetail!
                }
                if self.fieldRank != nil {
                    map["fieldRank"] = self.fieldRank!
                }
                if self.fieldSource != nil {
                    map["fieldSource"] = self.fieldSource!
                }
                if self.fieldType != nil {
                    map["fieldType"] = self.fieldType!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.inputFieldType != nil {
                    map["inputFieldType"] = self.inputFieldType!
                }
                if self.inputRequired != nil {
                    map["inputRequired"] = self.inputRequired!
                }
                if self.inputs != nil {
                    map["inputs"] = self.inputs!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.outlier != nil {
                    map["outlier"] = self.outlier!
                }
                if self.outputThreshold != nil {
                    map["outputThreshold"] = self.outputThreshold?.toMap()
                }
                if self.parentName != nil {
                    map["parentName"] = self.parentName!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.variableVelocity != nil {
                    map["variableVelocity"] = self.variableVelocity?.toMap()
                }
                if self.xLabel != nil {
                    map["xLabel"] = self.xLabel!
                }
                if self.yLabel != nil {
                    map["yLabel"] = self.yLabel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("dataDisplay") {
                    self.dataDisplay = dict["dataDisplay"] as! String
                }
                if dict.keys.contains("defineId") {
                    self.defineId = dict["defineId"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("displayType") {
                    self.displayType = dict["displayType"] as! String
                }
                if dict.keys.contains("expressionTitle") {
                    self.expressionTitle = dict["expressionTitle"] as! String
                }
                if dict.keys.contains("favoriteFlag") {
                    self.favoriteFlag = dict["favoriteFlag"] as! Bool
                }
                if dict.keys.contains("fieldDetail") {
                    self.fieldDetail = dict["fieldDetail"] as! String
                }
                if dict.keys.contains("fieldRank") {
                    self.fieldRank = dict["fieldRank"] as! Int32
                }
                if dict.keys.contains("fieldSource") {
                    self.fieldSource = dict["fieldSource"] as! String
                }
                if dict.keys.contains("fieldType") {
                    self.fieldType = dict["fieldType"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("inputFieldType") {
                    self.inputFieldType = dict["inputFieldType"] as! String
                }
                if dict.keys.contains("inputRequired") {
                    self.inputRequired = dict["inputRequired"] as! String
                }
                if dict.keys.contains("inputs") {
                    self.inputs = dict["inputs"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("outlier") {
                    self.outlier = dict["outlier"] as! String
                }
                if dict.keys.contains("outputThreshold") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.ExpressionVariables.OutputThreshold()
                    model.fromMap(dict["outputThreshold"] as! [String: Any])
                    self.outputThreshold = model
                }
                if dict.keys.contains("parentName") {
                    self.parentName = dict["parentName"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("variableVelocity") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.ExpressionVariables.VariableVelocity()
                    model.fromMap(dict["variableVelocity"] as! [String: Any])
                    self.variableVelocity = model
                }
                if dict.keys.contains("xLabel") {
                    self.xLabel = dict["xLabel"] as! String
                }
                if dict.keys.contains("yLabel") {
                    self.yLabel = dict["yLabel"] as! String
                }
            }
        }
        public class FavoriteVariables : Tea.TeaModel {
            public class OutputThreshold : Tea.TeaModel {
                public var maxValue: Double?

                public var minValue: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxValue != nil {
                        map["maxValue"] = self.maxValue!
                    }
                    if self.minValue != nil {
                        map["minValue"] = self.minValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxValue") {
                        self.maxValue = dict["maxValue"] as! Double
                    }
                    if dict.keys.contains("minValue") {
                        self.minValue = dict["minValue"] as! Double
                    }
                }
            }
            public class VariableVelocity : Tea.TeaModel {
                public var iv: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.iv != nil {
                        map["iv"] = self.iv!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("iv") {
                        self.iv = dict["iv"] as! String
                    }
                }
            }
            public var code: String?

            public var dataDisplay: String?

            public var defineId: String?

            public var description_: String?

            public var displayType: String?

            public var expressionTitle: String?

            public var favoriteFlag: Bool?

            public var fieldDetail: String?

            public var fieldRank: Int32?

            public var fieldSource: String?

            public var fieldType: String?

            public var id: Int64?

            public var inputFieldType: String?

            public var inputRequired: String?

            public var inputs: String?

            public var name: String?

            public var outlier: String?

            public var outputThreshold: DescribeEventVariableListResponseBody.ResultObject.FavoriteVariables.OutputThreshold?

            public var parentName: String?

            public var sourceType: String?

            public var title: String?

            public var type: String?

            public var variableVelocity: DescribeEventVariableListResponseBody.ResultObject.FavoriteVariables.VariableVelocity?

            public var xLabel: String?

            public var yLabel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputThreshold?.validate()
                try self.variableVelocity?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.dataDisplay != nil {
                    map["dataDisplay"] = self.dataDisplay!
                }
                if self.defineId != nil {
                    map["defineId"] = self.defineId!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.displayType != nil {
                    map["displayType"] = self.displayType!
                }
                if self.expressionTitle != nil {
                    map["expressionTitle"] = self.expressionTitle!
                }
                if self.favoriteFlag != nil {
                    map["favoriteFlag"] = self.favoriteFlag!
                }
                if self.fieldDetail != nil {
                    map["fieldDetail"] = self.fieldDetail!
                }
                if self.fieldRank != nil {
                    map["fieldRank"] = self.fieldRank!
                }
                if self.fieldSource != nil {
                    map["fieldSource"] = self.fieldSource!
                }
                if self.fieldType != nil {
                    map["fieldType"] = self.fieldType!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.inputFieldType != nil {
                    map["inputFieldType"] = self.inputFieldType!
                }
                if self.inputRequired != nil {
                    map["inputRequired"] = self.inputRequired!
                }
                if self.inputs != nil {
                    map["inputs"] = self.inputs!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.outlier != nil {
                    map["outlier"] = self.outlier!
                }
                if self.outputThreshold != nil {
                    map["outputThreshold"] = self.outputThreshold?.toMap()
                }
                if self.parentName != nil {
                    map["parentName"] = self.parentName!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.variableVelocity != nil {
                    map["variableVelocity"] = self.variableVelocity?.toMap()
                }
                if self.xLabel != nil {
                    map["xLabel"] = self.xLabel!
                }
                if self.yLabel != nil {
                    map["yLabel"] = self.yLabel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("dataDisplay") {
                    self.dataDisplay = dict["dataDisplay"] as! String
                }
                if dict.keys.contains("defineId") {
                    self.defineId = dict["defineId"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("displayType") {
                    self.displayType = dict["displayType"] as! String
                }
                if dict.keys.contains("expressionTitle") {
                    self.expressionTitle = dict["expressionTitle"] as! String
                }
                if dict.keys.contains("favoriteFlag") {
                    self.favoriteFlag = dict["favoriteFlag"] as! Bool
                }
                if dict.keys.contains("fieldDetail") {
                    self.fieldDetail = dict["fieldDetail"] as! String
                }
                if dict.keys.contains("fieldRank") {
                    self.fieldRank = dict["fieldRank"] as! Int32
                }
                if dict.keys.contains("fieldSource") {
                    self.fieldSource = dict["fieldSource"] as! String
                }
                if dict.keys.contains("fieldType") {
                    self.fieldType = dict["fieldType"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("inputFieldType") {
                    self.inputFieldType = dict["inputFieldType"] as! String
                }
                if dict.keys.contains("inputRequired") {
                    self.inputRequired = dict["inputRequired"] as! String
                }
                if dict.keys.contains("inputs") {
                    self.inputs = dict["inputs"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("outlier") {
                    self.outlier = dict["outlier"] as! String
                }
                if dict.keys.contains("outputThreshold") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.FavoriteVariables.OutputThreshold()
                    model.fromMap(dict["outputThreshold"] as! [String: Any])
                    self.outputThreshold = model
                }
                if dict.keys.contains("parentName") {
                    self.parentName = dict["parentName"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("variableVelocity") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.FavoriteVariables.VariableVelocity()
                    model.fromMap(dict["variableVelocity"] as! [String: Any])
                    self.variableVelocity = model
                }
                if dict.keys.contains("xLabel") {
                    self.xLabel = dict["xLabel"] as! String
                }
                if dict.keys.contains("yLabel") {
                    self.yLabel = dict["yLabel"] as! String
                }
            }
        }
        public class MiddleVariables : Tea.TeaModel {
            public class OutputThreshold : Tea.TeaModel {
                public var maxValue: Double?

                public var minValue: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxValue != nil {
                        map["maxValue"] = self.maxValue!
                    }
                    if self.minValue != nil {
                        map["minValue"] = self.minValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxValue") {
                        self.maxValue = dict["maxValue"] as! Double
                    }
                    if dict.keys.contains("minValue") {
                        self.minValue = dict["minValue"] as! Double
                    }
                }
            }
            public class VariableVelocity : Tea.TeaModel {
                public var iv: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.iv != nil {
                        map["iv"] = self.iv!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("iv") {
                        self.iv = dict["iv"] as! String
                    }
                }
            }
            public var code: String?

            public var dataDisplay: String?

            public var defineId: String?

            public var description_: String?

            public var displayType: String?

            public var expressionTitle: String?

            public var favoriteFlag: Bool?

            public var fieldDetail: String?

            public var fieldRank: Int32?

            public var fieldSource: String?

            public var fieldType: String?

            public var id: Int64?

            public var inputFieldType: String?

            public var inputRequired: String?

            public var inputs: String?

            public var name: String?

            public var outlier: String?

            public var outputThreshold: DescribeEventVariableListResponseBody.ResultObject.MiddleVariables.OutputThreshold?

            public var parentName: String?

            public var sourceType: String?

            public var title: String?

            public var type: String?

            public var variableVelocity: DescribeEventVariableListResponseBody.ResultObject.MiddleVariables.VariableVelocity?

            public var xLabel: String?

            public var yLabel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputThreshold?.validate()
                try self.variableVelocity?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.dataDisplay != nil {
                    map["dataDisplay"] = self.dataDisplay!
                }
                if self.defineId != nil {
                    map["defineId"] = self.defineId!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.displayType != nil {
                    map["displayType"] = self.displayType!
                }
                if self.expressionTitle != nil {
                    map["expressionTitle"] = self.expressionTitle!
                }
                if self.favoriteFlag != nil {
                    map["favoriteFlag"] = self.favoriteFlag!
                }
                if self.fieldDetail != nil {
                    map["fieldDetail"] = self.fieldDetail!
                }
                if self.fieldRank != nil {
                    map["fieldRank"] = self.fieldRank!
                }
                if self.fieldSource != nil {
                    map["fieldSource"] = self.fieldSource!
                }
                if self.fieldType != nil {
                    map["fieldType"] = self.fieldType!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.inputFieldType != nil {
                    map["inputFieldType"] = self.inputFieldType!
                }
                if self.inputRequired != nil {
                    map["inputRequired"] = self.inputRequired!
                }
                if self.inputs != nil {
                    map["inputs"] = self.inputs!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.outlier != nil {
                    map["outlier"] = self.outlier!
                }
                if self.outputThreshold != nil {
                    map["outputThreshold"] = self.outputThreshold?.toMap()
                }
                if self.parentName != nil {
                    map["parentName"] = self.parentName!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.variableVelocity != nil {
                    map["variableVelocity"] = self.variableVelocity?.toMap()
                }
                if self.xLabel != nil {
                    map["xLabel"] = self.xLabel!
                }
                if self.yLabel != nil {
                    map["yLabel"] = self.yLabel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("dataDisplay") {
                    self.dataDisplay = dict["dataDisplay"] as! String
                }
                if dict.keys.contains("defineId") {
                    self.defineId = dict["defineId"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("displayType") {
                    self.displayType = dict["displayType"] as! String
                }
                if dict.keys.contains("expressionTitle") {
                    self.expressionTitle = dict["expressionTitle"] as! String
                }
                if dict.keys.contains("favoriteFlag") {
                    self.favoriteFlag = dict["favoriteFlag"] as! Bool
                }
                if dict.keys.contains("fieldDetail") {
                    self.fieldDetail = dict["fieldDetail"] as! String
                }
                if dict.keys.contains("fieldRank") {
                    self.fieldRank = dict["fieldRank"] as! Int32
                }
                if dict.keys.contains("fieldSource") {
                    self.fieldSource = dict["fieldSource"] as! String
                }
                if dict.keys.contains("fieldType") {
                    self.fieldType = dict["fieldType"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("inputFieldType") {
                    self.inputFieldType = dict["inputFieldType"] as! String
                }
                if dict.keys.contains("inputRequired") {
                    self.inputRequired = dict["inputRequired"] as! String
                }
                if dict.keys.contains("inputs") {
                    self.inputs = dict["inputs"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("outlier") {
                    self.outlier = dict["outlier"] as! String
                }
                if dict.keys.contains("outputThreshold") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.MiddleVariables.OutputThreshold()
                    model.fromMap(dict["outputThreshold"] as! [String: Any])
                    self.outputThreshold = model
                }
                if dict.keys.contains("parentName") {
                    self.parentName = dict["parentName"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("variableVelocity") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.MiddleVariables.VariableVelocity()
                    model.fromMap(dict["variableVelocity"] as! [String: Any])
                    self.variableVelocity = model
                }
                if dict.keys.contains("xLabel") {
                    self.xLabel = dict["xLabel"] as! String
                }
                if dict.keys.contains("yLabel") {
                    self.yLabel = dict["yLabel"] as! String
                }
            }
        }
        public class ModelVariables : Tea.TeaModel {
            public class OutputThreshold : Tea.TeaModel {
                public var maxValue: Double?

                public var minValue: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxValue != nil {
                        map["maxValue"] = self.maxValue!
                    }
                    if self.minValue != nil {
                        map["minValue"] = self.minValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxValue") {
                        self.maxValue = dict["maxValue"] as! Double
                    }
                    if dict.keys.contains("minValue") {
                        self.minValue = dict["minValue"] as! Double
                    }
                }
            }
            public class VariableVelocity : Tea.TeaModel {
                public var iv: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.iv != nil {
                        map["iv"] = self.iv!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("iv") {
                        self.iv = dict["iv"] as! String
                    }
                }
            }
            public var code: String?

            public var dataDisplay: String?

            public var defineId: String?

            public var description_: String?

            public var displayType: String?

            public var expressionTitle: String?

            public var favoriteFlag: Bool?

            public var fieldDetail: String?

            public var fieldRank: Int32?

            public var fieldSource: String?

            public var fieldType: String?

            public var id: Int64?

            public var inputFieldType: String?

            public var inputRequired: String?

            public var inputs: String?

            public var name: String?

            public var outlier: String?

            public var outputThreshold: DescribeEventVariableListResponseBody.ResultObject.ModelVariables.OutputThreshold?

            public var parentName: String?

            public var sourceType: String?

            public var title: String?

            public var type: String?

            public var variableVelocity: DescribeEventVariableListResponseBody.ResultObject.ModelVariables.VariableVelocity?

            public var xLabel: String?

            public var yLabel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputThreshold?.validate()
                try self.variableVelocity?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.dataDisplay != nil {
                    map["dataDisplay"] = self.dataDisplay!
                }
                if self.defineId != nil {
                    map["defineId"] = self.defineId!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.displayType != nil {
                    map["displayType"] = self.displayType!
                }
                if self.expressionTitle != nil {
                    map["expressionTitle"] = self.expressionTitle!
                }
                if self.favoriteFlag != nil {
                    map["favoriteFlag"] = self.favoriteFlag!
                }
                if self.fieldDetail != nil {
                    map["fieldDetail"] = self.fieldDetail!
                }
                if self.fieldRank != nil {
                    map["fieldRank"] = self.fieldRank!
                }
                if self.fieldSource != nil {
                    map["fieldSource"] = self.fieldSource!
                }
                if self.fieldType != nil {
                    map["fieldType"] = self.fieldType!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.inputFieldType != nil {
                    map["inputFieldType"] = self.inputFieldType!
                }
                if self.inputRequired != nil {
                    map["inputRequired"] = self.inputRequired!
                }
                if self.inputs != nil {
                    map["inputs"] = self.inputs!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.outlier != nil {
                    map["outlier"] = self.outlier!
                }
                if self.outputThreshold != nil {
                    map["outputThreshold"] = self.outputThreshold?.toMap()
                }
                if self.parentName != nil {
                    map["parentName"] = self.parentName!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.variableVelocity != nil {
                    map["variableVelocity"] = self.variableVelocity?.toMap()
                }
                if self.xLabel != nil {
                    map["xLabel"] = self.xLabel!
                }
                if self.yLabel != nil {
                    map["yLabel"] = self.yLabel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("dataDisplay") {
                    self.dataDisplay = dict["dataDisplay"] as! String
                }
                if dict.keys.contains("defineId") {
                    self.defineId = dict["defineId"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("displayType") {
                    self.displayType = dict["displayType"] as! String
                }
                if dict.keys.contains("expressionTitle") {
                    self.expressionTitle = dict["expressionTitle"] as! String
                }
                if dict.keys.contains("favoriteFlag") {
                    self.favoriteFlag = dict["favoriteFlag"] as! Bool
                }
                if dict.keys.contains("fieldDetail") {
                    self.fieldDetail = dict["fieldDetail"] as! String
                }
                if dict.keys.contains("fieldRank") {
                    self.fieldRank = dict["fieldRank"] as! Int32
                }
                if dict.keys.contains("fieldSource") {
                    self.fieldSource = dict["fieldSource"] as! String
                }
                if dict.keys.contains("fieldType") {
                    self.fieldType = dict["fieldType"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("inputFieldType") {
                    self.inputFieldType = dict["inputFieldType"] as! String
                }
                if dict.keys.contains("inputRequired") {
                    self.inputRequired = dict["inputRequired"] as! String
                }
                if dict.keys.contains("inputs") {
                    self.inputs = dict["inputs"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("outlier") {
                    self.outlier = dict["outlier"] as! String
                }
                if dict.keys.contains("outputThreshold") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.ModelVariables.OutputThreshold()
                    model.fromMap(dict["outputThreshold"] as! [String: Any])
                    self.outputThreshold = model
                }
                if dict.keys.contains("parentName") {
                    self.parentName = dict["parentName"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("variableVelocity") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.ModelVariables.VariableVelocity()
                    model.fromMap(dict["variableVelocity"] as! [String: Any])
                    self.variableVelocity = model
                }
                if dict.keys.contains("xLabel") {
                    self.xLabel = dict["xLabel"] as! String
                }
                if dict.keys.contains("yLabel") {
                    self.yLabel = dict["yLabel"] as! String
                }
            }
        }
        public class NameList : Tea.TeaModel {
            public class OutputThreshold : Tea.TeaModel {
                public var maxValue: Double?

                public var minValue: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxValue != nil {
                        map["maxValue"] = self.maxValue!
                    }
                    if self.minValue != nil {
                        map["minValue"] = self.minValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxValue") {
                        self.maxValue = dict["maxValue"] as! Double
                    }
                    if dict.keys.contains("minValue") {
                        self.minValue = dict["minValue"] as! Double
                    }
                }
            }
            public class VariableVelocity : Tea.TeaModel {
                public var iv: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.iv != nil {
                        map["iv"] = self.iv!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("iv") {
                        self.iv = dict["iv"] as! String
                    }
                }
            }
            public var code: String?

            public var dataDisplay: String?

            public var defineId: String?

            public var description_: String?

            public var displayType: String?

            public var expressionTitle: String?

            public var favoriteFlag: Bool?

            public var fieldDetail: String?

            public var fieldRank: Int32?

            public var fieldSource: String?

            public var fieldType: String?

            public var id: Int64?

            public var inputFieldType: String?

            public var inputRequired: String?

            public var inputs: String?

            public var name: String?

            public var outlier: String?

            public var outputThreshold: DescribeEventVariableListResponseBody.ResultObject.NameList.OutputThreshold?

            public var parentName: String?

            public var sourceType: String?

            public var title: String?

            public var type: String?

            public var variableVelocity: DescribeEventVariableListResponseBody.ResultObject.NameList.VariableVelocity?

            public var xLabel: String?

            public var yLabel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputThreshold?.validate()
                try self.variableVelocity?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.dataDisplay != nil {
                    map["dataDisplay"] = self.dataDisplay!
                }
                if self.defineId != nil {
                    map["defineId"] = self.defineId!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.displayType != nil {
                    map["displayType"] = self.displayType!
                }
                if self.expressionTitle != nil {
                    map["expressionTitle"] = self.expressionTitle!
                }
                if self.favoriteFlag != nil {
                    map["favoriteFlag"] = self.favoriteFlag!
                }
                if self.fieldDetail != nil {
                    map["fieldDetail"] = self.fieldDetail!
                }
                if self.fieldRank != nil {
                    map["fieldRank"] = self.fieldRank!
                }
                if self.fieldSource != nil {
                    map["fieldSource"] = self.fieldSource!
                }
                if self.fieldType != nil {
                    map["fieldType"] = self.fieldType!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.inputFieldType != nil {
                    map["inputFieldType"] = self.inputFieldType!
                }
                if self.inputRequired != nil {
                    map["inputRequired"] = self.inputRequired!
                }
                if self.inputs != nil {
                    map["inputs"] = self.inputs!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.outlier != nil {
                    map["outlier"] = self.outlier!
                }
                if self.outputThreshold != nil {
                    map["outputThreshold"] = self.outputThreshold?.toMap()
                }
                if self.parentName != nil {
                    map["parentName"] = self.parentName!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.variableVelocity != nil {
                    map["variableVelocity"] = self.variableVelocity?.toMap()
                }
                if self.xLabel != nil {
                    map["xLabel"] = self.xLabel!
                }
                if self.yLabel != nil {
                    map["yLabel"] = self.yLabel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("dataDisplay") {
                    self.dataDisplay = dict["dataDisplay"] as! String
                }
                if dict.keys.contains("defineId") {
                    self.defineId = dict["defineId"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("displayType") {
                    self.displayType = dict["displayType"] as! String
                }
                if dict.keys.contains("expressionTitle") {
                    self.expressionTitle = dict["expressionTitle"] as! String
                }
                if dict.keys.contains("favoriteFlag") {
                    self.favoriteFlag = dict["favoriteFlag"] as! Bool
                }
                if dict.keys.contains("fieldDetail") {
                    self.fieldDetail = dict["fieldDetail"] as! String
                }
                if dict.keys.contains("fieldRank") {
                    self.fieldRank = dict["fieldRank"] as! Int32
                }
                if dict.keys.contains("fieldSource") {
                    self.fieldSource = dict["fieldSource"] as! String
                }
                if dict.keys.contains("fieldType") {
                    self.fieldType = dict["fieldType"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("inputFieldType") {
                    self.inputFieldType = dict["inputFieldType"] as! String
                }
                if dict.keys.contains("inputRequired") {
                    self.inputRequired = dict["inputRequired"] as! String
                }
                if dict.keys.contains("inputs") {
                    self.inputs = dict["inputs"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("outlier") {
                    self.outlier = dict["outlier"] as! String
                }
                if dict.keys.contains("outputThreshold") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.NameList.OutputThreshold()
                    model.fromMap(dict["outputThreshold"] as! [String: Any])
                    self.outputThreshold = model
                }
                if dict.keys.contains("parentName") {
                    self.parentName = dict["parentName"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("variableVelocity") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.NameList.VariableVelocity()
                    model.fromMap(dict["variableVelocity"] as! [String: Any])
                    self.variableVelocity = model
                }
                if dict.keys.contains("xLabel") {
                    self.xLabel = dict["xLabel"] as! String
                }
                if dict.keys.contains("yLabel") {
                    self.yLabel = dict["yLabel"] as! String
                }
            }
        }
        public class NativeVariableFunctions : Tea.TeaModel {
            public class OutputThreshold : Tea.TeaModel {
                public var maxValue: Double?

                public var minValue: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxValue != nil {
                        map["maxValue"] = self.maxValue!
                    }
                    if self.minValue != nil {
                        map["minValue"] = self.minValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxValue") {
                        self.maxValue = dict["maxValue"] as! Double
                    }
                    if dict.keys.contains("minValue") {
                        self.minValue = dict["minValue"] as! Double
                    }
                }
            }
            public class VariableVelocity : Tea.TeaModel {
                public var iv: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.iv != nil {
                        map["iv"] = self.iv!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("iv") {
                        self.iv = dict["iv"] as! String
                    }
                }
            }
            public var code: String?

            public var dataDisplay: String?

            public var defineId: String?

            public var description_: String?

            public var displayType: String?

            public var expressionTitle: String?

            public var favoriteFlag: Bool?

            public var fieldDetail: String?

            public var fieldRank: Int32?

            public var fieldSource: String?

            public var fieldType: String?

            public var id: Int64?

            public var inputFieldType: String?

            public var inputRequired: String?

            public var inputs: String?

            public var name: String?

            public var outlier: String?

            public var outputThreshold: DescribeEventVariableListResponseBody.ResultObject.NativeVariableFunctions.OutputThreshold?

            public var parentName: String?

            public var sourceType: String?

            public var title: String?

            public var type: String?

            public var variableVelocity: DescribeEventVariableListResponseBody.ResultObject.NativeVariableFunctions.VariableVelocity?

            public var xLabel: String?

            public var yLabel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputThreshold?.validate()
                try self.variableVelocity?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.dataDisplay != nil {
                    map["dataDisplay"] = self.dataDisplay!
                }
                if self.defineId != nil {
                    map["defineId"] = self.defineId!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.displayType != nil {
                    map["displayType"] = self.displayType!
                }
                if self.expressionTitle != nil {
                    map["expressionTitle"] = self.expressionTitle!
                }
                if self.favoriteFlag != nil {
                    map["favoriteFlag"] = self.favoriteFlag!
                }
                if self.fieldDetail != nil {
                    map["fieldDetail"] = self.fieldDetail!
                }
                if self.fieldRank != nil {
                    map["fieldRank"] = self.fieldRank!
                }
                if self.fieldSource != nil {
                    map["fieldSource"] = self.fieldSource!
                }
                if self.fieldType != nil {
                    map["fieldType"] = self.fieldType!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.inputFieldType != nil {
                    map["inputFieldType"] = self.inputFieldType!
                }
                if self.inputRequired != nil {
                    map["inputRequired"] = self.inputRequired!
                }
                if self.inputs != nil {
                    map["inputs"] = self.inputs!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.outlier != nil {
                    map["outlier"] = self.outlier!
                }
                if self.outputThreshold != nil {
                    map["outputThreshold"] = self.outputThreshold?.toMap()
                }
                if self.parentName != nil {
                    map["parentName"] = self.parentName!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.variableVelocity != nil {
                    map["variableVelocity"] = self.variableVelocity?.toMap()
                }
                if self.xLabel != nil {
                    map["xLabel"] = self.xLabel!
                }
                if self.yLabel != nil {
                    map["yLabel"] = self.yLabel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("dataDisplay") {
                    self.dataDisplay = dict["dataDisplay"] as! String
                }
                if dict.keys.contains("defineId") {
                    self.defineId = dict["defineId"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("displayType") {
                    self.displayType = dict["displayType"] as! String
                }
                if dict.keys.contains("expressionTitle") {
                    self.expressionTitle = dict["expressionTitle"] as! String
                }
                if dict.keys.contains("favoriteFlag") {
                    self.favoriteFlag = dict["favoriteFlag"] as! Bool
                }
                if dict.keys.contains("fieldDetail") {
                    self.fieldDetail = dict["fieldDetail"] as! String
                }
                if dict.keys.contains("fieldRank") {
                    self.fieldRank = dict["fieldRank"] as! Int32
                }
                if dict.keys.contains("fieldSource") {
                    self.fieldSource = dict["fieldSource"] as! String
                }
                if dict.keys.contains("fieldType") {
                    self.fieldType = dict["fieldType"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("inputFieldType") {
                    self.inputFieldType = dict["inputFieldType"] as! String
                }
                if dict.keys.contains("inputRequired") {
                    self.inputRequired = dict["inputRequired"] as! String
                }
                if dict.keys.contains("inputs") {
                    self.inputs = dict["inputs"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("outlier") {
                    self.outlier = dict["outlier"] as! String
                }
                if dict.keys.contains("outputThreshold") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.NativeVariableFunctions.OutputThreshold()
                    model.fromMap(dict["outputThreshold"] as! [String: Any])
                    self.outputThreshold = model
                }
                if dict.keys.contains("parentName") {
                    self.parentName = dict["parentName"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("variableVelocity") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.NativeVariableFunctions.VariableVelocity()
                    model.fromMap(dict["variableVelocity"] as! [String: Any])
                    self.variableVelocity = model
                }
                if dict.keys.contains("xLabel") {
                    self.xLabel = dict["xLabel"] as! String
                }
                if dict.keys.contains("yLabel") {
                    self.yLabel = dict["yLabel"] as! String
                }
            }
        }
        public class NativeVariables : Tea.TeaModel {
            public class OutputThreshold : Tea.TeaModel {
                public var maxValue: Double?

                public var minValue: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxValue != nil {
                        map["maxValue"] = self.maxValue!
                    }
                    if self.minValue != nil {
                        map["minValue"] = self.minValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxValue") {
                        self.maxValue = dict["maxValue"] as! Double
                    }
                    if dict.keys.contains("minValue") {
                        self.minValue = dict["minValue"] as! Double
                    }
                }
            }
            public class VariableVelocity : Tea.TeaModel {
                public var iv: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.iv != nil {
                        map["iv"] = self.iv!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("iv") {
                        self.iv = dict["iv"] as! String
                    }
                }
            }
            public var code: String?

            public var dataDisplay: String?

            public var defineId: String?

            public var description_: String?

            public var displayType: String?

            public var expressionTitle: String?

            public var favoriteFlag: Bool?

            public var fieldDetail: String?

            public var fieldRank: Int32?

            public var fieldSource: String?

            public var fieldType: String?

            public var id: Int64?

            public var inputFieldType: String?

            public var inputRequired: String?

            public var inputs: String?

            public var name: String?

            public var outlier: String?

            public var outputThreshold: DescribeEventVariableListResponseBody.ResultObject.NativeVariables.OutputThreshold?

            public var parentName: String?

            public var sourceType: String?

            public var title: String?

            public var type: String?

            public var variableVelocity: DescribeEventVariableListResponseBody.ResultObject.NativeVariables.VariableVelocity?

            public var xLabel: String?

            public var yLabel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputThreshold?.validate()
                try self.variableVelocity?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.dataDisplay != nil {
                    map["dataDisplay"] = self.dataDisplay!
                }
                if self.defineId != nil {
                    map["defineId"] = self.defineId!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.displayType != nil {
                    map["displayType"] = self.displayType!
                }
                if self.expressionTitle != nil {
                    map["expressionTitle"] = self.expressionTitle!
                }
                if self.favoriteFlag != nil {
                    map["favoriteFlag"] = self.favoriteFlag!
                }
                if self.fieldDetail != nil {
                    map["fieldDetail"] = self.fieldDetail!
                }
                if self.fieldRank != nil {
                    map["fieldRank"] = self.fieldRank!
                }
                if self.fieldSource != nil {
                    map["fieldSource"] = self.fieldSource!
                }
                if self.fieldType != nil {
                    map["fieldType"] = self.fieldType!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.inputFieldType != nil {
                    map["inputFieldType"] = self.inputFieldType!
                }
                if self.inputRequired != nil {
                    map["inputRequired"] = self.inputRequired!
                }
                if self.inputs != nil {
                    map["inputs"] = self.inputs!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.outlier != nil {
                    map["outlier"] = self.outlier!
                }
                if self.outputThreshold != nil {
                    map["outputThreshold"] = self.outputThreshold?.toMap()
                }
                if self.parentName != nil {
                    map["parentName"] = self.parentName!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.variableVelocity != nil {
                    map["variableVelocity"] = self.variableVelocity?.toMap()
                }
                if self.xLabel != nil {
                    map["xLabel"] = self.xLabel!
                }
                if self.yLabel != nil {
                    map["yLabel"] = self.yLabel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("dataDisplay") {
                    self.dataDisplay = dict["dataDisplay"] as! String
                }
                if dict.keys.contains("defineId") {
                    self.defineId = dict["defineId"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("displayType") {
                    self.displayType = dict["displayType"] as! String
                }
                if dict.keys.contains("expressionTitle") {
                    self.expressionTitle = dict["expressionTitle"] as! String
                }
                if dict.keys.contains("favoriteFlag") {
                    self.favoriteFlag = dict["favoriteFlag"] as! Bool
                }
                if dict.keys.contains("fieldDetail") {
                    self.fieldDetail = dict["fieldDetail"] as! String
                }
                if dict.keys.contains("fieldRank") {
                    self.fieldRank = dict["fieldRank"] as! Int32
                }
                if dict.keys.contains("fieldSource") {
                    self.fieldSource = dict["fieldSource"] as! String
                }
                if dict.keys.contains("fieldType") {
                    self.fieldType = dict["fieldType"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("inputFieldType") {
                    self.inputFieldType = dict["inputFieldType"] as! String
                }
                if dict.keys.contains("inputRequired") {
                    self.inputRequired = dict["inputRequired"] as! String
                }
                if dict.keys.contains("inputs") {
                    self.inputs = dict["inputs"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("outlier") {
                    self.outlier = dict["outlier"] as! String
                }
                if dict.keys.contains("outputThreshold") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.NativeVariables.OutputThreshold()
                    model.fromMap(dict["outputThreshold"] as! [String: Any])
                    self.outputThreshold = model
                }
                if dict.keys.contains("parentName") {
                    self.parentName = dict["parentName"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("variableVelocity") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.NativeVariables.VariableVelocity()
                    model.fromMap(dict["variableVelocity"] as! [String: Any])
                    self.variableVelocity = model
                }
                if dict.keys.contains("xLabel") {
                    self.xLabel = dict["xLabel"] as! String
                }
                if dict.keys.contains("yLabel") {
                    self.yLabel = dict["yLabel"] as! String
                }
            }
        }
        public class QueryVariables : Tea.TeaModel {
            public class OutputThreshold : Tea.TeaModel {
                public var maxValue: Double?

                public var minValue: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxValue != nil {
                        map["maxValue"] = self.maxValue!
                    }
                    if self.minValue != nil {
                        map["minValue"] = self.minValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxValue") {
                        self.maxValue = dict["maxValue"] as! Double
                    }
                    if dict.keys.contains("minValue") {
                        self.minValue = dict["minValue"] as! Double
                    }
                }
            }
            public class VariableVelocity : Tea.TeaModel {
                public var iv: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.iv != nil {
                        map["iv"] = self.iv!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("iv") {
                        self.iv = dict["iv"] as! String
                    }
                }
            }
            public var code: String?

            public var dataDisplay: String?

            public var defineId: String?

            public var description_: String?

            public var displayType: String?

            public var expressionTitle: String?

            public var favoriteFlag: Bool?

            public var fieldDetail: String?

            public var fieldRank: Int32?

            public var fieldSource: String?

            public var fieldType: String?

            public var id: Int64?

            public var inputFieldType: String?

            public var inputRequired: String?

            public var inputs: String?

            public var name: String?

            public var outlier: String?

            public var outputThreshold: DescribeEventVariableListResponseBody.ResultObject.QueryVariables.OutputThreshold?

            public var parentName: String?

            public var sourceType: String?

            public var title: String?

            public var type: String?

            public var variableVelocity: DescribeEventVariableListResponseBody.ResultObject.QueryVariables.VariableVelocity?

            public var xLabel: String?

            public var yLabel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputThreshold?.validate()
                try self.variableVelocity?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.dataDisplay != nil {
                    map["dataDisplay"] = self.dataDisplay!
                }
                if self.defineId != nil {
                    map["defineId"] = self.defineId!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.displayType != nil {
                    map["displayType"] = self.displayType!
                }
                if self.expressionTitle != nil {
                    map["expressionTitle"] = self.expressionTitle!
                }
                if self.favoriteFlag != nil {
                    map["favoriteFlag"] = self.favoriteFlag!
                }
                if self.fieldDetail != nil {
                    map["fieldDetail"] = self.fieldDetail!
                }
                if self.fieldRank != nil {
                    map["fieldRank"] = self.fieldRank!
                }
                if self.fieldSource != nil {
                    map["fieldSource"] = self.fieldSource!
                }
                if self.fieldType != nil {
                    map["fieldType"] = self.fieldType!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.inputFieldType != nil {
                    map["inputFieldType"] = self.inputFieldType!
                }
                if self.inputRequired != nil {
                    map["inputRequired"] = self.inputRequired!
                }
                if self.inputs != nil {
                    map["inputs"] = self.inputs!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.outlier != nil {
                    map["outlier"] = self.outlier!
                }
                if self.outputThreshold != nil {
                    map["outputThreshold"] = self.outputThreshold?.toMap()
                }
                if self.parentName != nil {
                    map["parentName"] = self.parentName!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.variableVelocity != nil {
                    map["variableVelocity"] = self.variableVelocity?.toMap()
                }
                if self.xLabel != nil {
                    map["xLabel"] = self.xLabel!
                }
                if self.yLabel != nil {
                    map["yLabel"] = self.yLabel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("dataDisplay") {
                    self.dataDisplay = dict["dataDisplay"] as! String
                }
                if dict.keys.contains("defineId") {
                    self.defineId = dict["defineId"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("displayType") {
                    self.displayType = dict["displayType"] as! String
                }
                if dict.keys.contains("expressionTitle") {
                    self.expressionTitle = dict["expressionTitle"] as! String
                }
                if dict.keys.contains("favoriteFlag") {
                    self.favoriteFlag = dict["favoriteFlag"] as! Bool
                }
                if dict.keys.contains("fieldDetail") {
                    self.fieldDetail = dict["fieldDetail"] as! String
                }
                if dict.keys.contains("fieldRank") {
                    self.fieldRank = dict["fieldRank"] as! Int32
                }
                if dict.keys.contains("fieldSource") {
                    self.fieldSource = dict["fieldSource"] as! String
                }
                if dict.keys.contains("fieldType") {
                    self.fieldType = dict["fieldType"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("inputFieldType") {
                    self.inputFieldType = dict["inputFieldType"] as! String
                }
                if dict.keys.contains("inputRequired") {
                    self.inputRequired = dict["inputRequired"] as! String
                }
                if dict.keys.contains("inputs") {
                    self.inputs = dict["inputs"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("outlier") {
                    self.outlier = dict["outlier"] as! String
                }
                if dict.keys.contains("outputThreshold") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.QueryVariables.OutputThreshold()
                    model.fromMap(dict["outputThreshold"] as! [String: Any])
                    self.outputThreshold = model
                }
                if dict.keys.contains("parentName") {
                    self.parentName = dict["parentName"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("variableVelocity") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.QueryVariables.VariableVelocity()
                    model.fromMap(dict["variableVelocity"] as! [String: Any])
                    self.variableVelocity = model
                }
                if dict.keys.contains("xLabel") {
                    self.xLabel = dict["xLabel"] as! String
                }
                if dict.keys.contains("yLabel") {
                    self.yLabel = dict["yLabel"] as! String
                }
            }
        }
        public class SelfVariables : Tea.TeaModel {
            public class OutputThreshold : Tea.TeaModel {
                public var maxValue: Double?

                public var minValue: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxValue != nil {
                        map["maxValue"] = self.maxValue!
                    }
                    if self.minValue != nil {
                        map["minValue"] = self.minValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxValue") {
                        self.maxValue = dict["maxValue"] as! Double
                    }
                    if dict.keys.contains("minValue") {
                        self.minValue = dict["minValue"] as! Double
                    }
                }
            }
            public class VariableVelocity : Tea.TeaModel {
                public var iv: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.iv != nil {
                        map["iv"] = self.iv!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("iv") {
                        self.iv = dict["iv"] as! String
                    }
                }
            }
            public var code: String?

            public var dataDisplay: String?

            public var defineId: String?

            public var description_: String?

            public var displayType: String?

            public var expressionTitle: String?

            public var favoriteFlag: Bool?

            public var fieldDetail: String?

            public var fieldRank: Int32?

            public var fieldSource: String?

            public var fieldType: String?

            public var id: Int64?

            public var inputFieldType: String?

            public var inputRequired: String?

            public var inputs: String?

            public var name: String?

            public var outlier: String?

            public var outputThreshold: DescribeEventVariableListResponseBody.ResultObject.SelfVariables.OutputThreshold?

            public var parentName: String?

            public var sourceType: String?

            public var title: String?

            public var type: String?

            public var variableVelocity: DescribeEventVariableListResponseBody.ResultObject.SelfVariables.VariableVelocity?

            public var xLabel: String?

            public var yLabel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputThreshold?.validate()
                try self.variableVelocity?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.dataDisplay != nil {
                    map["dataDisplay"] = self.dataDisplay!
                }
                if self.defineId != nil {
                    map["defineId"] = self.defineId!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.displayType != nil {
                    map["displayType"] = self.displayType!
                }
                if self.expressionTitle != nil {
                    map["expressionTitle"] = self.expressionTitle!
                }
                if self.favoriteFlag != nil {
                    map["favoriteFlag"] = self.favoriteFlag!
                }
                if self.fieldDetail != nil {
                    map["fieldDetail"] = self.fieldDetail!
                }
                if self.fieldRank != nil {
                    map["fieldRank"] = self.fieldRank!
                }
                if self.fieldSource != nil {
                    map["fieldSource"] = self.fieldSource!
                }
                if self.fieldType != nil {
                    map["fieldType"] = self.fieldType!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.inputFieldType != nil {
                    map["inputFieldType"] = self.inputFieldType!
                }
                if self.inputRequired != nil {
                    map["inputRequired"] = self.inputRequired!
                }
                if self.inputs != nil {
                    map["inputs"] = self.inputs!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.outlier != nil {
                    map["outlier"] = self.outlier!
                }
                if self.outputThreshold != nil {
                    map["outputThreshold"] = self.outputThreshold?.toMap()
                }
                if self.parentName != nil {
                    map["parentName"] = self.parentName!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.variableVelocity != nil {
                    map["variableVelocity"] = self.variableVelocity?.toMap()
                }
                if self.xLabel != nil {
                    map["xLabel"] = self.xLabel!
                }
                if self.yLabel != nil {
                    map["yLabel"] = self.yLabel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("dataDisplay") {
                    self.dataDisplay = dict["dataDisplay"] as! String
                }
                if dict.keys.contains("defineId") {
                    self.defineId = dict["defineId"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("displayType") {
                    self.displayType = dict["displayType"] as! String
                }
                if dict.keys.contains("expressionTitle") {
                    self.expressionTitle = dict["expressionTitle"] as! String
                }
                if dict.keys.contains("favoriteFlag") {
                    self.favoriteFlag = dict["favoriteFlag"] as! Bool
                }
                if dict.keys.contains("fieldDetail") {
                    self.fieldDetail = dict["fieldDetail"] as! String
                }
                if dict.keys.contains("fieldRank") {
                    self.fieldRank = dict["fieldRank"] as! Int32
                }
                if dict.keys.contains("fieldSource") {
                    self.fieldSource = dict["fieldSource"] as! String
                }
                if dict.keys.contains("fieldType") {
                    self.fieldType = dict["fieldType"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("inputFieldType") {
                    self.inputFieldType = dict["inputFieldType"] as! String
                }
                if dict.keys.contains("inputRequired") {
                    self.inputRequired = dict["inputRequired"] as! String
                }
                if dict.keys.contains("inputs") {
                    self.inputs = dict["inputs"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("outlier") {
                    self.outlier = dict["outlier"] as! String
                }
                if dict.keys.contains("outputThreshold") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.SelfVariables.OutputThreshold()
                    model.fromMap(dict["outputThreshold"] as! [String: Any])
                    self.outputThreshold = model
                }
                if dict.keys.contains("parentName") {
                    self.parentName = dict["parentName"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("variableVelocity") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.SelfVariables.VariableVelocity()
                    model.fromMap(dict["variableVelocity"] as! [String: Any])
                    self.variableVelocity = model
                }
                if dict.keys.contains("xLabel") {
                    self.xLabel = dict["xLabel"] as! String
                }
                if dict.keys.contains("yLabel") {
                    self.yLabel = dict["yLabel"] as! String
                }
            }
        }
        public class SysVariables : Tea.TeaModel {
            public class OutputThreshold : Tea.TeaModel {
                public var maxValue: Double?

                public var minValue: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxValue != nil {
                        map["maxValue"] = self.maxValue!
                    }
                    if self.minValue != nil {
                        map["minValue"] = self.minValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxValue") {
                        self.maxValue = dict["maxValue"] as! Double
                    }
                    if dict.keys.contains("minValue") {
                        self.minValue = dict["minValue"] as! Double
                    }
                }
            }
            public class VariableVelocity : Tea.TeaModel {
                public var iv: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.iv != nil {
                        map["iv"] = self.iv!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("iv") {
                        self.iv = dict["iv"] as! String
                    }
                }
            }
            public var code: String?

            public var dataDisplay: String?

            public var defineId: String?

            public var description_: String?

            public var displayType: String?

            public var expressionTitle: String?

            public var favoriteFlag: Bool?

            public var fieldDetail: String?

            public var fieldRank: Int32?

            public var fieldSource: String?

            public var fieldType: String?

            public var id: Int64?

            public var inputFieldType: String?

            public var inputRequired: String?

            public var inputs: String?

            public var name: String?

            public var outlier: String?

            public var outputThreshold: DescribeEventVariableListResponseBody.ResultObject.SysVariables.OutputThreshold?

            public var parentName: String?

            public var sourceType: String?

            public var title: String?

            public var type: String?

            public var variableVelocity: DescribeEventVariableListResponseBody.ResultObject.SysVariables.VariableVelocity?

            public var xLabel: String?

            public var yLabel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputThreshold?.validate()
                try self.variableVelocity?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.dataDisplay != nil {
                    map["dataDisplay"] = self.dataDisplay!
                }
                if self.defineId != nil {
                    map["defineId"] = self.defineId!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.displayType != nil {
                    map["displayType"] = self.displayType!
                }
                if self.expressionTitle != nil {
                    map["expressionTitle"] = self.expressionTitle!
                }
                if self.favoriteFlag != nil {
                    map["favoriteFlag"] = self.favoriteFlag!
                }
                if self.fieldDetail != nil {
                    map["fieldDetail"] = self.fieldDetail!
                }
                if self.fieldRank != nil {
                    map["fieldRank"] = self.fieldRank!
                }
                if self.fieldSource != nil {
                    map["fieldSource"] = self.fieldSource!
                }
                if self.fieldType != nil {
                    map["fieldType"] = self.fieldType!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.inputFieldType != nil {
                    map["inputFieldType"] = self.inputFieldType!
                }
                if self.inputRequired != nil {
                    map["inputRequired"] = self.inputRequired!
                }
                if self.inputs != nil {
                    map["inputs"] = self.inputs!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.outlier != nil {
                    map["outlier"] = self.outlier!
                }
                if self.outputThreshold != nil {
                    map["outputThreshold"] = self.outputThreshold?.toMap()
                }
                if self.parentName != nil {
                    map["parentName"] = self.parentName!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.variableVelocity != nil {
                    map["variableVelocity"] = self.variableVelocity?.toMap()
                }
                if self.xLabel != nil {
                    map["xLabel"] = self.xLabel!
                }
                if self.yLabel != nil {
                    map["yLabel"] = self.yLabel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("dataDisplay") {
                    self.dataDisplay = dict["dataDisplay"] as! String
                }
                if dict.keys.contains("defineId") {
                    self.defineId = dict["defineId"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("displayType") {
                    self.displayType = dict["displayType"] as! String
                }
                if dict.keys.contains("expressionTitle") {
                    self.expressionTitle = dict["expressionTitle"] as! String
                }
                if dict.keys.contains("favoriteFlag") {
                    self.favoriteFlag = dict["favoriteFlag"] as! Bool
                }
                if dict.keys.contains("fieldDetail") {
                    self.fieldDetail = dict["fieldDetail"] as! String
                }
                if dict.keys.contains("fieldRank") {
                    self.fieldRank = dict["fieldRank"] as! Int32
                }
                if dict.keys.contains("fieldSource") {
                    self.fieldSource = dict["fieldSource"] as! String
                }
                if dict.keys.contains("fieldType") {
                    self.fieldType = dict["fieldType"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("inputFieldType") {
                    self.inputFieldType = dict["inputFieldType"] as! String
                }
                if dict.keys.contains("inputRequired") {
                    self.inputRequired = dict["inputRequired"] as! String
                }
                if dict.keys.contains("inputs") {
                    self.inputs = dict["inputs"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("outlier") {
                    self.outlier = dict["outlier"] as! String
                }
                if dict.keys.contains("outputThreshold") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.SysVariables.OutputThreshold()
                    model.fromMap(dict["outputThreshold"] as! [String: Any])
                    self.outputThreshold = model
                }
                if dict.keys.contains("parentName") {
                    self.parentName = dict["parentName"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("variableVelocity") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.SysVariables.VariableVelocity()
                    model.fromMap(dict["variableVelocity"] as! [String: Any])
                    self.variableVelocity = model
                }
                if dict.keys.contains("xLabel") {
                    self.xLabel = dict["xLabel"] as! String
                }
                if dict.keys.contains("yLabel") {
                    self.yLabel = dict["yLabel"] as! String
                }
            }
        }
        public class VelocityVariables : Tea.TeaModel {
            public class OutputThreshold : Tea.TeaModel {
                public var maxValue: Double?

                public var minValue: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxValue != nil {
                        map["maxValue"] = self.maxValue!
                    }
                    if self.minValue != nil {
                        map["minValue"] = self.minValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxValue") {
                        self.maxValue = dict["maxValue"] as! Double
                    }
                    if dict.keys.contains("minValue") {
                        self.minValue = dict["minValue"] as! Double
                    }
                }
            }
            public class VariableVelocity : Tea.TeaModel {
                public var iv: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.iv != nil {
                        map["iv"] = self.iv!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("iv") {
                        self.iv = dict["iv"] as! String
                    }
                }
            }
            public var code: String?

            public var dataDisplay: String?

            public var defineId: String?

            public var description_: String?

            public var displayType: String?

            public var expressionTitle: String?

            public var favoriteFlag: Bool?

            public var fieldDetail: String?

            public var fieldRank: Int32?

            public var fieldSource: String?

            public var fieldType: String?

            public var id: Int64?

            public var inputFieldType: String?

            public var inputRequired: String?

            public var inputs: String?

            public var name: String?

            public var outlier: String?

            public var outputThreshold: DescribeEventVariableListResponseBody.ResultObject.VelocityVariables.OutputThreshold?

            public var parentName: String?

            public var sourceType: String?

            public var title: String?

            public var type: String?

            public var variableVelocity: DescribeEventVariableListResponseBody.ResultObject.VelocityVariables.VariableVelocity?

            public var xLabel: String?

            public var yLabel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputThreshold?.validate()
                try self.variableVelocity?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.dataDisplay != nil {
                    map["dataDisplay"] = self.dataDisplay!
                }
                if self.defineId != nil {
                    map["defineId"] = self.defineId!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.displayType != nil {
                    map["displayType"] = self.displayType!
                }
                if self.expressionTitle != nil {
                    map["expressionTitle"] = self.expressionTitle!
                }
                if self.favoriteFlag != nil {
                    map["favoriteFlag"] = self.favoriteFlag!
                }
                if self.fieldDetail != nil {
                    map["fieldDetail"] = self.fieldDetail!
                }
                if self.fieldRank != nil {
                    map["fieldRank"] = self.fieldRank!
                }
                if self.fieldSource != nil {
                    map["fieldSource"] = self.fieldSource!
                }
                if self.fieldType != nil {
                    map["fieldType"] = self.fieldType!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.inputFieldType != nil {
                    map["inputFieldType"] = self.inputFieldType!
                }
                if self.inputRequired != nil {
                    map["inputRequired"] = self.inputRequired!
                }
                if self.inputs != nil {
                    map["inputs"] = self.inputs!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.outlier != nil {
                    map["outlier"] = self.outlier!
                }
                if self.outputThreshold != nil {
                    map["outputThreshold"] = self.outputThreshold?.toMap()
                }
                if self.parentName != nil {
                    map["parentName"] = self.parentName!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.variableVelocity != nil {
                    map["variableVelocity"] = self.variableVelocity?.toMap()
                }
                if self.xLabel != nil {
                    map["xLabel"] = self.xLabel!
                }
                if self.yLabel != nil {
                    map["yLabel"] = self.yLabel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("dataDisplay") {
                    self.dataDisplay = dict["dataDisplay"] as! String
                }
                if dict.keys.contains("defineId") {
                    self.defineId = dict["defineId"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("displayType") {
                    self.displayType = dict["displayType"] as! String
                }
                if dict.keys.contains("expressionTitle") {
                    self.expressionTitle = dict["expressionTitle"] as! String
                }
                if dict.keys.contains("favoriteFlag") {
                    self.favoriteFlag = dict["favoriteFlag"] as! Bool
                }
                if dict.keys.contains("fieldDetail") {
                    self.fieldDetail = dict["fieldDetail"] as! String
                }
                if dict.keys.contains("fieldRank") {
                    self.fieldRank = dict["fieldRank"] as! Int32
                }
                if dict.keys.contains("fieldSource") {
                    self.fieldSource = dict["fieldSource"] as! String
                }
                if dict.keys.contains("fieldType") {
                    self.fieldType = dict["fieldType"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("inputFieldType") {
                    self.inputFieldType = dict["inputFieldType"] as! String
                }
                if dict.keys.contains("inputRequired") {
                    self.inputRequired = dict["inputRequired"] as! String
                }
                if dict.keys.contains("inputs") {
                    self.inputs = dict["inputs"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("outlier") {
                    self.outlier = dict["outlier"] as! String
                }
                if dict.keys.contains("outputThreshold") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.VelocityVariables.OutputThreshold()
                    model.fromMap(dict["outputThreshold"] as! [String: Any])
                    self.outputThreshold = model
                }
                if dict.keys.contains("parentName") {
                    self.parentName = dict["parentName"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("variableVelocity") {
                    var model = DescribeEventVariableListResponseBody.ResultObject.VelocityVariables.VariableVelocity()
                    model.fromMap(dict["variableVelocity"] as! [String: Any])
                    self.variableVelocity = model
                }
                if dict.keys.contains("xLabel") {
                    self.xLabel = dict["xLabel"] as! String
                }
                if dict.keys.contains("yLabel") {
                    self.yLabel = dict["yLabel"] as! String
                }
            }
        }
        public var actions: [DescribeEventVariableListResponseBody.ResultObject.Actions]?

        public var deviceVariables: [DescribeEventVariableListResponseBody.ResultObject.DeviceVariables]?

        public var expressionVariables: [DescribeEventVariableListResponseBody.ResultObject.ExpressionVariables]?

        public var favoriteVariables: [DescribeEventVariableListResponseBody.ResultObject.FavoriteVariables]?

        public var middleVariables: [DescribeEventVariableListResponseBody.ResultObject.MiddleVariables]?

        public var modelVariables: [DescribeEventVariableListResponseBody.ResultObject.ModelVariables]?

        public var nameList: [DescribeEventVariableListResponseBody.ResultObject.NameList]?

        public var nativeVariableFunctions: [DescribeEventVariableListResponseBody.ResultObject.NativeVariableFunctions]?

        public var nativeVariables: [DescribeEventVariableListResponseBody.ResultObject.NativeVariables]?

        public var queryVariables: [DescribeEventVariableListResponseBody.ResultObject.QueryVariables]?

        public var selfVariables: [DescribeEventVariableListResponseBody.ResultObject.SelfVariables]?

        public var sysVariables: [DescribeEventVariableListResponseBody.ResultObject.SysVariables]?

        public var thirdVariables: [String: Any]?

        public var velocityVariables: [DescribeEventVariableListResponseBody.ResultObject.VelocityVariables]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actions != nil {
                var tmp : [Any] = []
                for k in self.actions! {
                    tmp.append(k.toMap())
                }
                map["actions"] = tmp
            }
            if self.deviceVariables != nil {
                var tmp : [Any] = []
                for k in self.deviceVariables! {
                    tmp.append(k.toMap())
                }
                map["deviceVariables"] = tmp
            }
            if self.expressionVariables != nil {
                var tmp : [Any] = []
                for k in self.expressionVariables! {
                    tmp.append(k.toMap())
                }
                map["expressionVariables"] = tmp
            }
            if self.favoriteVariables != nil {
                var tmp : [Any] = []
                for k in self.favoriteVariables! {
                    tmp.append(k.toMap())
                }
                map["favoriteVariables"] = tmp
            }
            if self.middleVariables != nil {
                var tmp : [Any] = []
                for k in self.middleVariables! {
                    tmp.append(k.toMap())
                }
                map["middleVariables"] = tmp
            }
            if self.modelVariables != nil {
                var tmp : [Any] = []
                for k in self.modelVariables! {
                    tmp.append(k.toMap())
                }
                map["modelVariables"] = tmp
            }
            if self.nameList != nil {
                var tmp : [Any] = []
                for k in self.nameList! {
                    tmp.append(k.toMap())
                }
                map["nameList"] = tmp
            }
            if self.nativeVariableFunctions != nil {
                var tmp : [Any] = []
                for k in self.nativeVariableFunctions! {
                    tmp.append(k.toMap())
                }
                map["nativeVariableFunctions"] = tmp
            }
            if self.nativeVariables != nil {
                var tmp : [Any] = []
                for k in self.nativeVariables! {
                    tmp.append(k.toMap())
                }
                map["nativeVariables"] = tmp
            }
            if self.queryVariables != nil {
                var tmp : [Any] = []
                for k in self.queryVariables! {
                    tmp.append(k.toMap())
                }
                map["queryVariables"] = tmp
            }
            if self.selfVariables != nil {
                var tmp : [Any] = []
                for k in self.selfVariables! {
                    tmp.append(k.toMap())
                }
                map["selfVariables"] = tmp
            }
            if self.sysVariables != nil {
                var tmp : [Any] = []
                for k in self.sysVariables! {
                    tmp.append(k.toMap())
                }
                map["sysVariables"] = tmp
            }
            if self.thirdVariables != nil {
                map["thirdVariables"] = self.thirdVariables!
            }
            if self.velocityVariables != nil {
                var tmp : [Any] = []
                for k in self.velocityVariables! {
                    tmp.append(k.toMap())
                }
                map["velocityVariables"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("actions") {
                var tmp : [DescribeEventVariableListResponseBody.ResultObject.Actions] = []
                for v in dict["actions"] as! [Any] {
                    var model = DescribeEventVariableListResponseBody.ResultObject.Actions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.actions = tmp
            }
            if dict.keys.contains("deviceVariables") {
                var tmp : [DescribeEventVariableListResponseBody.ResultObject.DeviceVariables] = []
                for v in dict["deviceVariables"] as! [Any] {
                    var model = DescribeEventVariableListResponseBody.ResultObject.DeviceVariables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.deviceVariables = tmp
            }
            if dict.keys.contains("expressionVariables") {
                var tmp : [DescribeEventVariableListResponseBody.ResultObject.ExpressionVariables] = []
                for v in dict["expressionVariables"] as! [Any] {
                    var model = DescribeEventVariableListResponseBody.ResultObject.ExpressionVariables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.expressionVariables = tmp
            }
            if dict.keys.contains("favoriteVariables") {
                var tmp : [DescribeEventVariableListResponseBody.ResultObject.FavoriteVariables] = []
                for v in dict["favoriteVariables"] as! [Any] {
                    var model = DescribeEventVariableListResponseBody.ResultObject.FavoriteVariables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.favoriteVariables = tmp
            }
            if dict.keys.contains("middleVariables") {
                var tmp : [DescribeEventVariableListResponseBody.ResultObject.MiddleVariables] = []
                for v in dict["middleVariables"] as! [Any] {
                    var model = DescribeEventVariableListResponseBody.ResultObject.MiddleVariables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.middleVariables = tmp
            }
            if dict.keys.contains("modelVariables") {
                var tmp : [DescribeEventVariableListResponseBody.ResultObject.ModelVariables] = []
                for v in dict["modelVariables"] as! [Any] {
                    var model = DescribeEventVariableListResponseBody.ResultObject.ModelVariables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.modelVariables = tmp
            }
            if dict.keys.contains("nameList") {
                var tmp : [DescribeEventVariableListResponseBody.ResultObject.NameList] = []
                for v in dict["nameList"] as! [Any] {
                    var model = DescribeEventVariableListResponseBody.ResultObject.NameList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nameList = tmp
            }
            if dict.keys.contains("nativeVariableFunctions") {
                var tmp : [DescribeEventVariableListResponseBody.ResultObject.NativeVariableFunctions] = []
                for v in dict["nativeVariableFunctions"] as! [Any] {
                    var model = DescribeEventVariableListResponseBody.ResultObject.NativeVariableFunctions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nativeVariableFunctions = tmp
            }
            if dict.keys.contains("nativeVariables") {
                var tmp : [DescribeEventVariableListResponseBody.ResultObject.NativeVariables] = []
                for v in dict["nativeVariables"] as! [Any] {
                    var model = DescribeEventVariableListResponseBody.ResultObject.NativeVariables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nativeVariables = tmp
            }
            if dict.keys.contains("queryVariables") {
                var tmp : [DescribeEventVariableListResponseBody.ResultObject.QueryVariables] = []
                for v in dict["queryVariables"] as! [Any] {
                    var model = DescribeEventVariableListResponseBody.ResultObject.QueryVariables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.queryVariables = tmp
            }
            if dict.keys.contains("selfVariables") {
                var tmp : [DescribeEventVariableListResponseBody.ResultObject.SelfVariables] = []
                for v in dict["selfVariables"] as! [Any] {
                    var model = DescribeEventVariableListResponseBody.ResultObject.SelfVariables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.selfVariables = tmp
            }
            if dict.keys.contains("sysVariables") {
                var tmp : [DescribeEventVariableListResponseBody.ResultObject.SysVariables] = []
                for v in dict["sysVariables"] as! [Any] {
                    var model = DescribeEventVariableListResponseBody.ResultObject.SysVariables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sysVariables = tmp
            }
            if dict.keys.contains("thirdVariables") {
                self.thirdVariables = dict["thirdVariables"] as! [String: Any]
            }
            if dict.keys.contains("velocityVariables") {
                var tmp : [DescribeEventVariableListResponseBody.ResultObject.VelocityVariables] = []
                for v in dict["velocityVariables"] as! [Any] {
                    var model = DescribeEventVariableListResponseBody.ResultObject.VelocityVariables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.velocityVariables = tmp
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeEventVariableListResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeEventVariableListResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeEventVariableListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventVariableListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEventVariableListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventVariableTemplateBindRequest : Tea.TeaModel {
    public var lang: String?

    public var inputs: String?

    public var regId: String?

    public var templateCode: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.inputs != nil {
            map["inputs"] = self.inputs!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.templateCode != nil {
            map["templateCode"] = self.templateCode!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("inputs") {
            self.inputs = dict["inputs"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("templateCode") {
            self.templateCode = dict["templateCode"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class DescribeEventVariableTemplateBindResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class ChargeVariables : Tea.TeaModel {
            public var code: String?

            public var description_: String?

            public var fieldType: String?

            public var id: Int64?

            public var name: String?

            public var title: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.fieldType != nil {
                    map["fieldType"] = self.fieldType!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("fieldType") {
                    self.fieldType = dict["fieldType"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public class FreeVariables : Tea.TeaModel {
            public var code: String?

            public var description_: String?

            public var fieldType: String?

            public var id: Int64?

            public var name: String?

            public var title: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.fieldType != nil {
                    map["fieldType"] = self.fieldType!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("fieldType") {
                    self.fieldType = dict["fieldType"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var chargeVariables: [DescribeEventVariableTemplateBindResponseBody.ResultObject.ChargeVariables]?

        public var freeVariables: [DescribeEventVariableTemplateBindResponseBody.ResultObject.FreeVariables]?

        public var templateCode: String?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chargeVariables != nil {
                var tmp : [Any] = []
                for k in self.chargeVariables! {
                    tmp.append(k.toMap())
                }
                map["chargeVariables"] = tmp
            }
            if self.freeVariables != nil {
                var tmp : [Any] = []
                for k in self.freeVariables! {
                    tmp.append(k.toMap())
                }
                map["freeVariables"] = tmp
            }
            if self.templateCode != nil {
                map["templateCode"] = self.templateCode!
            }
            if self.totalCount != nil {
                map["totalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("chargeVariables") {
                var tmp : [DescribeEventVariableTemplateBindResponseBody.ResultObject.ChargeVariables] = []
                for v in dict["chargeVariables"] as! [Any] {
                    var model = DescribeEventVariableTemplateBindResponseBody.ResultObject.ChargeVariables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.chargeVariables = tmp
            }
            if dict.keys.contains("freeVariables") {
                var tmp : [DescribeEventVariableTemplateBindResponseBody.ResultObject.FreeVariables] = []
                for v in dict["freeVariables"] as! [Any] {
                    var model = DescribeEventVariableTemplateBindResponseBody.ResultObject.FreeVariables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.freeVariables = tmp
            }
            if dict.keys.contains("templateCode") {
                self.templateCode = dict["templateCode"] as! String
            }
            if dict.keys.contains("totalCount") {
                self.totalCount = dict["totalCount"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeEventVariableTemplateBindResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeEventVariableTemplateBindResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeEventVariableTemplateBindResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventVariableTemplateBindResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEventVariableTemplateBindResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventVariableTemplateListRequest : Tea.TeaModel {
    public var lang: String?

    public var inputs: String?

    public var regId: String?

    public var templateCode: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.inputs != nil {
            map["inputs"] = self.inputs!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.templateCode != nil {
            map["templateCode"] = self.templateCode!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("inputs") {
            self.inputs = dict["inputs"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("templateCode") {
            self.templateCode = dict["templateCode"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class DescribeEventVariableTemplateListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Variables : Tea.TeaModel {
            public var code: String?

            public var description_: String?

            public var fieldType: String?

            public var id: Int64?

            public var name: String?

            public var title: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.fieldType != nil {
                    map["fieldType"] = self.fieldType!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("fieldType") {
                    self.fieldType = dict["fieldType"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var templateCode: String?

        public var templateName: String?

        public var variables: [DescribeEventVariableTemplateListResponseBody.ResultObject.Variables]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.templateCode != nil {
                map["templateCode"] = self.templateCode!
            }
            if self.templateName != nil {
                map["templateName"] = self.templateName!
            }
            if self.variables != nil {
                var tmp : [Any] = []
                for k in self.variables! {
                    tmp.append(k.toMap())
                }
                map["variables"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("templateCode") {
                self.templateCode = dict["templateCode"] as! String
            }
            if dict.keys.contains("templateName") {
                self.templateName = dict["templateName"] as! String
            }
            if dict.keys.contains("variables") {
                var tmp : [DescribeEventVariableTemplateListResponseBody.ResultObject.Variables] = []
                for v in dict["variables"] as! [Any] {
                    var model = DescribeEventVariableTemplateListResponseBody.ResultObject.Variables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.variables = tmp
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeEventVariableTemplateListResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeEventVariableTemplateListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeEventVariableTemplateListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeEventVariableTemplateListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventVariableTemplateListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEventVariableTemplateListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventsVariableListRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var eventCodes: String?

    public var filterDTO: String?

    public var regId: String?

    public var scene: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.filterDTO != nil {
            map["filterDTO"] = self.filterDTO!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.scene != nil {
            map["scene"] = self.scene!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("filterDTO") {
            self.filterDTO = dict["filterDTO"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("scene") {
            self.scene = dict["scene"] as! String
        }
    }
}

public class DescribeEventsVariableListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeEventsVariableListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventsVariableListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEventsVariableListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExcuteNumRequest : Tea.TeaModel {
    public var code: String?

    public var degree: String?

    public var endDate: String?

    public var lang: String?

    public var sourceIp: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.degree != nil {
            map["Degree"] = self.degree!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Degree") {
            self.degree = dict["Degree"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribeExcuteNumResponseBody : Tea.TeaModel {
    public var categories: [String]?

    public var data: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categories != nil {
            map["Categories"] = self.categories!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Categories") {
            self.categories = dict["Categories"] as! [String]
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeExcuteNumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExcuteNumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeExcuteNumResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExistNameRequest : Tea.TeaModel {
    public var lang: String?

    public var name: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeExistNameResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeExistNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExistNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeExistNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExistSceneRequest : Tea.TeaModel {
    public var lang: String?

    public var sceneName: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sceneName != nil {
            map["SceneName"] = self.sceneName!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SceneName") {
            self.sceneName = dict["SceneName"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeExistSceneResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var data: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! Bool
        }
    }
}

public class DescribeExistSceneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExistSceneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeExistSceneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExpressionVariableDetailRequest : Tea.TeaModel {
    public var lang: String?

    public var id: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeExpressionVariableDetailResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! [String: Any]
        }
    }
}

public class DescribeExpressionVariableDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExpressionVariableDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeExpressionVariableDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExpressionVariableFunctionListRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeExpressionVariableFunctionListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var description_: String?

        public var key: String?

        public var maxParamSize: Int64?

        public var minParamSize: Int64?

        public var paramTypes: String?

        public var redirect: Bool?

        public var returnTypes: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.key != nil {
                map["key"] = self.key!
            }
            if self.maxParamSize != nil {
                map["maxParamSize"] = self.maxParamSize!
            }
            if self.minParamSize != nil {
                map["minParamSize"] = self.minParamSize!
            }
            if self.paramTypes != nil {
                map["paramTypes"] = self.paramTypes!
            }
            if self.redirect != nil {
                map["redirect"] = self.redirect!
            }
            if self.returnTypes != nil {
                map["returnTypes"] = self.returnTypes!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("key") {
                self.key = dict["key"] as! String
            }
            if dict.keys.contains("maxParamSize") {
                self.maxParamSize = dict["maxParamSize"] as! Int64
            }
            if dict.keys.contains("minParamSize") {
                self.minParamSize = dict["minParamSize"] as! Int64
            }
            if dict.keys.contains("paramTypes") {
                self.paramTypes = dict["paramTypes"] as! String
            }
            if dict.keys.contains("redirect") {
                self.redirect = dict["redirect"] as! Bool
            }
            if dict.keys.contains("returnTypes") {
                self.returnTypes = dict["returnTypes"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeExpressionVariableFunctionListResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeExpressionVariableFunctionListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeExpressionVariableFunctionListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeExpressionVariableFunctionListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExpressionVariableFunctionListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeExpressionVariableFunctionListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExpressionVariablePageRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: String?

    public var eventCode: String?

    public var outputs: String?

    public var pageSize: String?

    public var regId: String?

    public var status: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.outputs != nil {
            map["outputs"] = self.outputs!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.value != nil {
            map["value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("outputs") {
            self.outputs = dict["outputs"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("value") {
            self.value = dict["value"] as! String
        }
    }
}

public class DescribeExpressionVariablePageResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var description_: String?

        public var eventName: String?

        public var gmtModified: Int64?

        public var id: Int64?

        public var outputs: String?

        public var status: String?

        public var title: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.outputs != nil {
                map["outputs"] = self.outputs!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("outputs") {
                self.outputs = dict["outputs"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeExpressionVariablePageResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeExpressionVariablePageResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeExpressionVariablePageResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeExpressionVariablePageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExpressionVariablePageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeExpressionVariablePageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFieldByIdRequest : Tea.TeaModel {
    public var lang: String?

    public var id: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeFieldByIdResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeFieldByIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFieldByIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFieldByIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFieldListRequest : Tea.TeaModel {
    public var lang: String?

    public var condition: String?

    public var inputs: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.condition != nil {
            map["condition"] = self.condition!
        }
        if self.inputs != nil {
            map["inputs"] = self.inputs!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("condition") {
            self.condition = dict["condition"] as! String
        }
        if dict.keys.contains("inputs") {
            self.inputs = dict["inputs"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeFieldListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var classify: String?

        public var description_: String?

        public var enumData: String?

        public var id: Int64?

        public var name: String?

        public var source: String?

        public var status: String?

        public var title: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classify != nil {
                map["classify"] = self.classify!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.enumData != nil {
                map["enumData"] = self.enumData!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("classify") {
                self.classify = dict["classify"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("enumData") {
                self.enumData = dict["enumData"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("source") {
                self.source = dict["source"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeFieldListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeFieldListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeFieldListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeFieldListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFieldListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFieldListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFieldPageRequest : Tea.TeaModel {
    public var lang: String?

    public var classify: String?

    public var condition: String?

    public var currentPage: String?

    public var name: String?

    public var pageSize: String?

    public var regId: String?

    public var source: String?

    public var status: String?

    public var title: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.classify != nil {
            map["classify"] = self.classify!
        }
        if self.condition != nil {
            map["condition"] = self.condition!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("classify") {
            self.classify = dict["classify"] as! String
        }
        if dict.keys.contains("condition") {
            self.condition = dict["condition"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("source") {
            self.source = dict["source"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class DescribeFieldPageResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var classify: String?

        public var description_: String?

        public var enumData: String?

        public var id: Int64?

        public var name: String?

        public var source: String?

        public var status: String?

        public var title: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classify != nil {
                map["classify"] = self.classify!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.enumData != nil {
                map["enumData"] = self.enumData!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("classify") {
                self.classify = dict["classify"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("enumData") {
                self.enumData = dict["enumData"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("source") {
                self.source = dict["source"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeFieldPageResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeFieldPageResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeFieldPageResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeFieldPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFieldPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFieldPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGroupAccountPageRequest : Tea.TeaModel {
    public var lang: String?

    public var communityNo: String?

    public var currentPage: String?

    public var direction: String?

    public var fieldKey: String?

    public var fieldVal: String?

    public var isPage: Bool?

    public var order: String?

    public var pageSize: String?

    public var regId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.communityNo != nil {
            map["communityNo"] = self.communityNo!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.direction != nil {
            map["direction"] = self.direction!
        }
        if self.fieldKey != nil {
            map["fieldKey"] = self.fieldKey!
        }
        if self.fieldVal != nil {
            map["fieldVal"] = self.fieldVal!
        }
        if self.isPage != nil {
            map["isPage"] = self.isPage!
        }
        if self.order != nil {
            map["order"] = self.order!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("communityNo") {
            self.communityNo = dict["communityNo"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("direction") {
            self.direction = dict["direction"] as! String
        }
        if dict.keys.contains("fieldKey") {
            self.fieldKey = dict["fieldKey"] as! String
        }
        if dict.keys.contains("fieldVal") {
            self.fieldVal = dict["fieldVal"] as! String
        }
        if dict.keys.contains("isPage") {
            self.isPage = dict["isPage"] as! Bool
        }
        if dict.keys.contains("order") {
            self.order = dict["order"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class DescribeGroupAccountPageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var currentPage: Int32?

    public var data: Bool?

    public var pageSize: Int32?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! Bool
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeGroupAccountPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGroupAccountPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGroupAccountPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGroupConditionListRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeGroupConditionListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var fieldKey: String?

        public var fieldValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldKey != nil {
                map["fieldKey"] = self.fieldKey!
            }
            if self.fieldValue != nil {
                map["fieldValue"] = self.fieldValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldKey") {
                self.fieldKey = dict["fieldKey"] as! String
            }
            if dict.keys.contains("fieldValue") {
                self.fieldValue = dict["fieldValue"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeGroupConditionListResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeGroupConditionListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeGroupConditionListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeGroupConditionListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGroupConditionListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGroupConditionListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGroupPageRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: String?

    public var direction: String?

    public var order: String?

    public var pageSize: String?

    public var regId: String?

    public var taskId: String?

    public var timeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.direction != nil {
            map["direction"] = self.direction!
        }
        if self.order != nil {
            map["order"] = self.order!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        if self.timeType != nil {
            map["timeType"] = self.timeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("direction") {
            self.direction = dict["direction"] as! String
        }
        if dict.keys.contains("order") {
            self.order = dict["order"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! String
        }
        if dict.keys.contains("timeType") {
            self.timeType = dict["timeType"] as! String
        }
    }
}

public class DescribeGroupPageResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var communityNo: String?

        public var createTime: Int64?

        public var groupRisk: String?

        public var groupScale: String?

        public var id: Int64?

        public var sceneName: String?

        public var taskId: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.communityNo != nil {
                map["communityNo"] = self.communityNo!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.groupRisk != nil {
                map["groupRisk"] = self.groupRisk!
            }
            if self.groupScale != nil {
                map["groupScale"] = self.groupScale!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.sceneName != nil {
                map["sceneName"] = self.sceneName!
            }
            if self.taskId != nil {
                map["taskId"] = self.taskId!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("communityNo") {
                self.communityNo = dict["communityNo"] as! String
            }
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("groupRisk") {
                self.groupRisk = dict["groupRisk"] as! String
            }
            if dict.keys.contains("groupScale") {
                self.groupScale = dict["groupScale"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("sceneName") {
                self.sceneName = dict["sceneName"] as! String
            }
            if dict.keys.contains("taskId") {
                self.taskId = dict["taskId"] as! Int64
            }
            if dict.keys.contains("userId") {
                self.userId = dict["userId"] as! String
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeGroupPageResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeGroupPageResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeGroupPageResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeGroupPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGroupPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGroupPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGroupStatisticsByTodayRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeGroupStatisticsByTodayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var data: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! Bool
        }
    }
}

public class DescribeGroupStatisticsByTodayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGroupStatisticsByTodayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGroupStatisticsByTodayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGroupTrendRequest : Tea.TeaModel {
    public var lang: String?

    public var day: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.day != nil {
            map["day"] = self.day!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("day") {
            self.day = dict["day"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeGroupTrendResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var data: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! Bool
        }
    }
}

public class DescribeGroupTrendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGroupTrendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGroupTrendResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHasRuleNameByEventCodeRequest : Tea.TeaModel {
    public var lang: String?

    public var eventCode: String?

    public var excludeRuleId: String?

    public var regId: String?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.excludeRuleId != nil {
            map["excludeRuleId"] = self.excludeRuleId!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleName != nil {
            map["ruleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("excludeRuleId") {
            self.excludeRuleId = dict["excludeRuleId"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleName") {
            self.ruleName = dict["ruleName"] as! String
        }
    }
}

public class DescribeHasRuleNameByEventCodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeHasRuleNameByEventCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHasRuleNameByEventCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeHasRuleNameByEventCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHighRiskPieChartRequest : Tea.TeaModel {
    public var lang: String?

    public var beginTime: Int64?

    public var endTime: Int64?

    public var eventCodes: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! Int64
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeHighRiskPieChartResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class HighRiskIPCity : Tea.TeaModel {
            public class Grid : Tea.TeaModel {
                public var show: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.show != nil {
                        map["show"] = self.show!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("show") {
                        self.show = dict["show"] as! Bool
                    }
                }
            }
            public class Series : Tea.TeaModel {
                public class Data : Tea.TeaModel {
                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        if self.value != nil {
                            map["value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("name") {
                            self.name = dict["name"] as! String
                        }
                        if dict.keys.contains("value") {
                            self.value = dict["value"] as! String
                        }
                    }
                }
                public var data: [DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPCity.Series.Data]?

                public var name: String?

                public var roseType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.data != nil {
                        var tmp : [Any] = []
                        for k in self.data! {
                            tmp.append(k.toMap())
                        }
                        map["data"] = tmp
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.roseType != nil {
                        map["roseType"] = self.roseType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("data") {
                        var tmp : [DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPCity.Series.Data] = []
                        for v in dict["data"] as! [Any] {
                            var model = DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPCity.Series.Data()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.data = tmp
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("roseType") {
                        self.roseType = dict["roseType"] as! String
                    }
                }
            }
            public var animation: Bool?

            public var grid: DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPCity.Grid?

            public var series: [DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPCity.Series]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.grid?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.animation != nil {
                    map["animation"] = self.animation!
                }
                if self.grid != nil {
                    map["grid"] = self.grid?.toMap()
                }
                if self.series != nil {
                    var tmp : [Any] = []
                    for k in self.series! {
                        tmp.append(k.toMap())
                    }
                    map["series"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("animation") {
                    self.animation = dict["animation"] as! Bool
                }
                if dict.keys.contains("grid") {
                    var model = DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPCity.Grid()
                    model.fromMap(dict["grid"] as! [String: Any])
                    self.grid = model
                }
                if dict.keys.contains("series") {
                    var tmp : [DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPCity.Series] = []
                    for v in dict["series"] as! [Any] {
                        var model = DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPCity.Series()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.series = tmp
                }
            }
        }
        public class HighRiskIPProvince : Tea.TeaModel {
            public class Grid : Tea.TeaModel {
                public var show: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.show != nil {
                        map["show"] = self.show!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("show") {
                        self.show = dict["show"] as! Bool
                    }
                }
            }
            public class Series : Tea.TeaModel {
                public class Data : Tea.TeaModel {
                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        if self.value != nil {
                            map["value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("name") {
                            self.name = dict["name"] as! String
                        }
                        if dict.keys.contains("value") {
                            self.value = dict["value"] as! String
                        }
                    }
                }
                public var data: [DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPProvince.Series.Data]?

                public var name: String?

                public var roseType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.data != nil {
                        var tmp : [Any] = []
                        for k in self.data! {
                            tmp.append(k.toMap())
                        }
                        map["data"] = tmp
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.roseType != nil {
                        map["roseType"] = self.roseType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("data") {
                        var tmp : [DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPProvince.Series.Data] = []
                        for v in dict["data"] as! [Any] {
                            var model = DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPProvince.Series.Data()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.data = tmp
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("roseType") {
                        self.roseType = dict["roseType"] as! String
                    }
                }
            }
            public var animation: Bool?

            public var grid: DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPProvince.Grid?

            public var series: [DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPProvince.Series]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.grid?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.animation != nil {
                    map["animation"] = self.animation!
                }
                if self.grid != nil {
                    map["grid"] = self.grid?.toMap()
                }
                if self.series != nil {
                    var tmp : [Any] = []
                    for k in self.series! {
                        tmp.append(k.toMap())
                    }
                    map["series"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("animation") {
                    self.animation = dict["animation"] as! Bool
                }
                if dict.keys.contains("grid") {
                    var model = DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPProvince.Grid()
                    model.fromMap(dict["grid"] as! [String: Any])
                    self.grid = model
                }
                if dict.keys.contains("series") {
                    var tmp : [DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPProvince.Series] = []
                    for v in dict["series"] as! [Any] {
                        var model = DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPProvince.Series()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.series = tmp
                }
            }
        }
        public class HighRiskMobileCity : Tea.TeaModel {
            public class Grid : Tea.TeaModel {
                public var show: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.show != nil {
                        map["show"] = self.show!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("show") {
                        self.show = dict["show"] as! Bool
                    }
                }
            }
            public class Series : Tea.TeaModel {
                public class Data : Tea.TeaModel {
                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        if self.value != nil {
                            map["value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("name") {
                            self.name = dict["name"] as! String
                        }
                        if dict.keys.contains("value") {
                            self.value = dict["value"] as! String
                        }
                    }
                }
                public var data: [DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileCity.Series.Data]?

                public var name: String?

                public var roseType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.data != nil {
                        var tmp : [Any] = []
                        for k in self.data! {
                            tmp.append(k.toMap())
                        }
                        map["data"] = tmp
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.roseType != nil {
                        map["roseType"] = self.roseType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("data") {
                        var tmp : [DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileCity.Series.Data] = []
                        for v in dict["data"] as! [Any] {
                            var model = DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileCity.Series.Data()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.data = tmp
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("roseType") {
                        self.roseType = dict["roseType"] as! String
                    }
                }
            }
            public var animation: Bool?

            public var grid: DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileCity.Grid?

            public var series: [DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileCity.Series]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.grid?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.animation != nil {
                    map["animation"] = self.animation!
                }
                if self.grid != nil {
                    map["grid"] = self.grid?.toMap()
                }
                if self.series != nil {
                    var tmp : [Any] = []
                    for k in self.series! {
                        tmp.append(k.toMap())
                    }
                    map["series"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("animation") {
                    self.animation = dict["animation"] as! Bool
                }
                if dict.keys.contains("grid") {
                    var model = DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileCity.Grid()
                    model.fromMap(dict["grid"] as! [String: Any])
                    self.grid = model
                }
                if dict.keys.contains("series") {
                    var tmp : [DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileCity.Series] = []
                    for v in dict["series"] as! [Any] {
                        var model = DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileCity.Series()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.series = tmp
                }
            }
        }
        public class HighRiskMobileProvince : Tea.TeaModel {
            public class Grid : Tea.TeaModel {
                public var show: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.show != nil {
                        map["show"] = self.show!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("show") {
                        self.show = dict["show"] as! Bool
                    }
                }
            }
            public class Series : Tea.TeaModel {
                public class Data : Tea.TeaModel {
                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        if self.value != nil {
                            map["value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("name") {
                            self.name = dict["name"] as! String
                        }
                        if dict.keys.contains("value") {
                            self.value = dict["value"] as! String
                        }
                    }
                }
                public var data: [DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileProvince.Series.Data]?

                public var name: String?

                public var roseType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.data != nil {
                        var tmp : [Any] = []
                        for k in self.data! {
                            tmp.append(k.toMap())
                        }
                        map["data"] = tmp
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.roseType != nil {
                        map["roseType"] = self.roseType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("data") {
                        var tmp : [DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileProvince.Series.Data] = []
                        for v in dict["data"] as! [Any] {
                            var model = DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileProvince.Series.Data()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.data = tmp
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("roseType") {
                        self.roseType = dict["roseType"] as! String
                    }
                }
            }
            public var animation: Bool?

            public var grid: DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileProvince.Grid?

            public var series: [DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileProvince.Series]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.grid?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.animation != nil {
                    map["animation"] = self.animation!
                }
                if self.grid != nil {
                    map["grid"] = self.grid?.toMap()
                }
                if self.series != nil {
                    var tmp : [Any] = []
                    for k in self.series! {
                        tmp.append(k.toMap())
                    }
                    map["series"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("animation") {
                    self.animation = dict["animation"] as! Bool
                }
                if dict.keys.contains("grid") {
                    var model = DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileProvince.Grid()
                    model.fromMap(dict["grid"] as! [String: Any])
                    self.grid = model
                }
                if dict.keys.contains("series") {
                    var tmp : [DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileProvince.Series] = []
                    for v in dict["series"] as! [Any] {
                        var model = DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileProvince.Series()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.series = tmp
                }
            }
        }
        public var highRiskIPCity: DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPCity?

        public var highRiskIPProvince: DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPProvince?

        public var highRiskMobileCity: DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileCity?

        public var highRiskMobileProvince: DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileProvince?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.highRiskIPCity?.validate()
            try self.highRiskIPProvince?.validate()
            try self.highRiskMobileCity?.validate()
            try self.highRiskMobileProvince?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.highRiskIPCity != nil {
                map["highRiskIPCity"] = self.highRiskIPCity?.toMap()
            }
            if self.highRiskIPProvince != nil {
                map["highRiskIPProvince"] = self.highRiskIPProvince?.toMap()
            }
            if self.highRiskMobileCity != nil {
                map["highRiskMobileCity"] = self.highRiskMobileCity?.toMap()
            }
            if self.highRiskMobileProvince != nil {
                map["highRiskMobileProvince"] = self.highRiskMobileProvince?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("highRiskIPCity") {
                var model = DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPCity()
                model.fromMap(dict["highRiskIPCity"] as! [String: Any])
                self.highRiskIPCity = model
            }
            if dict.keys.contains("highRiskIPProvince") {
                var model = DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskIPProvince()
                model.fromMap(dict["highRiskIPProvince"] as! [String: Any])
                self.highRiskIPProvince = model
            }
            if dict.keys.contains("highRiskMobileCity") {
                var model = DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileCity()
                model.fromMap(dict["highRiskMobileCity"] as! [String: Any])
                self.highRiskMobileCity = model
            }
            if dict.keys.contains("highRiskMobileProvince") {
                var model = DescribeHighRiskPieChartResponseBody.ResultObject.HighRiskMobileProvince()
                model.fromMap(dict["highRiskMobileProvince"] as! [String: Any])
                self.highRiskMobileProvince = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: DescribeHighRiskPieChartResponseBody.ResultObject?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeHighRiskPieChartResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeHighRiskPieChartResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHighRiskPieChartResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeHighRiskPieChartResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHitRuleFluctuationRequest : Tea.TeaModel {
    public var lang: String?

    public var eventCodes: String?

    public var regId: String?

    public var ruleStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleStatus != nil {
            map["ruleStatus"] = self.ruleStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleStatus") {
            self.ruleStatus = dict["ruleStatus"] as! String
        }
    }
}

public class DescribeHitRuleFluctuationResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var ruleId: String?

        public var ruleName: String?

        public var todayNum: Int64?

        public var withinSevenDayNum: String?

        public var withinThirtyDayNum: String?

        public var withinThreeDayNum: String?

        public var yesterdayNum: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleId != nil {
                map["ruleId"] = self.ruleId!
            }
            if self.ruleName != nil {
                map["ruleName"] = self.ruleName!
            }
            if self.todayNum != nil {
                map["todayNum"] = self.todayNum!
            }
            if self.withinSevenDayNum != nil {
                map["withinSevenDayNum"] = self.withinSevenDayNum!
            }
            if self.withinThirtyDayNum != nil {
                map["withinThirtyDayNum"] = self.withinThirtyDayNum!
            }
            if self.withinThreeDayNum != nil {
                map["withinThreeDayNum"] = self.withinThreeDayNum!
            }
            if self.yesterdayNum != nil {
                map["yesterdayNum"] = self.yesterdayNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ruleId") {
                self.ruleId = dict["ruleId"] as! String
            }
            if dict.keys.contains("ruleName") {
                self.ruleName = dict["ruleName"] as! String
            }
            if dict.keys.contains("todayNum") {
                self.todayNum = dict["todayNum"] as! Int64
            }
            if dict.keys.contains("withinSevenDayNum") {
                self.withinSevenDayNum = dict["withinSevenDayNum"] as! String
            }
            if dict.keys.contains("withinThirtyDayNum") {
                self.withinThirtyDayNum = dict["withinThirtyDayNum"] as! String
            }
            if dict.keys.contains("withinThreeDayNum") {
                self.withinThreeDayNum = dict["withinThreeDayNum"] as! String
            }
            if dict.keys.contains("yesterdayNum") {
                self.yesterdayNum = dict["yesterdayNum"] as! Int64
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: [DescribeHitRuleFluctuationResponseBody.ResultObject]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeHitRuleFluctuationResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeHitRuleFluctuationResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeHitRuleFluctuationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHitRuleFluctuationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeHitRuleFluctuationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHitRuleListRequest : Tea.TeaModel {
    public var lang: String?

    public var beginTime: Int64?

    public var endTime: Int64?

    public var eventCodes: String?

    public var eventType: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.eventType != nil {
            map["eventType"] = self.eventType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! Int64
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("eventType") {
            self.eventType = dict["eventType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeHitRuleListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var hitCount: Int32?

        public var ruleName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hitCount != nil {
                map["hitCount"] = self.hitCount!
            }
            if self.ruleName != nil {
                map["ruleName"] = self.ruleName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("hitCount") {
                self.hitCount = dict["hitCount"] as! Int32
            }
            if dict.keys.contains("ruleName") {
                self.ruleName = dict["ruleName"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeHitRuleListResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeHitRuleListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeHitRuleListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeHitRuleListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHitRuleListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeHitRuleListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHitRuleTrendRequest : Tea.TeaModel {
    public var lang: String?

    public var beginTime: Int64?

    public var endTime: Int64?

    public var eventCodes: String?

    public var regId: String?

    public var ruleStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleStatus != nil {
            map["ruleStatus"] = self.ruleStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! Int64
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleStatus") {
            self.ruleStatus = dict["ruleStatus"] as! String
        }
    }
}

public class DescribeHitRuleTrendResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Series : Tea.TeaModel {
            public class Data : Tea.TeaModel {
                public var num: Int64?

                public var scale: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.num != nil {
                        map["num"] = self.num!
                    }
                    if self.scale != nil {
                        map["scale"] = self.scale!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("num") {
                        self.num = dict["num"] as! Int64
                    }
                    if dict.keys.contains("scale") {
                        self.scale = dict["scale"] as! String
                    }
                }
            }
            public var data: [DescribeHitRuleTrendResponseBody.ResultObject.Series.Data]?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    var tmp : [Any] = []
                    for k in self.data! {
                        tmp.append(k.toMap())
                    }
                    map["data"] = tmp
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    var tmp : [DescribeHitRuleTrendResponseBody.ResultObject.Series.Data] = []
                    for v in dict["data"] as! [Any] {
                        var model = DescribeHitRuleTrendResponseBody.ResultObject.Series.Data()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.data = tmp
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public class Xaxis : Tea.TeaModel {
            public var data: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    self.data = dict["data"] as! [String]
                }
            }
        }
        public var series: [DescribeHitRuleTrendResponseBody.ResultObject.Series]?

        public var xaxis: DescribeHitRuleTrendResponseBody.ResultObject.Xaxis?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.xaxis?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.series != nil {
                var tmp : [Any] = []
                for k in self.series! {
                    tmp.append(k.toMap())
                }
                map["series"] = tmp
            }
            if self.xaxis != nil {
                map["xaxis"] = self.xaxis?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("series") {
                var tmp : [DescribeHitRuleTrendResponseBody.ResultObject.Series] = []
                for v in dict["series"] as! [Any] {
                    var model = DescribeHitRuleTrendResponseBody.ResultObject.Series()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.series = tmp
            }
            if dict.keys.contains("xaxis") {
                var model = DescribeHitRuleTrendResponseBody.ResultObject.Xaxis()
                model.fromMap(dict["xaxis"] as! [String: Any])
                self.xaxis = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: DescribeHitRuleTrendResponseBody.ResultObject?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeHitRuleTrendResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeHitRuleTrendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHitRuleTrendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeHitRuleTrendResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInputFeildCountByEventCodeRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var eventCode: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeInputFeildCountByEventCodeResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var limit: Bool?

        public var maxTotalItem: Int32?

        public var totalItem: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.limit != nil {
                map["limit"] = self.limit!
            }
            if self.maxTotalItem != nil {
                map["maxTotalItem"] = self.maxTotalItem!
            }
            if self.totalItem != nil {
                map["totalItem"] = self.totalItem!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("limit") {
                self.limit = dict["limit"] as! Bool
            }
            if dict.keys.contains("maxTotalItem") {
                self.maxTotalItem = dict["maxTotalItem"] as! Int32
            }
            if dict.keys.contains("totalItem") {
                self.totalItem = dict["totalItem"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeInputFeildCountByEventCodeResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeInputFeildCountByEventCodeResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeInputFeildCountByEventCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInputFeildCountByEventCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInputFeildCountByEventCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeListPocRequest : Tea.TeaModel {
    public var currentPage: Int64?

    public var lang: String?

    public var pageSize: Int64?

    public var regId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["RegId"] = self.regId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int64
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RegId") {
            self.regId = dict["RegId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeListPocResponseBody : Tea.TeaModel {
    public var code: String?

    public var currentPage: String?

    public var httpStatusCode: String?

    public var message: String?

    public var pageSize: String?

    public var requestId: String?

    public var resultObject: Bool?

    public var totalItem: String?

    public var totalPage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["ResultObject"] = self.resultObject!
        }
        if self.totalItem != nil {
            map["TotalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultObject") {
            self.resultObject = dict["ResultObject"] as! Bool
        }
        if dict.keys.contains("TotalItem") {
            self.totalItem = dict["TotalItem"] as! String
        }
        if dict.keys.contains("TotalPage") {
            self.totalPage = dict["TotalPage"] as! String
        }
    }
}

public class DescribeListPocResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeListPocResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeListPocResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoanExecListRequest : Tea.TeaModel {
    public var lang: String?

    public var batchNo: String?

    public var currentPage: String?

    public var monitorObj: String?

    public var monitorStatus: String?

    public var pageSize: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.batchNo != nil {
            map["batchNo"] = self.batchNo!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.monitorObj != nil {
            map["monitorObj"] = self.monitorObj!
        }
        if self.monitorStatus != nil {
            map["monitorStatus"] = self.monitorStatus!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("batchNo") {
            self.batchNo = dict["batchNo"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("monitorObj") {
            self.monitorObj = dict["monitorObj"] as! String
        }
        if dict.keys.contains("monitorStatus") {
            self.monitorStatus = dict["monitorStatus"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeLoanExecListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: Bool?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeLoanExecListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoanExecListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLoanExecListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoanTaskListRequest : Tea.TeaModel {
    public var lang: String?

    public var batchNo: String?

    public var currentPage: String?

    public var monitorStatus: String?

    public var pageSize: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.batchNo != nil {
            map["batchNo"] = self.batchNo!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.monitorStatus != nil {
            map["monitorStatus"] = self.monitorStatus!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("batchNo") {
            self.batchNo = dict["batchNo"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("monitorStatus") {
            self.monitorStatus = dict["monitorStatus"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeLoanTaskListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: Bool?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeLoanTaskListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoanTaskListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLoanTaskListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMarkPageRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: String?

    public var direction: String?

    public var isPage: Bool?

    public var order: String?

    public var pageSize: String?

    public var regId: String?

    public var taskLogId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.direction != nil {
            map["direction"] = self.direction!
        }
        if self.isPage != nil {
            map["isPage"] = self.isPage!
        }
        if self.order != nil {
            map["order"] = self.order!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.taskLogId != nil {
            map["taskLogId"] = self.taskLogId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("direction") {
            self.direction = dict["direction"] as! String
        }
        if dict.keys.contains("isPage") {
            self.isPage = dict["isPage"] as! Bool
        }
        if dict.keys.contains("order") {
            self.order = dict["order"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("taskLogId") {
            self.taskLogId = dict["taskLogId"] as! String
        }
    }
}

public class DescribeMarkPageResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var fieldName: String?

        public var fieldValue: String?

        public var id: Int64?

        public var markType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldName != nil {
                map["fieldName"] = self.fieldName!
            }
            if self.fieldValue != nil {
                map["fieldValue"] = self.fieldValue!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.markType != nil {
                map["markType"] = self.markType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldName") {
                self.fieldName = dict["fieldName"] as! String
            }
            if dict.keys.contains("fieldValue") {
                self.fieldValue = dict["fieldValue"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("markType") {
                self.markType = dict["markType"] as! String
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeMarkPageResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeMarkPageResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeMarkPageResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeMarkPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMarkPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMarkPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMenuPermissionRequest : Tea.TeaModel {
    public var lang: String?

    public var permissionType: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.permissionType != nil {
            map["permissionType"] = self.permissionType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("permissionType") {
            self.permissionType = dict["permissionType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeMenuPermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeMenuPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMenuPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMenuPermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMonitorTaskLimitRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeMonitorTaskLimitResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var limit: Bool?

        public var maxTotalItem: Int32?

        public var totalItem: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.limit != nil {
                map["limit"] = self.limit!
            }
            if self.maxTotalItem != nil {
                map["maxTotalItem"] = self.maxTotalItem!
            }
            if self.totalItem != nil {
                map["totalItem"] = self.totalItem!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("limit") {
                self.limit = dict["limit"] as! Bool
            }
            if dict.keys.contains("maxTotalItem") {
                self.maxTotalItem = dict["maxTotalItem"] as! Int32
            }
            if dict.keys.contains("totalItem") {
                self.totalItem = dict["totalItem"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeMonitorTaskLimitResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeMonitorTaskLimitResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeMonitorTaskLimitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMonitorTaskLimitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMonitorTaskLimitResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNameListRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var currentPage: String?

    public var pageSize: String?

    public var regId: String?

    public var value: String?

    public var variableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.value != nil {
            map["value"] = self.value!
        }
        if self.variableId != nil {
            map["variableId"] = self.variableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("value") {
            self.value = dict["value"] as! String
        }
        if dict.keys.contains("variableId") {
            self.variableId = dict["variableId"] as! String
        }
    }
}

public class DescribeNameListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var identifier: String?

        public var title: String?

        public var value: String?

        public var variableId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            if self.variableId != nil {
                map["variableId"] = self.variableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
            if dict.keys.contains("variableId") {
                self.variableId = dict["variableId"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeNameListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeNameListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeNameListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeNameListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNameListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNameListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNameListDownloadUrlRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var variableId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.variableId != nil {
            map["variableId"] = self.variableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("variableId") {
            self.variableId = dict["variableId"] as! Int64
        }
    }
}

public class DescribeNameListDownloadUrlResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var downloadFileUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadFileUrl != nil {
                map["downloadFileUrl"] = self.downloadFileUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("downloadFileUrl") {
                self.downloadFileUrl = dict["downloadFileUrl"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeNameListDownloadUrlResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeNameListDownloadUrlResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeNameListDownloadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNameListDownloadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNameListDownloadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNameListLimitRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeNameListLimitResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var limit: Bool?

        public var maxTotalItem: Int64?

        public var totalItem: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.limit != nil {
                map["limit"] = self.limit!
            }
            if self.maxTotalItem != nil {
                map["maxTotalItem"] = self.maxTotalItem!
            }
            if self.totalItem != nil {
                map["totalItem"] = self.totalItem!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("limit") {
                self.limit = dict["limit"] as! Bool
            }
            if dict.keys.contains("maxTotalItem") {
                self.maxTotalItem = dict["maxTotalItem"] as! Int64
            }
            if dict.keys.contains("totalItem") {
                self.totalItem = dict["totalItem"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeNameListLimitResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeNameListLimitResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeNameListLimitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNameListLimitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNameListLimitResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNameListPageListRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var regId: String?

    public var updateBeginTime: Int64?

    public var updateEndTime: Int64?

    public var value: String?

    public var variableId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.updateBeginTime != nil {
            map["updateBeginTime"] = self.updateBeginTime!
        }
        if self.updateEndTime != nil {
            map["updateEndTime"] = self.updateEndTime!
        }
        if self.value != nil {
            map["value"] = self.value!
        }
        if self.variableId != nil {
            map["variableId"] = self.variableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("updateBeginTime") {
            self.updateBeginTime = dict["updateBeginTime"] as! Int64
        }
        if dict.keys.contains("updateEndTime") {
            self.updateEndTime = dict["updateEndTime"] as! Int64
        }
        if dict.keys.contains("value") {
            self.value = dict["value"] as! String
        }
        if dict.keys.contains("variableId") {
            self.variableId = dict["variableId"] as! Int64
        }
    }
}

public class DescribeNameListPageListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var name: String?

        public var nameListType: String?

        public var title: String?

        public var userId: String?

        public var value: String?

        public var variableId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameListType != nil {
                map["nameListType"] = self.nameListType!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            if self.variableId != nil {
                map["variableId"] = self.variableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("nameListType") {
                self.nameListType = dict["nameListType"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
            if dict.keys.contains("userId") {
                self.userId = dict["userId"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
            if dict.keys.contains("variableId") {
                self.variableId = dict["variableId"] as! Int64
            }
        }
    }
    public var currentPage: String?

    public var pageSize: String?

    public var requestId: String?

    public var resultObject: [DescribeNameListPageListResponseBody.ResultObject]?

    public var totalItem: String?

    public var totalPage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeNameListPageListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeNameListPageListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! String
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! String
        }
    }
}

public class DescribeNameListPageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNameListPageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNameListPageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNameListTypeListRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeNameListTypeListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["key"] = self.key!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("key") {
                self.key = dict["key"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeNameListTypeListResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeNameListTypeListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeNameListTypeListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeNameListTypeListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNameListTypeListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNameListTypeListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNameListVariablePageListRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: Int32?

    public var name: String?

    public var nameListType: String?

    public var pageSize: Int32?

    public var regId: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.nameListType != nil {
            map["nameListType"] = self.nameListType!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.value != nil {
            map["value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("nameListType") {
            self.nameListType = dict["nameListType"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("value") {
            self.value = dict["value"] as! String
        }
    }
}

public class DescribeNameListVariablePageListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var capacity: Int64?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var leftCapacity: Int64?

        public var name: String?

        public var nameListType: String?

        public var refObjId: String?

        public var refObjType: Int64?

        public var sourceType: String?

        public var title: String?

        public var type: String?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.capacity != nil {
                map["capacity"] = self.capacity!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.leftCapacity != nil {
                map["leftCapacity"] = self.leftCapacity!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameListType != nil {
                map["nameListType"] = self.nameListType!
            }
            if self.refObjId != nil {
                map["refObjId"] = self.refObjId!
            }
            if self.refObjType != nil {
                map["refObjType"] = self.refObjType!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("capacity") {
                self.capacity = dict["capacity"] as! Int64
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("leftCapacity") {
                self.leftCapacity = dict["leftCapacity"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("nameListType") {
                self.nameListType = dict["nameListType"] as! String
            }
            if dict.keys.contains("refObjId") {
                self.refObjId = dict["refObjId"] as! String
            }
            if dict.keys.contains("refObjType") {
                self.refObjType = dict["refObjType"] as! Int64
            }
            if dict.keys.contains("sourceType") {
                self.sourceType = dict["sourceType"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("userId") {
                self.userId = dict["userId"] as! Int64
            }
        }
    }
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var resultObject: [DescribeNameListVariablePageListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeNameListVariablePageListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeNameListVariablePageListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeNameListVariablePageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNameListVariablePageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNameListVariablePageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOperationLogPageListRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: Int32?

    public var endDate: Int64?

    public var pageSize: Int32?

    public var regId: String?

    public var startDate: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.endDate != nil {
            map["endDate"] = self.endDate!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.startDate != nil {
            map["startDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("endDate") {
            self.endDate = dict["endDate"] as! Int64
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("startDate") {
            self.startDate = dict["startDate"] as! Int64
        }
    }
}

public class DescribeOperationLogPageListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var clientIp: String?

        public var gmtCreate: Int64?

        public var newContent: String?

        public var oldContent: String?

        public var operationSummary: String?

        public var operationType: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientIp != nil {
                map["clientIp"] = self.clientIp!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.newContent != nil {
                map["newContent"] = self.newContent!
            }
            if self.oldContent != nil {
                map["oldContent"] = self.oldContent!
            }
            if self.operationSummary != nil {
                map["operationSummary"] = self.operationSummary!
            }
            if self.operationType != nil {
                map["operationType"] = self.operationType!
            }
            if self.userName != nil {
                map["userName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("clientIp") {
                self.clientIp = dict["clientIp"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("newContent") {
                self.newContent = dict["newContent"] as! String
            }
            if dict.keys.contains("oldContent") {
                self.oldContent = dict["oldContent"] as! String
            }
            if dict.keys.contains("operationSummary") {
                self.operationSummary = dict["operationSummary"] as! String
            }
            if dict.keys.contains("operationType") {
                self.operationType = dict["operationType"] as! String
            }
            if dict.keys.contains("userName") {
                self.userName = dict["userName"] as! String
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeOperationLogPageListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeOperationLogPageListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeOperationLogPageListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeOperationLogPageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOperationLogPageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOperationLogPageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOperatorListRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeOperatorListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Operators : Tea.TeaModel {
            public class RightVariables : Tea.TeaModel {
                public var fieldName: String?

                public var fieldType: String?

                public var fieldValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldName != nil {
                        map["fieldName"] = self.fieldName!
                    }
                    if self.fieldType != nil {
                        map["fieldType"] = self.fieldType!
                    }
                    if self.fieldValue != nil {
                        map["fieldValue"] = self.fieldValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("fieldName") {
                        self.fieldName = dict["fieldName"] as! String
                    }
                    if dict.keys.contains("fieldType") {
                        self.fieldType = dict["fieldType"] as! String
                    }
                    if dict.keys.contains("fieldValue") {
                        self.fieldValue = dict["fieldValue"] as! String
                    }
                }
            }
            public var code: String?

            public var hasRightVariable: Bool?

            public var memo: String?

            public var name: String?

            public var rightVariables: [DescribeOperatorListResponseBody.ResultObject.Operators.RightVariables]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.hasRightVariable != nil {
                    map["hasRightVariable"] = self.hasRightVariable!
                }
                if self.memo != nil {
                    map["memo"] = self.memo!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.rightVariables != nil {
                    var tmp : [Any] = []
                    for k in self.rightVariables! {
                        tmp.append(k.toMap())
                    }
                    map["rightVariables"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("hasRightVariable") {
                    self.hasRightVariable = dict["hasRightVariable"] as! Bool
                }
                if dict.keys.contains("memo") {
                    self.memo = dict["memo"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("rightVariables") {
                    var tmp : [DescribeOperatorListResponseBody.ResultObject.Operators.RightVariables] = []
                    for v in dict["rightVariables"] as! [Any] {
                        var model = DescribeOperatorListResponseBody.ResultObject.Operators.RightVariables()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.rightVariables = tmp
                }
            }
        }
        public var fieldType: String?

        public var operators: [DescribeOperatorListResponseBody.ResultObject.Operators]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldType != nil {
                map["fieldType"] = self.fieldType!
            }
            if self.operators != nil {
                var tmp : [Any] = []
                for k in self.operators! {
                    tmp.append(k.toMap())
                }
                map["operators"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldType") {
                self.fieldType = dict["fieldType"] as! String
            }
            if dict.keys.contains("operators") {
                var tmp : [DescribeOperatorListResponseBody.ResultObject.Operators] = []
                for v in dict["operators"] as! [Any] {
                    var model = DescribeOperatorListResponseBody.ResultObject.Operators()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.operators = tmp
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeOperatorListResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeOperatorListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeOperatorListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeOperatorListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOperatorListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOperatorListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOperatorListBySceneRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var scene: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.scene != nil {
            map["scene"] = self.scene!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("scene") {
            self.scene = dict["scene"] as! String
        }
    }
}

public class DescribeOperatorListBySceneResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Operators : Tea.TeaModel {
            public class RightVariables : Tea.TeaModel {
                public var fieldName: String?

                public var fieldType: String?

                public var fieldValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fieldName != nil {
                        map["fieldName"] = self.fieldName!
                    }
                    if self.fieldType != nil {
                        map["fieldType"] = self.fieldType!
                    }
                    if self.fieldValue != nil {
                        map["fieldValue"] = self.fieldValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("fieldName") {
                        self.fieldName = dict["fieldName"] as! String
                    }
                    if dict.keys.contains("fieldType") {
                        self.fieldType = dict["fieldType"] as! String
                    }
                    if dict.keys.contains("fieldValue") {
                        self.fieldValue = dict["fieldValue"] as! String
                    }
                }
            }
            public var code: String?

            public var hasRightVariable: Bool?

            public var memo: String?

            public var name: String?

            public var rightVariables: [DescribeOperatorListBySceneResponseBody.ResultObject.Operators.RightVariables]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.hasRightVariable != nil {
                    map["hasRightVariable"] = self.hasRightVariable!
                }
                if self.memo != nil {
                    map["memo"] = self.memo!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.rightVariables != nil {
                    var tmp : [Any] = []
                    for k in self.rightVariables! {
                        tmp.append(k.toMap())
                    }
                    map["rightVariables"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("hasRightVariable") {
                    self.hasRightVariable = dict["hasRightVariable"] as! Bool
                }
                if dict.keys.contains("memo") {
                    self.memo = dict["memo"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("rightVariables") {
                    var tmp : [DescribeOperatorListBySceneResponseBody.ResultObject.Operators.RightVariables] = []
                    for v in dict["rightVariables"] as! [Any] {
                        var model = DescribeOperatorListBySceneResponseBody.ResultObject.Operators.RightVariables()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.rightVariables = tmp
                }
            }
        }
        public var fieldType: String?

        public var operators: [DescribeOperatorListBySceneResponseBody.ResultObject.Operators]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldType != nil {
                map["fieldType"] = self.fieldType!
            }
            if self.operators != nil {
                var tmp : [Any] = []
                for k in self.operators! {
                    tmp.append(k.toMap())
                }
                map["operators"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldType") {
                self.fieldType = dict["fieldType"] as! String
            }
            if dict.keys.contains("operators") {
                var tmp : [DescribeOperatorListBySceneResponseBody.ResultObject.Operators] = []
                for v in dict["operators"] as! [Any] {
                    var model = DescribeOperatorListBySceneResponseBody.ResultObject.Operators()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.operators = tmp
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeOperatorListBySceneResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeOperatorListBySceneResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeOperatorListBySceneResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeOperatorListBySceneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOperatorListBySceneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOperatorListBySceneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOperatorListByTypeRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeOperatorListByTypeResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Operators : Tea.TeaModel {
            public var code: String?

            public var hasRightVariable: Bool?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.hasRightVariable != nil {
                    map["hasRightVariable"] = self.hasRightVariable!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! String
                }
                if dict.keys.contains("hasRightVariable") {
                    self.hasRightVariable = dict["hasRightVariable"] as! Bool
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public var fieldType: String?

        public var operators: [DescribeOperatorListByTypeResponseBody.ResultObject.Operators]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldType != nil {
                map["fieldType"] = self.fieldType!
            }
            if self.operators != nil {
                var tmp : [Any] = []
                for k in self.operators! {
                    tmp.append(k.toMap())
                }
                map["operators"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldType") {
                self.fieldType = dict["fieldType"] as! String
            }
            if dict.keys.contains("operators") {
                var tmp : [DescribeOperatorListByTypeResponseBody.ResultObject.Operators] = []
                for v in dict["operators"] as! [Any] {
                    var model = DescribeOperatorListByTypeResponseBody.ResultObject.Operators()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.operators = tmp
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeOperatorListByTypeResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeOperatorListByTypeResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeOperatorListByTypeResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeOperatorListByTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOperatorListByTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOperatorListByTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOssAuthStatusRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeOssAuthStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! String
        }
    }
}

public class DescribeOssAuthStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOssAuthStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOssAuthStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOssPolicyRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var scene: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.scene != nil {
            map["scene"] = self.scene!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("scene") {
            self.scene = dict["scene"] as! String
        }
    }
}

public class DescribeOssPolicyResponseBody : Tea.TeaModel {
    public var accessId: String?

    public var host: String?

    public var key: String?

    public var policy: String?

    public var signature: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessId != nil {
            map["AccessId"] = self.accessId!
        }
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.signature != nil {
            map["Signature"] = self.signature!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessId") {
            self.accessId = dict["AccessId"] as! String
        }
        if dict.keys.contains("Host") {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("Signature") {
            self.signature = dict["Signature"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DescribeOssPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOssPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOssPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOssTokenRequest : Tea.TeaModel {
    public var lang: String?

    public var fileName: String?

    public var regId: String?

    public var uploadType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.fileName != nil {
            map["fileName"] = self.fileName!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.uploadType != nil {
            map["uploadType"] = self.uploadType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("fileName") {
            self.fileName = dict["fileName"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("uploadType") {
            self.uploadType = dict["uploadType"] as! String
        }
    }
}

public class DescribeOssTokenResponseBody : Tea.TeaModel {
    public var accessId: String?

    public var host: String?

    public var key: String?

    public var policy: String?

    public var requestId: String?

    public var signature: String?

    public var stsToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessId != nil {
            map["AccessId"] = self.accessId!
        }
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.signature != nil {
            map["Signature"] = self.signature!
        }
        if self.stsToken != nil {
            map["StsToken"] = self.stsToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessId") {
            self.accessId = dict["AccessId"] as! String
        }
        if dict.keys.contains("Host") {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Signature") {
            self.signature = dict["Signature"] as! String
        }
        if dict.keys.contains("StsToken") {
            self.stsToken = dict["StsToken"] as! String
        }
    }
}

public class DescribeOssTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOssTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOssTokenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeParamByEventCodesRequest : Tea.TeaModel {
    public var lang: String?

    public var eventCodes: String?

    public var parma: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.parma != nil {
            map["parma"] = self.parma!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("parma") {
            self.parma = dict["parma"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeParamByEventCodesResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var code: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["code"] = self.code!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("code") {
                self.code = dict["code"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeParamByEventCodesResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeParamByEventCodesResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeParamByEventCodesResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeParamByEventCodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeParamByEventCodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeParamByEventCodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeParamListRequest : Tea.TeaModel {
    public var lang: String?

    public var fileUrl: String?

    public var regId: String?

    public var serviceCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.fileUrl != nil {
            map["fileUrl"] = self.fileUrl!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.serviceCode != nil {
            map["serviceCode"] = self.serviceCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("fileUrl") {
            self.fileUrl = dict["fileUrl"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("serviceCode") {
            self.serviceCode = dict["serviceCode"] as! String
        }
    }
}

public class DescribeParamListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeParamListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeParamListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeParamListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePocDetailRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var taskId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class DescribePocDetailResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribePocDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePocDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePocDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePocOssTokenRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribePocOssTokenResponseBody : Tea.TeaModel {
    public var accessId: String?

    public var host: String?

    public var key: String?

    public var policy: String?

    public var requestId: String?

    public var signature: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessId != nil {
            map["AccessId"] = self.accessId!
        }
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.signature != nil {
            map["Signature"] = self.signature!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessId") {
            self.accessId = dict["AccessId"] as! String
        }
        if dict.keys.contains("Host") {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Signature") {
            self.signature = dict["Signature"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribePocOssTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePocOssTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePocOssTokenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePocTaskListRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var regId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class DescribePocTaskListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var createTime: String?

        public var downloadUrl: String?

        public var fileType: String?

        public var serviceName: String?

        public var status: String?

        public var taskId: String?

        public var taskName: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.downloadUrl != nil {
                map["downloadUrl"] = self.downloadUrl!
            }
            if self.fileType != nil {
                map["fileType"] = self.fileType!
            }
            if self.serviceName != nil {
                map["serviceName"] = self.serviceName!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.taskId != nil {
                map["taskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["taskName"] = self.taskName!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("downloadUrl") {
                self.downloadUrl = dict["downloadUrl"] as! String
            }
            if dict.keys.contains("fileType") {
                self.fileType = dict["fileType"] as! String
            }
            if dict.keys.contains("serviceName") {
                self.serviceName = dict["serviceName"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("taskId") {
                self.taskId = dict["taskId"] as! String
            }
            if dict.keys.contains("taskName") {
                self.taskName = dict["taskName"] as! String
            }
            if dict.keys.contains("updateTime") {
                self.updateTime = dict["updateTime"] as! String
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribePocTaskListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribePocTaskListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribePocTaskListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribePocTaskListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePocTaskListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePocTaskListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePrivateStackRequest : Tea.TeaModel {
    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribePrivateStackResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribePrivateStackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePrivateStackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePrivateStackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeQueryVariableDetailRequest : Tea.TeaModel {
    public var lang: String?

    public var id: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeQueryVariableDetailResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var dataSourceCode: Int64?

        public var dataSourceName: String?

        public var description_: String?

        public var eventCode: String?

        public var expression: String?

        public var expressionTitle: String?

        public var expressionVariable: String?

        public var id: Int64?

        public var outlier: String?

        public var outputs: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSourceCode != nil {
                map["dataSourceCode"] = self.dataSourceCode!
            }
            if self.dataSourceName != nil {
                map["dataSourceName"] = self.dataSourceName!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.expression != nil {
                map["expression"] = self.expression!
            }
            if self.expressionTitle != nil {
                map["expressionTitle"] = self.expressionTitle!
            }
            if self.expressionVariable != nil {
                map["expressionVariable"] = self.expressionVariable!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.outlier != nil {
                map["outlier"] = self.outlier!
            }
            if self.outputs != nil {
                map["outputs"] = self.outputs!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("dataSourceCode") {
                self.dataSourceCode = dict["dataSourceCode"] as! Int64
            }
            if dict.keys.contains("dataSourceName") {
                self.dataSourceName = dict["dataSourceName"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("expression") {
                self.expression = dict["expression"] as! String
            }
            if dict.keys.contains("expressionTitle") {
                self.expressionTitle = dict["expressionTitle"] as! String
            }
            if dict.keys.contains("expressionVariable") {
                self.expressionVariable = dict["expressionVariable"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("outlier") {
                self.outlier = dict["outlier"] as! String
            }
            if dict.keys.contains("outputs") {
                self.outputs = dict["outputs"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeQueryVariableDetailResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeQueryVariableDetailResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeQueryVariableDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeQueryVariableDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeQueryVariableDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeQueryVariablePageListRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: Int64?

    public var dataSourceCode: String?

    public var eventCode: String?

    public var name: String?

    public var pageSize: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.dataSourceCode != nil {
            map["dataSourceCode"] = self.dataSourceCode!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int64
        }
        if dict.keys.contains("dataSourceCode") {
            self.dataSourceCode = dict["dataSourceCode"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeQueryVariablePageListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var dataSourceCode: Int64?

        public var dataSourceName: String?

        public var description_: String?

        public var eventName: String?

        public var fieldType: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var name: String?

        public var status: String?

        public var total: Int64?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSourceCode != nil {
                map["dataSourceCode"] = self.dataSourceCode!
            }
            if self.dataSourceName != nil {
                map["dataSourceName"] = self.dataSourceName!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.fieldType != nil {
                map["fieldType"] = self.fieldType!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.total != nil {
                map["total"] = self.total!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("dataSourceCode") {
                self.dataSourceCode = dict["dataSourceCode"] as! Int64
            }
            if dict.keys.contains("dataSourceName") {
                self.dataSourceName = dict["dataSourceName"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("fieldType") {
                self.fieldType = dict["fieldType"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("total") {
                self.total = dict["total"] as! Int64
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int64?

    public var pageSize: Int64?

    public var resultObject: [DescribeQueryVariablePageListResponseBody.ResultObject]?

    public var totalItem: Int64?

    public var totalPage: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int64
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeQueryVariablePageListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeQueryVariablePageListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int64
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int64
        }
    }
}

public class DescribeQueryVariablePageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeQueryVariablePageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeQueryVariablePageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRecommendSceneVariablesRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var sampleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.sampleId != nil {
            map["sampleId"] = self.sampleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("sampleId") {
            self.sampleId = dict["sampleId"] as! Int64
        }
    }
}

public class DescribeRecommendSceneVariablesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeRecommendSceneVariablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecommendSceneVariablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRecommendSceneVariablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRecommendTaskDetailRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! Int64
        }
    }
}

public class DescribeRecommendTaskDetailResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class RecommendRuleDTOs : Tea.TeaModel {
            public class RecommendRules : Tea.TeaModel {
                public var left_: String?

                public var operator_: String?

                public var right_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.left_ != nil {
                        map["left"] = self.left_!
                    }
                    if self.operator_ != nil {
                        map["operator"] = self.operator_!
                    }
                    if self.right_ != nil {
                        map["right"] = self.right_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("left") {
                        self.left_ = dict["left"] as! String
                    }
                    if dict.keys.contains("operator") {
                        self.operator_ = dict["operator"] as! String
                    }
                    if dict.keys.contains("right") {
                        self.right_ = dict["right"] as! String
                    }
                }
            }
            public var computeExpression: String?

            public var hitSample: Int64?

            public var id: Int64?

            public var notHitSample: Int64?

            public var recommendRules: [DescribeRecommendTaskDetailResponseBody.ResultObject.RecommendRuleDTOs.RecommendRules]?

            public var ruleId: String?

            public var ruleName: String?

            public var status: String?

            public var velocities: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.computeExpression != nil {
                    map["computeExpression"] = self.computeExpression!
                }
                if self.hitSample != nil {
                    map["hitSample"] = self.hitSample!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.notHitSample != nil {
                    map["notHitSample"] = self.notHitSample!
                }
                if self.recommendRules != nil {
                    var tmp : [Any] = []
                    for k in self.recommendRules! {
                        tmp.append(k.toMap())
                    }
                    map["recommendRules"] = tmp
                }
                if self.ruleId != nil {
                    map["ruleId"] = self.ruleId!
                }
                if self.ruleName != nil {
                    map["ruleName"] = self.ruleName!
                }
                if self.status != nil {
                    map["status"] = self.status!
                }
                if self.velocities != nil {
                    map["velocities"] = self.velocities!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("computeExpression") {
                    self.computeExpression = dict["computeExpression"] as! String
                }
                if dict.keys.contains("hitSample") {
                    self.hitSample = dict["hitSample"] as! Int64
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("notHitSample") {
                    self.notHitSample = dict["notHitSample"] as! Int64
                }
                if dict.keys.contains("recommendRules") {
                    var tmp : [DescribeRecommendTaskDetailResponseBody.ResultObject.RecommendRuleDTOs.RecommendRules] = []
                    for v in dict["recommendRules"] as! [Any] {
                        var model = DescribeRecommendTaskDetailResponseBody.ResultObject.RecommendRuleDTOs.RecommendRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.recommendRules = tmp
                }
                if dict.keys.contains("ruleId") {
                    self.ruleId = dict["ruleId"] as! String
                }
                if dict.keys.contains("ruleName") {
                    self.ruleName = dict["ruleName"] as! String
                }
                if dict.keys.contains("status") {
                    self.status = dict["status"] as! String
                }
                if dict.keys.contains("velocities") {
                    self.velocities = dict["velocities"] as! String
                }
            }
        }
        public class RecommendVariableDTOs : Tea.TeaModel {
            public var id: Int64?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public var eventCode: String?

        public var eventName: String?

        public var expectVelocities: [String]?

        public var gmtCreate: Int64?

        public var normalSize: Int64?

        public var recommendRuleDTOs: [DescribeRecommendTaskDetailResponseBody.ResultObject.RecommendRuleDTOs]?

        public var recommendVariableDTOs: [DescribeRecommendTaskDetailResponseBody.ResultObject.RecommendVariableDTOs]?

        public var riskSize: Int64?

        public var sampleName: String?

        public var sampleScene: String?

        public var sampleSceneName: String?

        public var taskId: Int64?

        public var taskName: String?

        public var taskStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.expectVelocities != nil {
                map["expectVelocities"] = self.expectVelocities!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.normalSize != nil {
                map["normalSize"] = self.normalSize!
            }
            if self.recommendRuleDTOs != nil {
                var tmp : [Any] = []
                for k in self.recommendRuleDTOs! {
                    tmp.append(k.toMap())
                }
                map["recommendRuleDTOs"] = tmp
            }
            if self.recommendVariableDTOs != nil {
                var tmp : [Any] = []
                for k in self.recommendVariableDTOs! {
                    tmp.append(k.toMap())
                }
                map["recommendVariableDTOs"] = tmp
            }
            if self.riskSize != nil {
                map["riskSize"] = self.riskSize!
            }
            if self.sampleName != nil {
                map["sampleName"] = self.sampleName!
            }
            if self.sampleScene != nil {
                map["sampleScene"] = self.sampleScene!
            }
            if self.sampleSceneName != nil {
                map["sampleSceneName"] = self.sampleSceneName!
            }
            if self.taskId != nil {
                map["taskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["taskName"] = self.taskName!
            }
            if self.taskStatus != nil {
                map["taskStatus"] = self.taskStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("expectVelocities") {
                self.expectVelocities = dict["expectVelocities"] as! [String]
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("normalSize") {
                self.normalSize = dict["normalSize"] as! Int64
            }
            if dict.keys.contains("recommendRuleDTOs") {
                var tmp : [DescribeRecommendTaskDetailResponseBody.ResultObject.RecommendRuleDTOs] = []
                for v in dict["recommendRuleDTOs"] as! [Any] {
                    var model = DescribeRecommendTaskDetailResponseBody.ResultObject.RecommendRuleDTOs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.recommendRuleDTOs = tmp
            }
            if dict.keys.contains("recommendVariableDTOs") {
                var tmp : [DescribeRecommendTaskDetailResponseBody.ResultObject.RecommendVariableDTOs] = []
                for v in dict["recommendVariableDTOs"] as! [Any] {
                    var model = DescribeRecommendTaskDetailResponseBody.ResultObject.RecommendVariableDTOs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.recommendVariableDTOs = tmp
            }
            if dict.keys.contains("riskSize") {
                self.riskSize = dict["riskSize"] as! Int64
            }
            if dict.keys.contains("sampleName") {
                self.sampleName = dict["sampleName"] as! String
            }
            if dict.keys.contains("sampleScene") {
                self.sampleScene = dict["sampleScene"] as! String
            }
            if dict.keys.contains("sampleSceneName") {
                self.sampleSceneName = dict["sampleSceneName"] as! String
            }
            if dict.keys.contains("taskId") {
                self.taskId = dict["taskId"] as! Int64
            }
            if dict.keys.contains("taskName") {
                self.taskName = dict["taskName"] as! String
            }
            if dict.keys.contains("taskStatus") {
                self.taskStatus = dict["taskStatus"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeRecommendTaskDetailResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeRecommendTaskDetailResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeRecommendTaskDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecommendTaskDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRecommendTaskDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRecommendTaskPageListRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: String?

    public var pageSize: String?

    public var regId: String?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.taskName != nil {
            map["taskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("taskName") {
            self.taskName = dict["taskName"] as! String
        }
    }
}

public class DescribeRecommendTaskPageListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var expectVelocities: [String]?

        public var gmtCreate: Int64?

        public var normalCount: Int64?

        public var normalSize: Int64?

        public var riskCount: Int64?

        public var riskSize: Int64?

        public var sampleName: String?

        public var sampleScene: String?

        public var taskId: Int64?

        public var taskName: String?

        public var taskStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expectVelocities != nil {
                map["expectVelocities"] = self.expectVelocities!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.normalCount != nil {
                map["normalCount"] = self.normalCount!
            }
            if self.normalSize != nil {
                map["normalSize"] = self.normalSize!
            }
            if self.riskCount != nil {
                map["riskCount"] = self.riskCount!
            }
            if self.riskSize != nil {
                map["riskSize"] = self.riskSize!
            }
            if self.sampleName != nil {
                map["sampleName"] = self.sampleName!
            }
            if self.sampleScene != nil {
                map["sampleScene"] = self.sampleScene!
            }
            if self.taskId != nil {
                map["taskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["taskName"] = self.taskName!
            }
            if self.taskStatus != nil {
                map["taskStatus"] = self.taskStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("expectVelocities") {
                self.expectVelocities = dict["expectVelocities"] as! [String]
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("normalCount") {
                self.normalCount = dict["normalCount"] as! Int64
            }
            if dict.keys.contains("normalSize") {
                self.normalSize = dict["normalSize"] as! Int64
            }
            if dict.keys.contains("riskCount") {
                self.riskCount = dict["riskCount"] as! Int64
            }
            if dict.keys.contains("riskSize") {
                self.riskSize = dict["riskSize"] as! Int64
            }
            if dict.keys.contains("sampleName") {
                self.sampleName = dict["sampleName"] as! String
            }
            if dict.keys.contains("sampleScene") {
                self.sampleScene = dict["sampleScene"] as! String
            }
            if dict.keys.contains("taskId") {
                self.taskId = dict["taskId"] as! Int64
            }
            if dict.keys.contains("taskName") {
                self.taskName = dict["taskName"] as! String
            }
            if dict.keys.contains("taskStatus") {
                self.taskStatus = dict["taskStatus"] as! String
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeRecommendTaskPageListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeRecommendTaskPageListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeRecommendTaskPageListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeRecommendTaskPageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecommendTaskPageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRecommendTaskPageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRecommendVariablesVelocityRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var taskId: Int64?

    public var variableIdsStr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        if self.variableIdsStr != nil {
            map["variableIdsStr"] = self.variableIdsStr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! Int64
        }
        if dict.keys.contains("variableIdsStr") {
            self.variableIdsStr = dict["variableIdsStr"] as! String
        }
    }
}

public class DescribeRecommendVariablesVelocityResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeRecommendVariablesVelocityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecommendVariablesVelocityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRecommendVariablesVelocityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRecommendVelocitiesRequest : Tea.TeaModel {
    public var lang: String?

    public var code: String?

    public var regId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class DescribeRecommendVelocitiesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeRecommendVelocitiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecommendVelocitiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRecommendVelocitiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRegionsRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRequestHitRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var sRequestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.sRequestId != nil {
            map["sRequestId"] = self.sRequestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("sRequestId") {
            self.sRequestId = dict["sRequestId"] as! String
        }
    }
}

public class DescribeRequestHitResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class RuleHitRecords : Tea.TeaModel {
            public var cost: Int32?

            public var hitSuccessful: Bool?

            public var isShowDetail: Bool?

            public var order: Int32?

            public var ruleId: String?

            public var ruleName: String?

            public var ruleSnapshotId: String?

            public var ruleStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cost != nil {
                    map["cost"] = self.cost!
                }
                if self.hitSuccessful != nil {
                    map["hitSuccessful"] = self.hitSuccessful!
                }
                if self.isShowDetail != nil {
                    map["isShowDetail"] = self.isShowDetail!
                }
                if self.order != nil {
                    map["order"] = self.order!
                }
                if self.ruleId != nil {
                    map["ruleId"] = self.ruleId!
                }
                if self.ruleName != nil {
                    map["ruleName"] = self.ruleName!
                }
                if self.ruleSnapshotId != nil {
                    map["ruleSnapshotId"] = self.ruleSnapshotId!
                }
                if self.ruleStatus != nil {
                    map["ruleStatus"] = self.ruleStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cost") {
                    self.cost = dict["cost"] as! Int32
                }
                if dict.keys.contains("hitSuccessful") {
                    self.hitSuccessful = dict["hitSuccessful"] as! Bool
                }
                if dict.keys.contains("isShowDetail") {
                    self.isShowDetail = dict["isShowDetail"] as! Bool
                }
                if dict.keys.contains("order") {
                    self.order = dict["order"] as! Int32
                }
                if dict.keys.contains("ruleId") {
                    self.ruleId = dict["ruleId"] as! String
                }
                if dict.keys.contains("ruleName") {
                    self.ruleName = dict["ruleName"] as! String
                }
                if dict.keys.contains("ruleSnapshotId") {
                    self.ruleSnapshotId = dict["ruleSnapshotId"] as! String
                }
                if dict.keys.contains("ruleStatus") {
                    self.ruleStatus = dict["ruleStatus"] as! String
                }
            }
        }
        public var eventCode: String?

        public var eventName: String?

        public var inputs: String?

        public var outputs: String?

        public var requestTime: Int64?

        public var ruleHitRecords: [DescribeRequestHitResponseBody.ResultObject.RuleHitRecords]?

        public var sRequestId: String?

        public var totalCost: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.inputs != nil {
                map["inputs"] = self.inputs!
            }
            if self.outputs != nil {
                map["outputs"] = self.outputs!
            }
            if self.requestTime != nil {
                map["requestTime"] = self.requestTime!
            }
            if self.ruleHitRecords != nil {
                var tmp : [Any] = []
                for k in self.ruleHitRecords! {
                    tmp.append(k.toMap())
                }
                map["ruleHitRecords"] = tmp
            }
            if self.sRequestId != nil {
                map["sRequestId"] = self.sRequestId!
            }
            if self.totalCost != nil {
                map["totalCost"] = self.totalCost!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("inputs") {
                self.inputs = dict["inputs"] as! String
            }
            if dict.keys.contains("outputs") {
                self.outputs = dict["outputs"] as! String
            }
            if dict.keys.contains("requestTime") {
                self.requestTime = dict["requestTime"] as! Int64
            }
            if dict.keys.contains("ruleHitRecords") {
                var tmp : [DescribeRequestHitResponseBody.ResultObject.RuleHitRecords] = []
                for v in dict["ruleHitRecords"] as! [Any] {
                    var model = DescribeRequestHitResponseBody.ResultObject.RuleHitRecords()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ruleHitRecords = tmp
            }
            if dict.keys.contains("sRequestId") {
                self.sRequestId = dict["sRequestId"] as! String
            }
            if dict.keys.contains("totalCost") {
                self.totalCost = dict["totalCost"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeRequestHitResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeRequestHitResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeRequestHitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRequestHitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRequestHitResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRequestPeakReportRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeRequestPeakReportResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var ratio: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ratio != nil {
                map["ratio"] = self.ratio!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ratio") {
                self.ratio = dict["ratio"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: [DescribeRequestPeakReportResponseBody.ResultObject]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeRequestPeakReportResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeRequestPeakReportResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeRequestPeakReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRequestPeakReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRequestPeakReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeResultCountRequest : Tea.TeaModel {
    public var lang: String?

    public var beginTime: Int64?

    public var endTime: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! Int64
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeResultCountResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var result: String?

        public var total: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            if self.total != nil {
                map["total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("result") {
                self.result = dict["result"] as! String
            }
            if dict.keys.contains("total") {
                self.total = dict["total"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: [DescribeResultCountResponseBody.ResultObject]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeResultCountResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeResultCountResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeResultCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResultCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeResultCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRiskLineChartRequest : Tea.TeaModel {
    public var lang: String?

    public var beginTime: Int64?

    public var endTime: Int64?

    public var eventCodes: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! Int64
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeRiskLineChartResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Series : Tea.TeaModel {
            public var data: [String]?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    self.data = dict["data"] as! [String]
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public class Xaxis : Tea.TeaModel {
            public var data: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    self.data = dict["data"] as! [String]
                }
            }
        }
        public var series: [DescribeRiskLineChartResponseBody.ResultObject.Series]?

        public var xaxis: DescribeRiskLineChartResponseBody.ResultObject.Xaxis?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.xaxis?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.series != nil {
                var tmp : [Any] = []
                for k in self.series! {
                    tmp.append(k.toMap())
                }
                map["series"] = tmp
            }
            if self.xaxis != nil {
                map["xaxis"] = self.xaxis?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("series") {
                var tmp : [DescribeRiskLineChartResponseBody.ResultObject.Series] = []
                for v in dict["series"] as! [Any] {
                    var model = DescribeRiskLineChartResponseBody.ResultObject.Series()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.series = tmp
            }
            if dict.keys.contains("xaxis") {
                var model = DescribeRiskLineChartResponseBody.ResultObject.Xaxis()
                model.fromMap(dict["xaxis"] as! [String: Any])
                self.xaxis = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: DescribeRiskLineChartResponseBody.ResultObject?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeRiskLineChartResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeRiskLineChartResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRiskLineChartResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRiskLineChartResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRuleBarChartRequest : Tea.TeaModel {
    public var lang: String?

    public var beginTime: Int64?

    public var endTime: Int64?

    public var eventCodes: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! Int64
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeRuleBarChartResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Series : Tea.TeaModel {
            public class Data : Tea.TeaModel {
                public var eventName: String?

                public var num: Int64?

                public var ruleName: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.eventName != nil {
                        map["eventName"] = self.eventName!
                    }
                    if self.num != nil {
                        map["num"] = self.num!
                    }
                    if self.ruleName != nil {
                        map["ruleName"] = self.ruleName!
                    }
                    if self.status != nil {
                        map["status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("eventName") {
                        self.eventName = dict["eventName"] as! String
                    }
                    if dict.keys.contains("num") {
                        self.num = dict["num"] as! Int64
                    }
                    if dict.keys.contains("ruleName") {
                        self.ruleName = dict["ruleName"] as! String
                    }
                    if dict.keys.contains("status") {
                        self.status = dict["status"] as! String
                    }
                }
            }
            public var data: [DescribeRuleBarChartResponseBody.ResultObject.Series.Data]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    var tmp : [Any] = []
                    for k in self.data! {
                        tmp.append(k.toMap())
                    }
                    map["data"] = tmp
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    var tmp : [DescribeRuleBarChartResponseBody.ResultObject.Series.Data] = []
                    for v in dict["data"] as! [Any] {
                        var model = DescribeRuleBarChartResponseBody.ResultObject.Series.Data()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.data = tmp
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public class Yaxis : Tea.TeaModel {
            public var data: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    self.data = dict["data"] as! [String]
                }
            }
        }
        public var series: [DescribeRuleBarChartResponseBody.ResultObject.Series]?

        public var yaxis: DescribeRuleBarChartResponseBody.ResultObject.Yaxis?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.yaxis?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.series != nil {
                var tmp : [Any] = []
                for k in self.series! {
                    tmp.append(k.toMap())
                }
                map["series"] = tmp
            }
            if self.yaxis != nil {
                map["yaxis"] = self.yaxis?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("series") {
                var tmp : [DescribeRuleBarChartResponseBody.ResultObject.Series] = []
                for v in dict["series"] as! [Any] {
                    var model = DescribeRuleBarChartResponseBody.ResultObject.Series()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.series = tmp
            }
            if dict.keys.contains("yaxis") {
                var model = DescribeRuleBarChartResponseBody.ResultObject.Yaxis()
                model.fromMap(dict["yaxis"] as! [String: Any])
                self.yaxis = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: DescribeRuleBarChartResponseBody.ResultObject?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeRuleBarChartResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeRuleBarChartResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRuleBarChartResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRuleBarChartResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRuleCountByUserIdRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeRuleCountByUserIdResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var limit: Bool?

        public var maxTotalItem: Int32?

        public var totalItem: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.limit != nil {
                map["limit"] = self.limit!
            }
            if self.maxTotalItem != nil {
                map["maxTotalItem"] = self.maxTotalItem!
            }
            if self.totalItem != nil {
                map["totalItem"] = self.totalItem!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("limit") {
                self.limit = dict["limit"] as! Bool
            }
            if dict.keys.contains("maxTotalItem") {
                self.maxTotalItem = dict["maxTotalItem"] as! Int32
            }
            if dict.keys.contains("totalItem") {
                self.totalItem = dict["totalItem"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeRuleCountByUserIdResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeRuleCountByUserIdResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeRuleCountByUserIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRuleCountByUserIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRuleCountByUserIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRuleDetailByRuleIdRequest : Tea.TeaModel {
    public var lang: String?

    public var consoleRuleId: Int64?

    public var regId: String?

    public var ruleId: String?

    public var ruleVersionId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.consoleRuleId != nil {
            map["consoleRuleId"] = self.consoleRuleId!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleId != nil {
            map["ruleId"] = self.ruleId!
        }
        if self.ruleVersionId != nil {
            map["ruleVersionId"] = self.ruleVersionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("consoleRuleId") {
            self.consoleRuleId = dict["consoleRuleId"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleId") {
            self.ruleId = dict["ruleId"] as! String
        }
        if dict.keys.contains("ruleVersionId") {
            self.ruleVersionId = dict["ruleVersionId"] as! Int64
        }
    }
}

public class DescribeRuleDetailByRuleIdResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var bizVersion: String?

        public var consoleRuleId: Int64?

        public var eventCode: String?

        public var eventName: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var logicExpression: String?

        public var mainEventCode: String?

        public var memo: String?

        public var ruleActionMap: [String: Any]?

        public var ruleActions: String?

        public var ruleExpressions: String?

        public var ruleId: String?

        public var ruleName: String?

        public var ruleStatus: String?

        public var ruleVersionId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizVersion != nil {
                map["bizVersion"] = self.bizVersion!
            }
            if self.consoleRuleId != nil {
                map["consoleRuleId"] = self.consoleRuleId!
            }
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.logicExpression != nil {
                map["logicExpression"] = self.logicExpression!
            }
            if self.mainEventCode != nil {
                map["mainEventCode"] = self.mainEventCode!
            }
            if self.memo != nil {
                map["memo"] = self.memo!
            }
            if self.ruleActionMap != nil {
                map["ruleActionMap"] = self.ruleActionMap!
            }
            if self.ruleActions != nil {
                map["ruleActions"] = self.ruleActions!
            }
            if self.ruleExpressions != nil {
                map["ruleExpressions"] = self.ruleExpressions!
            }
            if self.ruleId != nil {
                map["ruleId"] = self.ruleId!
            }
            if self.ruleName != nil {
                map["ruleName"] = self.ruleName!
            }
            if self.ruleStatus != nil {
                map["ruleStatus"] = self.ruleStatus!
            }
            if self.ruleVersionId != nil {
                map["ruleVersionId"] = self.ruleVersionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("bizVersion") {
                self.bizVersion = dict["bizVersion"] as! String
            }
            if dict.keys.contains("consoleRuleId") {
                self.consoleRuleId = dict["consoleRuleId"] as! Int64
            }
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("logicExpression") {
                self.logicExpression = dict["logicExpression"] as! String
            }
            if dict.keys.contains("mainEventCode") {
                self.mainEventCode = dict["mainEventCode"] as! String
            }
            if dict.keys.contains("memo") {
                self.memo = dict["memo"] as! String
            }
            if dict.keys.contains("ruleActionMap") {
                self.ruleActionMap = dict["ruleActionMap"] as! [String: Any]
            }
            if dict.keys.contains("ruleActions") {
                self.ruleActions = dict["ruleActions"] as! String
            }
            if dict.keys.contains("ruleExpressions") {
                self.ruleExpressions = dict["ruleExpressions"] as! String
            }
            if dict.keys.contains("ruleId") {
                self.ruleId = dict["ruleId"] as! String
            }
            if dict.keys.contains("ruleName") {
                self.ruleName = dict["ruleName"] as! String
            }
            if dict.keys.contains("ruleStatus") {
                self.ruleStatus = dict["ruleStatus"] as! String
            }
            if dict.keys.contains("ruleVersionId") {
                self.ruleVersionId = dict["ruleVersionId"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeRuleDetailByRuleIdResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeRuleDetailByRuleIdResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeRuleDetailByRuleIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRuleDetailByRuleIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRuleDetailByRuleIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRuleHitRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var ruleId: String?

    public var ruleSnapshotId: String?

    public var sRequestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleId != nil {
            map["ruleId"] = self.ruleId!
        }
        if self.ruleSnapshotId != nil {
            map["ruleSnapshotId"] = self.ruleSnapshotId!
        }
        if self.sRequestId != nil {
            map["sRequestId"] = self.sRequestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleId") {
            self.ruleId = dict["ruleId"] as! String
        }
        if dict.keys.contains("ruleSnapshotId") {
            self.ruleSnapshotId = dict["ruleSnapshotId"] as! String
        }
        if dict.keys.contains("sRequestId") {
            self.sRequestId = dict["sRequestId"] as! String
        }
    }
}

public class DescribeRuleHitResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! [String: Any]
        }
    }
}

public class DescribeRuleHitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRuleHitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRuleHitResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRuleListByEventCodesListRequest : Tea.TeaModel {
    public var lang: String?

    public var eventCodes: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeRuleListByEventCodesListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var ruleId: String?

        public var ruleName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleId != nil {
                map["ruleId"] = self.ruleId!
            }
            if self.ruleName != nil {
                map["ruleName"] = self.ruleName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ruleId") {
                self.ruleId = dict["ruleId"] as! String
            }
            if dict.keys.contains("ruleName") {
                self.ruleName = dict["ruleName"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeRuleListByEventCodesListResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeRuleListByEventCodesListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeRuleListByEventCodesListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeRuleListByEventCodesListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRuleListByEventCodesListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRuleListByEventCodesListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRulePageListRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var currentPage: String?

    public var eventCode: String?

    public var pageSize: String?

    public var regId: String?

    public var ruleAuthType: String?

    public var ruleName: String?

    public var ruleStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleAuthType != nil {
            map["ruleAuthType"] = self.ruleAuthType!
        }
        if self.ruleName != nil {
            map["ruleName"] = self.ruleName!
        }
        if self.ruleStatus != nil {
            map["ruleStatus"] = self.ruleStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleAuthType") {
            self.ruleAuthType = dict["ruleAuthType"] as! String
        }
        if dict.keys.contains("ruleName") {
            self.ruleName = dict["ruleName"] as! String
        }
        if dict.keys.contains("ruleStatus") {
            self.ruleStatus = dict["ruleStatus"] as! String
        }
    }
}

public class DescribeRulePageListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class ConsoleAudit : Tea.TeaModel {
            public var applyUserId: String?

            public var applyUserName: String?

            public var auditMsg: String?

            public var auditRealUserId: String?

            public var auditRealUserName: String?

            public var auditRemark: String?

            public var auditStatus: String?

            public var auditTime: Int64?

            public var auditUserId: String?

            public var auditUserName: String?

            public var gmtCreate: Int64?

            public var id: Int64?

            public var relationExt: String?

            public var relationId: Int64?

            public var relationName: String?

            public var relationType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applyUserId != nil {
                    map["applyUserId"] = self.applyUserId!
                }
                if self.applyUserName != nil {
                    map["applyUserName"] = self.applyUserName!
                }
                if self.auditMsg != nil {
                    map["auditMsg"] = self.auditMsg!
                }
                if self.auditRealUserId != nil {
                    map["auditRealUserId"] = self.auditRealUserId!
                }
                if self.auditRealUserName != nil {
                    map["auditRealUserName"] = self.auditRealUserName!
                }
                if self.auditRemark != nil {
                    map["auditRemark"] = self.auditRemark!
                }
                if self.auditStatus != nil {
                    map["auditStatus"] = self.auditStatus!
                }
                if self.auditTime != nil {
                    map["auditTime"] = self.auditTime!
                }
                if self.auditUserId != nil {
                    map["auditUserId"] = self.auditUserId!
                }
                if self.auditUserName != nil {
                    map["auditUserName"] = self.auditUserName!
                }
                if self.gmtCreate != nil {
                    map["gmtCreate"] = self.gmtCreate!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.relationExt != nil {
                    map["relationExt"] = self.relationExt!
                }
                if self.relationId != nil {
                    map["relationId"] = self.relationId!
                }
                if self.relationName != nil {
                    map["relationName"] = self.relationName!
                }
                if self.relationType != nil {
                    map["relationType"] = self.relationType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("applyUserId") {
                    self.applyUserId = dict["applyUserId"] as! String
                }
                if dict.keys.contains("applyUserName") {
                    self.applyUserName = dict["applyUserName"] as! String
                }
                if dict.keys.contains("auditMsg") {
                    self.auditMsg = dict["auditMsg"] as! String
                }
                if dict.keys.contains("auditRealUserId") {
                    self.auditRealUserId = dict["auditRealUserId"] as! String
                }
                if dict.keys.contains("auditRealUserName") {
                    self.auditRealUserName = dict["auditRealUserName"] as! String
                }
                if dict.keys.contains("auditRemark") {
                    self.auditRemark = dict["auditRemark"] as! String
                }
                if dict.keys.contains("auditStatus") {
                    self.auditStatus = dict["auditStatus"] as! String
                }
                if dict.keys.contains("auditTime") {
                    self.auditTime = dict["auditTime"] as! Int64
                }
                if dict.keys.contains("auditUserId") {
                    self.auditUserId = dict["auditUserId"] as! String
                }
                if dict.keys.contains("auditUserName") {
                    self.auditUserName = dict["auditUserName"] as! String
                }
                if dict.keys.contains("gmtCreate") {
                    self.gmtCreate = dict["gmtCreate"] as! Int64
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("relationExt") {
                    self.relationExt = dict["relationExt"] as! String
                }
                if dict.keys.contains("relationId") {
                    self.relationId = dict["relationId"] as! Int64
                }
                if dict.keys.contains("relationName") {
                    self.relationName = dict["relationName"] as! String
                }
                if dict.keys.contains("relationType") {
                    self.relationType = dict["relationType"] as! String
                }
            }
        }
        public var authType: String?

        public var consoleAudit: DescribeRulePageListResponseBody.ResultObject.ConsoleAudit?

        public var eventCode: String?

        public var eventName: String?

        public var eventType: String?

        public var externalRuleName: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var mainRuleId: String?

        public var priority: Int64?

        public var ruleAuthType: String?

        public var ruleId: String?

        public var ruleMemo: String?

        public var ruleName: String?

        public var ruleStatus: String?

        public var ruleVersionId: Int64?

        public var templateId: Int64?

        public var version: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.consoleAudit?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authType != nil {
                map["authType"] = self.authType!
            }
            if self.consoleAudit != nil {
                map["consoleAudit"] = self.consoleAudit?.toMap()
            }
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.eventType != nil {
                map["eventType"] = self.eventType!
            }
            if self.externalRuleName != nil {
                map["externalRuleName"] = self.externalRuleName!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.mainRuleId != nil {
                map["mainRuleId"] = self.mainRuleId!
            }
            if self.priority != nil {
                map["priority"] = self.priority!
            }
            if self.ruleAuthType != nil {
                map["ruleAuthType"] = self.ruleAuthType!
            }
            if self.ruleId != nil {
                map["ruleId"] = self.ruleId!
            }
            if self.ruleMemo != nil {
                map["ruleMemo"] = self.ruleMemo!
            }
            if self.ruleName != nil {
                map["ruleName"] = self.ruleName!
            }
            if self.ruleStatus != nil {
                map["ruleStatus"] = self.ruleStatus!
            }
            if self.ruleVersionId != nil {
                map["ruleVersionId"] = self.ruleVersionId!
            }
            if self.templateId != nil {
                map["templateId"] = self.templateId!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("authType") {
                self.authType = dict["authType"] as! String
            }
            if dict.keys.contains("consoleAudit") {
                var model = DescribeRulePageListResponseBody.ResultObject.ConsoleAudit()
                model.fromMap(dict["consoleAudit"] as! [String: Any])
                self.consoleAudit = model
            }
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("eventType") {
                self.eventType = dict["eventType"] as! String
            }
            if dict.keys.contains("externalRuleName") {
                self.externalRuleName = dict["externalRuleName"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("mainRuleId") {
                self.mainRuleId = dict["mainRuleId"] as! String
            }
            if dict.keys.contains("priority") {
                self.priority = dict["priority"] as! Int64
            }
            if dict.keys.contains("ruleAuthType") {
                self.ruleAuthType = dict["ruleAuthType"] as! String
            }
            if dict.keys.contains("ruleId") {
                self.ruleId = dict["ruleId"] as! String
            }
            if dict.keys.contains("ruleMemo") {
                self.ruleMemo = dict["ruleMemo"] as! String
            }
            if dict.keys.contains("ruleName") {
                self.ruleName = dict["ruleName"] as! String
            }
            if dict.keys.contains("ruleStatus") {
                self.ruleStatus = dict["ruleStatus"] as! String
            }
            if dict.keys.contains("ruleVersionId") {
                self.ruleVersionId = dict["ruleVersionId"] as! Int64
            }
            if dict.keys.contains("templateId") {
                self.templateId = dict["templateId"] as! Int64
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! Int32
            }
        }
    }
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var resultObject: [DescribeRulePageListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeRulePageListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeRulePageListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeRulePageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRulePageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRulePageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRuleSnapshotRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var ruleId: String?

    public var snapshotVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleId != nil {
            map["ruleId"] = self.ruleId!
        }
        if self.snapshotVersion != nil {
            map["snapshotVersion"] = self.snapshotVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleId") {
            self.ruleId = dict["ruleId"] as! String
        }
        if dict.keys.contains("snapshotVersion") {
            self.snapshotVersion = dict["snapshotVersion"] as! String
        }
    }
}

public class DescribeRuleSnapshotResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var bizVersion: String?

        public var eventCode: String?

        public var eventName: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var logicExpression: String?

        public var memo: String?

        public var ruleActions: String?

        public var ruleExpressions: String?

        public var ruleId: String?

        public var ruleName: String?

        public var ruleStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizVersion != nil {
                map["bizVersion"] = self.bizVersion!
            }
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.logicExpression != nil {
                map["logicExpression"] = self.logicExpression!
            }
            if self.memo != nil {
                map["memo"] = self.memo!
            }
            if self.ruleActions != nil {
                map["ruleActions"] = self.ruleActions!
            }
            if self.ruleExpressions != nil {
                map["ruleExpressions"] = self.ruleExpressions!
            }
            if self.ruleId != nil {
                map["ruleId"] = self.ruleId!
            }
            if self.ruleName != nil {
                map["ruleName"] = self.ruleName!
            }
            if self.ruleStatus != nil {
                map["ruleStatus"] = self.ruleStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("bizVersion") {
                self.bizVersion = dict["bizVersion"] as! String
            }
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("logicExpression") {
                self.logicExpression = dict["logicExpression"] as! String
            }
            if dict.keys.contains("memo") {
                self.memo = dict["memo"] as! String
            }
            if dict.keys.contains("ruleActions") {
                self.ruleActions = dict["ruleActions"] as! String
            }
            if dict.keys.contains("ruleExpressions") {
                self.ruleExpressions = dict["ruleExpressions"] as! String
            }
            if dict.keys.contains("ruleId") {
                self.ruleId = dict["ruleId"] as! String
            }
            if dict.keys.contains("ruleName") {
                self.ruleName = dict["ruleName"] as! String
            }
            if dict.keys.contains("ruleStatus") {
                self.ruleStatus = dict["ruleStatus"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeRuleSnapshotResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeRuleSnapshotResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeRuleSnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRuleSnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRuleSnapshotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRuleVersionListRequest : Tea.TeaModel {
    public var lang: String?

    public var consoleRuleId: Int64?

    public var regId: String?

    public var ruleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.consoleRuleId != nil {
            map["consoleRuleId"] = self.consoleRuleId!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleId != nil {
            map["ruleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("consoleRuleId") {
            self.consoleRuleId = dict["consoleRuleId"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleId") {
            self.ruleId = dict["ruleId"] as! String
        }
    }
}

public class DescribeRuleVersionListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class ConsoleAudit : Tea.TeaModel {
            public var applyUserId: String?

            public var applyUserName: String?

            public var auditMsg: String?

            public var auditRealUserId: String?

            public var auditRealUserName: String?

            public var auditRemark: String?

            public var auditStatus: String?

            public var auditTime: Int64?

            public var auditUserId: String?

            public var auditUserName: String?

            public var gmtCreate: Int64?

            public var id: Int64?

            public var relationExt: String?

            public var relationId: Int64?

            public var relationName: String?

            public var relationType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applyUserId != nil {
                    map["applyUserId"] = self.applyUserId!
                }
                if self.applyUserName != nil {
                    map["applyUserName"] = self.applyUserName!
                }
                if self.auditMsg != nil {
                    map["auditMsg"] = self.auditMsg!
                }
                if self.auditRealUserId != nil {
                    map["auditRealUserId"] = self.auditRealUserId!
                }
                if self.auditRealUserName != nil {
                    map["auditRealUserName"] = self.auditRealUserName!
                }
                if self.auditRemark != nil {
                    map["auditRemark"] = self.auditRemark!
                }
                if self.auditStatus != nil {
                    map["auditStatus"] = self.auditStatus!
                }
                if self.auditTime != nil {
                    map["auditTime"] = self.auditTime!
                }
                if self.auditUserId != nil {
                    map["auditUserId"] = self.auditUserId!
                }
                if self.auditUserName != nil {
                    map["auditUserName"] = self.auditUserName!
                }
                if self.gmtCreate != nil {
                    map["gmtCreate"] = self.gmtCreate!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.relationExt != nil {
                    map["relationExt"] = self.relationExt!
                }
                if self.relationId != nil {
                    map["relationId"] = self.relationId!
                }
                if self.relationName != nil {
                    map["relationName"] = self.relationName!
                }
                if self.relationType != nil {
                    map["relationType"] = self.relationType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("applyUserId") {
                    self.applyUserId = dict["applyUserId"] as! String
                }
                if dict.keys.contains("applyUserName") {
                    self.applyUserName = dict["applyUserName"] as! String
                }
                if dict.keys.contains("auditMsg") {
                    self.auditMsg = dict["auditMsg"] as! String
                }
                if dict.keys.contains("auditRealUserId") {
                    self.auditRealUserId = dict["auditRealUserId"] as! String
                }
                if dict.keys.contains("auditRealUserName") {
                    self.auditRealUserName = dict["auditRealUserName"] as! String
                }
                if dict.keys.contains("auditRemark") {
                    self.auditRemark = dict["auditRemark"] as! String
                }
                if dict.keys.contains("auditStatus") {
                    self.auditStatus = dict["auditStatus"] as! String
                }
                if dict.keys.contains("auditTime") {
                    self.auditTime = dict["auditTime"] as! Int64
                }
                if dict.keys.contains("auditUserId") {
                    self.auditUserId = dict["auditUserId"] as! String
                }
                if dict.keys.contains("auditUserName") {
                    self.auditUserName = dict["auditUserName"] as! String
                }
                if dict.keys.contains("gmtCreate") {
                    self.gmtCreate = dict["gmtCreate"] as! Int64
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("relationExt") {
                    self.relationExt = dict["relationExt"] as! String
                }
                if dict.keys.contains("relationId") {
                    self.relationId = dict["relationId"] as! Int64
                }
                if dict.keys.contains("relationName") {
                    self.relationName = dict["relationName"] as! String
                }
                if dict.keys.contains("relationType") {
                    self.relationType = dict["relationType"] as! String
                }
            }
        }
        public var consoleAudit: DescribeRuleVersionListResponseBody.ResultObject.ConsoleAudit?

        public var consoleRuleId: Int64?

        public var consoleRuleMemo: String?

        public var consoleRuleName: String?

        public var eventCode: String?

        public var eventType: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var lastOperator: String?

        public var priority: Int64?

        public var ruleId: String?

        public var ruleStatus: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.consoleAudit?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consoleAudit != nil {
                map["consoleAudit"] = self.consoleAudit?.toMap()
            }
            if self.consoleRuleId != nil {
                map["consoleRuleId"] = self.consoleRuleId!
            }
            if self.consoleRuleMemo != nil {
                map["consoleRuleMemo"] = self.consoleRuleMemo!
            }
            if self.consoleRuleName != nil {
                map["consoleRuleName"] = self.consoleRuleName!
            }
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.eventType != nil {
                map["eventType"] = self.eventType!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.lastOperator != nil {
                map["lastOperator"] = self.lastOperator!
            }
            if self.priority != nil {
                map["priority"] = self.priority!
            }
            if self.ruleId != nil {
                map["ruleId"] = self.ruleId!
            }
            if self.ruleStatus != nil {
                map["ruleStatus"] = self.ruleStatus!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("consoleAudit") {
                var model = DescribeRuleVersionListResponseBody.ResultObject.ConsoleAudit()
                model.fromMap(dict["consoleAudit"] as! [String: Any])
                self.consoleAudit = model
            }
            if dict.keys.contains("consoleRuleId") {
                self.consoleRuleId = dict["consoleRuleId"] as! Int64
            }
            if dict.keys.contains("consoleRuleMemo") {
                self.consoleRuleMemo = dict["consoleRuleMemo"] as! String
            }
            if dict.keys.contains("consoleRuleName") {
                self.consoleRuleName = dict["consoleRuleName"] as! String
            }
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("eventType") {
                self.eventType = dict["eventType"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("lastOperator") {
                self.lastOperator = dict["lastOperator"] as! String
            }
            if dict.keys.contains("priority") {
                self.priority = dict["priority"] as! Int64
            }
            if dict.keys.contains("ruleId") {
                self.ruleId = dict["ruleId"] as! String
            }
            if dict.keys.contains("ruleStatus") {
                self.ruleStatus = dict["ruleStatus"] as! String
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeRuleVersionListResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeRuleVersionListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeRuleVersionListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeRuleVersionListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRuleVersionListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRuleVersionListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSDKDownloadListRequest : Tea.TeaModel {
    public var lang: String?

    public var deviceType: String?

    public var listType: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.deviceType != nil {
            map["deviceType"] = self.deviceType!
        }
        if self.listType != nil {
            map["listType"] = self.listType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("deviceType") {
            self.deviceType = dict["deviceType"] as! String
        }
        if dict.keys.contains("listType") {
            self.listType = dict["listType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeSDKDownloadListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var description_: String?

        public var developer: String?

        public var deviceType: String?

        public var downloadUrl: String?

        public var md5: String?

        public var packageName: String?

        public var privacyLink: String?

        public var pushTime: String?

        public var sdkVersion: String?

        public var size: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.developer != nil {
                map["developer"] = self.developer!
            }
            if self.deviceType != nil {
                map["deviceType"] = self.deviceType!
            }
            if self.downloadUrl != nil {
                map["downloadUrl"] = self.downloadUrl!
            }
            if self.md5 != nil {
                map["md5"] = self.md5!
            }
            if self.packageName != nil {
                map["packageName"] = self.packageName!
            }
            if self.privacyLink != nil {
                map["privacyLink"] = self.privacyLink!
            }
            if self.pushTime != nil {
                map["pushTime"] = self.pushTime!
            }
            if self.sdkVersion != nil {
                map["sdkVersion"] = self.sdkVersion!
            }
            if self.size != nil {
                map["size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("developer") {
                self.developer = dict["developer"] as! String
            }
            if dict.keys.contains("deviceType") {
                self.deviceType = dict["deviceType"] as! String
            }
            if dict.keys.contains("downloadUrl") {
                self.downloadUrl = dict["downloadUrl"] as! String
            }
            if dict.keys.contains("md5") {
                self.md5 = dict["md5"] as! String
            }
            if dict.keys.contains("packageName") {
                self.packageName = dict["packageName"] as! String
            }
            if dict.keys.contains("privacyLink") {
                self.privacyLink = dict["privacyLink"] as! String
            }
            if dict.keys.contains("pushTime") {
                self.pushTime = dict["pushTime"] as! String
            }
            if dict.keys.contains("sdkVersion") {
                self.sdkVersion = dict["sdkVersion"] as! String
            }
            if dict.keys.contains("size") {
                self.size = dict["size"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeSDKDownloadListResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeSDKDownloadListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeSDKDownloadListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeSDKDownloadListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSDKDownloadListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSDKDownloadListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSafConsoleRequest : Tea.TeaModel {
    public var lang: String?

    public var content: String?

    public var service: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.service != nil {
            map["service"] = self.service!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("content") {
            self.content = dict["content"] as! String
        }
        if dict.keys.contains("service") {
            self.service = dict["service"] as! String
        }
    }
}

public class DescribeSafConsoleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var bizData: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.bizData != nil {
            map["bizData"] = self.bizData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("bizData") {
            self.bizData = dict["bizData"] as! [String]
        }
    }
}

public class DescribeSafConsoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSafConsoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSafConsoleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSafDeOrderRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: Int32?

    public var endDate: String?

    public var pageSize: Int32?

    public var regId: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.endDate != nil {
            map["endDate"] = self.endDate!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.startDate != nil {
            map["startDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("endDate") {
            self.endDate = dict["endDate"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("startDate") {
            self.startDate = dict["startDate"] as! String
        }
    }
}

public class DescribeSafDeOrderResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var expirationDate: Int64?

        public var openUserType: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expirationDate != nil {
                map["expirationDate"] = self.expirationDate!
            }
            if self.openUserType != nil {
                map["openUserType"] = self.openUserType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("expirationDate") {
                self.expirationDate = dict["expirationDate"] as! Int64
            }
            if dict.keys.contains("openUserType") {
                self.openUserType = dict["openUserType"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeSafDeOrderResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeSafDeOrderResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeSafDeOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSafDeOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSafDeOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSafOrderRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: Int32?

    public var endDate: String?

    public var exactProductCode: String?

    public var pageSize: Int32?

    public var regId: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.endDate != nil {
            map["endDate"] = self.endDate!
        }
        if self.exactProductCode != nil {
            map["exactProductCode"] = self.exactProductCode!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.startDate != nil {
            map["startDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("endDate") {
            self.endDate = dict["endDate"] as! String
        }
        if dict.keys.contains("exactProductCode") {
            self.exactProductCode = dict["exactProductCode"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("startDate") {
            self.startDate = dict["startDate"] as! String
        }
    }
}

public class DescribeSafOrderResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var expirationDate: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expirationDate != nil {
                map["expirationDate"] = self.expirationDate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("expirationDate") {
                self.expirationDate = dict["expirationDate"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeSafOrderResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeSafOrderResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeSafOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSafOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSafOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSafStartConfigRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeSafStartConfigResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var deviceTypes: [String]?

        public var eventCodes: [String]?

        public var languages: [String]?

        public var serverRegions: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceTypes != nil {
                map["deviceTypes"] = self.deviceTypes!
            }
            if self.eventCodes != nil {
                map["eventCodes"] = self.eventCodes!
            }
            if self.languages != nil {
                map["languages"] = self.languages!
            }
            if self.serverRegions != nil {
                map["serverRegions"] = self.serverRegions!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("deviceTypes") {
                self.deviceTypes = dict["deviceTypes"] as! [String]
            }
            if dict.keys.contains("eventCodes") {
                self.eventCodes = dict["eventCodes"] as! [String]
            }
            if dict.keys.contains("languages") {
                self.languages = dict["languages"] as! [String]
            }
            if dict.keys.contains("serverRegions") {
                self.serverRegions = dict["serverRegions"] as! [String]
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeSafStartConfigResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeSafStartConfigResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeSafStartConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSafStartConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSafStartConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSafStartStepsRequest : Tea.TeaModel {
    public var lang: String?

    public var aliyunServer: Bool?

    public var deviceTypesStr: String?

    public var eventCode: String?

    public var language: String?

    public var regId: String?

    public var serverRegion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.aliyunServer != nil {
            map["aliyunServer"] = self.aliyunServer!
        }
        if self.deviceTypesStr != nil {
            map["deviceTypesStr"] = self.deviceTypesStr!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.language != nil {
            map["language"] = self.language!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.serverRegion != nil {
            map["serverRegion"] = self.serverRegion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("aliyunServer") {
            self.aliyunServer = dict["aliyunServer"] as! Bool
        }
        if dict.keys.contains("deviceTypesStr") {
            self.deviceTypesStr = dict["deviceTypesStr"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("language") {
            self.language = dict["language"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("serverRegion") {
            self.serverRegion = dict["serverRegion"] as! String
        }
    }
}

public class DescribeSafStartStepsResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var content: String?

        public var id: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("content") {
                self.content = dict["content"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeSafStartStepsResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeSafStartStepsResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeSafStartStepsResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeSafStartStepsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSafStartStepsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSafStartStepsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSafTagListRequest : Tea.TeaModel {
    public var lang: String?

    public var apiId: String?

    public var currentPage: String?

    public var pageSize: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.apiId != nil {
            map["apiId"] = self.apiId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("apiId") {
            self.apiId = dict["apiId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeSafTagListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var tagDesc: String?

        public var tagMean: String?

        public var tagName: String?

        public var tagState: String?

        public var tagType: String?

        public var tagUid: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagDesc != nil {
                map["tagDesc"] = self.tagDesc!
            }
            if self.tagMean != nil {
                map["tagMean"] = self.tagMean!
            }
            if self.tagName != nil {
                map["tagName"] = self.tagName!
            }
            if self.tagState != nil {
                map["tagState"] = self.tagState!
            }
            if self.tagType != nil {
                map["tagType"] = self.tagType!
            }
            if self.tagUid != nil {
                map["tagUid"] = self.tagUid!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tagDesc") {
                self.tagDesc = dict["tagDesc"] as! String
            }
            if dict.keys.contains("tagMean") {
                self.tagMean = dict["tagMean"] as! String
            }
            if dict.keys.contains("tagName") {
                self.tagName = dict["tagName"] as! String
            }
            if dict.keys.contains("tagState") {
                self.tagState = dict["tagState"] as! String
            }
            if dict.keys.contains("tagType") {
                self.tagType = dict["tagType"] as! String
            }
            if dict.keys.contains("tagUid") {
                self.tagUid = dict["tagUid"] as! String
            }
            if dict.keys.contains("updateTime") {
                self.updateTime = dict["updateTime"] as! String
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeSafTagListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeSafTagListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeSafTagListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeSafTagListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSafTagListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSafTagListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSampleDataListRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: String?

    public var deleteTag: String?

    public var pageSize: String?

    public var queryContent: String?

    public var regId: String?

    public var sampleId: Int64?

    public var scene: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.deleteTag != nil {
            map["deleteTag"] = self.deleteTag!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.queryContent != nil {
            map["queryContent"] = self.queryContent!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.sampleId != nil {
            map["sampleId"] = self.sampleId!
        }
        if self.scene != nil {
            map["scene"] = self.scene!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("deleteTag") {
            self.deleteTag = dict["deleteTag"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("queryContent") {
            self.queryContent = dict["queryContent"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("sampleId") {
            self.sampleId = dict["sampleId"] as! Int64
        }
        if dict.keys.contains("scene") {
            self.scene = dict["scene"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
    }
}

public class DescribeSampleDataListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var classificationType: String?

        public var dataDistributed: String?

        public var dataTitle: String?

        public var deleteTag: String?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var name: String?

        public var normalSize: Int64?

        public var recallConfig: String?

        public var riskSize: Int64?

        public var riskValue: String?

        public var sampleLabelDetail: String?

        public var sampleSize: Int64?

        public var scene: String?

        public var status: String?

        public var storePath: String?

        public var storeType: String?

        public var supportRecall: String?

        public var userId: Int64?

        public var version: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classificationType != nil {
                map["classificationType"] = self.classificationType!
            }
            if self.dataDistributed != nil {
                map["dataDistributed"] = self.dataDistributed!
            }
            if self.dataTitle != nil {
                map["dataTitle"] = self.dataTitle!
            }
            if self.deleteTag != nil {
                map["deleteTag"] = self.deleteTag!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.normalSize != nil {
                map["normalSize"] = self.normalSize!
            }
            if self.recallConfig != nil {
                map["recallConfig"] = self.recallConfig!
            }
            if self.riskSize != nil {
                map["riskSize"] = self.riskSize!
            }
            if self.riskValue != nil {
                map["riskValue"] = self.riskValue!
            }
            if self.sampleLabelDetail != nil {
                map["sampleLabelDetail"] = self.sampleLabelDetail!
            }
            if self.sampleSize != nil {
                map["sampleSize"] = self.sampleSize!
            }
            if self.scene != nil {
                map["scene"] = self.scene!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.storePath != nil {
                map["storePath"] = self.storePath!
            }
            if self.storeType != nil {
                map["storeType"] = self.storeType!
            }
            if self.supportRecall != nil {
                map["supportRecall"] = self.supportRecall!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("classificationType") {
                self.classificationType = dict["classificationType"] as! String
            }
            if dict.keys.contains("dataDistributed") {
                self.dataDistributed = dict["dataDistributed"] as! String
            }
            if dict.keys.contains("dataTitle") {
                self.dataTitle = dict["dataTitle"] as! String
            }
            if dict.keys.contains("deleteTag") {
                self.deleteTag = dict["deleteTag"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("normalSize") {
                self.normalSize = dict["normalSize"] as! Int64
            }
            if dict.keys.contains("recallConfig") {
                self.recallConfig = dict["recallConfig"] as! String
            }
            if dict.keys.contains("riskSize") {
                self.riskSize = dict["riskSize"] as! Int64
            }
            if dict.keys.contains("riskValue") {
                self.riskValue = dict["riskValue"] as! String
            }
            if dict.keys.contains("sampleLabelDetail") {
                self.sampleLabelDetail = dict["sampleLabelDetail"] as! String
            }
            if dict.keys.contains("sampleSize") {
                self.sampleSize = dict["sampleSize"] as! Int64
            }
            if dict.keys.contains("scene") {
                self.scene = dict["scene"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("storePath") {
                self.storePath = dict["storePath"] as! String
            }
            if dict.keys.contains("storeType") {
                self.storeType = dict["storeType"] as! String
            }
            if dict.keys.contains("supportRecall") {
                self.supportRecall = dict["supportRecall"] as! String
            }
            if dict.keys.contains("userId") {
                self.userId = dict["userId"] as! Int64
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeSampleDataListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeSampleDataListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeSampleDataListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeSampleDataListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSampleDataListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSampleDataListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSampleDemoDownloadUrlRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var scene: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.scene != nil {
            map["scene"] = self.scene!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("scene") {
            self.scene = dict["scene"] as! String
        }
    }
}

public class DescribeSampleDemoDownloadUrlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeSampleDemoDownloadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSampleDemoDownloadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSampleDemoDownloadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSampleDownloadUrlRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var sampleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.sampleId != nil {
            map["sampleId"] = self.sampleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("sampleId") {
            self.sampleId = dict["sampleId"] as! Int64
        }
    }
}

public class DescribeSampleDownloadUrlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeSampleDownloadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSampleDownloadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSampleDownloadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSampleInfoRequest : Tea.TeaModel {
    public var lang: String?

    public var id: Int64?

    public var regId: String?

    public var versions: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.versions != nil {
            map["versions"] = self.versions!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("versions") {
            self.versions = dict["versions"] as! Int32
        }
    }
}

public class DescribeSampleInfoResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var id: Int64?

        public var sampleTags: String?

        public var sampleType: String?

        public var sampleValue: String?

        public var updateTime: String?

        public var version: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.sampleTags != nil {
                map["sampleTags"] = self.sampleTags!
            }
            if self.sampleType != nil {
                map["sampleType"] = self.sampleType!
            }
            if self.sampleValue != nil {
                map["sampleValue"] = self.sampleValue!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("sampleTags") {
                self.sampleTags = dict["sampleTags"] as! String
            }
            if dict.keys.contains("sampleType") {
                self.sampleType = dict["sampleType"] as! String
            }
            if dict.keys.contains("sampleValue") {
                self.sampleValue = dict["sampleValue"] as! String
            }
            if dict.keys.contains("updateTime") {
                self.updateTime = dict["updateTime"] as! String
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeSampleInfoResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeSampleInfoResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeSampleInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSampleInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSampleInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSampleListRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var regId: String?

    public var sampleType: String?

    public var sampleValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.sampleType != nil {
            map["sampleType"] = self.sampleType!
        }
        if self.sampleValue != nil {
            map["sampleValue"] = self.sampleValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("sampleType") {
            self.sampleType = dict["sampleType"] as! String
        }
        if dict.keys.contains("sampleValue") {
            self.sampleValue = dict["sampleValue"] as! String
        }
    }
}

public class DescribeSampleListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var id: Int64?

        public var sampleTags: String?

        public var sampleType: Int32?

        public var sampleValue: String?

        public var updateTime: Int64?

        public var version: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.sampleTags != nil {
                map["sampleTags"] = self.sampleTags!
            }
            if self.sampleType != nil {
                map["sampleType"] = self.sampleType!
            }
            if self.sampleValue != nil {
                map["sampleValue"] = self.sampleValue!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("sampleTags") {
                self.sampleTags = dict["sampleTags"] as! String
            }
            if dict.keys.contains("sampleType") {
                self.sampleType = dict["sampleType"] as! Int32
            }
            if dict.keys.contains("sampleValue") {
                self.sampleValue = dict["sampleValue"] as! String
            }
            if dict.keys.contains("updateTime") {
                self.updateTime = dict["updateTime"] as! Int64
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeSampleListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeSampleListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeSampleListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeSampleListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSampleListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSampleListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSampleSceneListRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeSampleSceneListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var bizType: String?

        public var configKey: String?

        public var configValue: String?

        public var creator: String?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var lastModifiedOperator: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizType != nil {
                map["bizType"] = self.bizType!
            }
            if self.configKey != nil {
                map["configKey"] = self.configKey!
            }
            if self.configValue != nil {
                map["configValue"] = self.configValue!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.lastModifiedOperator != nil {
                map["lastModifiedOperator"] = self.lastModifiedOperator!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("bizType") {
                self.bizType = dict["bizType"] as! String
            }
            if dict.keys.contains("configKey") {
                self.configKey = dict["configKey"] as! String
            }
            if dict.keys.contains("configValue") {
                self.configValue = dict["configValue"] as! String
            }
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("lastModifiedOperator") {
                self.lastModifiedOperator = dict["lastModifiedOperator"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeSampleSceneListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeSampleSceneListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeSampleSceneListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeSampleSceneListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSampleSceneListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSampleSceneListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSampleTagListRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeSampleTagListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeSampleTagListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSampleTagListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSampleTagListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSampleUploadPolicyRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeSampleUploadPolicyResponseBody : Tea.TeaModel {
    public var accessId: String?

    public var host: String?

    public var key: String?

    public var policy: String?

    public var requestId: String?

    public var signature: String?

    public var stsToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessId != nil {
            map["AccessId"] = self.accessId!
        }
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.signature != nil {
            map["Signature"] = self.signature!
        }
        if self.stsToken != nil {
            map["StsToken"] = self.stsToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessId") {
            self.accessId = dict["AccessId"] as! String
        }
        if dict.keys.contains("Host") {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Signature") {
            self.signature = dict["Signature"] as! String
        }
        if dict.keys.contains("StsToken") {
            self.stsToken = dict["StsToken"] as! String
        }
    }
}

public class DescribeSampleUploadPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSampleUploadPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSampleUploadPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSceneAllEventNameCodeListRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeSceneAllEventNameCodeListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Children : Tea.TeaModel {
            public var createType: String?

            public var eventCode: String?

            public var eventName: String?

            public var eventType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createType != nil {
                    map["createType"] = self.createType!
                }
                if self.eventCode != nil {
                    map["eventCode"] = self.eventCode!
                }
                if self.eventName != nil {
                    map["eventName"] = self.eventName!
                }
                if self.eventType != nil {
                    map["eventType"] = self.eventType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("createType") {
                    self.createType = dict["createType"] as! String
                }
                if dict.keys.contains("eventCode") {
                    self.eventCode = dict["eventCode"] as! String
                }
                if dict.keys.contains("eventName") {
                    self.eventName = dict["eventName"] as! String
                }
                if dict.keys.contains("eventType") {
                    self.eventType = dict["eventType"] as! String
                }
            }
        }
        public var children: [DescribeSceneAllEventNameCodeListResponseBody.ResultObject.Children]?

        public var createType: String?

        public var eventCode: String?

        public var eventName: String?

        public var eventType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.children != nil {
                var tmp : [Any] = []
                for k in self.children! {
                    tmp.append(k.toMap())
                }
                map["children"] = tmp
            }
            if self.createType != nil {
                map["createType"] = self.createType!
            }
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.eventType != nil {
                map["eventType"] = self.eventType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("children") {
                var tmp : [DescribeSceneAllEventNameCodeListResponseBody.ResultObject.Children] = []
                for v in dict["children"] as! [Any] {
                    var model = DescribeSceneAllEventNameCodeListResponseBody.ResultObject.Children()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.children = tmp
            }
            if dict.keys.contains("createType") {
                self.createType = dict["createType"] as! String
            }
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("eventType") {
                self.eventType = dict["eventType"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: [DescribeSceneAllEventNameCodeListResponseBody.ResultObject]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeSceneAllEventNameCodeListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeSceneAllEventNameCodeListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeSceneAllEventNameCodeListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSceneAllEventNameCodeListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSceneAllEventNameCodeListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSceneEventPageListRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: String?

    public var nameOrCode: String?

    public var pageSize: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.nameOrCode != nil {
            map["nameOrCode"] = self.nameOrCode!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("nameOrCode") {
            self.nameOrCode = dict["nameOrCode"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeSceneEventPageListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var commonRuleCount: String?

        public var customRuleCount: String?

        public var eventCode: String?

        public var eventName: String?

        public var gmtModified: String?

        public var modifier: String?

        public var normalRuleCount: String?

        public var service: String?

        public var useStatus: String?

        public var whiteBoxRuleCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commonRuleCount != nil {
                map["commonRuleCount"] = self.commonRuleCount!
            }
            if self.customRuleCount != nil {
                map["customRuleCount"] = self.customRuleCount!
            }
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.normalRuleCount != nil {
                map["normalRuleCount"] = self.normalRuleCount!
            }
            if self.service != nil {
                map["service"] = self.service!
            }
            if self.useStatus != nil {
                map["useStatus"] = self.useStatus!
            }
            if self.whiteBoxRuleCount != nil {
                map["whiteBoxRuleCount"] = self.whiteBoxRuleCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("commonRuleCount") {
                self.commonRuleCount = dict["commonRuleCount"] as! String
            }
            if dict.keys.contains("customRuleCount") {
                self.customRuleCount = dict["customRuleCount"] as! String
            }
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! String
            }
            if dict.keys.contains("modifier") {
                self.modifier = dict["modifier"] as! String
            }
            if dict.keys.contains("normalRuleCount") {
                self.normalRuleCount = dict["normalRuleCount"] as! String
            }
            if dict.keys.contains("service") {
                self.service = dict["service"] as! String
            }
            if dict.keys.contains("useStatus") {
                self.useStatus = dict["useStatus"] as! String
            }
            if dict.keys.contains("whiteBoxRuleCount") {
                self.whiteBoxRuleCount = dict["whiteBoxRuleCount"] as! String
            }
        }
    }
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var resultObject: [DescribeSceneEventPageListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeSceneEventPageListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeSceneEventPageListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeSceneEventPageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSceneEventPageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSceneEventPageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSceneRulePageListRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var currentPage: String?

    public var eventCode: String?

    public var pageSize: String?

    public var regId: String?

    public var ruleAuthType: String?

    public var ruleName: String?

    public var ruleStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleAuthType != nil {
            map["ruleAuthType"] = self.ruleAuthType!
        }
        if self.ruleName != nil {
            map["ruleName"] = self.ruleName!
        }
        if self.ruleStatus != nil {
            map["ruleStatus"] = self.ruleStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleAuthType") {
            self.ruleAuthType = dict["ruleAuthType"] as! String
        }
        if dict.keys.contains("ruleName") {
            self.ruleName = dict["ruleName"] as! String
        }
        if dict.keys.contains("ruleStatus") {
            self.ruleStatus = dict["ruleStatus"] as! String
        }
    }
}

public class DescribeSceneRulePageListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class ConsoleAudit : Tea.TeaModel {
            public var applyUserId: String?

            public var applyUserName: String?

            public var auditMsg: String?

            public var auditRealUserId: String?

            public var auditRealUserName: String?

            public var auditRemark: String?

            public var auditStatus: String?

            public var auditTime: Int64?

            public var auditUserId: String?

            public var auditUserName: String?

            public var gmtCreate: Int64?

            public var id: Int64?

            public var relationExt: String?

            public var relationId: Int64?

            public var relationName: String?

            public var relationType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applyUserId != nil {
                    map["applyUserId"] = self.applyUserId!
                }
                if self.applyUserName != nil {
                    map["applyUserName"] = self.applyUserName!
                }
                if self.auditMsg != nil {
                    map["auditMsg"] = self.auditMsg!
                }
                if self.auditRealUserId != nil {
                    map["auditRealUserId"] = self.auditRealUserId!
                }
                if self.auditRealUserName != nil {
                    map["auditRealUserName"] = self.auditRealUserName!
                }
                if self.auditRemark != nil {
                    map["auditRemark"] = self.auditRemark!
                }
                if self.auditStatus != nil {
                    map["auditStatus"] = self.auditStatus!
                }
                if self.auditTime != nil {
                    map["auditTime"] = self.auditTime!
                }
                if self.auditUserId != nil {
                    map["auditUserId"] = self.auditUserId!
                }
                if self.auditUserName != nil {
                    map["auditUserName"] = self.auditUserName!
                }
                if self.gmtCreate != nil {
                    map["gmtCreate"] = self.gmtCreate!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.relationExt != nil {
                    map["relationExt"] = self.relationExt!
                }
                if self.relationId != nil {
                    map["relationId"] = self.relationId!
                }
                if self.relationName != nil {
                    map["relationName"] = self.relationName!
                }
                if self.relationType != nil {
                    map["relationType"] = self.relationType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("applyUserId") {
                    self.applyUserId = dict["applyUserId"] as! String
                }
                if dict.keys.contains("applyUserName") {
                    self.applyUserName = dict["applyUserName"] as! String
                }
                if dict.keys.contains("auditMsg") {
                    self.auditMsg = dict["auditMsg"] as! String
                }
                if dict.keys.contains("auditRealUserId") {
                    self.auditRealUserId = dict["auditRealUserId"] as! String
                }
                if dict.keys.contains("auditRealUserName") {
                    self.auditRealUserName = dict["auditRealUserName"] as! String
                }
                if dict.keys.contains("auditRemark") {
                    self.auditRemark = dict["auditRemark"] as! String
                }
                if dict.keys.contains("auditStatus") {
                    self.auditStatus = dict["auditStatus"] as! String
                }
                if dict.keys.contains("auditTime") {
                    self.auditTime = dict["auditTime"] as! Int64
                }
                if dict.keys.contains("auditUserId") {
                    self.auditUserId = dict["auditUserId"] as! String
                }
                if dict.keys.contains("auditUserName") {
                    self.auditUserName = dict["auditUserName"] as! String
                }
                if dict.keys.contains("gmtCreate") {
                    self.gmtCreate = dict["gmtCreate"] as! Int64
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("relationExt") {
                    self.relationExt = dict["relationExt"] as! String
                }
                if dict.keys.contains("relationId") {
                    self.relationId = dict["relationId"] as! Int64
                }
                if dict.keys.contains("relationName") {
                    self.relationName = dict["relationName"] as! String
                }
                if dict.keys.contains("relationType") {
                    self.relationType = dict["relationType"] as! String
                }
            }
        }
        public var authType: String?

        public var consoleAudit: DescribeSceneRulePageListResponseBody.ResultObject.ConsoleAudit?

        public var eventCode: String?

        public var eventName: String?

        public var eventType: String?

        public var externalRuleName: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var mainRuleId: String?

        public var priority: Int64?

        public var ruleAuthType: String?

        public var ruleId: String?

        public var ruleMemo: String?

        public var ruleName: String?

        public var ruleStatus: String?

        public var ruleVersionId: Int64?

        public var templateId: Int64?

        public var version: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.consoleAudit?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authType != nil {
                map["authType"] = self.authType!
            }
            if self.consoleAudit != nil {
                map["consoleAudit"] = self.consoleAudit?.toMap()
            }
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.eventType != nil {
                map["eventType"] = self.eventType!
            }
            if self.externalRuleName != nil {
                map["externalRuleName"] = self.externalRuleName!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.mainRuleId != nil {
                map["mainRuleId"] = self.mainRuleId!
            }
            if self.priority != nil {
                map["priority"] = self.priority!
            }
            if self.ruleAuthType != nil {
                map["ruleAuthType"] = self.ruleAuthType!
            }
            if self.ruleId != nil {
                map["ruleId"] = self.ruleId!
            }
            if self.ruleMemo != nil {
                map["ruleMemo"] = self.ruleMemo!
            }
            if self.ruleName != nil {
                map["ruleName"] = self.ruleName!
            }
            if self.ruleStatus != nil {
                map["ruleStatus"] = self.ruleStatus!
            }
            if self.ruleVersionId != nil {
                map["ruleVersionId"] = self.ruleVersionId!
            }
            if self.templateId != nil {
                map["templateId"] = self.templateId!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("authType") {
                self.authType = dict["authType"] as! String
            }
            if dict.keys.contains("consoleAudit") {
                var model = DescribeSceneRulePageListResponseBody.ResultObject.ConsoleAudit()
                model.fromMap(dict["consoleAudit"] as! [String: Any])
                self.consoleAudit = model
            }
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("eventType") {
                self.eventType = dict["eventType"] as! String
            }
            if dict.keys.contains("externalRuleName") {
                self.externalRuleName = dict["externalRuleName"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("mainRuleId") {
                self.mainRuleId = dict["mainRuleId"] as! String
            }
            if dict.keys.contains("priority") {
                self.priority = dict["priority"] as! Int64
            }
            if dict.keys.contains("ruleAuthType") {
                self.ruleAuthType = dict["ruleAuthType"] as! String
            }
            if dict.keys.contains("ruleId") {
                self.ruleId = dict["ruleId"] as! String
            }
            if dict.keys.contains("ruleMemo") {
                self.ruleMemo = dict["ruleMemo"] as! String
            }
            if dict.keys.contains("ruleName") {
                self.ruleName = dict["ruleName"] as! String
            }
            if dict.keys.contains("ruleStatus") {
                self.ruleStatus = dict["ruleStatus"] as! String
            }
            if dict.keys.contains("ruleVersionId") {
                self.ruleVersionId = dict["ruleVersionId"] as! Int64
            }
            if dict.keys.contains("templateId") {
                self.templateId = dict["templateId"] as! Int64
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! Int32
            }
        }
    }
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var resultObject: [DescribeSceneRulePageListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeSceneRulePageListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeSceneRulePageListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeSceneRulePageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSceneRulePageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSceneRulePageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScoreSectionNumLineChartRequest : Tea.TeaModel {
    public var lang: String?

    public var beginTime: String?

    public var byPassEventCodes: String?

    public var endTime: String?

    public var mainEventCodes: String?

    public var regId: String?

    public var shuntEventCodes: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.byPassEventCodes != nil {
            map["byPassEventCodes"] = self.byPassEventCodes!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.mainEventCodes != nil {
            map["mainEventCodes"] = self.mainEventCodes!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.shuntEventCodes != nil {
            map["shuntEventCodes"] = self.shuntEventCodes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! String
        }
        if dict.keys.contains("byPassEventCodes") {
            self.byPassEventCodes = dict["byPassEventCodes"] as! String
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("mainEventCodes") {
            self.mainEventCodes = dict["mainEventCodes"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("shuntEventCodes") {
            self.shuntEventCodes = dict["shuntEventCodes"] as! String
        }
    }
}

public class DescribeScoreSectionNumLineChartResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Series : Tea.TeaModel {
            public var data: [String]?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    self.data = dict["data"] as! [String]
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public class Xaxis : Tea.TeaModel {
            public var data: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    self.data = dict["data"] as! [String]
                }
            }
        }
        public var series: [DescribeScoreSectionNumLineChartResponseBody.ResultObject.Series]?

        public var xaxis: DescribeScoreSectionNumLineChartResponseBody.ResultObject.Xaxis?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.xaxis?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.series != nil {
                var tmp : [Any] = []
                for k in self.series! {
                    tmp.append(k.toMap())
                }
                map["series"] = tmp
            }
            if self.xaxis != nil {
                map["xaxis"] = self.xaxis?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("series") {
                var tmp : [DescribeScoreSectionNumLineChartResponseBody.ResultObject.Series] = []
                for v in dict["series"] as! [Any] {
                    var model = DescribeScoreSectionNumLineChartResponseBody.ResultObject.Series()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.series = tmp
            }
            if dict.keys.contains("xaxis") {
                var model = DescribeScoreSectionNumLineChartResponseBody.ResultObject.Xaxis()
                model.fromMap(dict["xaxis"] as! [String: Any])
                self.xaxis = model
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeScoreSectionNumLineChartResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeScoreSectionNumLineChartResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeScoreSectionNumLineChartResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScoreSectionNumLineChartResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeScoreSectionNumLineChartResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScoreSectionPieChartRequest : Tea.TeaModel {
    public var lang: String?

    public var beginTime: Int64?

    public var endTime: Int64?

    public var eventCodes: String?

    public var eventType: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.eventType != nil {
            map["eventType"] = self.eventType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! Int64
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("eventType") {
            self.eventType = dict["eventType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeScoreSectionPieChartResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Grid : Tea.TeaModel {
            public var show: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.show != nil {
                    map["show"] = self.show!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("show") {
                    self.show = dict["show"] as! Bool
                }
            }
        }
        public class Series : Tea.TeaModel {
            public class Data : Tea.TeaModel {
                public var name: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("value") {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public var data: [DescribeScoreSectionPieChartResponseBody.ResultObject.Series.Data]?

            public var name: String?

            public var roseType: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    var tmp : [Any] = []
                    for k in self.data! {
                        tmp.append(k.toMap())
                    }
                    map["data"] = tmp
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.roseType != nil {
                    map["roseType"] = self.roseType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    var tmp : [DescribeScoreSectionPieChartResponseBody.ResultObject.Series.Data] = []
                    for v in dict["data"] as! [Any] {
                        var model = DescribeScoreSectionPieChartResponseBody.ResultObject.Series.Data()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.data = tmp
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("roseType") {
                    self.roseType = dict["roseType"] as! Bool
                }
            }
        }
        public var animation: Bool?

        public var grid: DescribeScoreSectionPieChartResponseBody.ResultObject.Grid?

        public var series: [DescribeScoreSectionPieChartResponseBody.ResultObject.Series]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.grid?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.animation != nil {
                map["animation"] = self.animation!
            }
            if self.grid != nil {
                map["grid"] = self.grid?.toMap()
            }
            if self.series != nil {
                var tmp : [Any] = []
                for k in self.series! {
                    tmp.append(k.toMap())
                }
                map["series"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("animation") {
                self.animation = dict["animation"] as! Bool
            }
            if dict.keys.contains("grid") {
                var model = DescribeScoreSectionPieChartResponseBody.ResultObject.Grid()
                model.fromMap(dict["grid"] as! [String: Any])
                self.grid = model
            }
            if dict.keys.contains("series") {
                var tmp : [DescribeScoreSectionPieChartResponseBody.ResultObject.Series] = []
                for v in dict["series"] as! [Any] {
                    var model = DescribeScoreSectionPieChartResponseBody.ResultObject.Series()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.series = tmp
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeScoreSectionPieChartResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeScoreSectionPieChartResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeScoreSectionPieChartResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScoreSectionPieChartResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeScoreSectionPieChartResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScoreSectionRatioLineChartRequest : Tea.TeaModel {
    public var lang: String?

    public var beginTime: String?

    public var byPassEventCodes: String?

    public var endTime: String?

    public var mainEventCodes: String?

    public var regId: String?

    public var shuntEventCodes: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.byPassEventCodes != nil {
            map["byPassEventCodes"] = self.byPassEventCodes!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.mainEventCodes != nil {
            map["mainEventCodes"] = self.mainEventCodes!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.shuntEventCodes != nil {
            map["shuntEventCodes"] = self.shuntEventCodes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! String
        }
        if dict.keys.contains("byPassEventCodes") {
            self.byPassEventCodes = dict["byPassEventCodes"] as! String
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("mainEventCodes") {
            self.mainEventCodes = dict["mainEventCodes"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("shuntEventCodes") {
            self.shuntEventCodes = dict["shuntEventCodes"] as! String
        }
    }
}

public class DescribeScoreSectionRatioLineChartResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Series : Tea.TeaModel {
            public var data: [String]?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    self.data = dict["data"] as! [String]
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public class Xaxis : Tea.TeaModel {
            public var data: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    self.data = dict["data"] as! [String]
                }
            }
        }
        public var series: [DescribeScoreSectionRatioLineChartResponseBody.ResultObject.Series]?

        public var xaxis: DescribeScoreSectionRatioLineChartResponseBody.ResultObject.Xaxis?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.xaxis?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.series != nil {
                var tmp : [Any] = []
                for k in self.series! {
                    tmp.append(k.toMap())
                }
                map["series"] = tmp
            }
            if self.xaxis != nil {
                map["xaxis"] = self.xaxis?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("series") {
                var tmp : [DescribeScoreSectionRatioLineChartResponseBody.ResultObject.Series] = []
                for v in dict["series"] as! [Any] {
                    var model = DescribeScoreSectionRatioLineChartResponseBody.ResultObject.Series()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.series = tmp
            }
            if dict.keys.contains("xaxis") {
                var model = DescribeScoreSectionRatioLineChartResponseBody.ResultObject.Xaxis()
                model.fromMap(dict["xaxis"] as! [String: Any])
                self.xaxis = model
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeScoreSectionRatioLineChartResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeScoreSectionRatioLineChartResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeScoreSectionRatioLineChartResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScoreSectionRatioLineChartResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeScoreSectionRatioLineChartResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSelectItemRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeSelectItemResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var monitorStatusList: [String]?

        public var taskIdList: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorStatusList != nil {
                map["monitorStatusList"] = self.monitorStatusList!
            }
            if self.taskIdList != nil {
                map["taskIdList"] = self.taskIdList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("monitorStatusList") {
                self.monitorStatusList = dict["monitorStatusList"] as! [String]
            }
            if dict.keys.contains("taskIdList") {
                self.taskIdList = dict["taskIdList"] as! [String]
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeSelectItemResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeSelectItemResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeSelectItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSelectItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSelectItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeServiceAppKeyRequest : Tea.TeaModel {
    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeServiceAppKeyResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: Bool?

    public var uccess: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        if self.uccess != nil {
            map["uccess"] = self.uccess!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
        if dict.keys.contains("uccess") {
            self.uccess = dict["uccess"] as! Bool
        }
    }
}

public class DescribeServiceAppKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeServiceAppKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeServiceAppKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeServiceConsumeRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: String?

    public var endDate: String?

    public var pageSize: String?

    public var regId: String?

    public var serviceCode: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.endDate != nil {
            map["endDate"] = self.endDate!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.serviceCode != nil {
            map["serviceCode"] = self.serviceCode!
        }
        if self.startDate != nil {
            map["startDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("endDate") {
            self.endDate = dict["endDate"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("serviceCode") {
            self.serviceCode = dict["serviceCode"] as! String
        }
        if dict.keys.contains("startDate") {
            self.startDate = dict["startDate"] as! String
        }
    }
}

public class DescribeServiceConsumeResponseBody : Tea.TeaModel {
    public class ConsumeRecords : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var count: Int32?

            public var serviceCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["count"] = self.count!
                }
                if self.serviceCode != nil {
                    map["serviceCode"] = self.serviceCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("count") {
                    self.count = dict["count"] as! Int32
                }
                if dict.keys.contains("serviceCode") {
                    self.serviceCode = dict["serviceCode"] as! String
                }
            }
        }
        public var date: String?

        public var records: [DescribeServiceConsumeResponseBody.ConsumeRecords.Records]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["date"] = self.date!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["records"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("date") {
                self.date = dict["date"] as! String
            }
            if dict.keys.contains("records") {
                var tmp : [DescribeServiceConsumeResponseBody.ConsumeRecords.Records] = []
                for v in dict["records"] as! [Any] {
                    var model = DescribeServiceConsumeResponseBody.ConsumeRecords.Records()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.records = tmp
            }
        }
    }
    public var requestId: String?

    public var consumeRecords: [DescribeServiceConsumeResponseBody.ConsumeRecords]?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.consumeRecords != nil {
            var tmp : [Any] = []
            for k in self.consumeRecords! {
                tmp.append(k.toMap())
            }
            map["consumeRecords"] = tmp
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("consumeRecords") {
            var tmp : [DescribeServiceConsumeResponseBody.ConsumeRecords] = []
            for v in dict["consumeRecords"] as! [Any] {
                var model = DescribeServiceConsumeResponseBody.ConsumeRecords()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.consumeRecords = tmp
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeServiceConsumeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeServiceConsumeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeServiceConsumeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeServiceConsumeDownloadUrlRequest : Tea.TeaModel {
    public var lang: String?

    public var endDate: String?

    public var regId: String?

    public var serviceCode: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.endDate != nil {
            map["endDate"] = self.endDate!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.serviceCode != nil {
            map["serviceCode"] = self.serviceCode!
        }
        if self.startDate != nil {
            map["startDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("endDate") {
            self.endDate = dict["endDate"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("serviceCode") {
            self.serviceCode = dict["serviceCode"] as! String
        }
        if dict.keys.contains("startDate") {
            self.startDate = dict["startDate"] as! String
        }
    }
}

public class DescribeServiceConsumeDownloadUrlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var downloadFileUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.downloadFileUrl != nil {
            map["downloadFileUrl"] = self.downloadFileUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("downloadFileUrl") {
            self.downloadFileUrl = dict["downloadFileUrl"] as! String
        }
    }
}

public class DescribeServiceConsumeDownloadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeServiceConsumeDownloadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeServiceConsumeDownloadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeServiceListRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeServiceListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var serviceCode: String?

        public var serviceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceCode != nil {
                map["serviceCode"] = self.serviceCode!
            }
            if self.serviceName != nil {
                map["serviceName"] = self.serviceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("serviceCode") {
                self.serviceCode = dict["serviceCode"] as! String
            }
            if dict.keys.contains("serviceName") {
                self.serviceName = dict["serviceName"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: [DescribeServiceListResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeServiceListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeServiceListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class DescribeServiceListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeServiceListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeServiceListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSimulationPreditInfoRequest : Tea.TeaModel {
    public var lang: String?

    public var eventCode: String?

    public var regId: String?

    public var rulesStr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.rulesStr != nil {
            map["rulesStr"] = self.rulesStr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("rulesStr") {
            self.rulesStr = dict["rulesStr"] as! String
        }
    }
}

public class DescribeSimulationPreditInfoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeSimulationPreditInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSimulationPreditInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSimulationPreditInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSimulationTaskCountRequest : Tea.TeaModel {
    public var lang: String?

    public var dataSourceConfig: String?

    public var dataSourceType: String?

    public var endTime: Int64?

    public var eventCode: String?

    public var filtersStr: String?

    public var regId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.dataSourceConfig != nil {
            map["dataSourceConfig"] = self.dataSourceConfig!
        }
        if self.dataSourceType != nil {
            map["dataSourceType"] = self.dataSourceType!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.filtersStr != nil {
            map["filtersStr"] = self.filtersStr!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("dataSourceConfig") {
            self.dataSourceConfig = dict["dataSourceConfig"] as! String
        }
        if dict.keys.contains("dataSourceType") {
            self.dataSourceType = dict["dataSourceType"] as! String
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("filtersStr") {
            self.filtersStr = dict["filtersStr"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! Int64
        }
    }
}

public class DescribeSimulationTaskCountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeSimulationTaskCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSimulationTaskCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSimulationTaskCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSimulationTaskListRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: String?

    public var id: String?

    public var name: String?

    public var pageSize: String?

    public var regId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
    }
}

public class DescribeSimulationTaskListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: Bool?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeSimulationTaskListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSimulationTaskListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSimulationTaskListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSlsUrlConfigRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeSlsUrlConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! String
        }
    }
}

public class DescribeSlsUrlConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSlsUrlConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSlsUrlConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSupportRuleListRequest : Tea.TeaModel {
    public var lang: String?

    public var eventCode: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeSupportRuleListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeSupportRuleListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSupportRuleListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSupportRuleListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagListRequest : Tea.TeaModel {
    public var id: String?

    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["RegId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RegId") {
            self.regId = dict["RegId"] as! String
        }
    }
}

public class DescribeTagListResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["ResultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultObject") {
            self.resultObject = dict["ResultObject"] as! String
        }
    }
}

public class DescribeTagListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTagListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagsBarChartRequest : Tea.TeaModel {
    public var lang: String?

    public var beginTime: Int64?

    public var endTime: Int64?

    public var eventCodes: String?

    public var regId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! Int64
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! String
        }
    }
}

public class DescribeTagsBarChartResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Series : Tea.TeaModel {
            public class Data : Tea.TeaModel {
                public var num: Int64?

                public var scale: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.num != nil {
                        map["num"] = self.num!
                    }
                    if self.scale != nil {
                        map["scale"] = self.scale!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("num") {
                        self.num = dict["num"] as! Int64
                    }
                    if dict.keys.contains("scale") {
                        self.scale = dict["scale"] as! String
                    }
                }
            }
            public var data: [DescribeTagsBarChartResponseBody.ResultObject.Series.Data]?

            public var name: String?

            public var stack: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    var tmp : [Any] = []
                    for k in self.data! {
                        tmp.append(k.toMap())
                    }
                    map["data"] = tmp
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.stack != nil {
                    map["stack"] = self.stack!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    var tmp : [DescribeTagsBarChartResponseBody.ResultObject.Series.Data] = []
                    for v in dict["data"] as! [Any] {
                        var model = DescribeTagsBarChartResponseBody.ResultObject.Series.Data()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.data = tmp
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("stack") {
                    self.stack = dict["stack"] as! String
                }
            }
        }
        public class Xaxis : Tea.TeaModel {
            public var data: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    self.data = dict["data"] as! [String]
                }
            }
        }
        public var series: [DescribeTagsBarChartResponseBody.ResultObject.Series]?

        public var xaxis: DescribeTagsBarChartResponseBody.ResultObject.Xaxis?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.xaxis?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.series != nil {
                var tmp : [Any] = []
                for k in self.series! {
                    tmp.append(k.toMap())
                }
                map["series"] = tmp
            }
            if self.xaxis != nil {
                map["xaxis"] = self.xaxis?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("series") {
                var tmp : [DescribeTagsBarChartResponseBody.ResultObject.Series] = []
                for v in dict["series"] as! [Any] {
                    var model = DescribeTagsBarChartResponseBody.ResultObject.Series()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.series = tmp
            }
            if dict.keys.contains("xaxis") {
                var model = DescribeTagsBarChartResponseBody.ResultObject.Xaxis()
                model.fromMap(dict["xaxis"] as! [String: Any])
                self.xaxis = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: DescribeTagsBarChartResponseBody.ResultObject?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeTagsBarChartResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeTagsBarChartResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagsBarChartResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTagsBarChartResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagsFluctuationRequest : Tea.TeaModel {
    public var lang: String?

    public var eventCodes: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeTagsFluctuationResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var tableName: String?

        public var todayNum: Int64?

        public var withinSevenDayNum: String?

        public var withinThirtyDayNum: String?

        public var withinThreeDayNum: String?

        public var yesterdayNum: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tableName != nil {
                map["tableName"] = self.tableName!
            }
            if self.todayNum != nil {
                map["todayNum"] = self.todayNum!
            }
            if self.withinSevenDayNum != nil {
                map["withinSevenDayNum"] = self.withinSevenDayNum!
            }
            if self.withinThirtyDayNum != nil {
                map["withinThirtyDayNum"] = self.withinThirtyDayNum!
            }
            if self.withinThreeDayNum != nil {
                map["withinThreeDayNum"] = self.withinThreeDayNum!
            }
            if self.yesterdayNum != nil {
                map["yesterdayNum"] = self.yesterdayNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tableName") {
                self.tableName = dict["tableName"] as! String
            }
            if dict.keys.contains("todayNum") {
                self.todayNum = dict["todayNum"] as! Int64
            }
            if dict.keys.contains("withinSevenDayNum") {
                self.withinSevenDayNum = dict["withinSevenDayNum"] as! String
            }
            if dict.keys.contains("withinThirtyDayNum") {
                self.withinThirtyDayNum = dict["withinThirtyDayNum"] as! String
            }
            if dict.keys.contains("withinThreeDayNum") {
                self.withinThreeDayNum = dict["withinThreeDayNum"] as! String
            }
            if dict.keys.contains("yesterdayNum") {
                self.yesterdayNum = dict["yesterdayNum"] as! Int64
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: [DescribeTagsFluctuationResponseBody.ResultObject]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeTagsFluctuationResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeTagsFluctuationResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeTagsFluctuationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagsFluctuationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTagsFluctuationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagsListRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeTagsListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeTagsListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagsListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTagsListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagsNumLineChartRequest : Tea.TeaModel {
    public var lang: String?

    public var beginTime: String?

    public var byPassEventCodes: String?

    public var endTime: String?

    public var mainEventCodes: String?

    public var regId: String?

    public var shuntEventCodes: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.byPassEventCodes != nil {
            map["byPassEventCodes"] = self.byPassEventCodes!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.mainEventCodes != nil {
            map["mainEventCodes"] = self.mainEventCodes!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.shuntEventCodes != nil {
            map["shuntEventCodes"] = self.shuntEventCodes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! String
        }
        if dict.keys.contains("byPassEventCodes") {
            self.byPassEventCodes = dict["byPassEventCodes"] as! String
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("mainEventCodes") {
            self.mainEventCodes = dict["mainEventCodes"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("shuntEventCodes") {
            self.shuntEventCodes = dict["shuntEventCodes"] as! String
        }
    }
}

public class DescribeTagsNumLineChartResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Series : Tea.TeaModel {
            public var data: [String]?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    self.data = dict["data"] as! [String]
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public class Xaxis : Tea.TeaModel {
            public var data: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    self.data = dict["data"] as! [String]
                }
            }
        }
        public var series: [DescribeTagsNumLineChartResponseBody.ResultObject.Series]?

        public var xaxis: DescribeTagsNumLineChartResponseBody.ResultObject.Xaxis?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.xaxis?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.series != nil {
                var tmp : [Any] = []
                for k in self.series! {
                    tmp.append(k.toMap())
                }
                map["series"] = tmp
            }
            if self.xaxis != nil {
                map["xaxis"] = self.xaxis?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("series") {
                var tmp : [DescribeTagsNumLineChartResponseBody.ResultObject.Series] = []
                for v in dict["series"] as! [Any] {
                    var model = DescribeTagsNumLineChartResponseBody.ResultObject.Series()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.series = tmp
            }
            if dict.keys.contains("xaxis") {
                var model = DescribeTagsNumLineChartResponseBody.ResultObject.Xaxis()
                model.fromMap(dict["xaxis"] as! [String: Any])
                self.xaxis = model
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeTagsNumLineChartResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeTagsNumLineChartResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeTagsNumLineChartResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagsNumLineChartResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTagsNumLineChartResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagsRatioLineChartRequest : Tea.TeaModel {
    public var lang: String?

    public var beginTime: Int64?

    public var byPassEventCodes: String?

    public var endTime: Int64?

    public var mainEventCodes: String?

    public var regId: String?

    public var shuntEventCodes: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.byPassEventCodes != nil {
            map["byPassEventCodes"] = self.byPassEventCodes!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.mainEventCodes != nil {
            map["mainEventCodes"] = self.mainEventCodes!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.shuntEventCodes != nil {
            map["shuntEventCodes"] = self.shuntEventCodes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! Int64
        }
        if dict.keys.contains("byPassEventCodes") {
            self.byPassEventCodes = dict["byPassEventCodes"] as! String
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("mainEventCodes") {
            self.mainEventCodes = dict["mainEventCodes"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("shuntEventCodes") {
            self.shuntEventCodes = dict["shuntEventCodes"] as! String
        }
    }
}

public class DescribeTagsRatioLineChartResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Series : Tea.TeaModel {
            public var data: [String]?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    self.data = dict["data"] as! [String]
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public class Xaxis : Tea.TeaModel {
            public var data: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    self.data = dict["data"] as! [String]
                }
            }
        }
        public var series: [DescribeTagsRatioLineChartResponseBody.ResultObject.Series]?

        public var xaxis: DescribeTagsRatioLineChartResponseBody.ResultObject.Xaxis?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.xaxis?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.series != nil {
                var tmp : [Any] = []
                for k in self.series! {
                    tmp.append(k.toMap())
                }
                map["series"] = tmp
            }
            if self.xaxis != nil {
                map["xaxis"] = self.xaxis?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("series") {
                var tmp : [DescribeTagsRatioLineChartResponseBody.ResultObject.Series] = []
                for v in dict["series"] as! [Any] {
                    var model = DescribeTagsRatioLineChartResponseBody.ResultObject.Series()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.series = tmp
            }
            if dict.keys.contains("xaxis") {
                var model = DescribeTagsRatioLineChartResponseBody.ResultObject.Xaxis()
                model.fromMap(dict["xaxis"] as! [String: Any])
                self.xaxis = model
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeTagsRatioLineChartResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeTagsRatioLineChartResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeTagsRatioLineChartResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagsRatioLineChartResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTagsRatioLineChartResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagsTrendRequest : Tea.TeaModel {
    public var lang: String?

    public var beginTime: Int64?

    public var endTime: Int64?

    public var eventCodes: String?

    public var regId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! Int64
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! String
        }
    }
}

public class DescribeTagsTrendResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Series : Tea.TeaModel {
            public class Data : Tea.TeaModel {
                public var num: Int64?

                public var scale: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.num != nil {
                        map["num"] = self.num!
                    }
                    if self.scale != nil {
                        map["scale"] = self.scale!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("num") {
                        self.num = dict["num"] as! Int64
                    }
                    if dict.keys.contains("scale") {
                        self.scale = dict["scale"] as! String
                    }
                }
            }
            public var data: [DescribeTagsTrendResponseBody.ResultObject.Series.Data]?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    var tmp : [Any] = []
                    for k in self.data! {
                        tmp.append(k.toMap())
                    }
                    map["data"] = tmp
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    var tmp : [DescribeTagsTrendResponseBody.ResultObject.Series.Data] = []
                    for v in dict["data"] as! [Any] {
                        var model = DescribeTagsTrendResponseBody.ResultObject.Series.Data()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.data = tmp
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public class Xaxis : Tea.TeaModel {
            public var data: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    self.data = dict["data"] as! [String]
                }
            }
        }
        public var series: [DescribeTagsTrendResponseBody.ResultObject.Series]?

        public var xaxis: DescribeTagsTrendResponseBody.ResultObject.Xaxis?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.xaxis?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.series != nil {
                var tmp : [Any] = []
                for k in self.series! {
                    tmp.append(k.toMap())
                }
                map["series"] = tmp
            }
            if self.xaxis != nil {
                map["xaxis"] = self.xaxis?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("series") {
                var tmp : [DescribeTagsTrendResponseBody.ResultObject.Series] = []
                for v in dict["series"] as! [Any] {
                    var model = DescribeTagsTrendResponseBody.ResultObject.Series()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.series = tmp
            }
            if dict.keys.contains("xaxis") {
                var model = DescribeTagsTrendResponseBody.ResultObject.Xaxis()
                model.fromMap(dict["xaxis"] as! [String: Any])
                self.xaxis = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: DescribeTagsTrendResponseBody.ResultObject?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeTagsTrendResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeTagsTrendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagsTrendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTagsTrendResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTaskListRequest : Tea.TeaModel {
    public var currentPage: String?

    public var isPage: Bool?

    public var lang: String?

    public var pageSize: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.isPage != nil {
            map["IsPage"] = self.isPage!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! String
        }
        if dict.keys.contains("IsPage") {
            self.isPage = dict["IsPage"] as! Bool
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeTaskListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var completionTime: Int64?

        public var createTime: Int64?

        public var id: Int64?

        public var mark: Int32?

        public var remark: String?

        public var sceneName: String?

        public var status: String?

        public var taskLogId: Int64?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completionTime != nil {
                map["completionTime"] = self.completionTime!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.mark != nil {
                map["mark"] = self.mark!
            }
            if self.remark != nil {
                map["remark"] = self.remark!
            }
            if self.sceneName != nil {
                map["sceneName"] = self.sceneName!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.taskLogId != nil {
                map["taskLogId"] = self.taskLogId!
            }
            if self.taskType != nil {
                map["taskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("completionTime") {
                self.completionTime = dict["completionTime"] as! Int64
            }
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("mark") {
                self.mark = dict["mark"] as! Int32
            }
            if dict.keys.contains("remark") {
                self.remark = dict["remark"] as! String
            }
            if dict.keys.contains("sceneName") {
                self.sceneName = dict["sceneName"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("taskLogId") {
                self.taskLogId = dict["taskLogId"] as! Int64
            }
            if dict.keys.contains("taskType") {
                self.taskType = dict["taskType"] as! String
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeTaskListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeTaskListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeTaskListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeTaskListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTaskListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTaskListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTaskLogListRequest : Tea.TeaModel {
    public var currentPage: String?

    public var isPage: Bool?

    public var lang: String?

    public var pageSize: String?

    public var taskId: String?

    public var taskLogId: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.isPage != nil {
            map["IsPage"] = self.isPage!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskLogId != nil {
            map["TaskLogId"] = self.taskLogId!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! String
        }
        if dict.keys.contains("IsPage") {
            self.isPage = dict["IsPage"] as! Bool
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskLogId") {
            self.taskLogId = dict["TaskLogId"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeTaskLogListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var completionTime: Int64?

        public var createTime: Int64?

        public var id: Int64?

        public var remark: String?

        public var sceneName: String?

        public var status: String?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completionTime != nil {
                map["completionTime"] = self.completionTime!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.remark != nil {
                map["remark"] = self.remark!
            }
            if self.sceneName != nil {
                map["sceneName"] = self.sceneName!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.taskType != nil {
                map["taskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("completionTime") {
                self.completionTime = dict["completionTime"] as! Int64
            }
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("remark") {
                self.remark = dict["remark"] as! String
            }
            if dict.keys.contains("sceneName") {
                self.sceneName = dict["sceneName"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("taskType") {
                self.taskType = dict["taskType"] as! String
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeTaskLogListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeTaskLogListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeTaskLogListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeTaskLogListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTaskLogListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTaskLogListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTemplateBaseInfoByTemplateIdRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var templateId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.templateId != nil {
            map["templateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("templateId") {
            self.templateId = dict["templateId"] as! Int64
        }
    }
}

public class DescribeTemplateBaseInfoByTemplateIdResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class InputFields : Tea.TeaModel {
            public var description_: String?

            public var fieldCode: String?

            public var fieldRank: String?

            public var fieldSource: String?

            public var fieldType: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.fieldCode != nil {
                    map["fieldCode"] = self.fieldCode!
                }
                if self.fieldRank != nil {
                    map["fieldRank"] = self.fieldRank!
                }
                if self.fieldSource != nil {
                    map["fieldSource"] = self.fieldSource!
                }
                if self.fieldType != nil {
                    map["fieldType"] = self.fieldType!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("fieldCode") {
                    self.fieldCode = dict["fieldCode"] as! String
                }
                if dict.keys.contains("fieldRank") {
                    self.fieldRank = dict["fieldRank"] as! String
                }
                if dict.keys.contains("fieldSource") {
                    self.fieldSource = dict["fieldSource"] as! String
                }
                if dict.keys.contains("fieldType") {
                    self.fieldType = dict["fieldType"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public class RuleDetails : Tea.TeaModel {
            public var logicExpression: String?

            public var memo: String?

            public var ruleActions: String?

            public var ruleExpressions: String?

            public var ruleId: String?

            public var ruleName: String?

            public var ruleStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logicExpression != nil {
                    map["logicExpression"] = self.logicExpression!
                }
                if self.memo != nil {
                    map["memo"] = self.memo!
                }
                if self.ruleActions != nil {
                    map["ruleActions"] = self.ruleActions!
                }
                if self.ruleExpressions != nil {
                    map["ruleExpressions"] = self.ruleExpressions!
                }
                if self.ruleId != nil {
                    map["ruleId"] = self.ruleId!
                }
                if self.ruleName != nil {
                    map["ruleName"] = self.ruleName!
                }
                if self.ruleStatus != nil {
                    map["ruleStatus"] = self.ruleStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("logicExpression") {
                    self.logicExpression = dict["logicExpression"] as! String
                }
                if dict.keys.contains("memo") {
                    self.memo = dict["memo"] as! String
                }
                if dict.keys.contains("ruleActions") {
                    self.ruleActions = dict["ruleActions"] as! String
                }
                if dict.keys.contains("ruleExpressions") {
                    self.ruleExpressions = dict["ruleExpressions"] as! String
                }
                if dict.keys.contains("ruleId") {
                    self.ruleId = dict["ruleId"] as! String
                }
                if dict.keys.contains("ruleName") {
                    self.ruleName = dict["ruleName"] as! String
                }
                if dict.keys.contains("ruleStatus") {
                    self.ruleStatus = dict["ruleStatus"] as! String
                }
            }
        }
        public var description_: String?

        public var eventCode: String?

        public var eventName: String?

        public var eventStauts: String?

        public var inputFields: [DescribeTemplateBaseInfoByTemplateIdResponseBody.ResultObject.InputFields]?

        public var ruleDetails: [DescribeTemplateBaseInfoByTemplateIdResponseBody.ResultObject.RuleDetails]?

        public var templateCode: String?

        public var templateName: String?

        public var templateType: String?

        public var version: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.eventStauts != nil {
                map["eventStauts"] = self.eventStauts!
            }
            if self.inputFields != nil {
                var tmp : [Any] = []
                for k in self.inputFields! {
                    tmp.append(k.toMap())
                }
                map["inputFields"] = tmp
            }
            if self.ruleDetails != nil {
                var tmp : [Any] = []
                for k in self.ruleDetails! {
                    tmp.append(k.toMap())
                }
                map["ruleDetails"] = tmp
            }
            if self.templateCode != nil {
                map["templateCode"] = self.templateCode!
            }
            if self.templateName != nil {
                map["templateName"] = self.templateName!
            }
            if self.templateType != nil {
                map["templateType"] = self.templateType!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("eventStauts") {
                self.eventStauts = dict["eventStauts"] as! String
            }
            if dict.keys.contains("inputFields") {
                var tmp : [DescribeTemplateBaseInfoByTemplateIdResponseBody.ResultObject.InputFields] = []
                for v in dict["inputFields"] as! [Any] {
                    var model = DescribeTemplateBaseInfoByTemplateIdResponseBody.ResultObject.InputFields()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inputFields = tmp
            }
            if dict.keys.contains("ruleDetails") {
                var tmp : [DescribeTemplateBaseInfoByTemplateIdResponseBody.ResultObject.RuleDetails] = []
                for v in dict["ruleDetails"] as! [Any] {
                    var model = DescribeTemplateBaseInfoByTemplateIdResponseBody.ResultObject.RuleDetails()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ruleDetails = tmp
            }
            if dict.keys.contains("templateCode") {
                self.templateCode = dict["templateCode"] as! String
            }
            if dict.keys.contains("templateName") {
                self.templateName = dict["templateName"] as! String
            }
            if dict.keys.contains("templateType") {
                self.templateType = dict["templateType"] as! String
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeTemplateBaseInfoByTemplateIdResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeTemplateBaseInfoByTemplateIdResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeTemplateBaseInfoByTemplateIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTemplateBaseInfoByTemplateIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTemplateBaseInfoByTemplateIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTemplateCountRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeTemplateCountResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var limit: Bool?

        public var maxTotalItem: Int32?

        public var totalItem: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.limit != nil {
                map["limit"] = self.limit!
            }
            if self.maxTotalItem != nil {
                map["maxTotalItem"] = self.maxTotalItem!
            }
            if self.totalItem != nil {
                map["totalItem"] = self.totalItem!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("limit") {
                self.limit = dict["limit"] as! Bool
            }
            if dict.keys.contains("maxTotalItem") {
                self.maxTotalItem = dict["maxTotalItem"] as! Int32
            }
            if dict.keys.contains("totalItem") {
                self.totalItem = dict["totalItem"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeTemplateCountResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeTemplateCountResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeTemplateCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTemplateCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTemplateCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTemplateDownloadRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeTemplateDownloadResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var data: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! Bool
        }
    }
}

public class DescribeTemplateDownloadResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTemplateDownloadResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTemplateDownloadResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTemplatePageListRequest : Tea.TeaModel {
    public var lang: String?

    public var currentPage: String?

    public var eventCodes: String?

    public var pageSize: String?

    public var regId: String?

    public var templateName: String?

    public var templateSearchItem: String?

    public var templateStatus: String?

    public var templateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.templateName != nil {
            map["templateName"] = self.templateName!
        }
        if self.templateSearchItem != nil {
            map["templateSearchItem"] = self.templateSearchItem!
        }
        if self.templateStatus != nil {
            map["templateStatus"] = self.templateStatus!
        }
        if self.templateType != nil {
            map["templateType"] = self.templateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("templateName") {
            self.templateName = dict["templateName"] as! String
        }
        if dict.keys.contains("templateSearchItem") {
            self.templateSearchItem = dict["templateSearchItem"] as! String
        }
        if dict.keys.contains("templateStatus") {
            self.templateStatus = dict["templateStatus"] as! String
        }
        if dict.keys.contains("templateType") {
            self.templateType = dict["templateType"] as! String
        }
    }
}

public class DescribeTemplatePageListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var description_: String?

        public var eventCode: String?

        public var eventName: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var ruleCount: Int32?

        public var templateCode: String?

        public var templateName: String?

        public var templateStatus: String?

        public var templateType: String?

        public var userCount: Int32?

        public var version: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.ruleCount != nil {
                map["ruleCount"] = self.ruleCount!
            }
            if self.templateCode != nil {
                map["templateCode"] = self.templateCode!
            }
            if self.templateName != nil {
                map["templateName"] = self.templateName!
            }
            if self.templateStatus != nil {
                map["templateStatus"] = self.templateStatus!
            }
            if self.templateType != nil {
                map["templateType"] = self.templateType!
            }
            if self.userCount != nil {
                map["userCount"] = self.userCount!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("ruleCount") {
                self.ruleCount = dict["ruleCount"] as! Int32
            }
            if dict.keys.contains("templateCode") {
                self.templateCode = dict["templateCode"] as! String
            }
            if dict.keys.contains("templateName") {
                self.templateName = dict["templateName"] as! String
            }
            if dict.keys.contains("templateStatus") {
                self.templateStatus = dict["templateStatus"] as! String
            }
            if dict.keys.contains("templateType") {
                self.templateType = dict["templateType"] as! String
            }
            if dict.keys.contains("userCount") {
                self.userCount = dict["userCount"] as! Int32
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! Int32
            }
        }
    }
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var resultObject: [DescribeTemplatePageListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeTemplatePageListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeTemplatePageListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeTemplatePageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTemplatePageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTemplatePageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUsedServiceRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeUsedServiceResponseBody : Tea.TeaModel {
    public class Records : Tea.TeaModel {
        public var enName: String?

        public var name: String?

        public var serviceCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enName != nil {
                map["enName"] = self.enName!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.serviceCode != nil {
                map["serviceCode"] = self.serviceCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("enName") {
                self.enName = dict["enName"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("serviceCode") {
                self.serviceCode = dict["serviceCode"] as! String
            }
        }
    }
    public var requestId: String?

    public var records: [DescribeUsedServiceResponseBody.Records]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.records != nil {
            var tmp : [Any] = []
            for k in self.records! {
                tmp.append(k.toMap())
            }
            map["records"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("records") {
            var tmp : [DescribeUsedServiceResponseBody.Records] = []
            for v in dict["records"] as! [Any] {
                var model = DescribeUsedServiceResponseBody.Records()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.records = tmp
        }
    }
}

public class DescribeUsedServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUsedServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeUsedServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUserInfoRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeUserInfoResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var clientIp: String?

        public var subId: String?

        public var userId: Int64?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientIp != nil {
                map["clientIp"] = self.clientIp!
            }
            if self.subId != nil {
                map["subId"] = self.subId!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            if self.userName != nil {
                map["userName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("clientIp") {
                self.clientIp = dict["clientIp"] as! String
            }
            if dict.keys.contains("subId") {
                self.subId = dict["subId"] as! String
            }
            if dict.keys.contains("userId") {
                self.userId = dict["userId"] as! Int64
            }
            if dict.keys.contains("userName") {
                self.userName = dict["userName"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var resultObject: DescribeUserInfoResponseBody.ResultObject?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeUserInfoResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DescribeUserInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUserInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeUserInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVariableBindDetailRequest : Tea.TeaModel {
    public var lang: String?

    public var defineId: Int64?

    public var id: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.defineId != nil {
            map["defineId"] = self.defineId!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("defineId") {
            self.defineId = dict["defineId"] as! Int64
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeVariableBindDetailResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class Params : Tea.TeaModel {
            public var eventFieldName: String?

            public var required_: Bool?

            public var variableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventFieldName != nil {
                    map["eventFieldName"] = self.eventFieldName!
                }
                if self.required_ != nil {
                    map["required"] = self.required_!
                }
                if self.variableName != nil {
                    map["variableName"] = self.variableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("eventFieldName") {
                    self.eventFieldName = dict["eventFieldName"] as! String
                }
                if dict.keys.contains("required") {
                    self.required_ = dict["required"] as! Bool
                }
                if dict.keys.contains("variableName") {
                    self.variableName = dict["variableName"] as! String
                }
            }
        }
        public class RelationRules : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["key"] = self.key!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("key") {
                    self.key = dict["key"] as! String
                }
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
            }
        }
        public var allowModify: Bool?

        public var defineId: Int64?

        public var defineTitle: String?

        public var description_: String?

        public var eventCode: String?

        public var id: Int64?

        public var params: [DescribeVariableBindDetailResponseBody.ResultObject.Params]?

        public var relationRules: [DescribeVariableBindDetailResponseBody.ResultObject.RelationRules]?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowModify != nil {
                map["allowModify"] = self.allowModify!
            }
            if self.defineId != nil {
                map["defineId"] = self.defineId!
            }
            if self.defineTitle != nil {
                map["defineTitle"] = self.defineTitle!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.params != nil {
                var tmp : [Any] = []
                for k in self.params! {
                    tmp.append(k.toMap())
                }
                map["params"] = tmp
            }
            if self.relationRules != nil {
                var tmp : [Any] = []
                for k in self.relationRules! {
                    tmp.append(k.toMap())
                }
                map["relationRules"] = tmp
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("allowModify") {
                self.allowModify = dict["allowModify"] as! Bool
            }
            if dict.keys.contains("defineId") {
                self.defineId = dict["defineId"] as! Int64
            }
            if dict.keys.contains("defineTitle") {
                self.defineTitle = dict["defineTitle"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("params") {
                var tmp : [DescribeVariableBindDetailResponseBody.ResultObject.Params] = []
                for v in dict["params"] as! [Any] {
                    var model = DescribeVariableBindDetailResponseBody.ResultObject.Params()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.params = tmp
            }
            if dict.keys.contains("relationRules") {
                var tmp : [DescribeVariableBindDetailResponseBody.ResultObject.RelationRules] = []
                for v in dict["relationRules"] as! [Any] {
                    var model = DescribeVariableBindDetailResponseBody.ResultObject.RelationRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.relationRules = tmp
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeVariableBindDetailResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeVariableBindDetailResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeVariableBindDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVariableBindDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVariableBindDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVariableDetailRequest : Tea.TeaModel {
    public var lang: String?

    public var id: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeVariableDetailResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public class BaseInfo : Tea.TeaModel {
            public var allowBind: String?

            public var chargingMode: String?

            public var chargingModeDesc: String?

            public var creator: String?

            public var dataDisplay: String?

            public var dataThreshold: String?

            public var deductionFactor: Int32?

            public var description_: String?

            public var frontAllowBind: String?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var id: Int64?

            public var inputRequired: String?

            public var inputs: String?

            public var inputsDesc: String?

            public var invokeKey: String?

            public var invokeRt: Int32?

            public var invokeSuccessRate: String?

            public var invokeTimes: Int64?

            public var lastModifiedOperator: String?

            public var name: String?

            public var outputs: String?

            public var outputsDesc: String?

            public var scene: [String]?

            public var sceneDesc: [String]?

            public var showOrder: String?

            public var source: String?

            public var sourceDesc: String?

            public var status: String?

            public var supportRegions: [String]?

            public var title: String?

            public var type: String?

            public var typeDesc: String?

            public var xLabel: String?

            public var yLabel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowBind != nil {
                    map["allowBind"] = self.allowBind!
                }
                if self.chargingMode != nil {
                    map["chargingMode"] = self.chargingMode!
                }
                if self.chargingModeDesc != nil {
                    map["chargingModeDesc"] = self.chargingModeDesc!
                }
                if self.creator != nil {
                    map["creator"] = self.creator!
                }
                if self.dataDisplay != nil {
                    map["dataDisplay"] = self.dataDisplay!
                }
                if self.dataThreshold != nil {
                    map["dataThreshold"] = self.dataThreshold!
                }
                if self.deductionFactor != nil {
                    map["deductionFactor"] = self.deductionFactor!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.frontAllowBind != nil {
                    map["frontAllowBind"] = self.frontAllowBind!
                }
                if self.gmtCreate != nil {
                    map["gmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["gmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.inputRequired != nil {
                    map["inputRequired"] = self.inputRequired!
                }
                if self.inputs != nil {
                    map["inputs"] = self.inputs!
                }
                if self.inputsDesc != nil {
                    map["inputsDesc"] = self.inputsDesc!
                }
                if self.invokeKey != nil {
                    map["invokeKey"] = self.invokeKey!
                }
                if self.invokeRt != nil {
                    map["invokeRt"] = self.invokeRt!
                }
                if self.invokeSuccessRate != nil {
                    map["invokeSuccessRate"] = self.invokeSuccessRate!
                }
                if self.invokeTimes != nil {
                    map["invokeTimes"] = self.invokeTimes!
                }
                if self.lastModifiedOperator != nil {
                    map["lastModifiedOperator"] = self.lastModifiedOperator!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.outputs != nil {
                    map["outputs"] = self.outputs!
                }
                if self.outputsDesc != nil {
                    map["outputsDesc"] = self.outputsDesc!
                }
                if self.scene != nil {
                    map["scene"] = self.scene!
                }
                if self.sceneDesc != nil {
                    map["sceneDesc"] = self.sceneDesc!
                }
                if self.showOrder != nil {
                    map["showOrder"] = self.showOrder!
                }
                if self.source != nil {
                    map["source"] = self.source!
                }
                if self.sourceDesc != nil {
                    map["sourceDesc"] = self.sourceDesc!
                }
                if self.status != nil {
                    map["status"] = self.status!
                }
                if self.supportRegions != nil {
                    map["supportRegions"] = self.supportRegions!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.typeDesc != nil {
                    map["typeDesc"] = self.typeDesc!
                }
                if self.xLabel != nil {
                    map["xLabel"] = self.xLabel!
                }
                if self.yLabel != nil {
                    map["yLabel"] = self.yLabel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("allowBind") {
                    self.allowBind = dict["allowBind"] as! String
                }
                if dict.keys.contains("chargingMode") {
                    self.chargingMode = dict["chargingMode"] as! String
                }
                if dict.keys.contains("chargingModeDesc") {
                    self.chargingModeDesc = dict["chargingModeDesc"] as! String
                }
                if dict.keys.contains("creator") {
                    self.creator = dict["creator"] as! String
                }
                if dict.keys.contains("dataDisplay") {
                    self.dataDisplay = dict["dataDisplay"] as! String
                }
                if dict.keys.contains("dataThreshold") {
                    self.dataThreshold = dict["dataThreshold"] as! String
                }
                if dict.keys.contains("deductionFactor") {
                    self.deductionFactor = dict["deductionFactor"] as! Int32
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("frontAllowBind") {
                    self.frontAllowBind = dict["frontAllowBind"] as! String
                }
                if dict.keys.contains("gmtCreate") {
                    self.gmtCreate = dict["gmtCreate"] as! Int64
                }
                if dict.keys.contains("gmtModified") {
                    self.gmtModified = dict["gmtModified"] as! Int64
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("inputRequired") {
                    self.inputRequired = dict["inputRequired"] as! String
                }
                if dict.keys.contains("inputs") {
                    self.inputs = dict["inputs"] as! String
                }
                if dict.keys.contains("inputsDesc") {
                    self.inputsDesc = dict["inputsDesc"] as! String
                }
                if dict.keys.contains("invokeKey") {
                    self.invokeKey = dict["invokeKey"] as! String
                }
                if dict.keys.contains("invokeRt") {
                    self.invokeRt = dict["invokeRt"] as! Int32
                }
                if dict.keys.contains("invokeSuccessRate") {
                    self.invokeSuccessRate = dict["invokeSuccessRate"] as! String
                }
                if dict.keys.contains("invokeTimes") {
                    self.invokeTimes = dict["invokeTimes"] as! Int64
                }
                if dict.keys.contains("lastModifiedOperator") {
                    self.lastModifiedOperator = dict["lastModifiedOperator"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("outputs") {
                    self.outputs = dict["outputs"] as! String
                }
                if dict.keys.contains("outputsDesc") {
                    self.outputsDesc = dict["outputsDesc"] as! String
                }
                if dict.keys.contains("scene") {
                    self.scene = dict["scene"] as! [String]
                }
                if dict.keys.contains("sceneDesc") {
                    self.sceneDesc = dict["sceneDesc"] as! [String]
                }
                if dict.keys.contains("showOrder") {
                    self.showOrder = dict["showOrder"] as! String
                }
                if dict.keys.contains("source") {
                    self.source = dict["source"] as! String
                }
                if dict.keys.contains("sourceDesc") {
                    self.sourceDesc = dict["sourceDesc"] as! String
                }
                if dict.keys.contains("status") {
                    self.status = dict["status"] as! String
                }
                if dict.keys.contains("supportRegions") {
                    self.supportRegions = dict["supportRegions"] as! [String]
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("typeDesc") {
                    self.typeDesc = dict["typeDesc"] as! String
                }
                if dict.keys.contains("xLabel") {
                    self.xLabel = dict["xLabel"] as! String
                }
                if dict.keys.contains("yLabel") {
                    self.yLabel = dict["yLabel"] as! String
                }
            }
        }
        public var baseInfo: DescribeVariableDetailResponseBody.ResultObject.BaseInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.baseInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baseInfo != nil {
                map["baseInfo"] = self.baseInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("baseInfo") {
                var model = DescribeVariableDetailResponseBody.ResultObject.BaseInfo()
                model.fromMap(dict["baseInfo"] as! [String: Any])
                self.baseInfo = model
            }
        }
    }
    public var requestId: String?

    public var resultObject: DescribeVariableDetailResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = DescribeVariableDetailResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class DescribeVariableDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVariableDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVariableDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVariableFeeRequest : Tea.TeaModel {
    public var lang: String?

    public var ids: [Int64]?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.ids != nil {
            map["ids"] = self.ids!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ids") {
            self.ids = dict["ids"] as! [Int64]
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeVariableFeeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class DescribeVariableFeeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVariableFeeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVariableFeeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVariableListRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var currentPage: String?

    public var pageSize: String?

    public var refObjId: String?

    public var regId: String?

    public var sourceType: String?

    public var type: String?

    public var typesStr: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.refObjId != nil {
            map["refObjId"] = self.refObjId!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.sourceType != nil {
            map["sourceType"] = self.sourceType!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        if self.typesStr != nil {
            map["typesStr"] = self.typesStr!
        }
        if self.value != nil {
            map["value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("refObjId") {
            self.refObjId = dict["refObjId"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("sourceType") {
            self.sourceType = dict["sourceType"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
        if dict.keys.contains("typesStr") {
            self.typesStr = dict["typesStr"] as! String
        }
        if dict.keys.contains("value") {
            self.value = dict["value"] as! String
        }
    }
}

public class DescribeVariableListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var capacity: Int64?

        public var defineId: String?

        public var description_: String?

        public var extendInfo: [String: Any]?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var leftCapacity: Int64?

        public var name: String?

        public var outputsType: String?

        public var refObjId: String?

        public var refObjName: String?

        public var refObjType: String?

        public var sourceType: String?

        public var title: String?

        public var type: String?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.capacity != nil {
                map["capacity"] = self.capacity!
            }
            if self.defineId != nil {
                map["defineId"] = self.defineId!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.extendInfo != nil {
                map["extendInfo"] = self.extendInfo!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.leftCapacity != nil {
                map["leftCapacity"] = self.leftCapacity!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.outputsType != nil {
                map["outputsType"] = self.outputsType!
            }
            if self.refObjId != nil {
                map["refObjId"] = self.refObjId!
            }
            if self.refObjName != nil {
                map["refObjName"] = self.refObjName!
            }
            if self.refObjType != nil {
                map["refObjType"] = self.refObjType!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("capacity") {
                self.capacity = dict["capacity"] as! Int64
            }
            if dict.keys.contains("defineId") {
                self.defineId = dict["defineId"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("extendInfo") {
                self.extendInfo = dict["extendInfo"] as! [String: Any]
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("leftCapacity") {
                self.leftCapacity = dict["leftCapacity"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("outputsType") {
                self.outputsType = dict["outputsType"] as! String
            }
            if dict.keys.contains("refObjId") {
                self.refObjId = dict["refObjId"] as! String
            }
            if dict.keys.contains("refObjName") {
                self.refObjName = dict["refObjName"] as! String
            }
            if dict.keys.contains("refObjType") {
                self.refObjType = dict["refObjType"] as! String
            }
            if dict.keys.contains("sourceType") {
                self.sourceType = dict["sourceType"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("userId") {
                self.userId = dict["userId"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeVariableListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeVariableListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeVariableListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeVariableListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVariableListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVariableListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVariableMarketListRequest : Tea.TeaModel {
    public var lang: String?

    public var chargingMode: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var paging: String?

    public var queryContent: String?

    public var regId: String?

    public var scenesStr: String?

    public var source: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.chargingMode != nil {
            map["chargingMode"] = self.chargingMode!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.paging != nil {
            map["paging"] = self.paging!
        }
        if self.queryContent != nil {
            map["queryContent"] = self.queryContent!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.scenesStr != nil {
            map["scenesStr"] = self.scenesStr!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("chargingMode") {
            self.chargingMode = dict["chargingMode"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("paging") {
            self.paging = dict["paging"] as! String
        }
        if dict.keys.contains("queryContent") {
            self.queryContent = dict["queryContent"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("scenesStr") {
            self.scenesStr = dict["scenesStr"] as! String
        }
        if dict.keys.contains("source") {
            self.source = dict["source"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
    }
}

public class DescribeVariableMarketListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: Bool?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeVariableMarketListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVariableMarketListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVariableMarketListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVariableSceneListRequest : Tea.TeaModel {
    public var lang: String?

    public var bizType: String?

    public var configKey: String?

    public var currentPage: String?

    public var pageSize: String?

    public var paging: Bool?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.bizType != nil {
            map["bizType"] = self.bizType!
        }
        if self.configKey != nil {
            map["configKey"] = self.configKey!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.paging != nil {
            map["paging"] = self.paging!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("bizType") {
            self.bizType = dict["bizType"] as! String
        }
        if dict.keys.contains("configKey") {
            self.configKey = dict["configKey"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! String
        }
        if dict.keys.contains("paging") {
            self.paging = dict["paging"] as! Bool
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class DescribeVariableSceneListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var bizType: String?

        public var configKey: String?

        public var configValue: String?

        public var creator: String?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var lastModifiedOperator: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizType != nil {
                map["bizType"] = self.bizType!
            }
            if self.configKey != nil {
                map["configKey"] = self.configKey!
            }
            if self.configValue != nil {
                map["configValue"] = self.configValue!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.lastModifiedOperator != nil {
                map["lastModifiedOperator"] = self.lastModifiedOperator!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("bizType") {
                self.bizType = dict["bizType"] as! String
            }
            if dict.keys.contains("configKey") {
                self.configKey = dict["configKey"] as! String
            }
            if dict.keys.contains("configValue") {
                self.configValue = dict["configValue"] as! String
            }
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("lastModifiedOperator") {
                self.lastModifiedOperator = dict["lastModifiedOperator"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
        }
    }
    public var requestId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resultObject: [DescribeVariableSceneListResponseBody.ResultObject]?

    public var totalItem: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        if self.totalItem != nil {
            map["totalItem"] = self.totalItem!
        }
        if self.totalPage != nil {
            map["totalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resultObject") {
            var tmp : [DescribeVariableSceneListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = DescribeVariableSceneListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
        if dict.keys.contains("totalItem") {
            self.totalItem = dict["totalItem"] as! Int32
        }
        if dict.keys.contains("totalPage") {
            self.totalPage = dict["totalPage"] as! Int32
        }
    }
}

public class DescribeVariableSceneListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVariableSceneListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVariableSceneListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExpressionTestRequest : Tea.TeaModel {
    public var lang: String?

    public var expression: String?

    public var expressionVariable: String?

    public var expressionVariableIds: String?

    public var id: Int64?

    public var regId: String?

    public var scene: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.expression != nil {
            map["expression"] = self.expression!
        }
        if self.expressionVariable != nil {
            map["expressionVariable"] = self.expressionVariable!
        }
        if self.expressionVariableIds != nil {
            map["expressionVariableIds"] = self.expressionVariableIds!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.scene != nil {
            map["scene"] = self.scene!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("expression") {
            self.expression = dict["expression"] as! String
        }
        if dict.keys.contains("expressionVariable") {
            self.expressionVariable = dict["expressionVariable"] as! String
        }
        if dict.keys.contains("expressionVariableIds") {
            self.expressionVariableIds = dict["expressionVariableIds"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("scene") {
            self.scene = dict["scene"] as! String
        }
    }
}

public class ExpressionTestResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class ExpressionTestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExpressionTestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExpressionTestResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class FileUploadRequest : Tea.TeaModel {
    public var fileName: String?

    public var fileUrl: String?

    public var lang: String?

    public var tab: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.tab != nil {
            map["Tab"] = self.tab!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileUrl") {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Tab") {
            self.tab = dict["Tab"] as! String
        }
    }
}

public class FileUploadResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["ResultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultObject") {
            self.resultObject = dict["ResultObject"] as! String
        }
    }
}

public class FileUploadResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: FileUploadResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = FileUploadResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportNameListRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var data: String?

    public var description_: String?

    public var importType: String?

    public var nameListType: String?

    public var regId: String?

    public var title: String?

    public var variableId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.importType != nil {
            map["importType"] = self.importType!
        }
        if self.nameListType != nil {
            map["nameListType"] = self.nameListType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.variableId != nil {
            map["variableId"] = self.variableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("importType") {
            self.importType = dict["importType"] as! String
        }
        if dict.keys.contains("nameListType") {
            self.nameListType = dict["nameListType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("variableId") {
            self.variableId = dict["variableId"] as! Int64
        }
    }
}

public class ImportNameListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class ImportNameListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportNameListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportNameListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportTemplateEventRequest : Tea.TeaModel {
    public var lang: String?

    public var eventTemplateIds: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventTemplateIds != nil {
            map["eventTemplateIds"] = self.eventTemplateIds!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventTemplateIds") {
            self.eventTemplateIds = dict["eventTemplateIds"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class ImportTemplateEventResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var data: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! Bool
        }
    }
}

public class ImportTemplateEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportTemplateEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportTemplateEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAppKeyRequest : Tea.TeaModel {
    public var lang: String?

    public var appKey: String?

    public var memo: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.appKey != nil {
            map["appKey"] = self.appKey!
        }
        if self.memo != nil {
            map["memo"] = self.memo!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("appKey") {
            self.appKey = dict["appKey"] as! String
        }
        if dict.keys.contains("memo") {
            self.memo = dict["memo"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class ModifyAppKeyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var data: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! Bool
        }
    }
}

public class ModifyAppKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAppKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyAppKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCustVariableRequest : Tea.TeaModel {
    public var lang: String?

    public var condition: String?

    public var dataVersion: Int64?

    public var description_: String?

    public var eventCodes: String?

    public var id: Int64?

    public var name: String?

    public var outputs: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.condition != nil {
            map["condition"] = self.condition!
        }
        if self.dataVersion != nil {
            map["dataVersion"] = self.dataVersion!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.eventCodes != nil {
            map["eventCodes"] = self.eventCodes!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.outputs != nil {
            map["outputs"] = self.outputs!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("condition") {
            self.condition = dict["condition"] as! String
        }
        if dict.keys.contains("dataVersion") {
            self.dataVersion = dict["dataVersion"] as! Int64
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("eventCodes") {
            self.eventCodes = dict["eventCodes"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("outputs") {
            self.outputs = dict["outputs"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class ModifyCustVariableResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var failType: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failType != nil {
                map["failType"] = self.failType!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.success != nil {
                map["success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("failType") {
                self.failType = dict["failType"] as! String
            }
            if dict.keys.contains("message") {
                self.message = dict["message"] as! String
            }
            if dict.keys.contains("success") {
                self.success = dict["success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultObject: [ModifyCustVariableResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [ModifyCustVariableResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = ModifyCustVariableResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class ModifyCustVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCustVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCustVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyEventRequest : Tea.TeaModel {
    public var lang: String?

    public var bizVersion: Int32?

    public var createType: String?

    public var eventCode: String?

    public var inputFieldsStr: String?

    public var memo: String?

    public var regId: String?

    public var templateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.bizVersion != nil {
            map["bizVersion"] = self.bizVersion!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.inputFieldsStr != nil {
            map["inputFieldsStr"] = self.inputFieldsStr!
        }
        if self.memo != nil {
            map["memo"] = self.memo!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.templateType != nil {
            map["templateType"] = self.templateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("bizVersion") {
            self.bizVersion = dict["bizVersion"] as! Int32
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("inputFieldsStr") {
            self.inputFieldsStr = dict["inputFieldsStr"] as! String
        }
        if dict.keys.contains("memo") {
            self.memo = dict["memo"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("templateType") {
            self.templateType = dict["templateType"] as! String
        }
    }
}

public class ModifyEventResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class ModifyEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyEventStatusRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var eventCode: String?

    public var fromEventSatus: String?

    public var regId: String?

    public var toEventSatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.fromEventSatus != nil {
            map["fromEventSatus"] = self.fromEventSatus!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.toEventSatus != nil {
            map["toEventSatus"] = self.toEventSatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("fromEventSatus") {
            self.fromEventSatus = dict["fromEventSatus"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("toEventSatus") {
            self.toEventSatus = dict["toEventSatus"] as! String
        }
    }
}

public class ModifyEventStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class ModifyEventStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEventStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyEventStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyExpressionVariableRequest : Tea.TeaModel {
    public var lang: String?

    public var dataVersion: Int64?

    public var description_: String?

    public var eventCode: String?

    public var expression: String?

    public var expressionTitle: String?

    public var expressionVariable: String?

    public var id: Int64?

    public var outlier: String?

    public var outputs: String?

    public var regId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.dataVersion != nil {
            map["dataVersion"] = self.dataVersion!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.expression != nil {
            map["expression"] = self.expression!
        }
        if self.expressionTitle != nil {
            map["expressionTitle"] = self.expressionTitle!
        }
        if self.expressionVariable != nil {
            map["expressionVariable"] = self.expressionVariable!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.outlier != nil {
            map["outlier"] = self.outlier!
        }
        if self.outputs != nil {
            map["outputs"] = self.outputs!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("dataVersion") {
            self.dataVersion = dict["dataVersion"] as! Int64
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("expression") {
            self.expression = dict["expression"] as! String
        }
        if dict.keys.contains("expressionTitle") {
            self.expressionTitle = dict["expressionTitle"] as! String
        }
        if dict.keys.contains("expressionVariable") {
            self.expressionVariable = dict["expressionVariable"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("outlier") {
            self.outlier = dict["outlier"] as! String
        }
        if dict.keys.contains("outputs") {
            self.outputs = dict["outputs"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
    }
}

public class ModifyExpressionVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class ModifyExpressionVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyExpressionVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyExpressionVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyFieldRequest : Tea.TeaModel {
    public var lang: String?

    public var classify: String?

    public var description_: String?

    public var enumData: String?

    public var id: Int64?

    public var name: String?

    public var regId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.classify != nil {
            map["classify"] = self.classify!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.enumData != nil {
            map["enumData"] = self.enumData!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("classify") {
            self.classify = dict["classify"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("enumData") {
            self.enumData = dict["enumData"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
    }
}

public class ModifyFieldResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class ModifyFieldResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyFieldResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyFieldResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyPocTaskRequest : Tea.TeaModel {
    public var lang: String?

    public var accessType: String?

    public var config: String?

    public var fileName: String?

    public var fileType: String?

    public var fileUrl: String?

    public var reason: String?

    public var regId: String?

    public var serviceCode: String?

    public var serviceName: String?

    public var taskId: String?

    public var taskName: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.accessType != nil {
            map["accessType"] = self.accessType!
        }
        if self.config != nil {
            map["config"] = self.config!
        }
        if self.fileName != nil {
            map["fileName"] = self.fileName!
        }
        if self.fileType != nil {
            map["fileType"] = self.fileType!
        }
        if self.fileUrl != nil {
            map["fileUrl"] = self.fileUrl!
        }
        if self.reason != nil {
            map["reason"] = self.reason!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.serviceCode != nil {
            map["serviceCode"] = self.serviceCode!
        }
        if self.serviceName != nil {
            map["serviceName"] = self.serviceName!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        if self.taskName != nil {
            map["taskName"] = self.taskName!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("accessType") {
            self.accessType = dict["accessType"] as! String
        }
        if dict.keys.contains("config") {
            self.config = dict["config"] as! String
        }
        if dict.keys.contains("fileName") {
            self.fileName = dict["fileName"] as! String
        }
        if dict.keys.contains("fileType") {
            self.fileType = dict["fileType"] as! String
        }
        if dict.keys.contains("fileUrl") {
            self.fileUrl = dict["fileUrl"] as! String
        }
        if dict.keys.contains("reason") {
            self.reason = dict["reason"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("serviceCode") {
            self.serviceCode = dict["serviceCode"] as! String
        }
        if dict.keys.contains("serviceName") {
            self.serviceName = dict["serviceName"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! String
        }
        if dict.keys.contains("taskName") {
            self.taskName = dict["taskName"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class ModifyPocTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class ModifyPocTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPocTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyPocTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyRulePriorityRequest : Tea.TeaModel {
    public var lang: String?

    public var consoleRuleId: Int64?

    public var priority: Int32?

    public var regId: String?

    public var ruleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.consoleRuleId != nil {
            map["consoleRuleId"] = self.consoleRuleId!
        }
        if self.priority != nil {
            map["priority"] = self.priority!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleId != nil {
            map["ruleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("consoleRuleId") {
            self.consoleRuleId = dict["consoleRuleId"] as! Int64
        }
        if dict.keys.contains("priority") {
            self.priority = dict["priority"] as! Int32
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleId") {
            self.ruleId = dict["ruleId"] as! Int64
        }
    }
}

public class ModifyRulePriorityResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class ModifyRulePriorityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRulePriorityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyRulePriorityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyRuleStatusRequest : Tea.TeaModel {
    public var lang: String?

    public var applyUserId: String?

    public var applyUserName: String?

    public var auditRemark: String?

    public var auditUserId: String?

    public var auditUserName: String?

    public var consoleRuleId: Int64?

    public var eventType: String?

    public var regId: String?

    public var ruleAuditType: String?

    public var ruleId: String?

    public var ruleVersionId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.applyUserId != nil {
            map["applyUserId"] = self.applyUserId!
        }
        if self.applyUserName != nil {
            map["applyUserName"] = self.applyUserName!
        }
        if self.auditRemark != nil {
            map["auditRemark"] = self.auditRemark!
        }
        if self.auditUserId != nil {
            map["auditUserId"] = self.auditUserId!
        }
        if self.auditUserName != nil {
            map["auditUserName"] = self.auditUserName!
        }
        if self.consoleRuleId != nil {
            map["consoleRuleId"] = self.consoleRuleId!
        }
        if self.eventType != nil {
            map["eventType"] = self.eventType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleAuditType != nil {
            map["ruleAuditType"] = self.ruleAuditType!
        }
        if self.ruleId != nil {
            map["ruleId"] = self.ruleId!
        }
        if self.ruleVersionId != nil {
            map["ruleVersionId"] = self.ruleVersionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("applyUserId") {
            self.applyUserId = dict["applyUserId"] as! String
        }
        if dict.keys.contains("applyUserName") {
            self.applyUserName = dict["applyUserName"] as! String
        }
        if dict.keys.contains("auditRemark") {
            self.auditRemark = dict["auditRemark"] as! String
        }
        if dict.keys.contains("auditUserId") {
            self.auditUserId = dict["auditUserId"] as! String
        }
        if dict.keys.contains("auditUserName") {
            self.auditUserName = dict["auditUserName"] as! String
        }
        if dict.keys.contains("consoleRuleId") {
            self.consoleRuleId = dict["consoleRuleId"] as! Int64
        }
        if dict.keys.contains("eventType") {
            self.eventType = dict["eventType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleAuditType") {
            self.ruleAuditType = dict["ruleAuditType"] as! String
        }
        if dict.keys.contains("ruleId") {
            self.ruleId = dict["ruleId"] as! String
        }
        if dict.keys.contains("ruleVersionId") {
            self.ruleVersionId = dict["ruleVersionId"] as! Int64
        }
    }
}

public class ModifyRuleStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class ModifyRuleStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRuleStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyRuleStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTemplateRequest : Tea.TeaModel {
    public class InputFields : Tea.TeaModel {
        public var description_: String?

        public var fieldCode: String?

        public var fieldRank: Int32?

        public var fieldSource: String?

        public var fieldType: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.fieldCode != nil {
                map["fieldCode"] = self.fieldCode!
            }
            if self.fieldRank != nil {
                map["fieldRank"] = self.fieldRank!
            }
            if self.fieldSource != nil {
                map["fieldSource"] = self.fieldSource!
            }
            if self.fieldType != nil {
                map["fieldType"] = self.fieldType!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("fieldCode") {
                self.fieldCode = dict["fieldCode"] as! String
            }
            if dict.keys.contains("fieldRank") {
                self.fieldRank = dict["fieldRank"] as! Int32
            }
            if dict.keys.contains("fieldSource") {
                self.fieldSource = dict["fieldSource"] as! String
            }
            if dict.keys.contains("fieldType") {
                self.fieldType = dict["fieldType"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
        }
    }
    public var lang: String?

    public var description_: String?

    public var eventCode: String?

    public var inputFields: ModifyTemplateRequest.InputFields?

    public var regId: String?

    public var templateId: Int64?

    public var templateType: String?

    public var version: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.inputFields?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.inputFields != nil {
            map["inputFields"] = self.inputFields?.toMap()
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.templateId != nil {
            map["templateId"] = self.templateId!
        }
        if self.templateType != nil {
            map["templateType"] = self.templateType!
        }
        if self.version != nil {
            map["version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("inputFields") {
            var model = ModifyTemplateRequest.InputFields()
            model.fromMap(dict["inputFields"] as! [String: Any])
            self.inputFields = model
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("templateId") {
            self.templateId = dict["templateId"] as! Int64
        }
        if dict.keys.contains("templateType") {
            self.templateType = dict["templateType"] as! String
        }
        if dict.keys.contains("version") {
            self.version = dict["version"] as! Int32
        }
    }
}

public class ModifyTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class ModifyTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTemplateStatusRequest : Tea.TeaModel {
    public var lang: String?

    public var fromTemplateSatus: String?

    public var regId: String?

    public var templateId: Int64?

    public var toTemplateSatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.fromTemplateSatus != nil {
            map["fromTemplateSatus"] = self.fromTemplateSatus!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.templateId != nil {
            map["templateId"] = self.templateId!
        }
        if self.toTemplateSatus != nil {
            map["toTemplateSatus"] = self.toTemplateSatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("fromTemplateSatus") {
            self.fromTemplateSatus = dict["fromTemplateSatus"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("templateId") {
            self.templateId = dict["templateId"] as! Int64
        }
        if dict.keys.contains("toTemplateSatus") {
            self.toTemplateSatus = dict["toTemplateSatus"] as! String
        }
    }
}

public class ModifyTemplateStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class ModifyTemplateStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTemplateStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTemplateStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVariableRequest : Tea.TeaModel {
    public var lang: String?

    public var description_: String?

    public var id: Int64?

    public var regId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
    }
}

public class ModifyVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class ModifyVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenConsoleSlsRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var scene: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.scene != nil {
            map["scene"] = self.scene!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("scene") {
            self.scene = dict["scene"] as! String
        }
    }
}

public class OpenConsoleSlsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! String
        }
    }
}

public class OpenConsoleSlsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenConsoleSlsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OpenConsoleSlsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OperateFavoriteVariableRequest : Tea.TeaModel {
    public var lang: String?

    public var id: Int64?

    public var operate: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.operate != nil {
            map["operate"] = self.operate!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("operate") {
            self.operate = dict["operate"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class OperateFavoriteVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class OperateFavoriteVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OperateFavoriteVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OperateFavoriteVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PermissionCheckRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["RegId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RegId") {
            self.regId = dict["RegId"] as! String
        }
    }
}

public class PermissionCheckResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["ResultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultObject") {
            self.resultObject = dict["ResultObject"] as! String
        }
    }
}

public class PermissionCheckResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PermissionCheckResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PermissionCheckResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAuthRuleDetailByRuleIdRequest : Tea.TeaModel {
    public var lang: String?

    public var consoleRuleId: Int64?

    public var regId: String?

    public var ruleId: String?

    public var ruleVersionId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.consoleRuleId != nil {
            map["consoleRuleId"] = self.consoleRuleId!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleId != nil {
            map["ruleId"] = self.ruleId!
        }
        if self.ruleVersionId != nil {
            map["ruleVersionId"] = self.ruleVersionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("consoleRuleId") {
            self.consoleRuleId = dict["consoleRuleId"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleId") {
            self.ruleId = dict["ruleId"] as! String
        }
        if dict.keys.contains("ruleVersionId") {
            self.ruleVersionId = dict["ruleVersionId"] as! Int64
        }
    }
}

public class QueryAuthRuleDetailByRuleIdResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var auditId: Int64?

        public var authType: String?

        public var authUsers: String?

        public var consoleRuleId: Int64?

        public var eventCode: String?

        public var eventName: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var logicExpression: String?

        public var memo: String?

        public var priority: Int64?

        public var ruleActionMap: [String: String]?

        public var ruleActions: String?

        public var ruleAuthType: String?

        public var ruleExpressions: String?

        public var ruleId: String?

        public var ruleName: String?

        public var ruleStatus: String?

        public var ruleVersionId: Int64?

        public var templateType: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.auditId != nil {
                map["auditId"] = self.auditId!
            }
            if self.authType != nil {
                map["authType"] = self.authType!
            }
            if self.authUsers != nil {
                map["authUsers"] = self.authUsers!
            }
            if self.consoleRuleId != nil {
                map["consoleRuleId"] = self.consoleRuleId!
            }
            if self.eventCode != nil {
                map["eventCode"] = self.eventCode!
            }
            if self.eventName != nil {
                map["eventName"] = self.eventName!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.logicExpression != nil {
                map["logicExpression"] = self.logicExpression!
            }
            if self.memo != nil {
                map["memo"] = self.memo!
            }
            if self.priority != nil {
                map["priority"] = self.priority!
            }
            if self.ruleActionMap != nil {
                map["ruleActionMap"] = self.ruleActionMap!
            }
            if self.ruleActions != nil {
                map["ruleActions"] = self.ruleActions!
            }
            if self.ruleAuthType != nil {
                map["ruleAuthType"] = self.ruleAuthType!
            }
            if self.ruleExpressions != nil {
                map["ruleExpressions"] = self.ruleExpressions!
            }
            if self.ruleId != nil {
                map["ruleId"] = self.ruleId!
            }
            if self.ruleName != nil {
                map["ruleName"] = self.ruleName!
            }
            if self.ruleStatus != nil {
                map["ruleStatus"] = self.ruleStatus!
            }
            if self.ruleVersionId != nil {
                map["ruleVersionId"] = self.ruleVersionId!
            }
            if self.templateType != nil {
                map["templateType"] = self.templateType!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("auditId") {
                self.auditId = dict["auditId"] as! Int64
            }
            if dict.keys.contains("authType") {
                self.authType = dict["authType"] as! String
            }
            if dict.keys.contains("authUsers") {
                self.authUsers = dict["authUsers"] as! String
            }
            if dict.keys.contains("consoleRuleId") {
                self.consoleRuleId = dict["consoleRuleId"] as! Int64
            }
            if dict.keys.contains("eventCode") {
                self.eventCode = dict["eventCode"] as! String
            }
            if dict.keys.contains("eventName") {
                self.eventName = dict["eventName"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("logicExpression") {
                self.logicExpression = dict["logicExpression"] as! String
            }
            if dict.keys.contains("memo") {
                self.memo = dict["memo"] as! String
            }
            if dict.keys.contains("priority") {
                self.priority = dict["priority"] as! Int64
            }
            if dict.keys.contains("ruleActionMap") {
                self.ruleActionMap = dict["ruleActionMap"] as! [String: String]
            }
            if dict.keys.contains("ruleActions") {
                self.ruleActions = dict["ruleActions"] as! String
            }
            if dict.keys.contains("ruleAuthType") {
                self.ruleAuthType = dict["ruleAuthType"] as! String
            }
            if dict.keys.contains("ruleExpressions") {
                self.ruleExpressions = dict["ruleExpressions"] as! String
            }
            if dict.keys.contains("ruleId") {
                self.ruleId = dict["ruleId"] as! String
            }
            if dict.keys.contains("ruleName") {
                self.ruleName = dict["ruleName"] as! String
            }
            if dict.keys.contains("ruleStatus") {
                self.ruleStatus = dict["ruleStatus"] as! String
            }
            if dict.keys.contains("ruleVersionId") {
                self.ruleVersionId = dict["ruleVersionId"] as! Int64
            }
            if dict.keys.contains("templateType") {
                self.templateType = dict["templateType"] as! String
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var resultObject: QueryAuthRuleDetailByRuleIdResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = QueryAuthRuleDetailByRuleIdResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class QueryAuthRuleDetailByRuleIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAuthRuleDetailByRuleIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryAuthRuleDetailByRuleIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAuthUserNameRequest : Tea.TeaModel {
    public var lang: String?

    public var bindId: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.bindId != nil {
            map["bindId"] = self.bindId!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("bindId") {
            self.bindId = dict["bindId"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class QueryAuthUserNameResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var company: String?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.company != nil {
                map["company"] = self.company!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("company") {
                self.company = dict["company"] as! String
            }
            if dict.keys.contains("userId") {
                self.userId = dict["userId"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var resultObject: QueryAuthUserNameResponseBody.ResultObject?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var model = QueryAuthUserNameResponseBody.ResultObject()
            model.fromMap(dict["resultObject"] as! [String: Any])
            self.resultObject = model
        }
    }
}

public class QueryAuthUserNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAuthUserNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryAuthUserNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAuthorizationUserListRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var eventCode: String?

    public var id: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class QueryAuthorizationUserListResponseBody : Tea.TeaModel {
    public class ResultObject : Tea.TeaModel {
        public var company: String?

        public var id: Int64?

        public var uid: String?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.company != nil {
                map["company"] = self.company!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.uid != nil {
                map["uid"] = self.uid!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("company") {
                self.company = dict["company"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("uid") {
                self.uid = dict["uid"] as! String
            }
            if dict.keys.contains("userId") {
                self.userId = dict["userId"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var resultObject: [QueryAuthorizationUserListResponseBody.ResultObject]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            var tmp : [Any] = []
            for k in self.resultObject! {
                tmp.append(k.toMap())
            }
            map["resultObject"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            var tmp : [QueryAuthorizationUserListResponseBody.ResultObject] = []
            for v in dict["resultObject"] as! [Any] {
                var model = QueryAuthorizationUserListResponseBody.ResultObject()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultObject = tmp
        }
    }
}

public class QueryAuthorizationUserListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAuthorizationUserListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryAuthorizationUserListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RecallRuleAuditRequest : Tea.TeaModel {
    public var id: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class RecallRuleAuditResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class RecallRuleAuditResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecallRuleAuditResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RecallRuleAuditResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveEventRequest : Tea.TeaModel {
    public var lang: String?

    public var createType: String?

    public var eventCode: String?

    public var id: Int64?

    public var regId: String?

    public var templateCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.createType != nil {
            map["createType"] = self.createType!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.templateCode != nil {
            map["templateCode"] = self.templateCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("createType") {
            self.createType = dict["createType"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("templateCode") {
            self.templateCode = dict["templateCode"] as! String
        }
    }
}

public class RemoveEventResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class RemoveEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveTemplateRequest : Tea.TeaModel {
    public var lang: String?

    public var eventCode: String?

    public var regId: String?

    public var templateId: Int64?

    public var version: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.templateId != nil {
            map["templateId"] = self.templateId!
        }
        if self.version != nil {
            map["version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("templateId") {
            self.templateId = dict["templateId"] as! Int64
        }
        if dict.keys.contains("version") {
            self.version = dict["version"] as! Int32
        }
    }
}

public class RemoveTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class RemoveTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SampleFileDownloadRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var tab: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["RegId"] = self.regId!
        }
        if self.tab != nil {
            map["Tab"] = self.tab!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RegId") {
            self.regId = dict["RegId"] as! String
        }
        if dict.keys.contains("Tab") {
            self.tab = dict["Tab"] as! String
        }
    }
}

public class SampleFileDownloadResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["ResultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultObject") {
            self.resultObject = dict["ResultObject"] as! String
        }
    }
}

public class SampleFileDownloadResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SampleFileDownloadResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SampleFileDownloadResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveAnalysisColumnRequest : Tea.TeaModel {
    public var lang: String?

    public var columns: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.columns != nil {
            map["columns"] = self.columns!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("columns") {
            self.columns = dict["columns"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class SaveAnalysisColumnResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class SaveAnalysisColumnResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveAnalysisColumnResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveAnalysisColumnResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveByPassOrShuntEventRequest : Tea.TeaModel {
    public var lang: String?

    public var eventId: Int64?

    public var eventName: String?

    public var eventType: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventId != nil {
            map["eventId"] = self.eventId!
        }
        if self.eventName != nil {
            map["eventName"] = self.eventName!
        }
        if self.eventType != nil {
            map["eventType"] = self.eventType!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventId") {
            self.eventId = dict["eventId"] as! Int64
        }
        if dict.keys.contains("eventName") {
            self.eventName = dict["eventName"] as! String
        }
        if dict.keys.contains("eventType") {
            self.eventType = dict["eventType"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class SaveByPassOrShuntEventResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class SaveByPassOrShuntEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveByPassOrShuntEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveByPassOrShuntEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartOrStopByPassShuntEventRequest : Tea.TeaModel {
    public var lang: String?

    public var eventId: Int64?

    public var regId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventId != nil {
            map["eventId"] = self.eventId!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventId") {
            self.eventId = dict["eventId"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
    }
}

public class StartOrStopByPassShuntEventResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class StartOrStopByPassShuntEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartOrStopByPassShuntEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartOrStopByPassShuntEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartSimulationTaskRequest : Tea.TeaModel {
    public var lang: String?

    public var id: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class StartSimulationTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class StartSimulationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartSimulationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartSimulationTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopSimulationTaskRequest : Tea.TeaModel {
    public var lang: String?

    public var id: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class StopSimulationTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class StopSimulationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopSimulationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopSimulationTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitImportTaskRequest : Tea.TeaModel {
    public var lang: String?

    public var fileName: String?

    public var regId: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.fileName != nil {
            map["fileName"] = self.fileName!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("fileName") {
            self.fileName = dict["fileName"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("url") {
            self.url = dict["url"] as! String
        }
    }
}

public class SubmitImportTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class SubmitImportTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitImportTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitImportTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SwitchExpressionVariableRequest : Tea.TeaModel {
    public var lang: String?

    public var dataVersion: Int64?

    public var id: Int64?

    public var regId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.dataVersion != nil {
            map["dataVersion"] = self.dataVersion!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("dataVersion") {
            self.dataVersion = dict["dataVersion"] as! Int64
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
    }
}

public class SwitchExpressionVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class SwitchExpressionVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchExpressionVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SwitchExpressionVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SwitchFieldRequest : Tea.TeaModel {
    public var lang: String?

    public var id: Int64?

    public var name: String?

    public var regId: String?

    public var source: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("source") {
            self.source = dict["source"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
    }
}

public class SwitchFieldResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class SwitchFieldResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchFieldResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SwitchFieldResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SwitchQueryVariableRequest : Tea.TeaModel {
    public var lang: String?

    public var id: Int64?

    public var regId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
    }
}

public class SwitchQueryVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class SwitchQueryVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchQueryVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SwitchQueryVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SwitchToOnlineRequest : Tea.TeaModel {
    public var lang: String?

    public var eventId: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventId != nil {
            map["eventId"] = self.eventId!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventId") {
            self.eventId = dict["eventId"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class SwitchToOnlineResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class SwitchToOnlineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchToOnlineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SwitchToOnlineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SwitchVariableRequest : Tea.TeaModel {
    public var lang: String?

    public var dataVersion: Int64?

    public var id: Int64?

    public var name: String?

    public var regId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.dataVersion != nil {
            map["dataVersion"] = self.dataVersion!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("dataVersion") {
            self.dataVersion = dict["dataVersion"] as! Int64
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
    }
}

public class SwitchVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class SwitchVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SwitchVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TaskNameByUserIdRequest : Tea.TeaModel {
    public var lang: String?

    public var regId: String?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regId != nil {
            map["RegId"] = self.regId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RegId") {
            self.regId = dict["RegId"] as! String
        }
        if dict.keys.contains("TaskName") {
            self.taskName = dict["TaskName"] as! String
        }
    }
}

public class TaskNameByUserIdResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["ResultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultObject") {
            self.resultObject = dict["ResultObject"] as! Bool
        }
    }
}

public class TaskNameByUserIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TaskNameByUserIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TaskNameByUserIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAnalysisConditionFavoriteRequest : Tea.TeaModel {
    public var lang: String?

    public var condition: String?

    public var eventBeginTime: Int64?

    public var eventCode: String?

    public var eventEndTime: Int64?

    public var fieldName: String?

    public var fieldValue: String?

    public var id: Int64?

    public var name: String?

    public var regId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.condition != nil {
            map["condition"] = self.condition!
        }
        if self.eventBeginTime != nil {
            map["eventBeginTime"] = self.eventBeginTime!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.eventEndTime != nil {
            map["eventEndTime"] = self.eventEndTime!
        }
        if self.fieldName != nil {
            map["fieldName"] = self.fieldName!
        }
        if self.fieldValue != nil {
            map["fieldValue"] = self.fieldValue!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("condition") {
            self.condition = dict["condition"] as! String
        }
        if dict.keys.contains("eventBeginTime") {
            self.eventBeginTime = dict["eventBeginTime"] as! Int64
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("eventEndTime") {
            self.eventEndTime = dict["eventEndTime"] as! Int64
        }
        if dict.keys.contains("fieldName") {
            self.fieldName = dict["fieldName"] as! String
        }
        if dict.keys.contains("fieldValue") {
            self.fieldValue = dict["fieldValue"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class UpdateAnalysisConditionFavoriteResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class UpdateAnalysisConditionFavoriteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAnalysisConditionFavoriteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAnalysisConditionFavoriteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAuditRequest : Tea.TeaModel {
    public var lang: String?

    public var auditMsg: String?

    public var auditRelationType: String?

    public var auditStatus: String?

    public var id: Int64?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.auditMsg != nil {
            map["auditMsg"] = self.auditMsg!
        }
        if self.auditRelationType != nil {
            map["auditRelationType"] = self.auditRelationType!
        }
        if self.auditStatus != nil {
            map["auditStatus"] = self.auditStatus!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("auditMsg") {
            self.auditMsg = dict["auditMsg"] as! String
        }
        if dict.keys.contains("auditRelationType") {
            self.auditRelationType = dict["auditRelationType"] as! String
        }
        if dict.keys.contains("auditStatus") {
            self.auditStatus = dict["auditStatus"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class UpdateAuditResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var resultObject: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateAuditResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAuditResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAuditResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAuthRuleRequest : Tea.TeaModel {
    public var lang: String?

    public var consoleRuleId: Int64?

    public var eventCode: String?

    public var regId: String?

    public var ruleActions: String?

    public var ruleExpressions: String?

    public var ruleId: String?

    public var ruleVersionId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.consoleRuleId != nil {
            map["consoleRuleId"] = self.consoleRuleId!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleActions != nil {
            map["ruleActions"] = self.ruleActions!
        }
        if self.ruleExpressions != nil {
            map["ruleExpressions"] = self.ruleExpressions!
        }
        if self.ruleId != nil {
            map["ruleId"] = self.ruleId!
        }
        if self.ruleVersionId != nil {
            map["ruleVersionId"] = self.ruleVersionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("consoleRuleId") {
            self.consoleRuleId = dict["consoleRuleId"] as! Int64
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleActions") {
            self.ruleActions = dict["ruleActions"] as! String
        }
        if dict.keys.contains("ruleExpressions") {
            self.ruleExpressions = dict["ruleExpressions"] as! String
        }
        if dict.keys.contains("ruleId") {
            self.ruleId = dict["ruleId"] as! String
        }
        if dict.keys.contains("ruleVersionId") {
            self.ruleVersionId = dict["ruleVersionId"] as! Int64
        }
    }
}

public class UpdateAuthRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class UpdateAuthRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAuthRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAuthRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateByPassShuntEventRequest : Tea.TeaModel {
    public var lang: String?

    public var eventId: Int64?

    public var eventName: String?

    public var regId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.eventId != nil {
            map["eventId"] = self.eventId!
        }
        if self.eventName != nil {
            map["eventName"] = self.eventName!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("eventId") {
            self.eventId = dict["eventId"] as! Int64
        }
        if dict.keys.contains("eventName") {
            self.eventName = dict["eventName"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
    }
}

public class UpdateByPassShuntEventResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var resultObject: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateByPassShuntEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateByPassShuntEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateByPassShuntEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDataSourceRequest : Tea.TeaModel {
    public var lang: String?

    public var description_: String?

    public var id: Int64?

    public var name: String?

    public var ossKey: String?

    public var regId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.ossKey != nil {
            map["ossKey"] = self.ossKey!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("ossKey") {
            self.ossKey = dict["ossKey"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class UpdateDataSourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class UpdateDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateQueryVariableRequest : Tea.TeaModel {
    public var lang: String?

    public var dataSourceCode: String?

    public var description_: String?

    public var eventCode: String?

    public var expression: String?

    public var expressionTitle: String?

    public var expressionVariable: String?

    public var id: Int64?

    public var outlier: String?

    public var outputs: String?

    public var regId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.dataSourceCode != nil {
            map["dataSourceCode"] = self.dataSourceCode!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.expression != nil {
            map["expression"] = self.expression!
        }
        if self.expressionTitle != nil {
            map["expressionTitle"] = self.expressionTitle!
        }
        if self.expressionVariable != nil {
            map["expressionVariable"] = self.expressionVariable!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.outlier != nil {
            map["outlier"] = self.outlier!
        }
        if self.outputs != nil {
            map["outputs"] = self.outputs!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("dataSourceCode") {
            self.dataSourceCode = dict["dataSourceCode"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("expression") {
            self.expression = dict["expression"] as! String
        }
        if dict.keys.contains("expressionTitle") {
            self.expressionTitle = dict["expressionTitle"] as! String
        }
        if dict.keys.contains("expressionVariable") {
            self.expressionVariable = dict["expressionVariable"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("outlier") {
            self.outlier = dict["outlier"] as! String
        }
        if dict.keys.contains("outputs") {
            self.outputs = dict["outputs"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
    }
}

public class UpdateQueryVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class UpdateQueryVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateQueryVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateQueryVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateRuleRequest : Tea.TeaModel {
    public var lang: String?

    public var consoleRuleId: Int64?

    public var eventCode: String?

    public var logicExpression: String?

    public var memo: String?

    public var regId: String?

    public var ruleActions: String?

    public var ruleExpressions: String?

    public var ruleId: String?

    public var ruleName: String?

    public var ruleStatus: String?

    public var ruleVersionId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.consoleRuleId != nil {
            map["consoleRuleId"] = self.consoleRuleId!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.logicExpression != nil {
            map["logicExpression"] = self.logicExpression!
        }
        if self.memo != nil {
            map["memo"] = self.memo!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleActions != nil {
            map["ruleActions"] = self.ruleActions!
        }
        if self.ruleExpressions != nil {
            map["ruleExpressions"] = self.ruleExpressions!
        }
        if self.ruleId != nil {
            map["ruleId"] = self.ruleId!
        }
        if self.ruleName != nil {
            map["ruleName"] = self.ruleName!
        }
        if self.ruleStatus != nil {
            map["ruleStatus"] = self.ruleStatus!
        }
        if self.ruleVersionId != nil {
            map["ruleVersionId"] = self.ruleVersionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("consoleRuleId") {
            self.consoleRuleId = dict["consoleRuleId"] as! Int64
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("logicExpression") {
            self.logicExpression = dict["logicExpression"] as! String
        }
        if dict.keys.contains("memo") {
            self.memo = dict["memo"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleActions") {
            self.ruleActions = dict["ruleActions"] as! String
        }
        if dict.keys.contains("ruleExpressions") {
            self.ruleExpressions = dict["ruleExpressions"] as! String
        }
        if dict.keys.contains("ruleId") {
            self.ruleId = dict["ruleId"] as! String
        }
        if dict.keys.contains("ruleName") {
            self.ruleName = dict["ruleName"] as! String
        }
        if dict.keys.contains("ruleStatus") {
            self.ruleStatus = dict["ruleStatus"] as! String
        }
        if dict.keys.contains("ruleVersionId") {
            self.ruleVersionId = dict["ruleVersionId"] as! Int64
        }
    }
}

public class UpdateRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class UpdateRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateRuleBaseRequest : Tea.TeaModel {
    public var lang: String?

    public var consoleRuleId: Int64?

    public var eventCode: String?

    public var memo: String?

    public var regId: String?

    public var ruleId: String?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.consoleRuleId != nil {
            map["consoleRuleId"] = self.consoleRuleId!
        }
        if self.eventCode != nil {
            map["eventCode"] = self.eventCode!
        }
        if self.memo != nil {
            map["memo"] = self.memo!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.ruleId != nil {
            map["ruleId"] = self.ruleId!
        }
        if self.ruleName != nil {
            map["ruleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("consoleRuleId") {
            self.consoleRuleId = dict["consoleRuleId"] as! Int64
        }
        if dict.keys.contains("eventCode") {
            self.eventCode = dict["eventCode"] as! String
        }
        if dict.keys.contains("memo") {
            self.memo = dict["memo"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("ruleId") {
            self.ruleId = dict["ruleId"] as! String
        }
        if dict.keys.contains("ruleName") {
            self.ruleName = dict["ruleName"] as! String
        }
    }
}

public class UpdateRuleBaseResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultObject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resultObject != nil {
            map["resultObject"] = self.resultObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resultObject") {
            self.resultObject = dict["resultObject"] as! Bool
        }
    }
}

public class UpdateRuleBaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRuleBaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateRuleBaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSampleBatchRequest : Tea.TeaModel {
    public var lang: String?

    public var ids: String?

    public var regId: String?

    public var tags: String?

    public var versions: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.ids != nil {
            map["ids"] = self.ids!
        }
        if self.regId != nil {
            map["regId"] = self.regId!
        }
        if self.tags != nil {
            map["tags"] = self.tags!
        }
        if self.versions != nil {
            map["versions"] = self.versions!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ids") {
            self.ids = dict["ids"] as! String
        }
        if dict.keys.contains("regId") {
            self.regId = dict["regId"] as! String
        }
        if dict.keys.contains("tags") {
            self.tags = dict["tags"] as! String
        }
        if dict.keys.contains("versions") {
            self.versions = dict["versions"] as! String
        }
    }
}

public class UpdateSampleBatchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var data: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! Bool
        }
    }
}

public class UpdateSampleBatchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSampleBatchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateSampleBatchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadSampleApiRequest : Tea.TeaModel {
    public var dataType: String?

    public var dataValue: String?

    public var sampleType: String?

    public var service: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataType != nil {
            map["DataType"] = self.dataType!
        }
        if self.dataValue != nil {
            map["DataValue"] = self.dataValue!
        }
        if self.sampleType != nil {
            map["SampleType"] = self.sampleType!
        }
        if self.service != nil {
            map["Service"] = self.service!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataType") {
            self.dataType = dict["DataType"] as! String
        }
        if dict.keys.contains("DataValue") {
            self.dataValue = dict["DataValue"] as! String
        }
        if dict.keys.contains("SampleType") {
            self.sampleType = dict["SampleType"] as! String
        }
        if dict.keys.contains("Service") {
            self.service = dict["Service"] as! String
        }
    }
}

public class UploadSampleApiResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UploadSampleApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadSampleApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UploadSampleApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
